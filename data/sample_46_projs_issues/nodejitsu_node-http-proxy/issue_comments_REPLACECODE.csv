issue_num,datetime,body,login,close_date
1155,2017-03-25 04:51:36,"hello. I wanna redirect ws connection.
like this (I know to redirect, Server A would response 301, so I said logically)

1. request(logically) 
Client[Ca] ----(ws)----> Server A(Sa) redirects ----(ws)----> Server B(Sb)
2. response(logically)
Server B[Sb] ----(ws)----> Client[Ca]

but the problem is... Server A consumes network bandwidth.
I wanna entirely consume network bandwidth for only Server B
my source is below.

<S_CODE_TOKEN>

client requests websocket(ws://) with 7654 port.
because client desn't request http, server can't catch 'request' event.

do you have any idea except changing client request as http?? (I can't be sure that exactly work)",khackskjs,
1154,2017-03-17 23:27:49,"This ensures the incoming request does not timeout before the target's timeout configured with `options.proxyTimeout`.

As I'm not familiar to the code base, I struggled seeing the best entry to write a test for this. Any thoughts would be appreciated.

Fixes https://github.com/nodejitsu/node-http-proxy/issues/1113

~~**Edit:** I'm looking into the existing timeout test failing~~",phillipj,
1154,2017-03-17 23:55:57,"Looking at the test that fails with these changes added, I wonder if that test is wrong.

It doesn't expect the client request being made to throw an error if an error occurs. At first glance that seems weird, cause a timeout is also an error to the client initiating the request, right?

Additionally there is two very similar tests, whereas the latter succeeds cause it expects timeouts to raise client error:
- failing: [it('should proxy the request and handle timeout error (proxyTimeout)', ..)](https://github.com/nodejitsu/node-http-proxy/blob/master/test/lib-http-proxy-passes-web-incoming-test.js#L209)
- similar: [it('should proxy the request and handle timeout error', ..)](https://github.com/nodejitsu/node-http-proxy/blob/master/test/lib-http-proxy-passes-web-incoming-test.js#L243)",phillipj,
1153,2017-03-16 12:39:15,"I see that the proxy server sends `if-none-match` HTTP header, which my API server handles as a key to check, was the data changed or not. Which is totally fine. But there is a problem: the proxy server receives 304 HTTP status code and empty body which makes sense. But, in that case, my browser doesn't get the data from the proxy server at all. 
Is there any way to fix that? except this one
<S_CODE_TOKEN>",nnnikolay,
1152,2017-03-14 11:48:52,"I am suffering from anything proxied via node being incredibly slow compared to direct and I cannot work out why!  The code is incredibly simple... but as you will see from these apache bench tests they are MUCH MUCH slower in real life. 

The idea of the ab tests is to show that the upstream servers in the round robin don't have any issues at all with the tests running from the server that the node code is running on.

This seems to happen for POST and GET requests.

The runtime of ab for the same request goes from 5 seconds to 105 seconds!

<S_CODE_TOKEN>


<S_CODE_TOKEN>",leearmstrong,
1152,2017-03-14 11:51:18,"Even a simpler script exhibits the same issue...

<S_CODE_TOKEN>",leearmstrong,
1152,2017-03-14 14:58:02,@leearmstrong try using something like `wrk` rather than apache bench. apache bench doesnt support http 1.1. See if that makes a difference in your benchmarks. I would also suggest using an [`Agent`](https://nodejs.org/api/http.html#http_class_http_agent) for this case so there is better socket reuse. ,jcrugzz,
1152,2017-03-14 14:58:34,Node version would also be interesting to know,jcrugzz,
1152,2017-03-14 14:59:44,"Never used wrk before so will give it a go.  All of the client connecting into the nginx server direct (before the proxy I want to implement) are only HTTP 1.0 capable anyway so ab may be a better test.

This is Node 6.10.0",leearmstrong,
1152,2017-03-14 15:15:38,"So I added a keep alive agent to it with a timeout of 30000msec and it made a bit of a difference, the test now completes in 75 seconds and not 103 seconds.  This is no where near the direct connections from ab to the upstream of closer to 5 seconds.  

I can accept there will be some overhead for proxying via node but this seems excessive?  Or is this to be expected?",leearmstrong,
1152,2017-03-14 15:29:57,"Stats using `wrk` and using a keepAlive config

<S_CODE_TOKEN>",leearmstrong,
1152,2017-03-14 15:47:45,I'm honestly not sure if we are comparing apples to apples if your backend is an nginx that can spawn workers. I would run your node process and do some profiling to get some more information. https://nodejs.org/en/docs/guides/simple-profiling/,jcrugzz,
1151,2017-03-13 09:44:09,"The proxy should be able in addition to keep headers case keep headers duplication.

#1150",thochra,
1151,2017-03-13 10:23:27,"For others who need to have the fix directly this is how I used it in my project (with a v1.16.2):
<S_CODE_TOKEN>

Edit: code update with last PR's commit",thochra,
1150,2017-03-13 09:15:49,"Hello, I needed the server repsonse headers to not be touched by node js so I've added a missing option ""preserveHeaderDuplications"".",thochra,
1149,2017-03-06 09:23:17,"Is it possible to measure the outgoing (ssl) connections? I can get the incoming connections, but we really want to measure the outgoing connections as well.",cyanic-webdesign,
1148,2017-03-04 20:38:03,"I bet someone has done this before...

I would want to be able to to do a generic authentication and authorization prior to proxying a downstream URL using node-http-proxy, and for that means I'd like to use a session inside my proxy application, which in turns authenticates, authorizes (if necessary) and then starts to proxy for a certain amount of time.

This works fine if I don't have a downstream session, which though is the case most of the time. So I need to start intercepting the `Cookie` and `Set-Cookie` headers and rewrite them...

This works, but it's tedious. Have I missed some setting which lets me do that ""out of the box"", or can somebody point me to some other project which has already implemented such functionality? Either on top of node-http-proxy (which works awesome otherwise!), or using some other library? Because I bet I am missing a ton of corner cases somebody else has found before me.

Best regards,
Martin",DonMartin76,
1147,2017-03-04 10:12:38,Updates options documentation for location rewrite to include 201 responses. See #1024,smh,
1146,2017-03-03 16:06:09,"I would like to know what, if any, protections node-http-proxy has against circular redirects? In particular, if my origin is outside of my purview and is a CNAME which can be altered later on, a malicious user could update that CNAME to point back to the proxy, thus creating an infinite loop. Are there any builtin protections against this or prescriptions for mitigating this issue?",maxcountryman,
1145,2017-03-01 19:54:50,"Hi I wonder if there is any chance to do selective caching, let me explain. I need to cache some specific pages on the proxy lets say /about-us, /contact and skip caching for others like /admin and I have all the logic that designates if a page is cacheable or not. Is there any way to when in the proxyReq event to cancel the request if the page exists on cache and to set the response to a cached version of the page that lays in the filesystem and return it to the user immediately?",asolenzal,
1144,2017-02-27 11:15:20,Added support for server listen callback #1143 .,barto-,
1143,2017-02-27 11:10:43,"I would like a callback when the server is listening. This is possible with <S_CODE_TOKEN> but it doesn't work with <S_CODE_TOKEN>.

Example:

<S_CODE_TOKEN>",barto-,
1142,2017-02-21 12:29:24,Cannot forward Post and PUT request using proxy.web method. can you help me how to fix this issue ,tamilvjm,
1142,2017-02-22 07:52:12,It's not responding while forwarding put request,tamilvjm,
1142,2017-02-27 18:42:54,"The problem seems like a *stream* ""issue"".  Are you using something  before sending the proxy request? 

For example:
<S_CODE_TOKEN>

That works like a charm for NON BODY requests, like GET, HEAD or DELETE.  But POST, for example, has lost its data stream before sending  to *proxy.web*. The upstream server will get the data, but no response will be received.

### UPDATE
worked after:
<S_CODE_TOKEN>",zanaca,
1142,2017-03-12 07:57:30,"when I use  proxyReq.write(bodyData), it call like this: throw new Error('Can\'t set headers after they are sent.'); How can I fix it? ",taikongfeizhu,
1141,2017-02-20 06:33:43,How do i get the client IP via this proxy? Is it possible even?,r0hi7,
1140,2017-02-17 00:21:26,"I am seeing an exception the above exception in production traffic very occasionally. it would see it happens with IPv6 addresses appended to X-Forwarded-For. From what I've read previously, due to an update in Node, IPv6 address must be surrounded in double quotes due to the fact they contain restricted characters, namely semicolons.

I'm not sure where this should be addressed, but it certainly seems to be a potentially breaking issue for `node-http-proxy` users.",maxcountryman,
1139,2017-02-08 17:12:53,This PR simply fixes the modifyResponse-middleware example to work properly by removing a deprecated function call (connect.createServer()) and passing the middleware functions to an http server.,costolo,
1138,2017-02-03 04:19:48,"Hi, I'm trying to figure out a good approach for my simple use case. Basically, a client (say `curl`) on machine 1 needs to download the raw JSON from a remote API (HTTP/HTTPS), via a proxy running on machine 2.

1. Performance wise, is it any better to use node-http-proxy instead of a simple nodejs script (HTTP server receives request from client, downloads target URL, responds back with the downloaded content and headers as JSON)?

2. If node-http-proxy is used, then is it correct that a forward proxy will be created? I'm familiar with forward and reverse proxies, but got a bit confused with the target configuration.

Any suggestions are appreciated.

Cheers!",voidmonk,
1137,2017-02-01 22:51:21,"Hello, i need your help because i'm stupid.

I don't understand this lib. It's one Nginx like?

I search lib for proxy my browser for modify response on the fly but is this possible with this lib?
I would like the target port to be the same as the listen port.

I have this code for my actual proxy server (it's juste skeleton code, it's to explain).

<S_CODE_TOKEN>

But it drop https request and i need server that is transparent with this, i tested this lib but i think it does not serve at all what I thought at the start :'(

Sorry, i'm noob, thanks for your help.",Nw-Fig,
1137,2017-02-02 08:05:07,"@Nw-Fig you can not proxy https in transparent mode. You need SSL certs but if you want to use as a browsing proxy, you have to let https pass directly.",brugnara,
1137,2017-02-02 12:14:11,"Yes, i want do this, but I don't understand if i can use this lib for that, for proxy browser/system http request, return a modified response and ignore https responses.

I think i am misled by the name of this lib because i don't find how use createProxyServer for my case, without target one port, just listen one port and pipe modified response inside, as in my example.

Thanks for your response.",Nw-Fig,
1137,2017-02-02 12:46:21,"@Nw-Fig recently I was figuring something similar, but there is a different kind of http proxies like this, focused on listen same domain and passing through its requests to another server with some changes like headers or kind of, and another ones catching al http petitions, caching on any domain request like Squid... something where https://www.npmjs.com/package/proxy code could help you better on what you want to reproduce... I just checked with https and worked. The difference on both kinds is described here https://en.wikipedia.org/wiki/Proxy_server#Types",sposmen,
1136,2017-01-31 23:19:16,"This is the script running on a server-A:

<S_CODE_TOKEN>

From my pc when I do `curl server-A:8001` the proxy server crash and returns this error.

<S_CODE_TOKEN>
If I do a `curl https://server-A:8001` the proxy server still run but curl returns this:
`curl: (35) gnutls_handshake() failed: The TLS connection was non-properly terminated.
`",roccomuso,
1135,2017-01-31 21:16:57,"If we set `target:req.url`, request to http://localhost/favicon.ico would be mapped to  http://localhost/favicon.ico/favicon.ico

This PR changes `target` to make it equal destination host authority",IdeaHunter,
1134,2017-01-21 17:48:07,This provides support for sending along a `servername` with encrypted requests. It should address #1133. ,maxcountryman,
1133,2017-01-21 02:54:44,"Node http.request seems to support this via its options map. However if node-http-proxy also supports this I don't seem to see it. Briefly, this is useful because it may be desirable to proxy requests where the origin server makes use of SNI. While it's trivial to set the Host header appropriately, SNI will fail if the request was not actually made from that host. In my case this is because my server proxies a large number of targets and I would like to be able to preview any changes made to the proxy before asking clients to update their CNAMES. ",maxcountryman,
1133,2017-03-09 06:10:36,And `changeOrigin: true` does not do what you need?,DonMartin76,
1133,2017-03-09 06:23:28,No. Please read the commit message...,maxcountryman,
1133,2017-03-09 07:25:33,"OK, sorry, misunderstood your original post.",DonMartin76,
1132,2017-01-19 13:07:50,"As mentioned by @bdefore and @kdepp in #851, changeOrigin should be set to true by default.

The very first reason is simply to be compatible with the HTTP 1.1 specifications that **requires** a _Host_ header. If a proxy listen on foobar.com and proxies request to bargee.net, then every requests sent to bargee.net must have a _Host_ header set: `Host: bargee.net`.
In turns, by fixing the inconsistencies generated by `changeOrigin=false`, it will enable all virtual host environment to serve request correctly. This is the case for example when using _http-proxy_ via _grunt-connect-proxy_ that even dropped support for changeOrigin and requires injecting forcefully the host header.

IMHO, it would even be better to get rid of that option completely and consider it is always true.",patrickallaert,
1131,2017-01-11 19:07:27,Update link to properties,eladb,2017-01-11 20:53:05
1130,2017-01-09 10:47:56,"changeOrigin has nothing to do with `origin` header which is confusing and harmful when working with CORS. As CORS middleware sometimes makes decisions depending on `origin` header.

`changeOrigin` option handles solely `host` header.",asvae,
1130,2017-01-19 13:15:33,"Correct, but in my opinion, the `changeOrigin` config should just be removed and default to `true`. See #1132 for more info.",patrickallaert,
1129,2017-01-05 08:05:48,"In the rewrite [redirect](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js) there are these status codes to redirect by:

    (line 5) var redirectRegex = /^201|30(1|2|7|8)$/;

I think you should also include the 303 (`SEE OTHER`) response status.
What do you think?",itaied246,
1129,2017-01-17 10:24:37,ran into the exact same problem. ,themasch,
1128,2017-01-03 17:05:37,"Handle toProxy option properly and get proxy settings from environment.

There is an option toProxy (true/false) for http-proxy. But it is never used afaiks.
This fix checks the option and uses the http/https proxy set in the environment variables.

Usage:
<S_CODE_TOKEN>

Sorry, for I had no time for unit tests (just needed a local hotfix ;) )... If you like the solution I could into this PR in more detail during the weekend.

",BernhardRode,
1128,2017-01-19 08:09:04,"Hi,

I have tested your patch, as is it's not working, below the correct code:

`if (options.toProxy) {
    var upstreamProxyServer;
    if (typeof options.toProxy === 'boolean') {
      upstreamProxyServer = url.parse(
        isSSL.test(options[forward || 'target'].protocol) ? process.env['https_proxy'] || '' : process.env['http_proxy'] || ''
      );
    } else {
      upstreamProxyServer = url.parse(options.toProxy);
    }
    
    if (upstreamProxyServer) {
      outgoing.path = options[forward || 'target'].protocol + '//' + outgoing.host + outgoing.path;
      outgoing.host = upstreamProxyServer.host;
      outgoing.hostname = upstreamProxyServer.hostname;
      outgoing.port = upstreamProxyServer.port;
    }
  }
`",assiomatica,
1127,2017-01-03 15:54:57,"Handle toProxy option properly and get proxy settings from environment.

There is an option toProxy (true/false) for http-proxy. But it is never used afaiks.
This fix checks the option and uses the http/https proxy set in the environment variables.

Usage:
<S_CODE_TOKEN>

Sorry, for I had no time for unit tests (just needed a local hotfix ;) )... If you like the solution I could into this PR in more detail during the weekend.

",BernhardRode,2017-01-03 17:05:26
1127,2017-01-03 17:06:55,"Created a feature brand for this PR.
See https://github.com/nodejitsu/node-http-proxy/pull/1128",BernhardRode,2017-01-03 17:05:26
1126,2016-12-30 09:24:37,"I'm using a simple proxy for web and socket and for some reason some of my request throw errors.

instead of having an object with { target: .., forward: ... } I got an empty withouth these two key. However I do have the ""secure"" key that I set while creating proxy object and I do have ""prependPath"".

Ex:
For most of my sockets request I have usually:
<S_CODE_TOKEN>

For some other I only got
`{ secure: false, prependPath: true }`

which is why the module throw error because of this check
<S_CODE_TOKEN>

Here is what I do on my server side

<S_CODE_TOKEN>

My stack is pretty simple and as I said, all my web request are ok, pretty much all sockets too. Only some of them fails.",mbret,2016-12-30 15:41:58
1126,2016-12-30 09:44:43,"After some digging, only the web socket request from wss:// are in cause. What is strange is that my web page is working, connected and receiving socket connection. Also when I use a dedicated proxy server (instead of my actual server) it works without any problem. So I think I'm missing some configuration with the socket proxying part ?",mbret,2016-12-30 15:41:58
1126,2016-12-30 15:11:44,"@mbret its because for your `web` proxy requests, you specify your target, you do not do the same for the `ws` proxy requests on the upgrade event. Add a 4th argument to the function that is an object that specifies `{ target: req.app.locals.system.config.sharedApiUrl })`

Your example should look like:

<S_CODE_TOKEN>",jcrugzz,2016-12-30 15:41:58
1126,2016-12-30 15:41:22,"Of course I did not -_-

Thanks a lot @jcrugzz. To be honest I'm a bit stupid because some of my socket request pass through http and so inside the req.app.locals.proxy.web. So I naively thought that my app.locals.proxy.ws was okay like this. Don't know if you get what I mean but whatever, thank you :)",mbret,2016-12-30 15:41:58
1126,2016-12-30 16:07:36,"yea if it was using the socket.io longpolling those would have worked, but if it upgraded, then the issues began. No problem and good luck",jcrugzz,2016-12-30 15:41:58
1125,2016-12-29 20:56:15,"resolves #845

This PR enables hostRewrite, autoRewrite, and protocolRewrite on HTTP 303 (See Other) redirects.",jrnail23,
1124,2016-12-29 03:21:32,<S_CODE_TOKEN>,sadovnik,2016-12-29 03:27:10
1124,2016-12-29 03:27:10,"Whoops, this is a port access issue.",sadovnik,2016-12-29 03:27:10
1123,2016-12-27 13:58:52,"Corresponding to the explanations preceded by the '‚Ä†' symbol. I had to re-read those lines when reading the doc, I think makes more reading-sense now.

Please review. Does not change the README itself.

Comes from missing PR's due to some errors #1122 and #1121 not rebasing the project when PR was made.

",ivannieto,
1122,2016-12-25 13:54:39,"Corresponding to the explanations preceded by the '‚Ä†' symbol. I had to re-read those lines when reading the doc, I think makes more reading-sense now.

Please review. Does not change the README itself.",ivannieto,2016-12-27 13:55:37
1122,2016-12-25 13:55:40,:thinking: why is it showing conflicts?,ivannieto,2016-12-27 13:55:37
1122,2016-12-26 18:37:28,@ivannieto can you rebase your changes off `origin/master`? you are still based on your previous git tree before your changes were merged. That is why there are so many extra commits above,jcrugzz,2016-12-27 13:55:37
1122,2016-12-27 13:43:59,sure @jcrugzz my bad! ,ivannieto,2016-12-27 13:55:37
1122,2016-12-27 13:55:37,Closing and reopening a new PR.,ivannieto,2016-12-27 13:55:37
1121,2016-12-25 13:45:34,"Corresponding to the explanations preceded by the '‚Ä†' symbol. I had to re-read those lines when reading the doc, I think makes more reading-sense now.

Please review. Does not change the README itself.",ivannieto,2016-12-25 13:52:57
1121,2016-12-25 13:52:57,"Forgot to pull before. I should remember Chuck's words... üòÑ 

Fixing now.",ivannieto,2016-12-25 13:52:57
1120,2016-12-24 18:42:10,"Added link to the Code Of Conduct file. 

I've inserted the link into the Contributing and Issues section, due to the relationship between contributing and how to become a good contributor.",ivannieto,2016-12-24 22:02:42
1120,2016-12-25 10:37:16,"Thanks @jcrugzz ! üëç üòÑ 

",ivannieto,2016-12-24 22:02:42
1119,2016-12-24 15:27:02,,ivannieto,2016-12-24 18:27:55
1119,2016-12-24 18:27:52,@ivannieto Thanks for adding this!,jcrugzz,2016-12-24 18:27:55
1119,2016-12-24 18:28:18,"@ivannieto i realized i merged to fast, would you mind adding a link to this in the README?",jcrugzz,2016-12-24 18:27:55
1119,2016-12-24 18:29:45,@jcrugzz do you want to say adding the link to this file in the repo? or to the default Covenant?,ivannieto,2016-12-24 18:27:55
1119,2016-12-24 18:30:52,@ivannieto add a link to the code of conduct file in this repo to our README so people have a direct link. ,jcrugzz,2016-12-24 18:27:55
1119,2016-12-24 18:42:45,Done in https://github.com/nodejitsu/node-http-proxy/pull/1120,ivannieto,2016-12-24 18:27:55
1118,2016-12-24 07:44:16,"How is it possible to have multiple HTTPS -> HTTP proxies?

Seems like I can't do something like in this example for HTTP -> HTTP:

<S_CODE_TOKEN>
because for each server instance I should provide certificate.

I found `SNICallback` in `https` options but I don't know is it right approach and how to use it.",SET001,2016-12-24 14:01:17
1118,2016-12-24 14:00:56,"@SET001 this technically doesnt have anything to do with `node-http-proxy`. This has to do with handling multiple SSL certs from a single `https` server. You are correct in that using `SNICallback` is the right approach. You should search for more examples and try it out yourself. I found [this](http://blog.sammauldin.com/configuring-https-with-node-js-startssl-and-sni/) blog post and improved their example below.


<S_CODE_TOKEN>",jcrugzz,2016-12-24 14:01:17
1118,2016-12-24 16:23:35,"@jcrugzz , thanx for you respond. I think it has to do with `node-http-proxy` because I need to proxy multiple sub-domain calls to multiple servers running each on different ports. Something like this:

https://a.foo.com -> 127.0.0.1:3000
https://b.foo.com -> 127.0.0.1:3001
https://c.foo.com -> 127.0.0.1:3002

also I have a certificates for each of this domain.

`SNICallback` will be called each time new connection to any of this sub-domains appears and I don't get how to proxy that connection to appropriate local server.
Also I'm lucking experience with express and node.js so I may miss something obvious here",SET001,2016-12-24 14:01:17
1118,2016-12-24 18:26:39,"A * based cert would make this easier ;) but doesnt matter either way. @SET001 check out the documentation as it gives examples of this. The proper cert will be handled by the SNICallback. You need to then proxy to a different `target` based on the `req.headers.host`. You can store a them similar to the certs above.

<S_CODE_TOKEN>

If you have anymore questions please ask on Stackoverflow or somewhere similar. If you find a bug or issue with `http-proxy` please feel free to open a new issue. Have fun :)",jcrugzz,2016-12-24 14:01:17
1118,2017-01-02 10:28:57,"What I still can't understand is that I have few `*.key`/`*.cer` files for all subdomains which i get from `letsencrypt.org` (they are not supporting wildcard certificates atm) and which I will use in `SNICallback` like in your code. But I also should put one pair to `https.createServer`. What certificates should it be?

I have also created [question](http://stackoverflow.com/questions/41311391/how-is-it-possible-to-have-multiple-https-proxies) on StackOverflow but with no responses. So for now, you are the only one helping  me to figure out all this hell, for which I am very grateful to you.",SET001,2016-12-24 14:01:17
1117,2016-12-23 14:16:15,,jtrussell,
1116,2016-12-22 10:09:15,"Hello !

I need to use my http-proxy module with a adresse format like this :

[http://ipProxy:portproxy/http://ipServeur:portServeur](url)

But i don't found an example.

Can somebody help me ?

BR",Toon34,
1115,2016-12-20 21:33:33,added hint to inform users not use use both target and forward,chrisnew,
1114,2016-12-19 22:50:21,"I've been using node-http-proxy via [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware), but found that the `origin` header is not being propagated to the target server, nor was I able to set it via the `proxyReq ` interface.

Is there a way to ensure the proxy will pass on the origin header in the request or avoid it from being removed/stripped?

See also:
https://github.com/chimurai/http-proxy-middleware/issues/139
https://github.com/facebookincubator/create-react-app/pull/1212
",adamreisnz,2016-12-19 22:58:31
1114,2016-12-19 22:58:31,"It seems it was user error, I was using proxyRes instead of proxyReq to set the header, but proxyRes is the actual *response* from the target.",adamreisnz,2016-12-19 22:58:31
1113,2016-12-19 21:51:35,"Hi!

I've found an issue allowing long running proxied connections to stay open. In this case, it's something we've seen related to the [webpack dev server](https://github.com/webpack/webpack-dev-server) which has this http-proxy package as its dependency via [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware).

In practise what we've seen is that long running proxied requests are being closed after 2 minutes, even though we specify a longer timeout with the **proxyTimeout** option. That in turn may make some browser automatically retry the request which failed, which is absolutely not wanted in some scenarios -- the latter isn't really this package's fault, so feel free to ignore that part.

After [digging for a while](https://github.com/webpack/webpack-dev-server/issues/369#issuecomment-266251977) I found the root cause to be in this package's request handler ([lib/http-proxy/index.js](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/index.js#L31)). By not setting a timeout on the incoming HTTP socket with [request.setTimeout()](https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_message_settimeout_msecs_callback), Node.js core sets 2 minutes by default.

Ideally we'd like to be able to set **proxyTimeout** to whatever number we want and be sure that's respected. That possibly means using the same value in `request.setTimeout()`.

Does this sound okey to you? Any other thoughts?

Refs https://github.com/webpack/webpack-dev-server/issues/369#issuecomment-266251977

/cc @Martin-Wegner",phillipj,
1113,2017-01-19 20:47:34,"FWIW, I was able to work around this via 

<S_CODE_TOKEN>

I just set the request timeout in the handler lambda before passing into the proxy handler itself.

That said: right or wrong, I 100% expected it to set the request timeout for me, mostly because I didn't even know that was a thing until I ran into the timeout in a long test.

So I have no idea what arguments might exist against setting the `request` timeout inside the proxy handler, but I can't imagine why it would be desirable to let the socket close when the proxy timeout hasn't elapsed. (as someone who has considered it for all of 10 minutes now üòÖ)",benmosher,
1112,2016-12-15 09:32:32,"i do not understand why i cannot modify request headers?

Ive tried 

    req.headers['x-my-header']=somestring

and even the doc sample

     proxy.on 'proxyReq', (proxyReq, req, res, options) ->
        proxyReq.setHeader 'x-my-header',somestring

but allways same error

> Error: `value` required in setHeader(""X-my-header"", value).
>      at ClientRequest.OutgoingMessage.setHeader (_http_outgoing.js:342:11)
>      at ProxyServer.<anonymous> (/app/lib/routes/proxy.js:78:20)
>      at ProxyServer.emit (/app/node_modules/http-proxy/node_modules/eventemitter3/index.js:119:35)
>      at ClientRequest.<anonymous> (/app/node_modules/http-proxy/lib/http-proxy/passes/web-incoming.js:125:27)
>      at emitOne (events.js:82:20)
>      at ClientRequest.emit (events.js:169:7)
>      at tickOnSocket (_http_client.js:491:7)
>      at onSocketNT (_http_client.js:503:5)
>      at nextTickCallbackWith2Args (node.js:442:9)
>      at process._tickCallback (node.js:356:17)


",dynnamitt,2016-12-28 20:46:56
1112,2016-12-15 09:35:04,"ok 
forgot to check somestring  ..its undef
",dynnamitt,2016-12-28 20:46:56
1111,2016-12-14 21:06:22,"I'm new in Node.JS and deployed the first application on VPS. After running on port 8000, i decided create a http-proxy for forward each domain to its specific port . I worte a little application like here :

var http = require('http'),
    httpProxy = require('http-proxy');

var option = {
    router : {
        'domain.com' : 'http://88.198.86.100:8000'
    }
};

var proxyServer = httpProxy.createServer(option);
proxyServer.listen(80);
88.198.86.100 is my server ip.


So, my problem here is shown , **when i typed 88.198.86.100 in my browser PC (Google Chrome), my proxy application in server was carshed and gave this error :**

C:\Users\Administrator\Desktop\Nodejs\node_modules\http-proxy\lib\http-proxy\index.js:119
throw err;
^

Error: Must provide a proper URL as target
at ProxyServer.<anonymous> (C:\Users\Administrator\Desktop\Nodejs\node_modules\http-proxy\lib\http-proxy\index.js:68:35)
at Server.closure (C:\Users\Administrator\Desktop\Nodejs\node_modules\http-proxy\lib\http-proxy\index.js:125:43)
at emitTwo (events.js:106:13)
at Server.emit (events.js:191:7)
at HTTPParser.parserOnIncoming [as onIncoming] (_http_server.js:546:12)
at HTTPParser.parserOnHeadersComplete (_http_common.js:99:23)
error: Forever detected script exited with code: 1


**I want to someone enter IP server into the each browser, my application will not crash.**",blackhair,
1111,2017-02-07 13:45:28,"Hi, 

Do you find a solution? I have same problem.",charlou28,
1111,2017-03-17 19:07:08,"Im having the same issue. Looking for issue/work around. 

I can proxy to http://1.1.1.1:8096/ but not to http://1.1.1.1:8080/. 

The difference? 
port 8096 = Emby media server -- https://emby.media/download.html
port 8080 = Pea Server -- https://github.com/recap/pea-server

Perhaps this is related to what the proxy receives as the response from the target?

Digging further I found that as of http-proxy/lib/http-proxy/index.js:60 i cannot find the target.
      console.log(options.target);    //was undefined
      console.log(options['target']);   //was undefined
      console.log(options[0]);   //was undefined



MUCH ODDNESS!   -- cleared my browser cache, moved the target out of setting it directly and instead pulled it from my dataset as i planned and somehow go this to work. I will post my code below for anyone wanting to see how i got it working.
app.db:
> {""data"":[{""table"":""routes"",""name"":""awe"",""authenticate"":""true"",""path"":""app"",""target"":""http://1.1.1.1:8080/"",""_id"":""ee3e2439-ef94-4f45-a702-faf00c2632e1""}

server.js:
<S_CODE_TOKEN>

app-lib.js:
<S_CODE_TOKEN>
app-db.js:
<S_CODE_TOKEN>",computermaster0101,
1110,2016-12-14 19:45:30,"I'm trying to capture a request and decide if I'm going to send it to another PROXY A or to PROXY B or to make a direct connection or return a null response.

There is any example or test or any project that is doing that so I can see a example? Any tip?

I'm going to try this only with HTTP, but the next step will be to make HTTPS work. 

For now I have the next code:

<S_CODE_TOKEN>",wiliame,
1110,2016-12-14 20:22:30,"For testing purposes, this is working, there is a better option?

<S_CODE_TOKEN>",wiliame,
1110,2017-01-03 15:56:06,"I provided a fix for the problem.

https://github.com/nodejitsu/node-http-proxy/pull/1128

",BernhardRode,
1110,2017-01-12 23:59:00,@BernhardRode can you provide an example for my case please?,wiliame,
1110,2017-01-13 06:56:20,"What do you mean with example? 

Try to checkout/link my #1128 branch... i think it should just work by then.",BernhardRode,
1109,2016-12-13 20:19:13,`node-http-proxy` is not affected by the only breaking change in version [2.0.0](https://github.com/primus/eventemitter3/releases/tag/2.0.0) so I think it makes sense to update as there are some nice performance improvements.,lpinca,2016-12-16 17:28:52
1109,2016-12-16 17:28:47,Thanks @lpinca ,jcrugzz,2016-12-16 17:28:52
1108,2016-12-13 10:25:09,#1107,mixxen,
1108,2016-12-16 14:59:36,"I'm welcome this PR, because I didn't care about incoming request.
But I'm not a maintainer, please take their review ;)

IMO, Existing specs seems not to cover additional behavior. Would you please add specs?",pachirel,
1107,2016-12-13 10:23:06,The option <S_CODE_TOKEN> works for web outgoing only,mixxen,
1107,2016-12-15 21:23:34,@pachirel I think you are the author of <S_CODE_TOKEN>. Could you take a look at this issue and pull request?,mixxen,
1107,2016-12-16 15:01:04,@mixxen thanks for your PR! I left my comments in the PR üëç ,pachirel,
1106,2016-12-06 15:40:38,"In 1.16.X, vs 1.15.X that I had been using, http-proxy's proxyRes listener would allow me to do things, such as proxyRes.header.location = ""newLocation"" or response.setHeader(""Location"", ""newLocation"").

After a fresh repo install and getting 1.16, my header location rewrite was broken. Through trial and error, we found that 1.16 is stomping on our header rewrite. We have downgraded to 1.15.2 in the mean time.

Is this expected changes for 1.16?

Regards,
Brandon",bwinchester,2016-12-06 18:08:33
1106,2016-12-06 18:08:33,"1.16.1 was the problem, 1.16.2 fixed this issue for me. ",bwinchester,2016-12-06 18:08:33
1105,2016-12-06 12:53:02,"Hi,

I using Gulp with browsersync and http-proxy + XAMPP. All works great but I have problem with htaccess. It doesn't works :(

Do you have solution for it?",kriss145,
1104,2016-12-06 07:23:44,"My change (#1098) has side effect because of the header values of `rawHeaders` are not always same with the values of `headers`. ( #1101, #1102, #1103) üôá 

This PR includes these changes to solve it:

1. Overwrite only key, not value.
2. Overwrite key if raw header key is available.
3. Add `preserveHeaderKeyCase` option (default: false).

@jcrugzz  I'd like to hear your thought. üç£ 

I have to add specs before marge this.
Sorry for any inconvenience, and thanks to all.",pachirel,2016-12-06 14:51:02
1104,2016-12-06 14:50:59,"@pachirel ill push this out now, submit a follow up PR with any additional changes you wanted to make so we can get this fixed.",jcrugzz,2016-12-06 14:51:02
1104,2016-12-06 14:54:03,"Sure :+1:
",pachirel,2016-12-06 14:51:02
1103,2016-12-05 16:13:40,"It seems the following commit introduces a bug and ""autoRewite"" doesn't work properly now:  https://github.com/nodejitsu/node-http-proxy/commit/4edbb62cc5881b20e7dae5e6240e693b03fd3609

Method [setRedirectHostRewrite ](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L71) changes ""location"" header, but [writeHeaders ](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L107) ignores it and uses `rawHeaders` instead of `headers`


",apalchys,2016-12-28 22:26:07
1103,2016-12-05 18:25:39,@apalchys could you give some more information on whats not working? what changed in the expectations? I apologize if all the conditions were not covered but the same logic is being run but is the value of the header not what is expected?,jcrugzz,2016-12-28 22:26:07
1103,2016-12-06 10:40:34,@jcrugzz you can find more details in a PR opened by @pachirel https://github.com/nodejitsu/node-http-proxy/pull/1104,apalchys,2016-12-28 22:26:07
1103,2016-12-06 10:48:44,"I have not tried to reproduce this issue yet.
Any additional information are welcome. :)",pachirel,2016-12-28 22:26:07
1103,2016-12-06 10:55:44,@pachirel  your PR looks good and should fix autoRewrite because it doesn't overwrite header value. thanks.,apalchys,2016-12-28 22:26:07
1103,2016-12-07 00:45:57,@apalchys 1.16.2 is available. please update and check your app. thanks to @jcrugzz.,pachirel,2016-12-28 22:26:07
1103,2016-12-08 02:46:54,"I don't know if this would be the right place for feedback but in lib/http-proxy/passes/web-outgoing.js
<S_CODE_TOKEN>

from 1.16.1 prior to the roll back was a breaking change. Our tooling was expecting a consistent array of cookies returned. The return of a string or an array was causing everything to break. Working locally and simply returning

<S_CODE_TOKEN>

got us back up and operational.

I don't know if this impacts autoRewrite specifically, but figured I could provide some feedback on my own investigations into the matter",myfancypants,2016-12-28 22:26:07
1103,2016-12-08 14:11:34,@pachirel it works now. thanks a lot!,apalchys,2016-12-28 22:26:07
1102,2016-12-04 04:38:10,"Implementation of proxy HTTP raw headers response processing in 1.16.0 fails to account for multiple `Set-Cookie` headers.  This patch accounts for multiple Set-Cookie header, and sets the source response headers to an array.",kriswill,2016-12-04 15:59:23
1102,2016-12-04 15:59:23,"cherry-picked, thanks!",jcrugzz,2016-12-04 15:59:23
1102,2016-12-06 05:13:08,@kriswill Thanks to fix this issue. and sorry for any inconvenience.,pachirel,2016-12-04 15:59:23
1101,2016-12-03 20:04:00,"Minor version bump of http-proxy caused our Ember-cli app to only forward a single cookie from the back-end, rather than all cookies. I believe this is because of the rewrite to web-outgoing.js/writeHeaders.

<S_CODE_TOKEN>

Gets turned into this in the response header:

<S_CODE_TOKEN>",tomlagier,2016-12-04 19:01:52
1101,2016-12-04 17:58:40,"@jcrugzz @tomlagier this should be fixed now, please retest!",kriswill,2016-12-04 19:01:52
1101,2016-12-04 19:01:52,Yes this should be fixed with the changes made by @kriswill. Will reopen if this is still a problem. My apologies for the trouble.,jcrugzz,2016-12-04 19:01:52
1100,2016-12-02 12:33:45,"In my merged PR #1099, I was too fast. I didn't make enough changes in the error handler and for `ECONNREFUSED` this introduced a new error, since `proxyReq` was not defined.

To fix it, I wrapped the error handler in a `createErrorHandler()` function to specify which request should be handled (`proxyReq` or `forwardReq`).",maartenth,2016-12-02 14:09:12
1100,2016-12-02 14:09:09,@maartenth We are both at fault here as I missed it too ;). Thanks for contributing! Please let me know if the forward proxy is working as expected as im not sure if it was originally written to spec. ,jcrugzz,2016-12-02 14:09:12
1099,2016-12-01 13:17:24,"Errors in forward requests were not handled. This caused my process to exit after an `ECONNREFUSED`.

Errors in target request and the original request were already properly handled. I added forward request error handling the same way.

Added a test case proving the fix.",maartenth,2016-12-01 14:39:46
1099,2016-12-01 14:39:56,LGTM üëç. Thanks,jcrugzz,2016-12-01 14:39:46
1098,2016-12-01 06:22:49,"This PR fixes the issue https://github.com/nodejitsu/node-http-proxy/issues/1029

In RFC, HTTP header key is case-insensitive (ref: https://github.com/nodejs/node-v0.x-archive/issues/1954).
But, proxy server should care not to change the original request unintentionally ‚ú® ",pachirel,2016-12-02 01:03:13
1098,2016-12-02 00:54:20,@jcrugzz Thank you for your quick response üòÑ  I fixed.,pachirel,2016-12-02 01:03:13
1098,2016-12-02 01:03:24,thanks!,jcrugzz,2016-12-02 01:03:13
1097,2016-11-29 19:27:42,I've only ever seen examples of users specifically setting a client certificate and key/passphrase in the target options. Is there a way to pass through the provided client certificate from the browser through the proxy? I don't want to have to provide a cert and key or pfx and passphrase as it is unsecure to do so.,kpaxton,
1097,2016-11-30 17:12:33,"If I understand your request, you are asking if the proxy can authenticate to a backend service with the clients PKI credentials.  It is not possible to do this because in order to authenticate with a client certificate, the private key must be accessible - which the client browser has, but the proxy server does not.  

The best you could do would be to generate a SAML assertion or JSON Web Token and use that.   Alternatively, I suppose the proxy could pass on the client certificate as a request header, but the backend service would have to trust that the user had authenticated properly to the proxy.  It is not possible to actually do real client-side certificate authentication through a proxy. ",risacher,
1096,2016-11-29 15:42:04,"Hello,

I wish to get the status code I got from the proxy in the proxy. I'm listening the 'proxyRes' event.

The parameters it has does not seem to have Status header set to any value for some reason.

BR,
Ville Miekk-oja

Update: resProxy.statusCode did the trick",VilleMiekkoja,2016-11-29 15:43:18
1095,2016-11-27 01:11:27,,purificant,2016-11-29 14:01:06
1094,2016-11-23 02:21:43,"I'm still working on this, but there's definitely an issue, and it's definitely an involving node-http-proxy. Here are the symptoms:

1. IE11 on Windows 7, on a separate machine, sometimes gets partial PDF files through a proxy
2. IE11 on the same system can access the same PDF successfully all the time if it bypasses the proxy
3. The original server is essentially express, and using res.download to send the file.
4. Incomplete files are truncated, usually at around 700 bytes (in a binary part of the PDF)
5. FF on Windows 7 also fails with ""the connection was reset"" -- about one in every five or six times it succeeds. 
6. If the proxy is stopped and restarted, the next request appears to be always OK for both IE and FF (i.e., it looks like connections are involved).
7. Chrome on Win 7 appears to be immune, as is curl. 

The proxy that makes the difference is literally:

<S_CODE_TOKEN>

I would be suspicious of a relation with #1007, but the fact that restarting the proxy makes the next request work makes me think something else is going on. 

IE is aware of the short length (in the dev tools) but never reports anything. The stored files are simply short. 

Any ideas?",morungos,2016-11-25 22:25:42
1094,2016-11-25 22:25:42,"Okay, so I apologize. Turns out this was a VirtualBox regression: https://www.virtualbox.org/ticket/16084. There had been reports of chunking issues in proxying with IE, but the latest VirtualBox has resolved the issue. ",morungos,2016-11-25 22:25:42
1093,2016-11-16 09:23:04,"I need to change the status code on some responses before passing them on based on the data in them. Their body is a JSON object containing a field that determines this. I have only found a way (using middleware) to change the body content:

<S_CODE_TOKEN>

However I found no way to change the status code and status message. Doing this:
`res.statusCode = 400`
has no effect on the response my client receives.",Raz-Hemo,
1093,2017-02-06 15:11:22,+1,lomori,
1093,2017-02-19 10:01:07,"I was able to do this by overriding the writeHead function

<S_CODE_TOKEN>",furqanZafar,
1092,2016-11-15 23:43:51,"This is problematic when you try to use [tus-node-server](https://github.com/tus/tus-node-server) behind 
http-proxy : when uploading a file, tus protocol first create an empty resource it will then patch with content. 
This goes as follow :

<S_CODE_TOKEN>
and here, we get an error, usually 404.
",MonsieurLanza,2016-11-16 10:26:49
1092,2016-11-16 10:26:41,"My bad, already fixed.
",MonsieurLanza,2016-11-16 10:26:49
1091,2016-11-14 22:44:28,"Fix for https://github.com/nodejitsu/node-http-proxy/issues/867, and possibly these others: https://github.com/nodejitsu/node-http-proxy/issues/908, https://github.com/nodejitsu/node-http-proxy/issues/930, https://github.com/nodejitsu/node-http-proxy/issues/889, https://github.com/nodejitsu/node-http-proxy/issues/680.

This solution was suggested by @giuliopaci in https://github.com/nodejitsu/node-http-proxy/issues/867.  The problem with the header re-writing example in the README is that when you do a POST, the headers are sent before the 'proxyReq' event is fired.  So you really have to add the headers before calling request().  This patch allows the user to register a synchronous callback that gets called in setupOutgoing() in which the caller can setup headers, or alter the outgoing request() options in whatever way desired.
",rick-kilgore,2016-12-08 00:19:18
1091,2016-11-18 22:14:34,"üëç 
",Jeremy-iCars,2016-12-08 00:19:18
1091,2016-12-02 14:31:23,@Jeremy-iCars @rick-kilgore in this case why not just pass the headers in? I guess we could be more defensive in this case and not fire the event on post requests if it can have this type of unexpected consequences. I just think adding more options isnt the right solution. ,jcrugzz,2016-12-08 00:19:18
1091,2016-12-03 01:33:15,"@jcrugzz Pass the headers in where?  In my case, I need to dynamically choose what to send in the way of headers based on the request.  Specifically, I'm supplying a default header value only if the original request does not contain the header.",rick-kilgore,2016-12-08 00:19:18
1091,2016-12-03 18:05:16,@rick-kilgore before you call `proxy.web` with the `req` and `res` you can optionally pass in headers as options. You can see it in the docs [here](https://github.com/nodejitsu/node-http-proxy#options) and in the code [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L46-L48).,jcrugzz,2016-12-08 00:19:18
1091,2016-12-06 12:17:46,"My current understanding, is that the ""proxyReq"" callback is called too late for the purpouse of changing headers. What about moving the event emission of ""proxyReq"" at the end of setupOngoing, without adding a new event?

As far as I understand from node-https-proxy, the only purpouse for this callback is to change headers, and this do not require a socket.

In my case I want to remove headers and, sometimes, adding new headers on the basis of the reveived ones, so the flexibility provided by proxyReq callback seems to be required.",giuliopaci,2016-12-08 00:19:18
1091,2016-12-08 00:19:13,"@jcrugzz - now I see what you mean.  I somehow got the mistaken impression that the function I pass into http.createServer() was being called only once at startup, instead of once for every request.

I think my confusion was partly reinforced by the example for setting headers, though.  You might want to change the example in the README to do it the way you're suggesting, since it won't work for POST requests the way it is.",rick-kilgore,2016-12-08 00:19:18
1091,2017-03-22 17:03:13,"What if the header to be set is conditional?

For instance, I have a post request that should be ""If this header `foo` is set on the incoming request, then also add header `bar`

@jcrugzz Is this currently supported?",aleclerc,2016-12-08 00:19:18
1090,2016-11-10 22:49:22,"Hi,

I have use case where I'm proxying to a server w/ require mutal tls? If so is there any documentation of that?

Regards,
Dat",datpham23,
1090,2016-11-17 00:55:39,"After digging through the code I finally got POC that worked, hopefully this can help someone else.

<S_CODE_TOKEN>
",datpham23,
1089,2016-11-10 12:42:27,"While updating `node-http-proxy` for one my projects I noticed there is no history of version changes. While search through this repository I also noted at some point this was removed. Was this a deliberate choice?

I think for a future perspective it would be useful to give a history of fixes and new features.",jjanssen,
1088,2016-11-09 14:09:56,"I have a service that is proxying requests to RESTHeart.

My service requires BasicAuth criteria#1 and RESTHeart requires BasicAuth criteria#2 ('admin:changeit').  In my service I amend the URL of the target, set the auth and make the proxy.web() call with new those options:

`var target = util.format(""http://%s:%d%s"", RESTHEART_HOST, RESTHEART_PORT, path);
    var options = {
        target: target, 
        ignorePath: true,
        auth: 'admin:changeit',
        method: clientRequest.method
    };

    proxy.web(clientRequest, clientResponse, options, function(err){
        /// stuff here
    });`

This gives a 401.  On inspection this was due to the criteria#1 being passed in the proxied request.  I also tried embedding auth in the target, viz:

`var target = util.format(""http://admin:changeit@%s:%d%s"", RESTHEART_HOST, RESTHEART_PORT, path);`

But likewise, this returns a 401.

Eventually I set the original auth in the client request to null which then forced http-proxy to work as expected, by inserting the following line above the var options:

`    clientRequest.headers.authorization = '';
`


Comments?",garysmith-github,
1088,2016-11-09 16:10:09,"I'm having a similar issue here. I'm having this module rerouting all my connections from my local server to my api. The proxy redirects properly the cookies but it doesn't redirect properly when my client request has another header:

<S_CODE_TOKEN>

I will keep investigating on this. Tell me if you have any solution. I'll do the same.
",rgolea,
1088,2017-02-24 20:38:55,"I have the same problem.  In my case, I have an inbound proxy that accepts Authorization: Bearer <JWT> and then reconnects to a server that wants Http Basic credentials.  I'm looking for a workaround but may have to patch this code.",GregTurner,
1088,2017-02-24 20:53:46,"This is the workaround I used.  Warning: I'm hooking an unpublished event here to get access to the req object earlier.  It would seem the outgoing req is cloned from the incoming BEFORE the proxyReq is emitted.  In any case, it would appear like defect and an easier to repair one.

<S_CODE_TOKEN>",GregTurner,
1087,2016-11-08 09:05:33,"Hello. First of all i think the info about `timeout` option should be added to **readme**, it is not obvious that you can use it (and shoud use it if you want to have more than 2 mins timeout) and how it differs from `proxyTimeout`.

Also you can't set timeout to zero which should imply infinite awaiting, because zero is false. I think it shoud be allowed.

https://github.com/nodejitsu/node-http-proxy/blob/d0f1dfeb8277d46a057017cd888b50e85f6725d6/lib/http-proxy/passes/web-incoming.js#L50",gavvvr,
1087,2016-11-08 15:46:21,"@gavvvr Would definitely take a PR that updates readme and accepts 0
",jcrugzz,
1086,2016-11-07 22:14:16,"im using a proxy for a live hls stream and with some streams it is working but there is a stream that the request the .ts files to the real origin, is there a way to make the stream request the .ts files to the proxy?",darkrole,
1085,2016-11-07 02:44:50,,adc-jrahoi,2016-11-07 09:44:01
1085,2016-11-07 09:44:14,"created by accident, sorry
",adc-jrahoi,2016-11-07 09:44:01
1084,2016-11-02 19:57:15,"Hi,

I did http -> https proxy using your example. Client makes POST request to the proxy.
Content-Type:application/x-www-form-urlencoded
Form data: draw=1&columns[0][data]=0&columns[0][name]=&columns[0][searchable]=true

After the proxy I get data that looks like json:
{ draw: '1',
  'columns[0][data]': '0',
  'columns[0][name]': '',
  'columns[0][searchable]': 'true'
}

How can I get correct form data after proxy? Please, help.

P.S. I don't use body-parser :) ",yvrublevskiy,2016-11-07 07:08:04
1083,2016-11-01 06:16:50,"We have a development target API server which is using https and a self sign cert. We want to send the http request to our frontend server and then proxy to that https server. So our scenario is like `http -> https`

My code is like:

<S_CODE_TOKEN>

Then I got an error: 
<S_CODE_TOKEN>

I tried to add `secure` and `ssl` options to our proxy server. Then the error become to 

<S_CODE_TOKEN>

Is there any problem with my code? The http-proxy version I am using is `1.15.2`.
",CrisLi,
1083,2016-12-15 13:53:57,"Just in case, have you tried `secure: false`?",mhnagaoka,
1083,2016-12-25 10:15:29,`secure: false` Solves it for me..,shaialon,
1083,2017-01-20 18:23:12,The docs could be clearer. It seems to default to `undefined`.,twhid,
1083,2017-01-20 18:23:55,"Which, seems to mean in practice that it defaults to `true`.",twhid,
1082,2016-10-28 08:10:05,"proxyToNext is a function like this,if return true proxy to next
`
proxyToNext: (proxyRes) => {
  if (matchRouterChain.length > 0 && $next && $next(proxyRes)) {
      ProxyWeb(req,res);
      return true;
 }
 return false;
}
`
",dzy321,
1081,2016-10-27 11:29:55,"My app works in docker container,  the `http-proxy` always response 404 http status.
However,  It worked well out of container.

<S_CODE_TOKEN>
",koolay,
1080,2016-10-23 20:09:39,"Hi

I have no idea how this happens but I am getting this crash dump when I proxy some requests.  It's especially annoying because I can't catch the Exception in my code as it happens in the http-proxy code.  

<S_CODE_TOKEN>

Could we add some sanity check in here?  I noticed that _http_server.js does this.

<S_CODE_TOKEN>

Using version 1.15.2 of http-proxy

Thanks
",philios33,
1080,2016-10-24 13:21:40,"@philios33 Could you inspect whats coming back from the response by logging on the `proxyRes` event? `proxy.on('proxyRes', function (res) { console.log(res.statusCode) });`
",jcrugzz,
1079,2016-10-12 06:56:51,"In the req.on('end"", ... ), proxy.web does not work.
I want to either proxy or mock based on request body.

<S_CODE_TOKEN>
",anyone-can-test,
1078,2016-10-05 14:21:56,"when using with 'http2', http2 throws an error 'can't set deprecated header : connection'
",nnIIInnjA,2016-10-06 20:24:45
1078,2016-10-06 07:04:17,"two test case added. 
if 'connection' header exists in req Object and when it doesn't.
",nnIIInnjA,2016-10-06 20:24:45
1077,2016-10-04 20:06:28,"I'm using Socket.io 1.4.5 to send data from my backend API to the frontend.
While polling works I can't seem to get WebSockets to work. The ""upgrade"" to ws is always cancelled with this error:

> WebSocket connection to 'ws://localhost:3000/ws/?EIO=3&transport=websocket&sid=CX4sQStiAfXCwsIbAAAC' failed: Error during WebSocket handshake: Invalid status line

The client part:

<S_CODE_TOKEN>

The frontend's proxy part:

<S_CODE_TOKEN>
",dj-hedgehog,
1077,2016-10-26 22:06:54,"Is your web service returning an Http 101 back to your client? Believe it will throw this error if you give back a status code such as 200 instead of the expect 101.
",ckross01,
1076,2016-10-04 11:50:16,"I got the same issue: https://github.com/indexzero/http-server/issues/244#issuecomment-250935798

The reason is union only support `response.writeHead(statusCode, [headers])`
https://github.com/flatiron/union/blob/master/lib/response-stream.js#L72
",lolychee,2016-10-04 13:54:27
1076,2016-10-04 13:54:26,"@lolychee this is not the proper fix for this problem. Reverting this commit breaks other projects and the root of the cause in this issue is `union`. The fix belongs in there as the problem is with it writing bad headers.
",jcrugzz,2016-10-04 13:54:27
1075,2016-10-01 03:32:53,"http-proxy provides a [proxyTimeout option](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L122) that allows us to set a timeout on the outgoing socket connection to the target. This timeout is very effective when the upstream target does not respond within an expected time.

I had wasted a few hours searching for this option. Documenting this option can save others a significant amount of time.
",ashishdahiya,2016-10-04 13:54:52
1075,2016-10-04 13:54:50,"Thanks!
",jcrugzz,2016-10-04 13:54:52
1074,2016-09-30 09:50:10,"Global options are being overwritten from `proxy.web(req, res, opts)`, which breaks some more complex scenarios like proxying to multiple servers with different options.

This is essentially the same as https://github.com/nodejitsu/node-http-proxy/pull/833 but with a test case.
",georgiyordanov,
1074,2017-01-16 00:06:06,"@jcrugzz or anyone else, any reason not to get this merged?",efokschaner,
1074,2017-02-12 05:01:56,Bump for great justice? @jcrugzz,efokschaner,
1073,2016-09-30 05:50:03,"I found that there are many requirements about  to modify the response results in Issues.
Sometimes the proxy server only returns the JSON. For example, call API from the server.
Harmon is for HTML/XML, but for JSON feels some heavy. So I create this PR to help others.
",langjt,
1072,2016-09-29 14:19:43,"Fixes path to http-proxy in two examples so that they can be run locally.
",kribblo,
1071,2016-09-28 21:10:53,"Tried to use the proxy with both signatures, with and without error Function, but was not able to use the proxy in an promise because i do not get the resolve state. 

How can I use it in promises? 
Please provide instructions and signature to are able to use it in promises. 
Thanks
",jimjaeger,
1071,2016-11-04 12:34:16,"I would be interested in the same thing.
",busybeaver,
1070,2016-09-28 00:16:13,"Sample Code

<S_CODE_TOKEN>

Error Stack

Error: Hostname/IP doesn't match certificate's altnames: ""IP: xxx.xxx.xxx.xxx is not in the cert's list: ""
    at Object.checkServerIdentity (tls.js:203:15)
    at TLSSocket.<anonymous> (_tls_wrap.js:1061:29)
    at emitNone (events.js:86:13)
    at TLSSocket.emit (events.js:185:7)
    at TLSSocket._finishInit (_tls_wrap.js:580:8)
    at TLSWrap.ssl.onhandshakedone (_tls_wrap.js:412:38)
",whitelife,2016-09-30 04:28:35
1070,2016-09-30 02:49:47,"try adding the  `changeOrigin: true` 

<S_CODE_TOKEN>
",VSuryaBhargava,2016-09-30 04:28:35
1070,2016-09-30 04:28:33,"Thanks! It was helpful. I tested by your advice. and it was succeeded.
",whitelife,2016-09-30 04:28:35
1069,2016-09-27 09:48:11,"or how not to send connection header in request ?
",nnIIInnjA,2016-10-06 20:45:33
1069,2017-02-23 09:42:09,Same problem here. Tried to used BrowserSync Proxy with HTTP2. üòû ,DaSchTour,2016-10-06 20:45:33
1068,2016-09-23 10:12:22,"can use like this:

let proxy = httpProxy.createProxyServer(
  [
    {
      target: proxyConfig.apiHost,
      // see https://github.com/nodejitsu/node-http-proxy#options
      changeOrigin: true
    },
    {
      target: proxyConfig.rapHost,
      // see https://github.com/nodejitsu/node-http-proxy#options
      changeOrigin: true
    }
  ]
)
",sydeEvans,
1067,2016-09-21 22:46:07,,piaolingxue,
1066,2016-09-21 02:46:58,"i want to change all the http ""get"" request   to    the target  by ""post"" method.

but i can not find  the node-http-proxy documents to resolve this problem.
",cuiyongjian,
1065,2016-09-21 01:42:26,"Hello,

I have 3 services and an ""api gateway"". One service accepts HTTP requests, and the other 2 are websocket services. I want to do URL-based routing to these services. For example:
- https://api..../route1 -> http service
- https://api..../route2 -> websocket service 1
- https://api..../route3 -> websocket service 2

When I do this, the websocket request never seems to reach the target server (no errors).

I have the following:

`boot.js`

<S_CODE_TOKEN>

`routes.js`

<S_CODE_TOKEN>
",zacharynevin,
1064,2016-09-20 10:53:36,"Hey

We are getting this exception `The header content contains invalid characters` after the update of 1.15.1. The reason is that union's response-stream does not implement the interface you describe in the 1.15.1 patch.

<S_CODE_TOKEN>

Not sure if you are willing to fix this, since this is basically unions fault. But the error is first exposed in your 1.15.1.

Best regards
Anders
",ducklord,
1064,2016-10-22 16:44:31,"+1
I'm seeing this in Chrome 52 running it as part of Express middleware. It happens in 1.15.1 and 1.15.2, but it is fine in 1.13.3.
",reykjavikingur,
1064,2016-10-22 18:00:53,"@ducklord the fix should be in union. @reykjavikingur could you post some code, a stacktrace and the version of express this is associated with? 
",jcrugzz,
1064,2016-10-22 18:48:30,"This should be fixed with latest union which would be installed with latest `http-server`. @reykjavikingur would love to see a test for your failure case added to this project. It doesn't seem clear to me why this would be happening with standard `express`
",jcrugzz,
1063,2016-09-19 15:19:24,"This adds the ability to override the stream into which the proxy response will be piped, e.g. to allow the proxy response to be piped through a transform stream before being sent back to the client.
",briman0094,
1062,2016-09-19 15:15:53,"This adds the ability to override the stream into which the proxy response will be piped, e.g. to allow the proxy response to be piped through a transform stream before being sent back to the client.
",briman0094,2016-09-19 15:16:53
1062,2016-09-19 15:16:53,"Closing...accidentally grabbed the commit from my other PR with this one
",briman0094,2016-09-19 15:16:53
1061,2016-09-14 18:55:29,"This re-adds the call to writeHead in [web-outgoing](/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L110) so that other middleware which depend on or patch the response.writeHead method (such as [harmon](/No9/harmon)) don't break.

Depends on No9/harmon#38 being accepted
",briman0094,2016-09-14 21:08:27
1061,2016-09-14 21:12:05,"@briman0094 @No9 would love a harmon test so this type of breakage could be prevented in the future. Thanks for the contribution!
",jcrugzz,2016-09-14 21:08:27
1060,2016-09-09 17:24:46,,mkrufky,2016-09-14 11:02:30
1059,2016-09-07 23:50:46,"I'm not sure if this is a bug or i'm doing something crazy. 
v5.7.1 and http-proxy@1.14.0

Okay, so I have a dockerized app that using http-proxy that works fine when pointing to either my local instance or remote instance. However when running the dockerized app and dockerized service locally i'm getting a 404 when the app is trying to hit the api. 

My setup:
docker run -it --name api -p 8080:8080 api 
docker run -it --link api:api -p 3000:3000 app 

App proxy code: 
const proxy = httpProxy.createProxyServer({
  target: 'http://api:8080/'
});

app.use('/api', (req, res) => {
  proxy.web(req, res, {target: 'http://api:8080/');
});

The api works 
http://localhost:8080/api/resource

If I curl from the app container it works
curl http://api:8080/api/resource

However if I hit my app which proxies to the api I always get a 404 
http://localhost:3000/api/resource
",datpham23,
1058,2016-09-02 11:16:35,"I would like to open a thread regarding performance, because I think it requires a bit more of attention than it has actually received lately.

Although this project does not aim to be as performant as other leading proxies such as HAProxy or nginx, I think most of its users would certainly be happy if the proxy does not degrade the performance to a nodejs server by a factor of 10x or 15x. 

This closed issue: https://github.com/nodejitsu/node-http-proxy/issues/929 shows that it is very easy to actually verify the performance degradation produced by the proxy. The workaround is to send a `http.Agent` with `keepAlive: true`, and maybe other finetunings. The issue refers to a FAQ, but I cannot find any FAQ. Also it would be great to provide a couple of things regarding http.Agent: 1) what is the tradeoff of using it? (if none, why is it not enabled by default), 2) Which is the optimal set of options for it? just changing arbitrarily and re-testing does not seem like a good approach, and also a dangerous one I may add, since the user most probably does not know what he is doing. 3) Why is http.Agent required to begin with?

One thing that may make many wondering is how is it possible that if a dummy http server in node js is capable of delivering responses in the order of magnitud 10k, a simple proxy infront of it, that should, in its most basic conceptual form, just pipe the data from source to target, reduces the performance to order of magnitude 0.5k. One could accept 50% degration, but not this much. Thing is, this may not be related to http-proxy at all, for instance I wrote this super simple example:

<S_CODE_TOKEN>

And got this results (in node 4.5):

<S_CODE_TOKEN>

<S_CODE_TOKEN>

So can it really be node's streams are so amazingly slow? It's a bit worrisome I must admit. Anybody as any insights that he wouldn¬¥t mind to share?
",manast,
1058,2016-09-03 07:55:31,"I did two more experiments that I find somehow interesting.

Using minimum http-proxy(I already got the same figures using https://github.com/OptimalBits/redbird based on http-proxy):

<S_CODE_TOKEN>

Gives basically the same result as using request streaming:

<S_CODE_TOKEN>

On the other hand, using `req-fast` (https://github.com/Tjatse/req-fast) I get consistently this:

<S_CODE_TOKEN>

<S_CODE_TOKEN>

So about twice as fast as request and http-proxy. Meaning that it is possible to implement a streaming proxy that is at least that fast inside http-proxy.
",manast,
1058,2016-09-03 08:04:01,"Using keepAlive: true on the http.Agent with http-proxy:

<S_CODE_TOKEN>

Using keepAlive with req-fast:

<S_CODE_TOKEN>

<S_CODE_TOKEN>

So http-proxy gets a huge 4 times better performance with keepAlive, while req-fast stays the same.
",manast,
1058,2016-09-04 08:52:18,"Previous experiments were aimed to just check what is the overhead for a minimal web server, now check this results when serving strings of different sizes from 32 bytes to 256Kb.

Test code:

<S_CODE_TOKEN>

In this case I used needle for implementing a proxy since it gave best performance than req-fast and request:

<S_CODE_TOKEN>

And the results:
![image](https://cloud.githubusercontent.com/assets/95200/18229951/24329e0a-728d-11e6-8dfa-b0f54fe1d2a0.png)

For me, the interesting here are basically 3 things:
- There is a lot of overhead to setup the streaming.
- For strings of size 32 and above, the proxy overhead is negligible.
- The streaming gives best performance with strings of size 32Kb, after that it starts degrading, which is strange, I was expecting less and less overhead so more and more raw throughput with large strings.
",manast,
1058,2016-09-04 09:09:44,"I filled the gaps to get a more linear chart:
![image](https://cloud.githubusercontent.com/assets/95200/18230042/5e13a54e-7290-11e6-90cf-4fe56458817a.png)
",manast,
1058,2016-09-04 18:57:42,"I would definitely like to see this addressed as well. I've been using Nginx as a dynamic reverse proxy for some time now. It's worked well, but the Nginx configuration spec is massive and confusing. And the dynamic part requires scripting in Lua, which isn't the easiest. I'd like to implement some more sophisticated features to my proxy, but that's painful in Nginx/Lua. It would be much simpler to do in Node.js, but I'm running into the same performance issues as manast with this module.

I did my own benchmarking. I spun up a Docker container first with a simple Nginx server serving static text (because I knew it would be lightning fast). I spun up a second Nginx container set up as a reverse proxy for the first to use as a comparison. I then spun up a Node.js 6.3 container testing a proxying with this module and the built in Node http client as well as serving static content for comparison. I benchmarked with wrk using 10 and 100 connections. Then I repeated the whole process with a Node.js source (instead of the Nginx one) introducing a 100 ms delay before serving content.

Here is my proxy code:

<S_CODE_TOKEN>

And here were the results:
![image](https://cloud.githubusercontent.com/assets/218771/18233134/f846e06a-72ac-11e6-80fd-c815c5f1b7e0.png)

The Nginx and Node.js static results are just there as a theoretical floor. The proxy server can't possible be faster than just serving static content. Nginx was definitely faster, but not quite as fast as I thought. It does perform better with 100 connections, but that's probably just because Node is using a single thread and Nginx is using 2 (one per CPU on my server).

The Nginx proxy results are the real target. If we can get close to the performance of Nginx we're in great shape.

With the node-http-proxy module, we see a 2x latency and 1/2 the requests compared to Nginx. I didn't see any difference between the default global agent (no keep-alive and infinity sockets) and no agent at all. Unexpectedly, when I enabled keep-alive the latency quadruples for 10 connections. For the 100 connections it performed much better.

I also proxied using the built-in http client to make a request to the upstream source and piped the results into the response. I did this with and without keep-alive. The results with keep-alive were fantastic! Even with a single thread the response times were lightning fast--even faster than the Nginx proxy--in all scenarios.

So what am I missing? Why is there such a huge latency added by node-http-proxy?
",dtjohnson,
1058,2016-09-05 12:56:40,"I just did a little more benchmarking. This time I put the source Node.JS container on one server, the proxy containers on a second server, and the wrk container on a third to get a more representative benchmarking and to avoid any competition of resources. I also added HAProxy to the mix and went up to 1000 connections. I also added a test with the Node.JS http client using cluster so there are 2 Node.JS workers (one per CPU). These are all with Node.JS 6.5. Here were the results:

![image](https://cloud.githubusercontent.com/assets/218771/18247982/d5a4198c-7343-11e6-83e3-e3c6e5eea622.png)

Here ""Direct"" means direct access to the source server with no proxy. There's a lot of network fluctuation, but it looks like the direction connection, HAProxy, and the Node.JS HTTP client piping with cluster are all about equally performant. node-http-proxy, by comparison, performs horribly. :( I was also surprised to see how poorly Nginx performed.

Here's my nginx.conf

<S_CODE_TOKEN>

Here's my haproxy.cfg

<S_CODE_TOKEN>

Here's my node-http-proxy JS code

<S_CODE_TOKEN>

Finally, here is my custom Node.JS HTTP client piping proxy with cluster (not sure if I got the error/abort handling done correctly though):

<S_CODE_TOKEN>
",dtjohnson,
1058,2016-09-05 13:49:23,"Quite interesting results. But how large is the data being proxied? as you can see in my results about it has a lot impact in the results. In any case, it will be interesting to know why http-proxy is performing so bad, I have to check the sources but I guess it is using http.request internally...
",manast,
1058,2016-09-06 00:56:49,"Following your suggestion, I ran the benchmarks with a variety of message lengths (from 1B to 1MB) using the randomstring module like you did. I didn't see the same issue as you. I wonder if you are seeing some strange behavior by running your proxy server and your upstream source on the same single Node.js thread. The results were very interesting though. Here are the results with the same 3 server configuration but with an even faster upstream source.

Here is 10 connections:
![image](https://cloud.githubusercontent.com/assets/218771/18258739/8072d9ba-73a9-11e6-8c00-de481ab51743.png)
And zoomed in on the <= 1kB messages:
![image](https://cloud.githubusercontent.com/assets/218771/18258747/a1101a8e-73a9-11e6-9416-9449a5808d95.png)

Now 100 connections:
![image](https://cloud.githubusercontent.com/assets/218771/18258755/c1a20d20-73a9-11e6-98f6-2beb56b70bb3.png)
And zoomed in on the <= 1kB messages:
![image](https://cloud.githubusercontent.com/assets/218771/18258768/00e1c71e-73aa-11e6-8a02-06983c1e9fec.png)

Now 1000 connections:
![image](https://cloud.githubusercontent.com/assets/218771/18258757/ca489f7a-73a9-11e6-834f-ffc47908de0c.png)
And zoomed in on the <= 1kB messages:
![image](https://cloud.githubusercontent.com/assets/218771/18258780/11919d5a-73aa-11e6-8df4-f9b28580cde4.png)

HAProxy performs very well, adding only a small overhead in all scenarios. Node.JS client piping makes a decent showing. Nginx performs surprisingly poorly, and node-http-proxy lags far behind. node-http-proxy failed completely in most of the 1000 connection runs.
",dtjohnson,
1058,2016-09-06 07:09:03,"I guess more people is needed to verify this results, but if so, this means that is not unrealistic to say that we could have a nodejs based proxy that is competitive enough to be used for high traffic sites. Its still quite amazing that nginx performs so bad in these tests, I wonder if there is not something in the configuration or the setup that makes it perform so bad (disclaimer: I am a novice in nginx).
",manast,
1058,2016-09-06 07:33:38,"Btw, it would be also highly relevant to test with HTTPS. We should agree that any serious site should work using HTTPS anyway, so that is the performance we should care about :)
",manast,
1058,2016-09-06 11:32:55,"I came to the same conclusion. Despite whatever is going on with node-http-proxy and Nginx, it certainly seems a Node.js-based proxy is a realistic option.

I'm stumped as to what is wrong with Nginx. I have to believe it is some configuration issue. I tried disabling proxy buffering and caches--no help. I tried using IP address instead of DNS for the target--no difference. I disabled keep-alive (which I need to support server-sent-events) and that did improve performance but still well below the the performance of Node.js.

HTTPS is a good idea to test too. I tend not to think about that as in my setup my proxies are fronted by an AWS Elastic Load Balancer that does SSL termination. Would be interesting to see any differences there though. Gzip on the proxy would interesting too.

One other point of consideration is that Nginx and HAProxy in my tests aren't set up with scripting. They are just fixed proxying. In the Node.js proxy we have access to the entire JS language and libraries. To do a fair test with Nginx and HAProxy we'd have to test dipping into a Lua script execution on each request to do a fair comparison.

I'd love to script the entire benchmarking workflow so we can iterate on this more quickly and consistently. So dynamically spin up 3 servers, start the proxy servers, benchmark them, and then terminate the servers.
",dtjohnson,
1058,2016-09-06 12:06:31,"As  I mentioned above I am the author of https://github.com/OptimalBits/redbird, and I am using http-proxy for the actual proxy work, but maybe it is not so difficult to implement a http.request based proxy instead. The risk is that there are probably a lot of cases, common as well as edge, regarding handling of headers and other stuffs that are not so easy to get right without a long period of battle testing such as http-proxy already has have.
",manast,
1058,2016-09-06 12:26:53,"Agreed. It's the variety of cases I worry about too, but I'm afraid it's a bridge I may have to cross. I don't think I'll be able to evolve my current dynamic Nginx proxy easily enough (especially seeing the Nginx performance issues from the above benchmarking). I really think I need to swtich to a Node.js based one.

Would love to see the authors of node-http-proxy chime in. I feel like I must be doing something majorly incorrect that would explain the performance issues...
",dtjohnson,
1058,2016-09-10 19:26:20,"@manast @dtjohnson Have you taken a look at #614? Providing node-http-proxy an https agent and setting maxScockets may help. There also appears to be potential slowdown from DNS when setting target other than ip address. May not make a difference in Node v4+
",eezing,
1058,2016-09-12 12:27:33,"@eezing, yeah, I tried a variety of options. See my first post on this thread. Keep-alive performance was definitely the worst option, but I need it for server-sent events (though I do have an alternative idea for that).

So I went ahead and automated the full benchmark process:
https://github.com/dtjohnson/proxy-benchmark
The code spins up 3 AWS EC2 servers on-demand (one for the upstream, one for the proxies, and one for wrk). It then runs through a suite of benchmarks. The results are viewable here:
https://dtjohnson.github.io/proxy-benchmark/

Here's an image, which is fairly consistent with the one above:
![image](https://cloud.githubusercontent.com/assets/218771/18435525/cc2da66a-78c1-11e6-85f5-68afd9477158.png)

This tool should make it easy to iterate on the Node proxy and see relatively quickly the performance implications of various configurations.

A number of next steps to try:
- Proxying headers (the current Node piping just sends the status code, no headers). I expect this will hurt performance.
- SSL
- Gzip
- No keep-alive
- Piping the sockets. There is an intriguing looking piece of code showing piping the underlying sockets here: https://nodejs.org/api/http.html#http_event_connect. I'm curious how that will perform.
",dtjohnson,
1058,2016-10-18 11:19:13,"Hmmm... Still no response?

I played some more with the Node proxy. In my examples before I wasn't sending the proxied response headers back. When I added it with:

<S_CODE_TOKEN>

The performance dropped dramatically--from 5ms to 40ms latency. I figured out it was because the upstream server sent a Content-Length header that was sent in the response. That prevented Node from using Transfer-Encoding: chunked. Deleting the header (and the Connection header) before sending the response restored the performance (code [here](https://github.com/dtjohnson/proxy-benchmark/blob/master/proxies/node/server/index.js)).

I looked at the proxy with node-http-proxy and it wasn't using Transfer-Encoding: chunked. I wonder if that might be responsible for the performance hit we're seeing. Unfortunately, I couldn't figure out from the docs how to enable chunked transfer or how to modify the response headers. 
",dtjohnson,
1058,2016-10-18 11:44:56,"@dtjohnson strange that having content-length prevented node from using chunked transfer, this needs to be verified somewhere, does not makes complete sense to me :/.
",manast,
1058,2016-10-18 11:48:29,"ok, you are right: https://en.wikipedia.org/wiki/Chunked_transfer_encoding
Buy still, the content should be streamed in chunks, there should not be any major performance differences.
",manast,
1058,2016-10-18 16:58:01,"Hmm thats a good point, this requires a bit more investigation into how `node` core behaves. Its not a bad idea to have certain headers that get stripped but we may want to make that opt in or it would be a breaking change. Thoughts?
",jcrugzz,
1058,2016-10-18 17:03:10,"In regards to the overall discussion here. Im +1 to have performance optimizations considered and implemented into this. My approach to start this was to extract some of the core logic out of `http-proxy` into [`http-proxy-stream`](https://github.com/jcrugzz/http-proxy-stream/tree/implement).

In reality we shouldn't be able to beat the performance of nginx or haproxy but we should do as best we can while maintaining 100% correctness given the foundation of `node` that we build upon. 
",jcrugzz,
1058,2016-10-19 14:42:39,"Unless my nginx configuration is completely wrong (which it may be), my benchmarks show that a Node proxy could absolutely outperform nginx. I'm not sure what I'm missing but it seems node-http-proxy is way slower than it should be...
",dtjohnson,
1058,2016-10-19 18:26:27,"@dtjohnson It does not seem that the http-proxy team has done any serious performance benchmarks, and that they have just assumed it is not possible to compete to other standardised solutions such as nginx or haproxy. I think benchmark should be a part of the development process of this module. It is paramount. Lets not give up in being faster than nginx until proved that it is not possible.
",manast,
1058,2016-12-20 01:50:47,"Picking this up again after a while away. I did some more experimenting. I spent some more time being careful about upstream keep-alives in my proxy benchmarking suite. This time I ran the node-http-proxy with a keep-alive agent and the results were actually [pretty good](https://dtjohnson.github.io/proxy-benchmark/#?url=https:%2F%2Fraw.githubusercontent.com%2Fdtjohnson%2Fproxy-benchmark%2Fmaster%2Fresults.json&compression=false&keepAlive=true&field=transferBytesPerSec&connections=2&delay=0):
![image](https://cloud.githubusercontent.com/assets/218771/21335215/36fae32a-c62b-11e6-9c1e-708807211de1.png)
The results in light-green are comparable with the results of my simple Node.js proxy in dark green.

When running without keep-alives on any of the proxies, the results were [not as good but still decent](https://dtjohnson.github.io/proxy-benchmark/#?url=https:%2F%2Fraw.githubusercontent.com%2Fdtjohnson%2Fproxy-benchmark%2Fmaster%2Fresults.json&compression=false&keepAlive=false&field=transferBytesPerSec&connections=2&delay=0).

When enabling gzip the [performance drops](https://dtjohnson.github.io/proxy-benchmark/#?url=https:%2F%2Fraw.githubusercontent.com%2Fdtjohnson%2Fproxy-benchmark%2Fmaster%2Fresults.json&compression=true&keepAlive=true&field=transferBytesPerSec&connections=2&delay=0):
![image](https://cloud.githubusercontent.com/assets/218771/21335265/ad421800-c62b-11e6-8e0d-4a74b80d0cc1.png)
I'm guessing this is due to performance issues with the zlib module, but it's still not terrible.

The results are pretty encouraging. I wish the gzip performance was better, but I'm much more comfortable using node-http-proxy now.",dtjohnson,
1058,2016-12-22 10:14:13,"@dtjohnson thanks for the results. We could then conclude that node-http-proxy is as fast as what is currently possible with node. The dev team should use a test like this to always verify that the proxy has not been degraded in performance between releases, and that it always is kept at the same level as what plain nodejs can offer as maximum throughput.",manast,
1058,2016-12-22 10:15:16,"btw, what version of nodejs did you use? (this will be pretty relevant since improvements in the http module as well as on streams will have huge impact on the benchmarks)",manast,
1058,2016-12-22 10:19:40,"another remark, what about HTTPS support? As internet is moving, HTTPS support is almost the standard now, so any relevant benchmark should include it.",manast,
1058,2016-12-31 20:11:02,"Certainly seems to be about as fast as possible--with the keep-alive agent!

I used the latest node Docker image, which is v7.3. I suspect the Node version is going to be the biggest driver of performance too.

I didn't bother with HTTPS as I use an AWS ELB for SSL termination in my use case. I also didn't want to figure out how to configure SSL certs for Apache, Nginx, and HAProxy.",dtjohnson,
1058,2016-12-31 22:34:22,"Even if you use AWS for HTTPS, lets say that the performance drop is 10x, then the performance of nodejs is just 10% av the total, which makes it even more irrelevant compared to the other contenders... (I am somehow trying to reach to the conclusion that node proxy is just as good as any other proxy) :).",manast,
1058,2017-01-01 17:44:30,Any comparison with Netlix Zuul proxy?,acanimal,
1058,2017-01-12 12:16:35,"Apologies for the late response. Things have been hectic.

@manast, fair point about SSL. I'll work on getting that benchmark in place. I just need to chase down all of the SSL configs for the various proxies.

@acanimal, nope, but I'm happy to add it if you want to give me a Docker container and config. Pull requests are welcome: https://github.com/dtjohnson/proxy-benchmark",dtjohnson,
1058,2017-01-12 12:56:10,"@dtjohnson a simple test would be to use AWS HTTPS for all the proxies, and compare results. If my theory is true there will almost no difference in performance between all of them...",manast,
1058,2017-01-12 13:11:19,@dtjohnson There is an official docker image for zuul: https://hub.docker.com/r/netflixoss/zuul/,acanimal,
1058,2017-01-13 12:21:36,"@manast, is your theory that the latency introduced by the ELB would outweigh the proxy latencies? I'd have to test that but I would guess it would just add the same additional latency to each. ELBs are also a little tough to test because AWS will add/remove nodes as the load demands so it's a bit tough to control the test.

I went ahead and added SSL support to the various proxies so we can compare SSL directly. I'll kick off the benchmarking soon, but it will take some time to complete.

@acanimal, the docs on zuul are pretty light. Could you provide a sample config for the proxy that includes SSL and Gzip support? If zuul can read environmental vars for the upstream settings that would be great too.",dtjohnson,
1058,2017-01-19 01:44:55,"Sorry for the delay. I had a bug to work through. The results with SSL are here:
https://dtjohnson.github.io/proxy-benchmark/#?compression=false&keepAlive=true&ssl=true&field=transferBytesPerSec&connections=2

Across all of the proxies, including Node, there isn't much of in impact from SSL. So I think it's safe to say that Node is fine with HTTPS.

What I do find very concerning is gzip performance. Here is the proxy requests/sec WITHOUT gzip:
![image](https://cloud.githubusercontent.com/assets/218771/22090145/df65f122-ddbd-11e6-8803-b37bd7c64510.png)
Node looks pretty good. (I'm also not sure what the drop at 10kB is all about, but it does seem real.)

Now, here is the requests/sec WITH gzip:
![image](https://cloud.githubusercontent.com/assets/218771/22090192/2df8a8e8-ddbe-11e6-9abe-ba6e1f738c0c.png)
You can see the Node performance tanks. I've tried playing with the zlib setup without any luck. The dark green line is Node piping the request right into a zlib gzip stream transform, while the light green is node-http-proxy using the compression module. No real difference.

I'm afraid the poor gzip performance is a show stopper for me as it seems to consistently add 50 ms to each request. I'm going to look into options for offloading gzip. I really wish I knew what was going on with zlib though...",dtjohnson,
1058,2017-01-19 09:38:30,"I think that when using gzip, the messages should not be compressed unless of certain size, maybe at least 5Kb or 10Kb, that is because for small sizes the compression is not so good anyway. There seems to be also some setup cost that is independent of the size of the response as if zlib requires some expensive setup. ",manast,
1058,2017-01-19 09:41:15,you may also be interested in this module: https://www.npmjs.com/package/snappy-stream,manast,
1058,2017-01-19 11:13:19,"Correct. You wouldn't get any benefit from compression unless the content size is large. In fact, you would expect gzip to hurt performance for small stuff as you mention.

The compression module does, in fact, check the content length and won't gzip if it's too small. The problem is that the default transfer encoding in HTTP 1.1 is chunked. The total content length is not sent as a header. The upstream in my benchmarks is using chunked encoding so compression will always try. All of the other proxies are able to gzip without a big performance loss. There's something about zlib that has a huge penalty.

I'll look into snappy. Thanks for that.",dtjohnson,
1058,2017-01-20 18:38:57,"Being very unsatisfied with the Node gzip results, I tried to get to the bottom of why the latencies were so bad. I found that gzipped output from Node was consistently showing a +40ms latency with wrk. However, when I tried benchmarking this by using a Node script to call it over and over, I got a much lower latency. I also tried some other benchmarking tools; some showed the large latency, some didn't.

Clearly Node was doing something that some of these benchmark tools like wrk didn't like. So I used tcpdump to see the raw TCP packets being sent. When sending a small message, the upstream server was packing the HTTP headers and the body into a single TCP packet. When HAProxy, for example, received this, it gzipped the body and sent the response on to the client again in a single TCP packet. The Node proxy handled things a little differently. Once Node receives the response it pipes it into the gzip transform and then into the response stream. What seems to be happening is that once the stream is piped, Node sends the HTTP headers in a packet by themselves. Then a data event fires from the upstream request stream. Gzip compresses the packet and sends it along as a second packet. Then the request stream finishes, which causes the gzip stream to send whatever closing bytes it needs to. So while HAProxy sends a single packet, Node sends 3. I'm not sure it's possible to change this behavior because it's fundamental to how streams behave, but I'm also not sure it's a problem.

This told me that wrk must not be handling the multiple packets correctly. I think the latencies are getting inflated because of the order in which wrk processes the packets coming from the numerous outstanding requests. That led me to [wrk2](https://github.com/giltene/wrk2), which is a variation of wrk focused on accurate latency times. It also benchmarks in a different way. It focuses on what the response latency is under a fixed request load, which seems to me to be a better way to benchmark the proxies anyway.

I ran some initial tests with wrk2 and found that at lower request rates the performance of Node is on par with the other proxies (all around 4-7ms latency). The performance tends to degrade more quickly than the others as the request rates go up, which makes sense given the higher CPU usage. I just started the full benchmark suite of tests (SSL, gzip, upstream keep-alive, various connections, message lengths, and now request rates). The full suite takes more than 24 hours at this point so it'll be a bit before I have the results, but I'm very optimistic!",dtjohnson,
1058,2017-01-21 11:11:52,"@adjohnson916 really good job!, I wonder if somebody else has made such a comprehensive benchmark on node just yet? Maybe even the core developers of node do not really know where we are in terms of performance. It seems also that some people, authors of node-http-proxy included, have given up on competing with other servers because they believe V8 is not capable of deliver as efficiently as a C/Asm optimized solution, which is a pity.
",manast,
1058,2017-01-22 12:41:18,"The results are in:
https://dtjohnson.github.io/proxy-benchmark/

First off, all proxies perform much better if keep alive connections are kept to the upstream. However, node-http-proxy seems to suffer especially poorly in this regard:
![image](https://cloud.githubusercontent.com/assets/218771/22182497/17c49466-e074-11e6-97fc-151b6ff3ff3c.png)
For the rest of the results below, upstream keep alives are turned on.

Without gzip and at low request rates and connections, the latencies of all of the proxies very close together (4-6 ms). HAProxy and Apache tend to lead the pack. Node and Nginx perform similarly. I also don't see any real difference between node-http-proxy and the Node proxy without dependencies.
![image](https://cloud.githubusercontent.com/assets/218771/22182405/d4cc1338-e072-11e6-88cd-38a86d4419e8.png)

SSL doesn't seem to make a difference for any of the proxies. At low rates you don't notice. At high rates it just ticks up slightly. (No point sharing a graph.)

If we increase the request rate to 1000 req/s, all of the proxies struggle to keep up, but the trend is the same:
![image](https://cloud.githubusercontent.com/assets/218771/22182435/5b0ddbc0-e073-11e6-9fec-c6d4cee6247a.png)
The raw Node proxy edges out node-http-proxy and both beat Nginx.

The number of connections (from 2 to 100) doesn't seem to make a huge difference in the relative behavior of the proxies either. However, at high request rates and 100 connections, Nginx suffers:
![image](https://cloud.githubusercontent.com/assets/218771/22182486/e6537bcc-e073-11e6-9534-0a93a06db6d7.png)

Now gzip. There are some fluctuations as you look across the various connection and request rate options, but the results across the proxies seem pretty close. Here is 20 requests/sec with 10 connections:
![image](https://cloud.githubusercontent.com/assets/218771/22182508/83ad698c-e074-11e6-9ae5-276a8ee1bb92.png)
At 100 connections and 1000 req/s:
![image](https://cloud.githubusercontent.com/assets/218771/22182520/f923bab8-e074-11e6-9e3a-29aed9cd05f1.png)

So here's my summary:

- The latencies across all of the proxies are quite close together. They should all do a good job serving as a proxy without a noticeable difference between them.
- In general, HAProxy and Apache are the best performing. Node and Nginx performance is similar.
- It does seem that, in general, node-http-proxy does not perform as well as it could. However, the performance gap is small (except when not using upstream keep alives).",dtjohnson,
1058,2017-01-22 17:06:46,"Why is gzip compression not affecting performance so badly as in previous tests? or you mean that it was wrk fault, with wrk2 works as expected?",manast,
1058,2017-01-22 19:52:44,"As I explained earlier, I think that was just an artifact of wrk and the way Node sends out more than one packet when gzipping. I switched to wrk2, which gives better latency measurements.

I'm thinking it might be interesting to swap the x-axis of the plots such that I'm sampling a large number of request rates instead of message lengths. Then we could see better at which request rates each proxy starts suffering....",dtjohnson,
1058,2017-01-22 21:32:35,"@dtjohnson @manast Thanks for spending so much time looking into this, really useful thread.",mikestead,
1057,2016-08-31 11:23:26,"In my test case, when the target server is not reachable, I get an incrementing number of errors thrown on each refresh of the page as shown below. 

I already use `res.headersSent` as described in #909 to capture the errors, but still, it's not were nice ;)

I'd like to know why I get these multiple errors. Are they thrown by the connection to the target? Is there something unfinished I can do?

The code is embedded in an Express framework: 

<S_CODE_TOKEN>

Resulting errors after three refreshes and continuing:

<S_CODE_TOKEN>
",IRT-fbachmann,
1057,2016-09-15 13:24:22,"I'm having the same issue, did you find a solution for this?
",alonsonic,
1057,2016-09-19 07:06:44,"No, sadly I haven't... lately I hadn't time to concern with this problem, but I'd appreciate to have one workaround less in my code ;)
",IRT-fbachmann,
1056,2016-08-30 01:34:52,"Currently I have an 2 api, but actually the second api depends on a response from the first api.  And right now I need to do that from the client side which I would love to know if there is a way to simplified it.   ( E.g. my first api could be getting a token to append to the second api )

<S_CODE_TOKEN>

So instead of having two routes, how can I make it only one route, so that I call the first api, only when it is done, it will call the second api ??

For example, something like the following could be possible ??

<S_CODE_TOKEN>
",iroy2000,
1055,2016-08-29 00:18:02,"I would love to play with the new PR: `cookieDomainRewrite option (#1009)`. When do you plan to publish to npmjs.org?

Thanks a lot!
",winding-lines,
1055,2016-09-13 15:22:44,"Considering that the `cookieDomainRewrite` API is documented in the current readme, I was surprised to see that this isn't included in the latest release.
",pmulac,
1054,2016-08-27 17:15:51,"I was proxying a PHP api service, when I debug it, from PHP side, seems like it doesn't have values in the cookie.  Does the proxy also forward the cookie ? 
",iroy2000,2016-08-30 05:04:22
1053,2016-08-27 06:27:31,"Not sure if it is a matter of configuration  ( or what is the correct way of doing that )

I have a PHP server serving api, and in order to get the response, I need to get a token.  If there is no token or an invalid token, it will denied your access. The token is session based. 

The sequence is like that

1) get the token ( /api/token )
2) append the token to the proxy request

I'm able to do that when I do that sequence from the browser, but when I used the proxy, I can't get that working. 

The following is a middleware for a particular route

<S_CODE_TOKEN>

And later on I use that middleware in one of my route

<S_CODE_TOKEN>

When I debug the issue, I found out that the token that I got from the middleware is different from the token in the php session.  ( Maybe it is passing the wrong Cookie, or the `request` and `proxy` is on different sessions ?? )   Wondering what is the best way to solve that issue. 

Thanks
",iroy2000,
1052,2016-08-21 13:34:41,"I see you have really lot Star in your project. I seem interesting with it. But what is this tool use for? :)
",jameshentai,
1052,2016-08-25 19:18:57,"http://whatismyipaddress.com/proxy-server
",kevbook,
1051,2016-08-17 22:12:26,"Calling res.writeHead has the side effect of setting the Reason-Phrase back to node defaults regardless of what is in the response status line.  I'm using Reason-Phrase codes to sub-route api responses and they were all being reset.  This change only sets the statusMessage (Reason-Phrase) if it exists on the proxyRes and is successfully passing it through in my tests.

from [docs](https://nodejs.org/api/http.html#http_response_statusmessage):

![image](https://cloud.githubusercontent.com/assets/424694/17754939/eab98ac6-648b-11e6-8f65-731c285f9e58.png)

So if just calling writeHead and not passing the optional statusMessage second argument, I believe it is getting reset to undefined and then defaulting it. I'm not sure if there is a good reason for using writeHead in general here since it seems like setting statusCode / statusMessage properties directly accomplishes the same with less side effects, could definitely be overlooking something.

What I see before change:
![image](https://cloud.githubusercontent.com/assets/424694/17755107/e35e1ca0-648c-11e6-928e-3a9f892b592a.png)

What I see after change:
![image](https://cloud.githubusercontent.com/assets/424694/17755121/f950b1e4-648c-11e6-872d-04091e622129.png)
",cchamberlain,2016-09-13 22:19:34
1051,2016-08-31 14:29:27,"Sorry for the slow response this dropped off my radar for a bit.
",cchamberlain,2016-09-13 22:19:34
1051,2016-09-09 19:53:35,"@jcrugzz - Any time frame on  when / if this will get merged? Not trying to rush, I just got some prod dependencies going out this week that are reliant on the status reason being passed through so I will have to fork if it does not get accepted soon.
",cchamberlain,2016-09-13 22:19:34
1051,2016-09-13 22:19:47,"@cchamberlain sorry it took so long. Thanks!
",jcrugzz,2016-09-13 22:19:34
1051,2016-09-14 18:25:08,"This breaks plugins such as [harmon](https://www.npmjs.com/package/harmon) that patch the `writeHead` function. Node supports `writeHead( statusCode, statusMessage, headers )`, which should be used instead of manually setting the status code and status message here.

(edit: although it looks like harmon [doesn't properly account for that overload](https://github.com/No9/harmon/blob/master/index.js#L34), so it would need to be patched in order for this method to work)
",briman0094,2016-09-13 22:19:34
1051,2016-09-15 13:55:09,"@briman0094 - I considered that solution as well but being unaware of harmon's dependency, went with this one since it seemed lighter weight (setting the fields directly has less of this to worry about) - 

![image](https://cloud.githubusercontent.com/assets/424694/18552319/c06d2eb2-7b10-11e6-9657-f09bdb3c7f6b.png)

I can modify / open a new PR? Should we implement the `headers` parameter to allow upstream headers to be passed through or is this already implemented elsewhere?
",cchamberlain,2016-09-13 22:19:34
1051,2016-09-19 16:00:50,"@cchamberlain I don't think we need to implement `headers` because the previous version of http-proxy that called writeHead didn't implement it. There's another pass in web-outgoing.js that writes the headers from `proxyRes.headers` into the response by calling `res.setHeader(...)`. I had a PR that got merged in a few days ago which fixes the issue and it seems to be working fine.
",briman0094,2016-09-13 22:19:34
1051,2016-09-19 18:07:22,"@briman0094 - Awesome, guess my work here is done!
",cchamberlain,2016-09-13 22:19:34
1050,2016-08-17 07:12:23,"When tools like HAProxy run health checks they don't supply http Host header,
which makes http-proxy to crash, pretty unfortunate side-effect for a health check. :)
",alexindigo,2016-09-14 11:03:48
1050,2016-09-14 11:03:45,"Thanks!
",jcrugzz,2016-09-14 11:03:48
1050,2016-09-14 16:34:50,"Thank you. Can you publish it on npm as well? :) 
",alexindigo,2016-09-14 11:03:48
1050,2016-09-14 17:07:59,"Done. new version at `1.15.0`
",jcrugzz,2016-09-14 11:03:48
1050,2016-09-14 17:55:40,"Thanks a lot.
",alexindigo,2016-09-14 11:03:48
1049,2016-08-16 22:20:26,"I am running my app on localhost. 
My proxy rules looks like this:

<S_CODE_TOKEN>

It gives me _cert error_  when I hit this
`http://localhost.qa.abc.com:9000/example1/getUsers` because of _https://example.qa.abc.com_

<S_CODE_TOKEN>

This returns me 404 when I hit 
http://localhost.qa.abc.com:9000/example1/getUsers

What am I doing wrong? Am I not using secure properly?
",supritashankar,
1048,2016-08-11 21:54:52,"I have simple [proxy](https://github.com/zboro/url-replace), which redirects some of the requests to another server. It works fine when I run it in node, but when I try to run it inside electron application, requests often take a long time or timeout completely (2 minutes) before reaching the target server.

proxy.web function is called and normally it would create request to target server, but server never receives that request. I have done some debugging and it seems, that web-incoming.js really creates request and immediately receives 'socket' event, but it does not receive any other event until timeout.

This behavior is not always consistent, sometimes requests get through, sometimes they do not.

Has anyone else tried using http-proxy in electron? It may be caused by issue in electron, I'm not sure yet.
",zboro,
1047,2016-08-11 20:03:55,"Please list which options are off/on by default in your README options summary.
",probablyup,2016-08-11 20:07:34
1046,2016-08-09 04:01:09,"### Environment

<S_CODE_TOKEN>
### Package.json

<S_CODE_TOKEN>
### Issue

Accessing the proxied route `http://localhost:3000/api/myRoute` causes an error on _exactly_ 50% of requests. We have not changed any of our proxy code, this started happening without warning. Looking at the logs on our API backend, none of the failed requests are even getting through.
### Code

apiMiddleware.js

<S_CODE_TOKEN>

Index.js

<S_CODE_TOKEN>
",andrewmclagan,
1045,2016-08-08 04:13:34,"I'm using http-proxy-middleware and at the back it is using this library for proxy. 

I have left a comment in there, I hope someone could help on this, seems like it is a pretty normal use case. It is about how to manipulate the proxy response. 

After I did some research, seems like some people recommended https://github.com/langjt/node-http-proxy-json, is that the only way currently?  Or what is the best practice here ?

Original questions on `http-proxy-middleware`
https://github.com/chimurai/http-proxy-middleware/issues/97

Same question on `stackoverflow`
http://stackoverflow.com/questions/38806249/node-http-proxy-http-proxy-middleware-how-do-you-manipulate-proxy-response

Any help is appreciated, thanks. 
",iroy2000,
1044,2016-08-04 06:38:47,"Is there any way to check the response body and codes, actually I need it for checking if any response got 404 0r 500.
",tasin-megamind,
1044,2016-08-05 19:50:59,"Hi, I don't use this project for long time so I don't know if there is a better/easy way, but maybe this can help: http://www.acuriousanimal.com/2015/08/31/how-to-read-from-a-writable-stream-httpserverresponse-in-node.html
",acanimal,
1043,2016-07-29 00:55:38,"How can I check if a server exists before proxying? When I put in addresses a server that not exists, it throws an error. Should I catch this error and shift proxy? Is there other way to do it?
",facundomedica,
1042,2016-07-28 12:32:09,"While using secure: true for proxy connections, there is no way to pass the trusted root CA(s) or intermediate CA(s). This change allows that to be passed in the httpProxy createServer options and used for the outgoing proxy connection.
",predhme,2016-08-11 16:20:35
1041,2016-07-26 21:54:58,"I've read the documentation but I somehow just can't figure out how to proxy HTTPS to HTTP and use WSS (secure websockets) at the same time.

I was able to get HTTPS->HTTP working but then wss would not work.

I currently have the following code:

<S_CODE_TOKEN>

I would be extremely thankful for an example that would demonstrate how to proxy HTTPS-HTTP and use WSS at the same time and on the same port.
",KCreate,2016-07-27 16:48:28
1041,2016-07-27 16:48:28,"Stupid me...

Adding this solved the issue:

<S_CODE_TOKEN>

I'd be more than willing to compose an example for the documentation if anyone thinks this would be a good idea.
",KCreate,2016-07-27 16:48:28
1040,2016-07-26 12:12:50,,gggin,
1039,2016-07-20 10:23:27,"Browserify fails to resolve the ""./http-proxy/"" as ""./http-proxy/index.js"" but as ""./http-proxy.js"" (so nothing works)
Beeing explicit here does not cost much for http-proxy, yet it's intrinsically complicated for browserify to fix (as trailing slash might be used as a pollyfill shim for native/non-natives addons i.e.  require('url/') vs require('url') )
",131,2016-10-22 15:46:26
1039,2016-09-15 12:59:51,"Rebased
",131,2016-10-22 15:46:26
1039,2016-09-17 20:48:24,"You got it :cake: 
",131,2016-10-22 15:46:26
1039,2016-09-27 21:56:22,"Last two commits are also related to code tooling, when trying to minify the code (through uglify-js), AST fail to detect function scope (& usage) when what's intended here was really simple (just register a list of ""named based hooks""). So switching to a plain old vanilla object is working fine and keep the code sane.

EDIT : i'v changed the PR title accordingly.
",131,2016-10-22 15:46:26
1039,2016-10-22 06:47:50,"What is the status of this? Sadly this breaks compatibility with Jest :/
",sorenvind,2016-10-22 15:46:26
1039,2016-10-22 14:38:25,"@sorenvind , are you saying my patch breaks some other module ? (or are you waiting for this to be merged ?)
[edit : nw, i got it]
",131,2016-10-22 15:46:26
1039,2016-10-22 15:19:07,"Will get this merged in today. Sorry for the wait.
",jcrugzz,2016-10-22 15:46:26
1039,2016-10-22 15:19:40,"With the change you requested :+1: 
",131,2016-10-22 15:46:26
1039,2016-10-22 15:46:26,"Cherry picked. Thanks!
",jcrugzz,2016-10-22 15:46:26
1039,2016-10-22 16:18:34,":-) thx!
",twhid,2016-10-22 15:46:26
1039,2016-10-22 17:00:54,"Wow guys! That was so much faster than I expected! @131 I talked about this being needed to fix the current lack of jest compatibility. 

Thanks!
",sorenvind,2016-10-22 15:46:26
1039,2016-10-22 17:58:50,"@twhid @sorenvind no problem. I would love to see the real fix in `node-resolve` but it seems that package needs some love.
",jcrugzz,2016-10-22 15:46:26
1038,2016-07-19 16:21:58,"New option `cookieRewrite`, and sample implementation:

<S_CODE_TOKEN>
",JohnWu-Pro,
1037,2016-07-19 16:14:59,"In `setRedirectHostRewrite` of `lib/http-proxy/passes/web-outgoing.js`, only status code 301, 302, 307, 308 are supported. Status code 303 should also be supported.

Or, even better, make the list of eligible/desired redirect status code configurable.
",JohnWu-Pro,
1037,2016-12-01 04:30:54,"+1 in my case, would like this for 401 as well",ankushsaxena5,
1037,2016-12-29 20:25:18,related issue #845: `Add support of 303 to hostRewrite option`,jrnail23,
1036,2016-07-18 17:04:56,"I start this code

<S_CODE_TOKEN>

I go to http://localhost:5050/?url=http://google.com/

![screenshot from 2016-07-18 20-02-19](https://cloud.githubusercontent.com/assets/9502625/16923402/c2309f3e-4d22-11e6-84b9-9fd27c1dcfeb.png)

why?

This working:
curl -x http://173.xxx.97.152:8800 -L http://google.com
",vortex14,
1035,2016-07-17 12:32:06,"Is it possible to add Typescript declarations ? (node-http-proxy.d.ts)
",miton18,
1035,2016-10-14 21:49:03,"+1 üëç 
",philcockfield,
1035,2016-12-26 04:43:46,"how about referencing
https://github.com/typed-contrib/node-http-proxy 
to get started?",devdoomari,
1034,2016-07-13 18:07:46,"Hello,
I have for different network connection like airtel, reliance, and 2 more network. I want to connect all 4 in single network. Is this solution possible? 
",surendrakumar1992,
1033,2016-07-13 13:35:01,"Issue origin :  ember-cli/ember-cli#6032

I wish to proxy all my request to a `cloudApiUrl` but we have our dev machine behind a corporate proxy (Ntlm Proxy). I have used Proxy Authentication application (Cntlm) to create a `no-auth` proxy Url at http://127.0.0.1:3128. 
I wish at all the outgoing traffic using `http-proxy` middleware to my `cloudApiUrl` through `http://127.0.0.1:3128`
Any pointers on `Options` to use `Configuration` to make will be helpful

PS : for reference [Link to how ember has used `http-proxy` ](https://github.com/ember-cli/ember-cli/blob/master/lib/tasks/server/middleware/proxy-server/index.js)
",ankeshdave,
1033,2016-10-28 12:37:31,"I have also the needs. To create a second-level proxy, which proxy all requests throw a next hop proxy.
Years ago, i use HTTPort, it's written in Windows C++, but i thought node-http-proxy could/should also be able to do this.
",chenzx,
1033,2016-10-28 12:38:28,"Or if i export HTTP_PROXY env var before start node-http-proxy? could that workÔºü
",chenzx,
1032,2016-07-11 18:55:41,"Hi,

I have set up a reverse proxy with a timeout set up, but when the timeout occurs, no even is fired and nothing happens in the `error` event handler. If I use CURL to connect to the proxy, after the timeout period, the server just sends an empty response.

What is the correct way of setting up and handling a proxy timeout? I require a low (5 second) timeout on the proxy but want to be able to handle the timeout gracefully in order to both log the request and present the end user with an error page rather than a standard browser 'no response' page.

Thanks
",lewislambert,
1032,2016-07-24 14:13:36,"Just had the same issue, I switched from using ""timeout"" to ""proxyTimeout"" in my option object, and it works just fine.
The error is emitted and you get an error - socket hung up
",amirsch,
1031,2016-07-06 20:15:34,"On Windows, when simultaneous connections are proxied, some of the connections are closed with a `ECONNRESET`. This PR ensures that the connection to the remote is closed.
",FredericHeem,2016-07-07 18:49:22
1031,2016-07-07 18:49:22,"Unfortunately, this PR doesn't completely solve the issue.
",FredericHeem,2016-07-07 18:49:22
1030,2016-07-05 00:22:28,"I want to reopen [this issue](37) since 301 redirects still don't seem to work. Here's some reproducible code:

`index.js`:

<S_CODE_TOKEN>

Here was the output:

<S_CODE_TOKEN>

For reference I'm using node 4.2.4, and http-proxy 1.14.0.
",patrickroberts,
1030,2016-10-18 13:30:02,"@patrickroberts

I'm also trying to route to a 301 redirect with http-proxy and so far I'm only seeing reverse proxy behavior. Even when I look at your example, there's no parameter that would specify a 301 response. The client should be sent an endpoint url to make a new request against, similar to Express' `res.redirect(301, redirectUrl);` which has the returns the response headers:

<S_CODE_TOKEN>

 `protocalRewrite: true` has no effect on the action of the`web({})` method. 

Also, can you please print the request + headers that you are using because I'm not able to reproduce the `TypeError` exception above.

Thanks,
John
",dancingfrog,
1030,2017-02-05 09:29:14,"I'm hitting the same issue with 1.14.0, basically any redirect I hit the browser traffic leaves the proxy for the real site.

I'm using the following setup:

<S_CODE_TOKEN>

",morkeleb,
1029,2016-06-26 03:08:19,"See https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L83-L89.

The `proxyRes.headers` are in lowercase. But the raw headers is not.
So I thought that we should use `proxyRes.rawHeaders` instead of `proxyRes.headers`.
",fundon,2016-12-02 14:12:56
1029,2016-09-01 10:10:17,":+1: 
",fragsalat,2016-12-02 14:12:56
1029,2016-10-30 23:58:55,"üëç
",oleynikd,2016-12-02 14:12:56
1029,2016-12-02 14:12:56,Fixed in 1.16.0,jcrugzz,2016-12-02 14:12:56
1029,2016-12-07 01:00:00,"I added `preserveHeaderKeyCase` option. If the option is enabled, you can get raw key name. #1104 ",pachirel,2016-12-02 14:12:56
1028,2016-06-23 12:48:36,"Express
500 TypeError: Cannot read property 'split' of undefined
at exports.authenticate (C:\salesforce\df14demo-master\routes\index.js:27:43)
at callbacks (C:\salesforce\df14demo-master\node_modules\express\lib\router\index.js:164:37)
at param (C:\salesforce\df14demo-master\node_modules\express\lib\router\index.js:138:11)
at pass (C:\salesforce\df14demo-master\node_modules\express\lib\router\index.js:145:5)
at Router._dispatch (C:\salesforce\df14demo-master\node_modules\express\lib\router\index.js:173:5)
at Object.router (C:\salesforce\df14demo-master\node_modules\express\lib\router\index.js:33:10)
at next (C:\salesforce\df14demo-master\node_modules\express\node_modules\connect\lib\proto.js:190:15)
at Immediate. (C:\salesforce\df14demo-master\node_modules\express-session\index.js:432:7)
at Immediate.immediate._onImmediate (timers.js:590:18)
at tryOnImmediate (timers.js:543:15)
",PAWAN1SINGH,2016-06-23 15:20:00
1028,2016-06-23 15:20:00,"This does not seem to have anything to do with `http-proxy`. It look like the error comes from your `routes/index.js` file as shown in the stacktrace.
",jcrugzz,2016-06-23 15:20:00
1027,2016-06-23 01:26:23,"Support for bodyparser.json and bodyparser.urlencoded.

Fixes #955 #843 #791
",matibek,2016-08-11 16:37:32
1027,2016-08-11 16:37:39,"Thanks! good looks @matibek 
",jcrugzz,2016-08-11 16:37:32
1026,2016-06-21 21:04:06,"Version info:
node: 0.12.12
http-proxy: 1.14.0

I'm trying to add a cors header using the proxyRes event emitter, but when the response is sent to the client, my header is missing.

<S_CODE_TOKEN>
",boulajp,2016-06-23 14:18:42
1026,2016-06-23 14:18:30,"Nevermind, this issue was related to something else in my project
",boulajp,2016-06-23 14:18:42
1025,2016-06-17 04:54:36,,wuchangming,2016-08-11 16:37:57
1024,2016-06-13 17:27:53,"Implement rewriting of the location header for responses with status code 201, according to RFC2616 section 10.2.2, in response to issue #914 
",gabrielboucher,2016-08-11 16:36:17
1024,2016-08-11 16:22:01,"@gabrielboucher seems reasonable to me if its in the spec. Thanks for the contribution! Would you mind adding a test for the `201` case just so we are covered? :)
",jcrugzz,2016-08-11 16:36:17
1024,2016-08-11 16:26:31,"The test is already there
",gabrielboucher,2016-08-11 16:36:17
1024,2016-08-11 16:36:15,"ha, looking too quickly. thanks for keeping me on my toes :)
",jcrugzz,2016-08-11 16:36:17
1023,2016-06-12 20:19:28,"Hi guys,
I want creat same site https://hide.me/en/proxy with Tor Project (I'll config default location US).
So maybe help me create simple for it.

Thanks guys !
",tungtouch,
1022,2016-06-09 22:32:08,"For example, my request is http://localhost/this/that/path and on the target, I want http-proxy to call the target like this http://target.server/final/path. If you noticed the `this/that` got replaced by `final`

<S_CODE_TOKEN>
",c0debreaker,
1022,2016-06-21 06:32:37,"has the same question
",JerryC8080,
1022,2016-07-12 00:39:09,"Same here.  #887 refers to an issue on `http-proxy-middleware`, which points to its docs and implies that there is a `pathRewrite` option. But I've tried that and it does not work.
",mrdanimal,
1022,2016-09-16 17:51:11,"did you try to modify your request?

<S_CODE_TOKEN>
",jf990,
1021,2016-06-09 05:16:36,,kittBoy,
1021,2016-06-11 04:02:25,"@kittBoy If you need to deal with html, you can try [harmon](https://github.com/No9/harmon). If you only deal with json, you can try [node-http-proxy-json](https://github.com/langjt/node-http-proxy-json)
",langjt,
1020,2016-06-08 14:08:56,"I configured my browser's proxy setting and I pointed it to my test app listening on port 9000. It somewhat worked. However, I noticed on my console.log that my app received other calls to assets. They didn't get displayed because I think I didn't have them in my code. However, that would be a pain if we specify every asset in the code. How is it done? Or is node-http-proxy not meant for these kinds of scenario? Thanks!

<S_CODE_TOKEN>

Output of console.log

<S_CODE_TOKEN>
",c0debreaker,
1020,2016-06-10 23:35:11,"I somewhat got it to work now. However, I am seeing some weirdness. When I pull our web app via Node-http-proxy, I'll get tons of 404 especially on multiple consecutive images being retrieved. When I copy the failed image url and I paste it to a new tab, I still get 404. However, once I kill my node app.js and restart it, when I reload the url image, it will display it.
",c0debreaker,
1019,2016-06-07 16:30:05,"I have a weird issue on proxying websocket, only when changing the request url. If I do nothing, my proxy on websocket works very fine. But, if I change the request url, it does not work anymore, in both firefox & chrome and they are complaining about missing _upgrade_ header. Indeed, it's missing from response, but when debugging I see it in `proxyRes` and `socket` buffer, like this

<S_CODE_TOKEN>

This log me 

<S_CODE_TOKEN>

So should be ok... but nope... browser wait several seconds, like a timeout, then yield about missing ""Upgrade"" header, and indeed if I look through the dev tool, I only see _sec-websocket-accept_ and _sec-websocket-protocol_

If anyone has a clue about why, I'm all ears!
",JSteunou,
1018,2016-06-02 03:08:38,"Since version [1.0.0](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_IOJS.md#http), Node has added support for getting the raw headers from an incomming message, like the ones `http.request` passes to its callback.

This opens the possibility of sending the headers to the client using the same capitalization as the target server used when responding to our request.

What the PR proposes to accomplish this goal is to add a new option, `keepHeaderCase`, that instructs the `writeHeaders` outgoing pass to build a map of lower-cased headers to its original representation located in the `rawHeaders` property of `proxyRes`.

To keep backwards compatibility with earlier versions of Node, the outgoing pass above uses the keys of the `proxyRes.headers` map as the first parameter of `res.setHeader`.

There are some corner cases regarding headers set by preceding passes; it wasn't clear to me what to do with those. But otherwise, the simple test added by the first commit in this PR works ok.

What do you think about this feature?

Thanks,
Diego
",diegonc,2017-01-06 13:25:35
1018,2017-01-06 13:25:35,"Hello, I'm closing this as result of doing cleanup of my PRs. I believe this feature was already implemented by @pachirel so this patch is not required anymore.

Thanks",diegonc,2017-01-06 13:25:35
1017,2016-06-01 20:50:52,"We've been seeing some ECONNRESET errors in our proxy application.  The errors are being handled  so its not causing any major issues, but we're worried there might be connectivity issues with the target server.  Is there anyway we can differentiate between ECONNRESET errors coming from the client side connection versus the target side?
",archa347,
1017,2016-06-29 04:21:57,"+1, I get request package in system, it seems to send request to localhost (original url), but not my target url
",PepperYan,
1016,2016-06-01 18:58:50,"I'm finding it troublesome to proxy to UNIX socket. I see that in the middle of the proxying this calls ""parse_url"". Does this break unix socket support? Is it supported?
",rafaelc0sta,2016-06-01 19:05:38
1016,2016-06-01 19:05:38,"Found it somewhere in the documentation.

Pass an object (rather than a String) on the target of the proxy and have one ""socketPath"" property in it
",rafaelc0sta,2016-06-01 19:05:38
1015,2016-06-01 18:09:12,"I recently built a small webserver that basically uses node-http-proxy to help me for development purposes.

I wanted to cache the RESTful API's response as a plaintext file to edit it and serve the edited content, if it exists.

However, in order to do this, I had to get pass gzip content. I ended up making another GET request to the API, unzipped the response and saved it to a file, [here](https://github.com/DictumMortuum/praestus/blob/master/index.js#L26-L47).

I've read the [entry on modifying the proxy's response](https://github.com/nodejitsu/node-http-proxy#modify-a-response-from-a-proxied-server), however this is not what I want, because I want this to work for JSON, too (which is problematic for trumpet - which uses css selectors) and I don't want to make any modifications on-the-fly with server-side logic.

Is there an easy way to avoid the second request to my API?
",DictumMortuum,
1015,2016-06-04 15:59:35," @DictumMortuum Hi, you can try this [node-http-proxy-json](https://github.com/langjt/node-http-proxy-json)
",langjt,
1015,2016-08-25 05:29:10,"@langjt is it possible to read proxy's response if the response is in chunked, gzipped and eventually the buffer will be html.
",ravitadi,
1015,2016-09-11 12:00:54,"@ravitadi If you need to deal with html, you can try [harmon](https://github.com/No9/harmon). If you only deal with json, you can try [node-http-proxy-json](https://github.com/langjt/node-http-proxy-json)
",langjt,
1014,2016-05-31 00:16:54,"Hi guys.

I'm using node-http-proxy to put multiple node.js apps behind one single adddress. We can access the different nodeJS apps through an url parameter, like the following example:

`http://host.com/socket.io/socket.io.js?tpdp=node_app`

In this case, ""tpdp"" is the parameter used to redirect to the right app.

The problem is that eventually, the proxy stops responding requests. When I looket at the log file, I saw an errors being reported repetaed times:
`{ [Error: getaddrinfo EADDRINFO] code: 'EADDRINFO', errno: 'EADDRINFO', syscall: 'getaddrinfo' }
`

<S_CODE_TOKEN>

I already saw more people with this same issue before. Somebody found a solution for this?

Regards
",dyegonery,
1013,2016-05-29 06:55:39,"sorry
",edab,2016-05-29 07:08:16
1012,2016-05-27 18:40:32,"I'm trying to make my proxy server receive a request like this:

http://127.0.0.1:8000/http%3A%2F%2Fwww.mytargetsite.com.br%2Ftenis-zx-flux%2FS75496.html%3Fasd%3D1

But I'm getting an error like ""The requested URL ""[no URL]"", is invalid""

This is my code:

<S_CODE_TOKEN>
",lucaswxp,
1011,2016-05-25 16:12:18,"### nodejitsu/node-http-proxy now has a Chat Room on Gitter

@jcrugzz has just created a chat room. You can visit it here: [https://gitter.im/nodejitsu/node-http-proxy](https://gitter.im/nodejitsu/node-http-proxy?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&content=body_link).

This pull-request adds this badge to your README.md:

[![Gitter](https://badges.gitter.im/nodejitsu/node-http-proxy.svg)](https://gitter.im/nodejitsu/node-http-proxy?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=body_badge)

If my aim is a little off, please [let me know](https://github.com/gitterHQ/readme-badger/issues).

Happy chatting.

PS: [Click here](https://gitter.im/settings/badger/opt-out) if you would prefer not to receive automatic pull-requests from Gitter in future.
",gitter-badger,
1010,2016-05-24 05:29:13,"One test ""`should emit open and close events when socket.io client connects and disconnects`"" is broken since socket.io-client upgraded to 1.4.6 (upgrading its dependency engine.io-client to 1.6.9), because of a new default value in commit: socketio/engine.io-client@7fa16d531b40fb316e418e8f3d9e50bb07b38531

This pull request force the value of `rejectUnauthorized` to null (like before upgrade) to fix the test.
",Volune,2016-05-25 16:18:51
1010,2016-05-25 16:18:45,"Thanks so much! üëç 
",jcrugzz,2016-05-25 16:18:51
1009,2016-05-18 10:06:13,"Sometime the `set-cookie` header specify a domain for the cookie. When proxying the a target using `changeOrigin` option, the response may contain a cookie not matching the domain of the client.

Example of such a cookie: `foo=bar; domain=my.domain; expires=Tue, 12-Feb-2019 10:50:41 GMT; path=/`

This pull request adds an option to rewrite the `set-cookie` header of the response.

Possible option values:
- disabled (default): `cookieDomainRewrite: false`
- rewrite all domains: `cookieDomainRewrite: ""my.client.domain""`
- remove all domains: `cookieDomainRewrite: """"`
- more advanced configuration (this example removes all except one):
  
  <S_CODE_TOKEN>

Let me know if I can improve this option or for any question.
",Volune,2016-08-12 17:42:18
1009,2016-06-10 13:38:39,"Looks promising
",drouillard,2016-08-12 17:42:18
1009,2016-08-09 15:16:26,"Would love to see this merged.
",parse,2016-08-12 17:42:18
1009,2016-08-10 10:23:43,"PR should be clean now, I also rebased on top of current master, and improved function comments. Let me know if I missed anything.
",Volune,2016-08-12 17:42:18
1009,2016-08-10 12:33:48,"@Volune Overall this looks good. I would like to see some more documentation for this option in the README, similar to what you have in this PR in your initial proposal. The only thing that kind of bothers me is having `''` remove all domains. Would it be more intuitive to use an explicit `null` as removal? I'm really not sure what the right answer is but is there something that semantically makes more sense for that implication?
",jcrugzz,2016-08-12 17:42:18
1009,2016-08-11 10:11:57,"@jcrugzz The first reason of using `''` is that it would transform `Domain=some.domain` to `Domain=`, which has the meaning of no domain, but (as far as I understand RFC 6265) is not a valid value. So I used it to remove the domain.

Also, it adds some meaning to the type of the option:
- boolean `false`: disable the option
- object: advanced configuration
- string: shorthand for `{ '*': value }` configuration

I'm not against using explicit `null` and/or explicit `undefined` to remove the domain, and document it.
Let me know what's your opinion, decision.
",Volune,2016-08-12 17:42:18
1009,2016-08-11 16:18:57,"@Volune Thats reasonable, i think its ok. Lets just document all the options for this option in the readme, take care of that one nit i have so that we are a bit more performant so we arent creating the regex everytime and we cache it in a variable at the top of `common.js` (with the other one thats there. Then we will get this merged :). Thanks for bearing with me
",jcrugzz,2016-08-12 17:42:18
1009,2016-08-11 19:44:32,"Also we just need a minor rebase. since i merged some other PRs 
",jcrugzz,2016-08-12 17:42:18
1009,2016-08-12 06:11:14,"Should be all good.
",Volune,2016-08-12 17:42:18
1009,2016-08-25 09:26:45,"Hey everyone, thanks for this - a very helpful feature. 

Wondering if there is any built-in way to also rewrite secure/httpOnly option? In local development, I am using `localhost:3000`, which obviously isn't secure, so even with the domain rewrite, cookies are failing to be set.
",isaachinman,2016-08-12 17:42:18
1009,2016-12-21 22:39:48,@isaachinman I am faced with this same issue as well.  Perhaps it would be good to open up a separate issue for this feature.,joeskeen,2016-08-12 17:42:18
1009,2016-12-29 08:12:30,"@isaachinman Just information, node-proxy-middleware has this implemented. It can't be hard to implement this in node-http-proxy

https://github.com/gonzalocasas/node-proxy-middleware/blob/master/index.js#L113

[edit] I added this `onProxyRes`-function to solve the problem temporary.
<S_CODE_TOKEN>",eonlepapillon,2016-08-12 17:42:18
1008,2016-05-17 16:32:24,"Am planing to write a cookie valider in the proxy server.
below is my code 
`var httpProxy = require(""http-proxy"");
var http = require(""http"");
var url = require(""url"");
var net = require('net');

var server = http.createServer(function (req, res) {
    var urlObj = url.parse(req.url);
    var target = urlObj.protocol + ""//"" + urlObj.host;

<S_CODE_TOKEN>

}).listen(8080);

var regex_hostport = /^([^:]+)(:([0-9]+))?$/;

var getHostPortFromString = function (hostString, defaultPort) {
    var host = hostString;
    var port = defaultPort;

<S_CODE_TOKEN>

};

server.addListener('connect', function (req, socket, bodyhead) {
    console.log(""Cookies2: "", req.headers[""cookies""])

<S_CODE_TOKEN>
## });`

but i unable to find cookie values in log ...
my output is shown below 
`Cookies1:  { host: 'api.mixpanel.com',
  'proxy-connection': 'keep-alive',
  'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36',
  origin: 'http://code.runnable.com',
  accept: '*/*',
  referer: 'http://code.runnable.com/UTlPPF-f2W1TAAET/how-to-use-cookies-in-express-for-node-js',
  'accept-encoding': 'gzip, deflate, sdch',
  'accept-language': 'en-GB,en-US;q=0.8,en;q=0.6' }`

pls help me on this...
my plan is to read cookie from web request then validated it in proxy server(before redirected to targeted server)
",rajsek,
1007,2016-05-16 16:16:52,"Node Version: 4.4.4
http-proxy version: 1.13.2

When proxying a browser request to a JSON RESTful endpoint that returns gzip content-encoding and chunked transfer-encoding the browser is receiving invalid bytes back from the proxy.  This causes a browser error: ERR_CONTENT_DECODING_FAILED

It looks like the server is returning valid bytes to the proxy, but when http-proxy pipes the data from the proxy response to the browser response, the bytes are being UTF-8 encoded.  To work around this I added an onProxyRes handler that hijacks the browser response ""write"" and ""end"" methods to force ""binary"" encoding when receiving a ""content-encoding"" header that contains gzip.

This feels like a really ugly solution:

<S_CODE_TOKEN>

Oddly enough, this is only an issue when the Accept request header contains ""text/html"" or ""application/xhtml+xml""  When no Accept request header is specified, the response is properly proxied.

I was hoping to use ServerResponse#setDefaultEncoding(""binary"") but it appears ServerResponse doesn't implement that Writable method.

I'm not sure if this is an issue with http-proxy or the underlying node http implementation, but please help.
",wtritch,
1006,2016-05-14 23:38:15,"If it doesn't have some sort of rate limiting feature implemented. Which nginx, and haproxy have.
",Dillybob92,2016-05-16 03:22:15
1006,2016-05-15 09:33:01,"IMO http-proxy is extremely flexibly. Adding a rate limiter is as easy as integrate any node module that implements a rate limiter and checks your requests before sending to http-proxy.
",acanimal,2016-05-16 03:22:15
1006,2016-05-16 03:22:15,"Im sorry you think a missing feature equates to the module being useless. This module is meant to be a building block not a ""do it all"" nginx/haproxy replacement. @acanimal has the right idea :). 
",jcrugzz,2016-05-16 03:22:15
1006,2016-07-13 00:35:07,"Immediately after reading this `https://runcommand.io/2016/06/26/my-condolences-youre-now-the-maintainer-of-a-popular-open-source-project/` I though it was funny seeing this ticket lol 
",colbyn,2016-05-16 03:22:15
1006,2016-07-13 00:40:47,"@Dillybob92 next time, dig deep and try to find some basic human empathy. Starting a conversation with an inflammatory and insulting title like ""This module is worthless"" only hurts. [Why do that?](https://speakerdeck.com/indexzero/keeping-important-code-alive-seattlejs-march-2015)

I am locking this issue. @jcrugzz we should use this as an opportunity to adopt a code of conduct since this kind of behavior is obviously not welcome. 
",indexzero,2016-05-16 03:22:15
1005,2016-05-09 13:55:22,"I am trying to proxy shiny server with node.js. I can do that with no problem but if I am trying to access it within an angular app  the web socket request is wrong. 

I have added base url in my angular view:

<S_CODE_TOKEN>

The ws base url makes no difference in solving the issue.

When I access the URL in the browser: http://localhost:8070/api 

It works and the url the shiny app use is correct.

It looks like this:
http://localhost:8070/api/**sockjs**/n=U4KBxHv7R0QfzjfwJR/info

When I access the URL in my Angular controller like this: 

<S_CODE_TOKEN>

I output the scope in the view:

<S_CODE_TOKEN>

All URL‚Äôs is correct except the websocket request (/api/ is missing):

http://localhost:8070/**sockjs**/n=quKu5RbSqQ5oKNRVGa/info

In console you can also see   Referer:http://localhost:8070/

Because of this I get the error message: ‚ÄùDisconnected from the server‚Äù

In the shiny server I have both tried to put my R code in: 

/srv/shiny-server/api

and /srv/shiny-server/

No difference in behavior. It works if I access the url directly but not with Angular.

In node.js I use node-http-proxy and express for routing:

<S_CODE_TOKEN>

My shiny code is the example hello shiny:

<S_CODE_TOKEN>

What could cause this issue?
Could it be the express configuration?
",appernetic,2016-05-10 12:57:36
1005,2016-05-09 16:49:43,"I have thought about the issue and I think that if I could change the referer for the websocket request It should work. If it is possible to do it in the angular http function or in the node server somewhere... 
",appernetic,2016-05-10 12:57:36
1005,2016-05-09 17:13:59,"It doesn't work to add a header to $http service in angular. I have also tried to add a header in node.js:

res.setHeader(""Referer"", ""http://localhost:8070/api/"");

No luck so far.
",appernetic,2016-05-10 12:57:36
1005,2016-05-10 12:57:36,"Nor is the browser happy if you change the referer header in Angular. 

To trick the browser and WebSocket (actually socks) that the origin is from the same path as in the shiny app I first enabled html5Mode in angular and then did a route rewriting function in the node server. 

Then all paths were wrong except the WebSocket path wich was working. So I had to modify the shiny app also. Now it's working. 

All issues were client side. No changes in the proxy.

Now on to next problem authenticating socks with auth0.

Closing! 
",appernetic,2016-05-10 12:57:36
1004,2016-05-05 21:09:14,"What am I doing wrong? When I connect from inside the LAN response is very fast. If I connect from outside response time increases to more than 30 seconds.

<S_CODE_TOKEN>

Maciej
",my-poi,2016-05-07 16:24:28
1004,2016-05-07 16:24:28,"OK! I use nginx.
",my-poi,2016-05-07 16:24:28
1003,2016-05-05 18:24:31,"Hi!  I wasn't able to run the modifyResponse middleware, so I updated it.  I think the `connect` module API must have changed.  The first error I hit was `connect.createServer is not a function`.  Next, `app.use` was being passed two functions, but it can only accept one.  I also added the examples' dependencies to devDependencies so they can be run without having to manually install more deps.  Hope this helps!  Let me know if there's anything you'd like me to change.
",mwcz,
1002,2016-05-05 09:12:05,"![2016-05-05 5 18 33](https://cloud.githubusercontent.com/assets/4456380/15040107/96d5c6ac-12e4-11e6-9fd4-2360a53b799b.png)

My config.

<S_CODE_TOKEN>
",lili21,
1002,2017-02-12 16:05:01,"I'm having the same issue.
+1

How to fix?",roccomuso,
1001,2016-05-04 15:37:08,"This prevents ECONNRESET errors from being thrown for connections
that are supposed to be closed (fixes #1000).
",nicolayr,2016-06-15 09:56:12
1001,2016-05-06 13:23:21,"The initial change caused some connections to be closed before all data was transmitted to the client.

I changed it so that instead of closing connections, connection errors for connections that are _supposed_ to be closed don't trigger the error callback.
",nicolayr,2016-06-15 09:56:12
1001,2016-06-15 09:56:12,"Seems to have been fixed by #966 
",nicolayr,2016-06-15 09:56:12
1000,2016-05-04 15:34:55,"When the target server sends a `Connection: close` header, normal behavior as per the HTTP protocol is that both the client and server should close the connection when data transmission has completed.

Currently node-http-proxy doesn't honor this. Instead the connection is left open, which results in `ECONNRESET` errors being thrown on subsequent requests.

There are several related open issues, but I couldn't find any that directly address the same problem. For example: #446, #813, #859, #757, #966.
",nicolayr,2016-06-15 09:56:41
1000,2016-06-15 09:56:41,"Fixed by #966 
",nicolayr,2016-06-15 09:56:41
999,2016-05-01 18:53:50,"I keep getting this error (Image below) after setting it up in this project (Link below) . Hope someone can help me. Thanks !
https://github.com/davidmann4/ogar-feeder-bot
![capture](https://cloud.githubusercontent.com/assets/18157373/14943659/82943d30-0fac-11e6-8843-3b18af74f7ac.PNG)
",ElieeCh,
999,2016-05-02 09:13:36,"use #HTTP on top of proxies list
",kurama129,
998,2016-04-28 02:49:07,"port 9001 -> port 9002
",ukari,2016-04-28 16:15:04
998,2016-04-28 16:15:10,"Thanks!
",jcrugzz,2016-04-28 16:15:04
997,2016-04-26 14:06:24,"Fixes #996.
",randunel,2016-04-26 20:26:35
996,2016-04-26 14:05:11,"None of the error handlers are triggered when proxying client requests with non-trimmed headers.

I think the request shouldn't fail at all, but it's not up to `http-proxy` how node.js sanitizes the outgoing requests. At least an error that can be caught should be emitted, instead of terminating the process. Alternatively, `http-proxy` can sanitize the headers itself (see #997). 

<S_CODE_TOKEN>
",randunel,2016-04-26 20:26:35
995,2016-04-25 05:23:11,"<S_CODE_TOKEN>
",shallwefootball,
995,2016-07-26 14:46:54,"I'm seeing the same thing. Did you ever figure out what was going on?
",edsu,
994,2016-04-22 22:53:38,"I am experiencing a 30 second idle timeout when proxying a basic websocket connection, how can i change this timeout amount?  If i connect without the proxy there is no idle timeout.
",narciero,
993,2016-04-21 13:57:05,"Hi,

I have the following setup:

Localhost Express (LAN machine #1) -> Localhost Proxy (LAN machine #1) -> Servlet (LAN machine #2).

Servlet is including a Jsessionid cookie in it's response header, which I'm able to modify and receive on the response header of Localhost Express, but for some reason won't store under browser resources. Any ideas?

Thanks.
",adi518,2016-04-25 16:23:49
993,2016-05-11 22:50:20,"I'm having trouble with the same issue, did you find a work around? The set-cookie header comes back with the JSESSIONID, but the browser doesnt retain it. 

@adi518
",whampop,2016-04-25 16:23:49
993,2016-05-11 23:12:01,"Yes, the solution was just under my nose. It had nothing to do with inner-workings of node-http-proxy. In my case I was making a request from a localized domain (as depicted in OP) to another localized domain (but a different port of course, because by default Node server listens to all domains assigned to loop-back in your hosts file), which was the proxy server. The mistake was not making the request from the same localized domain (that of Express). So what happened is, the proxy returned the cookie and the browser retained under the proxy domain.

To visualize the issue:
I had an Ajax call going from site.com:80 -> proxy.com:81. The Jsessionid cookie was then retained under the wrong domain, namely proxy.com. As soon as I made my call from site.com:80 -> site.com:81 the cookie was retained correctly. I use Chrome, so checking where the cookie ended up was done by simply browsing to: chrome://settings/cookies. If you already turn to a proxy under the same domain and the cookie still doesn't retain, you probably omitted XHR option **withCredentials** to your Ajax/XHR call, which in this case the response isn't granting the browser permission to retain the cookie, part of how CORS works (see: http://api.jquery.com/jquery.ajax/, https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials).
",adi518,2016-04-25 16:23:49
993,2016-05-12 01:29:58,"Thanks!

 For anyone else who stumbles across this issue, I didn't have the same setup,

 -> http://localhost -> proxy -> https://realserver.com, 

In my case the cookie had the Secure flag, so although JSESSIONID was stored @localhost, it was not being sent in subsequent requests because I didnt use the https:// by setting the https property on the webpack-dev-server config. 
",whampop,2016-04-25 16:23:49
992,2016-04-21 01:47:35,"`Accept: text/html,*/*` headers in request cause binary file (zip) downloads to be corrupted. Content type of response `content-type: ""application/octet-stream""` is not being used to process the response correctly.  These headers are automatically being set by Chrome.  If I instead test the same request with `curl ... -H 'Accept: */*'` alternatively, I am able to download the same zip via the proxy without corrupting it.

Here is the sequence of events:

<S_CODE_TOKEN>

Resulting downloads are larger than original files on the server.  And `unzip -t` indicates it is a corrupted archive.  In fact, using `cat a.zip | iconv -f utf-8 -t utf-8 > /dev/null` test on the corrupted file reveals they are in a valid UTF-8 format.  This suggests that proxy may not be honoring the content-type response coming back from the web server. Instead it may be using ""text/html"" as the content type to process files being downloaded. 

Attempting to rewrite the Accept headers to `*/*` using following method also fails.

<S_CODE_TOKEN>

Here is the code used to proxy the requests:

<S_CODE_TOKEN>
",sashadt,
992,2016-04-21 01:48:50,"For now I found a workaround of setting `download` attribute on the download links.

<S_CODE_TOKEN>
",sashadt,
991,2016-04-19 20:10:59,"I offer this PR up in case this functionality is desired for node-http-proxy - I needed this ability, but couldn't find it anywhere and thought someone else might find it useful.  Thanks for the solid code.

I've isolated this ability away from the normal proxy behavior.  If you set `wsInterceptMessages` to `true` in the options then it will intercept and relay websocket messages.

In options:
`wsOnMessageToServer` - Is a function called when a message is intercepted on its way to the server.  It takes two arguments: data is a websocket message in a Buffer class, and flags describe the message (compressed, binary, etc - from the websocket ws/lib/Receiver and Sender classes.  This function is expected to return a buffer that is to be used for the websocket message.  If `null` is returned, the message is consumed and nothing will be forwarded along the websocket proxy.
`wsOnMessageToClient` - Is a function called when a message is intercepted on its way to the client.  It also takes the same arguments as `wsOnMessageToServer`

Events:
`message_toserver` - Emitted on message to server, can be used in place of the functions if you only wish to monitor and not modify the messages.
`message_toclient` - Same as above for client.
`websocket_connected` - Emitted when websocket interception setup is complete.
",RoscoP,
990,2016-04-19 18:04:56,"**Setup a stand-alone proxy server with proxy request header re-writing**
Error: connect ECONNREFUSED 127.0.0.1:5060
    at Object.exports._errnoException (util.js:890:11)
    at exports._exceptionWithHostPort (util.js:913:20)
    at TCPConnectWrap.afterConnect [as oncomplete](net.js:1059:14)
",pearljamik,
989,2016-04-14 21:21:51,"missing bracket
",aroder,2016-04-26 20:23:33
988,2016-04-12 21:29:18,"Is node-http-proxy ready for production?
Someone using it successfully?
",roccomuso,2016-04-14 16:03:45
988,2016-04-12 22:06:12,"@roccomuso yes, we've used this in production for many years.
",jcrugzz,2016-04-14 16:03:45
988,2016-04-12 22:45:34,"@jcrugzz even as load balancer? a lot of people suggest tools like HAProxy or nginx.. But i'd like to have a full node.js stack.
",roccomuso,2016-04-14 16:03:45
988,2016-04-13 00:34:22,"@roccomuso HAProxy or nginx will be a more performant load balancer. HAProxy being the most performant. The advantage you get with `node-http-proxy` is the ability to write a dynamic load balancer very quickly that performs well. It wont be the fastest as previously stated but it depends if that matters for your application.
",jcrugzz,2016-04-14 16:03:45
988,2016-04-13 00:36:04,"For more context, we used it in production at nodejitsu for 5+ years, and it is used in a production application @godaddy as well. Figure out if its the right tool. Its at least a good place to start for getting things up and running. 
",jcrugzz,2016-04-14 16:03:45
988,2016-04-13 14:41:36,"@jcrugzz Thank you for pointing this out. ;) What i need is in fact a dynamic load balancer. Speed is not an essential requirement for my app.
",roccomuso,2016-04-14 16:03:45
988,2016-04-14 15:16:20,"Since I can't make it not freak out on even the simplest of proxy situations (ie, proxy all localhost:3000 to localhost:3001 -- no SSL, no custom logic, and the same curl request works against localhost:3001 but causes node-http-proxy to explode violently), I'm going to say... no.
",tomcanham,2016-04-14 16:03:45
988,2016-04-14 15:23:56,"Lest you think I'm just a Github hater, here's the _entirety_ of my node-http-proxy code:

<S_CODE_TOKEN>

And here's my curl request for a JWT from my auth server:

`curl -X POST -H ""Content-Type: application/json"" -d '{""username"": ""baz"", ""password"": ""bat""}' http://localhost:3000/api/v1/token`

This produces this ""production ready"" response:

<S_CODE_TOKEN>

Whereas this:

`curl -X POST -H ""Content-Type: application/json"" -d '{""username"": ""baz"", ""password"": ""bat""}' http://localhost:3001/api/v1/token`

(note the port change)

...produces a slightly more nice result:

<S_CODE_TOKEN>

So again -- I'm going to go with, no. It's not production ready. I could debug it, but then again, I could just cobble together my own ""reverse proxying"" with Express and isomorphic-fetch.
",tomcanham,2016-04-14 16:03:45
988,2016-04-14 16:03:44,"@jcrugzz going to mark this issue as resolved since @roccomuso's original question appears to have been answered. 

@tomcanham have you tried other targets besides `localhost`? Like `127.0.0.1`? You are getting a DNS lookup error for `localhost` (that's what `Error: getaddrinfo ENOTFOUND localhost` indicates) so it may be configured in a non-standard way on your development machine.

On standard setups in production you'd be using a DNS target that is known to be valid and/or proxying directly to an IP address depending on how you choose to configure the actors in your proxy-based system. I confirmed that the simple example in the `README`:

<S_CODE_TOKEN>

Works just fine on my machine (it also works in Travis and in a few VMs). All of which are running the latest Node LTS version.

<S_CODE_TOKEN>

Hope that helps! A PR to our docs outlining what was different about your system so that others can avoid this pitfall in the future would be most welcome. 
",indexzero,2016-04-14 16:03:45
987,2016-04-11 18:23:41,"Hello. I'm not sure if this is a bug or intended feature, but when the target issues a 301 redirect, the proxy forwards that to the client and the client gets redirected away from the proxy. Is there a way to resolve this?

Thanks!
",drm2,2016-04-19 19:43:14
987,2016-04-11 20:12:20,"In case anyone else is having this issue, I also [posted a question on Stack Overflow](http://stackoverflow.com/questions/36557440/how-can-i-suppress-301-redirects-from-the-target-with-node-http-proxy).
",drm2,2016-04-19 19:43:14
987,2016-04-15 18:03:05,"The point of a 301 redirect is to tell the viewer (i.e. the browser, Google crawler, etc) that this location has permanently moved. If the redirect were not sent to the client, the client would have no way of knowing this information. So this is the expected behavior. It sounds like you want to do something else. Suppressing the redirect will not achieve anything, the browser request will just hang until it times out.
",joshdickson40,2016-04-19 19:43:14
987,2016-04-15 18:08:19,"I am aware of the point of a 3xx redirect, but I don't think you quite understand what I am trying to achieve. I don't want to just suppress it altogether. I want the proxy to automatically load the new request at the redirected target without the client even knowing it happened. In this case, the proxy receives the redirect and just passes it to the client. I would prefer the proxy to just load the new location and continue to proxy the requests and responses for the client. Does this make sense? I appreciate the help.
",drm2,2016-04-19 19:43:14
987,2016-04-15 18:36:48,"I think I understand what you want. So a user submits, let's say, a GET that hits your server. You then would ordinarily forward that to route X. But in some cases, route X does not return data, it returns a 301. In this case you do not want this to be visible client side, you just want your proxy to try that automatically and then pipe back to the client as though nothing has ever happened, is that right?

This is outside what you want a proxy to do - it's too complicated. This module (and other proxies) is designed to handle a lot of requests very efficiently, and the only time where you want to be modifying the return is if it can be quickly done (see Harmon note [here](https://github.com/nodejitsu/node-http-proxy#modify-a-response-from-a-proxied-server)).

In your case, there could be a lot of logic going on, and it could take a long time. It would be far better architecturally to have your proxy send this to another node process, and that process can loop through receiving 301 redirects (for instance, it could see several in a row and continue to follow them until it gets to where it sees data). When it gets a response that is not a 301, it can then pipe it back to the client. This keeps your proxy simple and efficient, while giving you space to come up with more complicated routines like the one you're asking about.
",joshdickson40,2016-04-19 19:43:14
987,2016-04-15 18:46:15,"Exactly right! Do you have any resources on how I could achieve this result with this module and Harmon together? I've been searching, but I don't see a lot of documentation on piping the request between processes like you mentioned. Thank you!
",drm2,2016-04-19 19:43:14
987,2016-04-16 18:20:24,"No, you are trying to fit a use case into a proxy server that is not designed to do what you want. Rather than try to fit the tools to what you're doing, you should choose different tools. You should set up a different application that handles what you're talking about, and use this module (or nginx, HAproxy, etc) as designed.
",joshdickson40,2016-04-19 19:43:14
987,2016-04-19 19:43:14,"Is handling a protocol redirect really out of the scope of this module though? I just find it odd that a proxy module wouldn't be able to handle something as simple as a protocol redirect (which is incredibly common). I definitely understand where you are coming from, but it just doesn't feel like a complete proxy module if it can't handle protocol redirects on the same domain. In any case, I really appreciate the help, and I'm going to close this issue in light of the information you have given me. Thanks again!
",drm2,2016-04-19 19:43:14
987,2016-04-19 21:13:33,"You definitely _could_ do what you're asking, you'd just intercept the response and not immediately return the result. It's just not a smart design decision and that's why it's not an explicitly catered to use case. 
",joshdickson40,2016-04-19 19:43:14
987,2017-03-12 15:02:47,"I have this exact same issue, what i did to solve it is to modify the request host before sending it to the proxy.
e.g  
req.headers.host =  req.headers.host + "":8000"";
proxy.web(req, res, {
    		target: 'http://127.0.0.1:8000'
  	}); ",izukingz,2016-04-19 19:43:14
986,2016-04-01 18:06:47,"Hello
I need to make http-proxy work over our corporate proxy server, so I took advice from issues/832 to added proxy-agent as following:

  var HttpsProxyAgent = require('https-proxy-agent');
  var proxy = httpProxy.createProxyServer({
      agent: new HttpsProxyAgent(myProxyServerUrl)
  });

It works with proxy server.  But setHeader in the following code throws exception:
        proxy.on('proxyReq', function (proxyReq, req, res, options) {
            proxyReq.setHeader('my-header', someValue);
        });

error: uncaughtException: Can't set headers after they are sent.

I am using
node: 4.2.1
http-proxy: 1.13.2

Thanks
",wenjunche,
986,2016-08-24 13:00:19,"Having the same issue...
",busybeaver,
985,2016-03-30 22:13:28,"When requesting [this digg.com url](http://posthaven-assets.s3.amazonaws.com/assets/blog-4bc028df3b67274aee198b1e7747e44a.js), node-http-proxy sets the `proxyReq.path` to

 `/assets/blog-4bc028df3b67274aee198b1e7747e44a.js/assets/blog-4bc028df3b67274aee198b1e7747e44a.js` instead of `/assets/blog-4bc028df3b67274aee198b1e7747e44a.js`

the `path` is repeated twice.

To fix this I reset the `path` by doing

<S_CODE_TOKEN>

I'm using node.js v5.9.1.

Have I done something incorrectly?
",sshaginyan,
984,2016-03-30 22:01:14,"Hi,

Is available in node-http-proxy a cache mechanism like in nginx?
",roccomuso,
984,2016-04-19 19:35:01,"+1 on this. Any idea? 
",mmahalwy,
984,2017-02-10 12:23:33,+1,chrvadala,
984,2017-02-10 22:06:38,I think you can easily integrate node-http-proxy with an existent solution like https://github.com/kwhitley/apicache,acanimal,
983,2016-03-23 22:20:17,"This confused me while attempting to use this feature
",deanshelton913,2016-03-23 22:36:21
983,2016-03-23 22:36:25,"thanks!
",jcrugzz,2016-03-23 22:36:21
982,2016-03-22 15:47:21,"For clarity
",kylehayes,2016-03-22 19:13:09
982,2016-03-22 19:13:13,"Thanks!
",jcrugzz,2016-03-22 19:13:09
981,2016-03-21 01:06:19,"Hi, how to integrate multi thread with the proxy?

I found the  concurrency problem, the proxy will be slow, is there a solution with multi thread?
thx~
",fewiki,
980,2016-03-19 08:52:27,,ChrisCinelli,
979,2016-03-18 12:52:52,"I am proxying requests to web container jetty. It used to work fine, but suddenly stopped working.
Only changes we made is **Centos** version changed from **6.7** to **6.6.** I am assuming centos version change should not create any problem.

Please find the error received from API request
##### An error has occurred: {""code"":""EPROTO"",""errno"":""EPROTO"",""syscall"":""write""}

Snippet of the code:

`
function ecsRequest() {
    return function (req, res, next) {
                var buffer = httpProxy.buffer(req);
                req.url = req.originalUrl;
                proxy.proxyRequest(req, res, {
                        host: 'localhost',
                        port: 9981,
                        path: req.originalUrl,
                        target: {
                        https: true,
                        rejectUnauthorized: false,
                        buffer: buffer
                }
            });
    };
}
`
",srikanthhugar,2016-04-06 05:49:45
979,2016-04-06 05:49:45,"Issue was with web container jetty supported ciphers, i upgraded JDK to update the ciphers and it works.

Thank you.
",srikanthhugar,2016-04-06 05:49:45
978,2016-03-15 01:04:55,"I created some changes in order to help facility intercepting and modifying websocket messages.  I highly doubt this is something you would want to take in as is, but proved to be valuable to me and will hopefully for others.

When calling createProxyServer define callback functions in order to modify (and observe) the websocket message.

<S_CODE_TOKEN>

You can also attach event listeners to only observe the messages.

<S_CODE_TOKEN>
",RoscoP,2016-03-16 22:24:36
977,2016-03-14 18:56:11,"I have two server running same server code.
One will receive data and forward (or duplicate) to the other server while handling the request normally.

I try to use proxy.web but it requires the response object and I just want to handle this part using the original server but not the forwarded server.

How can i do this :( 
",tsuncp,
976,2016-03-14 02:12:24,"Currently, if a server that is being proxied explicitly redirects from e.g. `www.example.com` to `www.example.com:443`, the `hostRewrite` option will fail to re-write the host, as `'www.example.com' != 'www.example.com:443'`. 

Is this intended behavior? If not, I will submit a PR. Personally, I usually think of the ""Port"" as separate from the ""Host"". 
",jamescgibson,
975,2016-03-11 17:27:58,,idjem,2016-05-15 19:40:01
975,2016-05-15 17:51:14,"Just a drive-by here cause twitter and my own curiosity:

How does this break/fix browserify?
",jfhbrook,2016-05-15 19:40:01
975,2016-05-15 19:39:47,"Yea this is interesting that it does fix something but harmless regardless. Will push out a release when I'm home. 
",jcrugzz,2016-05-15 19:40:01
974,2016-03-08 23:08:16,"### Before

<img width=""873"" alt=""screen shot 2016-03-08 at 6 06 30 pm"" src=""https://cloud.githubusercontent.com/assets/54056/13619712/aeaaaa2c-e558-11e5-9aa1-1cf83428f9cd.png"">
### After

<img width=""866"" alt=""screen shot 2016-03-08 at 6 07 31 pm"" src=""https://cloud.githubusercontent.com/assets/54056/13619711/aeaadf92-e558-11e5-9c2e-4393c3a0d168.png"">
",bmac,2016-03-09 01:26:38
974,2016-03-09 01:26:36,"Thanks!
",jcrugzz,2016-03-09 01:26:38
973,2016-03-08 19:07:04,"Hi, I'm trying to use this proxy as passthrough but not able to make it work. below is my scenario.
I would really appreciate your help.

http://stackoverflow.com/questions/35857654/software-proxy-service-on-amazon-ec2
",KamMo,
973,2016-04-11 17:43:10,"@KamMo the link is dead.
",miensol,
972,2016-03-08 17:49:10,"[We](https://github.com/jupyter-incubator/dashboards_server) have a [requirement](https://github.com/jupyter-incubator/dashboards_server/issues/94) where data being proxied through a websocket needs to be transformed. I have implemented a [`Transform`](https://nodejs.org/api/stream.html#stream_class_stream_transform) stream that I would like place between the pipe of my socket and the proxied socket.

I have a simplified example of what my scenario is [here](https://gist.github.com/Lull3rSkat3r/4a33589e6121525ecb63). I am looking to see if there is a known way to achieve what I am trying to do.
",Lull3rSkat3r,
972,2016-09-13 15:22:56,"I'm trying to do something similar. Did you have any luck?
",johngeorgewright,
972,2016-09-14 16:30:21,"@johngeorgewright we ended up restructuring our code and didn't need this.
",Lull3rSkat3r,
971,2016-03-07 18:38:13,"I don't understand why I keep getting ECONNRESET with this rather simple proxy:

<S_CODE_TOKEN>

Not going through the proxy works perfectly.

node-proxy: 1.13.2
node: 5.5.0
",ronag,
971,2016-03-11 12:36:10,"Hi !

I have a same probleme on the specific case !
I upload on my serveur, behind the http-proxy, a large file (250Mo) with a slow connexion 64kb !
And in the specific case, i have a ECONNRESET error !
Without a slow connexion, it's works !
Initially, I thought it was nodejs. So i try all versions and the problem is appear in versin 3.3.0 (iojs) and later (4.x 5.x, so nodejs too). But the manipulation (upload) work without the proxy !

Regards

http-proxy : 1.13.2
node : > 3.3.0
OS linux 3.9.11
",Toon34,
971,2016-04-29 13:43:34,"Hi !

Should be fixed by https://github.com/nodejs/node/pull/6284
",Toon34,
970,2016-02-28 22:22:34,"There were errors in the examples highlighted, check issue #969
",Subomi,
969,2016-02-27 20:52:03,"In section Setup a stand-alone proxy server with custom server logic: 
We have: 
`var server = http.createServer(function(req, res) {
  // You can define here your custom logic to handle the request
  // and then proxy the request.
  proxy.web(req, res, { target: 'http://127.0.0.1:5060' });
});

console.log(""listening on port 5050"")
server.listen(5050);`

Instead of: 
`var server = http.createServer(function(req, res) {
  // You can define here your custom logic to handle the request
  // and then proxy the request.
  proxy.web(req, res, { target: 'http://127.0.0.1:5050' });
});

console.log(""listening on port 5050"")
server.listen(5050)'

And also the same thing in section Setup a stand-alone proxy server with proxy request header re-writing
",Subomi,
968,2016-02-27 06:20:07,"I cant modify response if proxy response is 5xx.

<S_CODE_TOKEN>

It's give me an error:

<S_CODE_TOKEN>
",mhf-ir,
968,2016-06-11 14:54:06,"I thinks it's must be major use cases for failover proxy server. why no attention ?
",mhf-ir,
968,2016-07-25 07:13:11,"+1
",bubenshchykov,
968,2016-09-28 11:27:44,"+1
",orkideh,
968,2016-12-01 04:41:21,+1,ankushsaxena5,
968,2016-12-28 10:26:04,+1,MrSpark2591,
967,2016-02-26 12:30:00,"Reasoning: Rack's request class [makes use of](https://github.com/rack/rack/blob/master/lib/rack/request.rb#L243) this HTTP header. Certain edge-case scenarios (proxying from ember-cli to a Rails backend) can be problematic without this header being present.

/cc @perlun, @jesjos
",jbacklund,2016-02-26 17:52:26
967,2016-02-26 17:45:57,"Seems reasonable.
",jcrugzz,2016-02-26 17:52:26
967,2016-02-27 16:06:22,"@jbacklund @jcrugzz 

With this change, the `xfwd` behavior for `web` is slightly different from `ws`.

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L65-L83
https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/ws-incoming.js#L54-L69

Would be good to keep the API consistent; By applying the same change to [WebSockets](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/ws-incoming.js#L54-L69) as well, instead of just the [Web](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L65-L83) part.
",chimurai,2016-02-26 17:52:26
967,2016-03-07 10:26:48,"Agree, we should fix that as well. Care to submit a PR?
",perlun,2016-02-26 17:52:26
966,2016-02-24 21:14:25,"Hello folks, 
This is my first contribution, if there is anything wrong with my PR, please let me know.

We've been using node-http-proxy in our prod server since 3 years now and its working as a charm (thank you!), but everyday we got our log files full of `socket hang up` messages, so I come here dig code and found an issue for that: #[813](https://github.com/nodejitsu/node-http-proxy/issues/813). 

To me, this looks like a bug also, we should not send as an error a disconnection between the client, so I made this PR using the info in the issue.

I'm not sure if emit a `disconnected` event is the best approach, or if you guys want something more elaborate for that. Please, let me know your thoughts.
",Deividy,2016-06-03 17:39:40
966,2016-02-25 00:33:08,"@Deividy thanks for the contribution! I saw you did some investigation on removing the `req.on('error')` listener. The proxyReq error event was still triggered when the client disconnected when removing it still? I can see this can still be an issue when the client request itself timed out but was curious :). Will comment
",jcrugzz,2016-06-03 17:39:40
966,2016-02-25 11:01:48,"Yep, the `proxyReq` error was still triggered even removing the listen `req.on('error')`, my test case was refresh the browser window like crazy, this can trigger the `socket hang up` false alarms, btw, this should be good to have a test case.

Thanks for the comments, I made the tweaks. 
About the `req` listener, what we can do about that? Maybe emit some other event or just remove it? I saw a PR removing it, don't know if I touch that or not.
",Deividy,2016-06-03 17:39:40
966,2016-02-26 08:42:08,"Maybe missing a line of comment to explain why this function has an early return instead of calling callback or triggering error event. Otherwise looks very good, thank you for this PR!
",JSteunou,2016-06-03 17:39:40
966,2016-04-08 07:31:02,"@jcrugzz good to go?
",JSteunou,2016-06-03 17:39:40
966,2016-06-03 17:39:34,"@Deividy thank you for your work. Will merge this. id like to rebase the branch that removes teh `req.on('error')` listener and see how it behaves.
",jcrugzz,2016-06-03 17:39:40
965,2016-02-23 19:11:48,"fixes https://github.com/nodejitsu/node-http-proxy/issues/964

I'm propagating errors when writing the headers. This is consistent with the way errors in `http.request` are handled https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L135.
",fjakobs,
964,2016-02-22 15:50:04,"The recent security release https://nodejs.org/en/blog/vulnerability/february-2016-security-releases/ of node.js makes header parsing much more strict:

> To fix this defect, HTTP header parsing in Node.js, for both requests and responses, is moving closer to the formal HTTP specification. HTTP headers containing characters outside of the valid set for tokens will be rejected. This check is performed for both requests and responses, for Node.js HTTP servers and clients.

Setting headers can throw now at https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L86.

Here the change in node.js https://github.com/nodejs/node/blob/fab240a886b69ef9fa78573fc210c15cfe0018f0/lib/_http_outgoing.js#L309

I'm getting `The header content contains invalid characters` error and then I get an uncaught exception.

Since I don't control the app being proxied and I can't wrap this call into a try/catch, this needs to be fixed in http-proxy.
",fjakobs,
964,2016-02-22 15:54:58,"@fjakobs what strings are causing this to throw? Could you log the headers that are being set here? Would love a test case for this
",jcrugzz,
964,2016-02-22 16:58:41,"@jcrugzz I found this in the wild:

`content-type: ""ÔøΩ?@""`

Not sure why someone would do this but is certainly should not crash the app.
",fjakobs,
964,2016-02-22 17:02:09,"here you can see what node is expecting https://github.com/nodejs/node/commit/7bef1b790727430cb82bf8be80cfe058480de100#diff-9ef7b1e52407f06cd19696d2f726e498R241
",fjakobs,
964,2016-02-22 20:29:46,"easy to reproduce. This works on node 0.10.41 and throws in 0.10.42

<S_CODE_TOKEN>

on node 0.10.42

<S_CODE_TOKEN>
",fjakobs,
964,2016-02-22 22:23:25,"@fjakobs hmm yea thats kind of unfortunate that we are receiving invalid headers. I'd almost rather do this check ourselves to prevent the need for a `try..catch`. Ill look at this later but would definitely take a PR that fixed this.
",jcrugzz,
964,2016-02-22 22:24:59,"Would you prefer sanitizing the headers or passing on the error?
",fjakobs,
964,2016-02-22 22:34:42,"@fjakobs how do you feel about the behavior of ignoring bad headers? I guess we could make it an option to receive it as an error but I dont think the proxy server should have to care if its receiving bad headers from a client, it just doesnt pass them along since they are not spec compliant. 

What im thinking about is using that internal check they added to node core and using that as a signal to ignore the header.
",jcrugzz,
964,2016-06-14 15:41:18,"@fjakobs @jcrugzz 

I am using latest Meteor and hitting something with the same signature.  I am trying to figure out a workaround and you guys seem to have the best handle on this.

Here is the stack dump:

<S_CODE_TOKEN>

A couple questions, this looks like an inbound request which crashes the server?

I wanted to simply comment the throw but it appears that the respective code gets compiled into the node elf executable?

Thanks in advance!
",ppotoplyak,
964,2016-06-14 16:28:18,"Refining my question a little.

So it looks like a request comes in, nothing necessarily particular about the request, but then on the response invalid characters are entered into the header?

Would the following be a reasonable workaround to provide immediate relief ? i.e. I need to prevent a hard crash when hitting this error.

<S_CODE_TOKEN>

Thanks again!
",ppotoplyak,
964,2016-06-14 17:06:34,"Sorry about the noise.  It appears that the issue can occur on the receive and send side.  I notified the Meteor folks that the issue exists on the receive side.  This is pretty nasty as a crafted request brings the server down.
",ppotoplyak,
964,2016-06-14 19:17:41,"@ppotoplyak if you want to rebase from this branch https://github.com/nodejitsu/node-http-proxy/pull/965 id merge it until we can figure out a better way that doesnt de-opt from the try catch.
",jcrugzz,
964,2016-06-15 02:57:37,"@jcrugzz sure, if you are okay waiting until next week

There is a worse problem on the incoming side.  A similarly crafted request brings the node/Meteor process down.

This is my workaround to prevent the process from terminating:

<S_CODE_TOKEN>

The malformed request will take an ""Error: socket hang up"" but the server will stay up.
",ppotoplyak,
964,2016-09-14 07:10:59,"I'm experiencing the same problem, any news on this recently? 
",TooBug,
964,2016-10-05 09:47:36,"Have the same problem with `_http_outgoing.js`
",blade254353074,
964,2016-11-01 14:22:09,"+1
",bubenshchykov,
964,2016-11-10 11:26:05,"@jcrugzz @fjakobs, is there any estimate on when you are thinking of releasing a fix? This issue is affecting us in production. Is there any easy workaround we can apply other than monkey patching the code?
",dlaha21,
963,2016-02-20 13:58:23,"Hi, maybe I'm not understanding the purpose of this library correctly but it does mention that it can be used for reverse proxies. I posted this on SO but didn't get any answers, it must be something I am not fundamentally understanding:

<S_CODE_TOKEN>

For example I would expect http://localhost:6622/images/nav_logo242.png to proxy to http://www.google.co.uk/images/nav_logo242.png instead of returning a 404 not found.

Thanks.
",DominicTobias,2016-02-20 19:22:02
963,2016-02-20 19:22:02,"It turns out this was failing as it needed a `Host` header:

<S_CODE_TOKEN>
",DominicTobias,2016-02-20 19:22:02
963,2016-03-28 21:50:18,"@DominicTobias I know this is closed, but there is a setting for that.  If you set ‚ÄúchangeOrigin‚Äù to true it will automatically change the host header to the upstream servers for you.
",pyper,2016-02-20 19:22:02
963,2016-03-28 21:58:53,"@pyper ah that's nice thanks
",DominicTobias,2016-02-20 19:22:02
962,2016-02-15 14:49:04,"This PR switches `npm test` to using the default mocha reporter. The ""landing"" reporter doesn't render well on CI servers like TravisCI.
",Turbo87,2016-02-15 15:35:41
961,2016-02-15 14:44:01,"This PR resolves #960
",Turbo87,2016-02-15 15:35:33
961,2016-02-15 15:35:30,"LGTM Thanks! :+1: 
",jcrugzz,2016-02-15 15:35:33
960,2016-02-13 22:05:01,"This issue is related to PR #373 where this exact bug was already fixed by a89e2f2, but then later apparently introduced again by 8663ac1.

The actual problem is that `DELETE` requests with both `Content-Length: 0` and `Transfer-Encoding: chunked` are illegal and are being rejected by some servers (in this case nodejs since v0.10.42). If the incoming request only has the `Transfer-Encoding` header the proxy will somehow automatically set the `Content-Length` header to `0` but won't remove the encoding header which leads to this issue.
",Turbo87,2016-02-15 15:35:33
960,2016-02-13 23:32:52,"@Turbo87 looks like this was lost in translation when the rewrite happened. I'd love PR for this :+1:. Definitely a good first contributor issue :)
",jcrugzz,2016-02-15 15:35:33
959,2016-02-13 16:44:18,"URLs get all their extra slashes merged into a single one.
For e.g. this `/some/endpoint//` gets transformed into this `/some/endpoint/`, which is not the desired behavior for some particular cases.

By simply removing `.replace(/\/+/g, '/')` inside the `urlJoin` function (`lib\http-proxy\common.js`) you can overcome the problem, but I guess this is not the intended way of working with the node-http-proxy.

One possible fix for this would be to allow the user of the library to intercept the `urlJoin` call so that he could do some final changes to the URL before it gets proxied.
",cosminnicula,
959,2016-02-15 16:33:24,"Hmm this is a good question, right now there is not a good way to handle both cases because there are people that have the opposite assumption when merging URLs together. Whats the example you are trying to make work? I'd love it in test form so we can work towards a solution that works for all cases or is at least configurable in some way.
",jcrugzz,
959,2016-02-18 08:40:09,"The URL that's being proxied looks like this:
`/api/files//path/to/folder`
The parameter of the REST API endpoint is `/path/to/folder`, which causes the final URL to look like this `/api/files//path/to/folder`, so there are no accidental double slashes here.
",cosminnicula,
959,2016-02-22 00:32:46,"A solid fix in userland is to [encode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) the API parameter, which you probably ought to be doing anyway.

In JavaScript you would do that with:

<S_CODE_TOKEN>

And thus make a request to:

<S_CODE_TOKEN>
",sholladay,
959,2016-02-22 07:09:07,"That's a good idea. Nevertheless this implies that the server should know to decode it.
",cosminnicula,
959,2016-02-22 21:01:31,"Right. This is a quirk of taking it in the path. Many libraries will automatically decode anything coming in via a query string. Not sure offhand about this module, but if you could switch to that, maybe it would reduce the burden on your implementation.
",sholladay,
958,2016-02-12 10:08:00,"Hello,

I want to achieve the following:

Proxy these:
`http://localhost:3000/css/css-home-123-34.css`
`http://localhost:3000/css/css-home-232-12.css`
`http://localhost:3000/css/css-home-378-68.css`

to this (same for all calls):
`http://branches.mysite.com/myBranch/resources/css-home.css`

I tried this but **did not work**:

<S_CODE_TOKEN>

What am I missing?

Note: I also use the `hosts` file to map an IP address to `branches.mysite.com`

Thanks for any clarification.
",marinetraffic,
958,2016-02-15 15:35:26,"Ok, I figured this out eventually:

<S_CODE_TOKEN>

If it is possible, it would be great to have examples like this on the documentation. Thanks!
",marinetraffic,
958,2016-05-20 08:39:46,"I am also having this problem with webpack-dev-server. (which I think it's a bug when proxying requests to a local virtual host), it doesn't send request with the correct host name, which is replaced by ""localhost""

the following config solved my issue:

<S_CODE_TOKEN>
",c9s,
958,2016-06-15 19:20:13,"Thanks, I can confirm this works to address VirtualHost:
- set target with host / protocol / port
- set changeOrigin: true
",mickaelperrin,
958,2016-10-04 09:46:39,"When proxying `localhost:8080` to `foo.com.local:8888` and using `changeOrigin: true` it changes the `HTTP_HOST`. Now all links (in a Laravel and Symfony application) point to the proxied `foo.com.local:8888`, instead of `localhost:8080`. Is there a way around that?

Interestingly, Browser-Sync doesn't have this behavior.
",bernhardw,
957,2016-02-10 16:42:27,"So the caveat here is that this is a breaking change, but i think it provides more useful context to the `error` as the `error` should be the actual `proxyReq` and not the `req` itself. In most cases (or at least using the `callback` api, you already have access to `req` and `res` so providing these ends up being useless. We were also previously capturing errors from client requests which I believe was creating false positives for people.

Thoughts @donasaur @indexzero 
",jcrugzz,
957,2016-02-10 20:36:20,"Yea, that's more helpful. I think if you also update the README for event listening, then it'll be fine
",donasaur,
956,2016-02-10 14:06:37,"Hi. I am implementing traffic log system (I want to log all websites to DB specified table). I have used example form your repo with http and https proxy server example. But I have troubles with it - I can't load files over http (files loads successfully over https). How can I fix it? Thanks.

Here is the code that I use - 

var http = require('http'),
    net = require('net'),
    httpProxy = require('http-proxy'),
    url = require('url'),
    util = require('util');

var proxy = httpProxy.createServer();

var server = http.createServer(function (req, res) {
  proxy.web(req, res, {target: req.url, secure: false});
}).listen(8213);

server.on('connect', function (req, socket) {
  var serverUrl = url.parse('https://' + req.url);
  var srvSocket = net.connect(serverUrl.port, serverUrl.hostname, function() {
    socket.write('HTTP/1.1 200 Connection Established\r\n' +
    'Proxy-agent: Node-Proxy\r\n' +
    '\r\n');
    srvSocket.pipe(socket);
    socket.pipe(srvSocket);
  });
});
",alexandrmatsyuk92,
955,2016-02-10 03:02:25,"The following is my code.

**route.js**

<S_CODE_TOKEN>

**app.js**

<S_CODE_TOKEN>

But still the POST request hangs and ultimately fails.

I also use bodyparser middleware and it has a known issue as mentioned in [Github](https://github.com/nodejitsu/node-http-proxy/issues/180) issue. So I tried adding this line as the last line in app.js

I also tried restreamer code but I get the following error if I use the restreamer

`error: uncaughtException: Can't set headers after they are sent.
`
I get this error because I emit end in the restreamer and then try to set the headers in proxy.on function. Any suggestions appreciated. 
",karthikus,2016-08-11 16:37:32
955,2016-02-11 01:18:48,"I manage to work around the issue. But now I am facing an unique issue. The content seems to be truncated when the request is proxied to the server. I tried setting content-length to the body length and it does not work. Any suggestions ?
",karthikus,2016-08-11 16:37:32
955,2016-02-11 17:28:49,"It maybe be how you are measuring the length.  That is the encoding may throw that off.  I don‚Äôt think you need have a content-length specified.  If not, just take the header out altogether.  Also, make sure it is actually getting set.  Validate that the destination server actually gets the header with the length you set.  What I think is happening for you in the bodyParser middleware is mutating the content, and thus the length, before it goes to the destination server.  
",pyper,2016-08-11 16:37:32
955,2016-04-29 16:02:14,"@karthikus How did you work around the issue?
",narciero,2016-08-11 16:37:32
954,2016-02-09 16:56:02,"At the proxy target server, I am setting a response cookie with a value that has an ""="" in the value.  This is getting set as %3D on the final client response.

Is there any way to disable this cookie encoding?

Thanks!
",Osmosis311,2016-02-09 18:27:03
954,2016-02-09 18:27:03,"Sorry, was an Express configuration issue.
",Osmosis311,2016-02-09 18:27:03
954,2016-02-09 19:46:48,"@Osmosis311 What was the issue?
",pyper,2016-02-09 18:27:03
953,2016-02-04 09:58:50,"my node.js version is 4.2.2

app.js:
`var api = require('./routes/api');
app.use('/api', api);`

api.js
`
proxy.on('proxyReq', function(proxyReq, req, res, options) {
proxyReq.setHeader('X-Special-Proxy-Header', 'foobar');
});
router.all(""/*"", function(req, res){ 
  proxy.web(req, res, { target: 'http://dev.lalocal.cn:8080/api' });
});
`

error:
Error: Can't set headers after they are sent.
",jnjnljljjsw,
953,2016-04-01 15:47:51,"Having the same issue under load. My set up is almost identical 
",michaellujan,
953,2016-04-15 03:28:34,"I ran into this too; it only seems to happen for multipart (chunked) responses. I didn't dig into it too much, but I found a workaround. When you call the proxy method, you pass in an options object -- the third parameter, which contains the target. 

Well apparently, if this object contains a 'headers' object, those headers are copied to the proxied request as it's being initialized, and the timing of this copy avoids whatever race condition is causing this failure.

From my code:

<S_CODE_TOKEN>
",tomcanham,
953,2016-07-25 07:12:01,"+1, happens during bigger load
",bubenshchykov,
952,2016-02-04 09:02:37,"So I'll say this is something I keep seeing on GitHub... barely useful examples. After spending the past 24 hours or so on this repo, I still can't figure it out.

How do I create an app with node-http-proxy that has separate custom server logic for each proxy? E.g. nodeone.com, nodetwo.com, nodethree.com
",ohenepee,
952,2016-02-08 22:40:45,"@ohenepee Are you trying to modify the response depending on the domain?
",pyper,
952,2016-02-10 00:09:05,"Yep!
",ohenepee,
952,2016-02-10 16:29:28,"@ohenepee There is two ways.  One you can use something called Harmon to modify the stream as it passes through.  Just use some logic on the incoming request to see what the domain is.  However, Harmon is slow.  The other way is to override the out-going response methods, and buffer and manipulate the content there to capture it.   There is a good example in this thread:

https://github.com/nodejitsu/node-http-proxy/issues/796

Also, try searching for ‚ÄúFAQ‚Äù tag under issues.  Many of the common pitfalls you will likely run into are usually there.
",pyper,
951,2016-02-03 20:30:30,"The documentation says one can specify a `callback` for `proxy.web()` call.
But this `callback` gets called only if case of an error.
It isn't called when there was no error.
https://github.com/nodejitsu/node-http-proxy/blob/302d981dd2cf06dbf751b1f64e3dfea08d0f9476/lib/http-proxy/passes/web-incoming.js#L130-L142
",halt-hammerzeit,2016-02-04 15:37:15
951,2016-02-03 22:28:16,"According to the docs this is the right behaviour.  They say ""Errors can be listened on either using the Event Emitter API‚Äù  .... ""or using the callback API‚Äù and then provide an example using the proxy.web() call.
",pyper,2016-02-04 15:37:15
951,2016-02-03 22:31:00,"@pyper a word `callback` in Node.js world always means only one thing: a function that will be called when the action is finished, whose first parameter is `error`, if any, and the rest parameters are the results.

The current `proxy.web()` is clearly not a ""callback API"".
",halt-hammerzeit,2016-02-04 15:37:15
951,2016-02-04 15:30:48,"@halt-hammerzeit I understand that, but I am just pointing out that is the behaviour as per the docs.  As well, the way node-proxy is built it is all streams.  If there was a callback for when there is no error, you wouldn‚Äôt be able to do much with it since response.end() would have been called on the response object between the end-user and proxy by the time the call was complete.
",pyper,2016-02-04 15:37:15
951,2016-02-04 15:31:48,"@halt-hammerzeit What are you trying to do?
",pyper,2016-02-04 15:37:15
951,2016-02-04 15:37:15,"@pyper 

> I am just pointing out that is the behaviour as per the docs

And I am pointing out that behaviour is not as per the docs because ""the callback API"" means ""call back"" when it's either done or aborted.
If you aren't interested in correcting that mistake in the README and renaming that word into something  more appropriate like ""error handler"" then I don't care.

> you wouldn‚Äôt be able to do much with it

I am able to do much with it.

Anyway, I have my solution and this issue is not for helping me do something, it's for pointing out the mistake in your documentation/api-design.

The workaround for those who are interested:
https://github.com/halt-hammerzeit/webapp/blob/80f2c37596e878895eaa129dc7666133e472443f/code/common/web%20server.js#L747-L766
",halt-hammerzeit,2016-02-04 15:37:15
951,2016-08-03 00:36:12,"Cheers @halt-hammerzeit! Link was much appreciated!
",jpstrikesback,2016-02-04 15:37:15
950,2016-02-02 13:57:14,"README example implies request instead of response parameter
",caioquirino,2016-02-15 15:36:24
950,2016-02-15 15:36:28,"Thanks @caioquirino 
",jcrugzz,2016-02-15 15:36:24
949,2016-02-02 02:51:48,"The repository README implies that the `close` callback will be given a request object, when it's really the proxy response object according to the relevant source.

//
// Listen for the `close` event on `proxy`.
//
proxy.on('close', function (req, socket, head) { // <-- `req` should be `res`
  // view disconnected websocket connections
  console.log('Client disconnected');
});
",nitind,
949,2016-02-02 04:58:29,"@niallo great find! Would love a quick fix PR :). 
",jcrugzz,
949,2016-02-02 13:57:56,"Quick Fix PR created :)
",caioquirino,
948,2016-01-30 17:26:45,"Fixed typo.
",Alfredo-Delgado,2016-02-02 04:58:45
948,2016-02-02 04:58:49,"Thanks!
",jcrugzz,2016-02-02 04:58:45
947,2016-01-28 18:27:43,"Shrunk replace options.
Fix https://github.com/nodejitsu/node-http-proxy/issues/946.
",coderaiser,2016-02-02 04:59:18
947,2016-01-28 19:02:35,"@coderaiser could you add a test for the case you pointed out in #946 
",jcrugzz,2016-02-02 04:59:18
947,2016-01-29 07:49:25,"@jcrugzz done
",coderaiser,2016-02-02 04:59:18
946,2016-01-28 15:33:22,"Why are you replace lines: `:/` to `://` in [urlJoin of common.js](https://github.com/nodejitsu/node-http-proxy/blob/302d981dd2cf06dbf751b1f64e3dfea08d0f9476/lib/http-proxy/common.js#L185)?

It corrupt work of [join-io](https://github.com/coderaiser/join-io) which uses such urls:

<S_CODE_TOKEN>
",coderaiser,2016-02-02 04:59:18
946,2016-01-28 15:36:44,"@coderaiser its meant to handle cases where `http://whatever.com` turns into `http:/whatever.com`. This is a naive urlJoin since it fails on this case, it should be more specific to the post `http`. I would love a PR to fix this if you can turn this into a test case :)
",jcrugzz,2016-02-02 04:59:18
946,2016-01-28 15:56:58,"The thing is no `http://` string is present on args. Here is example

<S_CODE_TOKEN>
",coderaiser,2016-02-02 04:59:18
946,2016-01-28 17:49:33,"@coderaiser Yes I understand. I was mentioning thats why it exists, Im not saying its correct. The code here needs to be smarter to handle the case you are mentioning.
",jcrugzz,2016-02-02 04:59:18
945,2016-01-27 19:40:35,"The correct is to reach server using host header, not URL.
",caioquirino,
944,2016-01-26 18:17:01,,pradeep122,2016-01-26 18:17:40
944,2016-01-26 18:20:06,"please ignore this, I wanted to merge the master to my repo, but did the reverse
",pradeep122,2016-01-26 18:17:40
944,2016-01-27 03:28:26,"Latest verion has this fix. thanks for the reminder. @pradeep122 
",jcrugzz,2016-01-26 18:17:40
943,2016-01-26 08:42:33,,pra85,2016-01-26 09:02:52
942,2016-01-24 20:11:24,"Would be great to get the NTLM fix into npm.
",merpnderp,2016-01-24 20:19:54
942,2016-01-24 20:19:51,"My apologies, meant to do that dance sooner. 
",jcrugzz,2016-01-24 20:19:54
942,2016-01-24 20:20:55,"published.
",jcrugzz,2016-01-24 20:19:54
942,2016-01-24 21:04:18,"Thanks, you're awesome.
",merpnderp,2016-01-24 20:19:54
941,2016-01-23 11:42:13,,k1ln,
941,2016-01-23 11:49:38,"For example: can i readout the html from the web here?:
 proxyReq.on('response', function(proxyRes) {
      if(server) { server.emit('proxyRes', proxyRes, req, res); }
      for(var i=0; i < web_o.length; i++) {
        if(web_o[i](req, res, proxyRes, options)) { break; }
      }

<S_CODE_TOKEN>

If i would like to read out what the page gets for example. because i can't get the data string. 
",k1ln,
941,2016-01-23 13:16:07,"No. You can't readout the html of the page. The response is getting piped. So it's not like the page gets loaded and then retransmitted. If you want to parse/modify the html that you are getting, look into harmon plugin that works with node-http-proxy.
",tarkeshwars,
941,2016-01-23 13:52:33,"Hi, I don't know if it is exactly the same but some time ago I require to read the response data. See http://www.acuriousanimal.com/2015/08/31/how-to-read-from-a-writable-stream-httpserverresponse-in-node.html
",acanimal,
941,2016-01-23 15:32:16,"Ok. Thanks a lot. 

The Problem is when i tried to access 'http://www.handelsblatt.com' it says: Forbidden can't access ""/"" on this server and i wanted to know if that is what was transmitted. Same with redirects if not enabled no redirect-code is shown. Did you get that error already (The one with the ""/"")?
",k1ln,
940,2016-01-22 15:20:40,"‚Ä¶et is not undefined, which should be the only falsey value that could accidently show up and break that call. This fixes windows NTLM auth issues behind http-proxy in issue [#938](https://github.com/nodejitsu/node-http-proxy/issues/938).
",merpnderp,2016-01-23 17:27:49
939,2016-01-21 23:10:38,"Hi, I'm trying to use node-http-proxy to proxy to my app's api if the request url contains a specific path, and if not, just serve up static content from a local file server...

<S_CODE_TOKEN>

I have [http-server](https://github.com/indexzero/http-server) running on 9001 and serving from `build`: `http-server ./build -p 9001 -c-1`.

If I hit `localhost:9000` I get this error:

<S_CODE_TOKEN>

I haven't been able to find anything related to this error inside the issues. Suggestions? I really have no idea what could be causing this except for the obvious stuff like localhost issues (tried 127.0.0.1, and modifying /etc/hosts to point to something like my.dev).
",aft-luke,
939,2016-01-21 23:47:32,"After futzing around for an hour I finally figured out that `target: http://` is the secret sauce. It appears without a protocol something coughs.
",aft-luke,
938,2016-01-21 15:51:17,"While using the [#727](https://github.com/nodejitsu/node-http-proxy/pull/727) example code to get NTLM working behind node-http-proxy, I saw an error on the second response from my node-sspi server. 

In line 85 of [http-outgoing.js](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L85) an error was thrown that looked like this: 

> _http_outgoing.js:342
>    throw new Error('`value` required in setHeader(""' + name + '"", value).');
>    ^
> 
> Error: `value` required in setHeader(""www-authenticate"", value).
>     at ServerResponse.OutgoingMessage.setHeader (_http_outgoing.js:342:11)

I created a net server that simply piped everything from the http-proxy to my app and another that piped everything from the browser to http-proxy and also outputted everything to stdout so I could compare what was going into and out of http-proxy. And when that error is thrown the header www-authenticate is not returned from node-sspi. It looks like it is somehow cached or held in a reused object inside of node-http-proxy.

My simple fix for now is to change line 85 of web-outgoing.js to: `if(proxyRes.headers[key]){ res.setHeader(key, proxyRes.headers[key]);}` but I'm not sure if that is the best solution since http-proxy is trying to set a header for which nothing was passed in.
",merpnderp,
938,2016-01-21 22:31:48,"@merpnderp i do find this very strange that this is happening but i would take a PR that adds that safety `if` clause
",jcrugzz,
938,2016-01-22 17:44:36,"Looks like the pull request test in Travis CI timed out. Don't think the safety check I added should break anything. Could the test be restarted to see if it was just a network issue?
",merpnderp,
937,2016-01-20 15:31:25,"Are you aware that your product and this page, is being actively blocked by Websense?
",zardoz,2016-01-20 15:38:53
937,2016-01-20 15:38:53,"This is an open source project found on github, not a product. Either way, this is not something in our control as maintainers of open source software. I am curious to the nature of this being ""blocked"" as i am not familiar with Websense. Please feel free to respond but closing as this is not a bug in the project
",jcrugzz,2016-01-20 15:38:53
937,2016-01-20 16:03:20,"Sorry bad terminology. I was trying to look at this link [https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/ws-incoming.js] on your repo yesterday, We use NodeJS in production, We have an issue with reverse proxy for websockets.  Have since realised it's actually our IIS / ARR infrastructure, go figure! Anyway we use Websense as a company-wide proxy, I've attached the report. It doesn't sit right with me, there may be truth to it but I'll let you find that out. Firstly they have said this resource is about proxy avoidance, which it's not, secondly that there are malicious links on the resource (your repo), in their words:

""A site lookup -
Master Database v7.x: Proxy Avoidance
Real-time Category: Proxy Avoidance 
Both investigations have confirmed that the URL is a in the category Proxy Avoidance. This category actually falls under the Risk Classes ""Legal Liability"" and ""Security Risk"". By default, this category will be blocked even if a site is added to an exception or a custom category to protect you and your environment.""

![ws1](https://cloud.githubusercontent.com/assets/48041/12454356/08692b46-bf8f-11e5-8cdc-8e1403f8ca9d.PNG)
![ws2](https://cloud.githubusercontent.com/assets/48041/12454357/08afac9c-bf8f-11e5-8700-6a0d7a65b5d9.PNG)

I just wanted to give you a heads up on this, so that you can investigate, and resolve this if you so wish to.

Yes this is not a bug
",zardoz,2016-01-20 15:38:53
937,2016-01-20 16:39:22,"They are likely blocking based on keywords in the URL.  Try visiting other URLs with similar keywords like ‚Äúproxy‚Äù, ‚Äúhttp‚Äù, ‚Äúincoming‚Äù, ‚Äúhttp-proxy‚Äù, etc.
",pyper,2016-01-20 15:38:53
937,2016-01-20 16:43:08,"I have, many and this was not the case....
",zardoz,2016-01-20 15:38:53
936,2016-01-15 07:50:36,"When i first wanted to build a local http proxy server, and cache all the images data to local disk, i searched for all the available proxy server scripts, since i like JavaScript, i preferred and tried node-http-proxy lib at first, but i found a problem:

In Node, stream objects can easily ""pipe"", since it's builtin method.

But i cannot easily clone/dump a stream, there is no such method. (Can i dispatch a single stream to multiple output channels?)

So i use python's httproxy, httproxy is too naive but it works after some modification.

Finally i switched to goproxy, which is really feature-complete and API-friendly.
",chenzx,
936,2016-01-23 07:50:31,"<S_CODE_TOKEN>
",JohnWong,
936,2016-01-25 10:51:49,"I haven't thought of overriding default methods, thanks!!!

2016-01-23 15:50 GMT+08:00 John Wong notifications@github.com:

> proxy.on('proxyRes', function(proxyReq, req, res, options) {
>   var oldWrite = res.write,
>     oldEnd = res.end;
> 
>   var chunks = [];
> 
>   res.write = function (chunk) {
>     chunks.push(chunk);
>     oldWrite.apply(res, arguments);
>   };
> 
>   res.end = function (chunk) {
>     if (chunk)
>       chunks.push(chunk);
> 
> <S_CODE_TOKEN>
> 
>   };
> });
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/nodejitsu/node-http-proxy/issues/936#issuecomment-174157553
> .
",chenzx,
935,2016-01-14 02:01:20,"I am trying to test a simple proxy out and maybe I am missing something obvious but when an image is proxied its just blank in the browser.

Is there a setting or something that needs to be done to support passing images through? The headers seem identical to me and it appears to be getting data, just not rendering.

Thanks
",nathanscully,2016-01-14 04:08:13
935,2016-01-14 04:08:13,"Ignore me - 
I was trying decode and forward some binary websocket data as it passes through the proxy but accidently was casting everything to utf8 which appeared to upset the image data. 

All solved - code for reference below if any one makes the same mistake!

<S_CODE_TOKEN>
",nathanscully,2016-01-14 04:08:13
934,2016-01-13 14:31:39,"When using option ignorePath common.js would set target to '/'.

This would break requests in cases where this slash was unwanted, for instance when fetching files, or in some cases when using GET parameters.
",Torthu,2016-01-26 20:56:58
934,2016-01-26 22:27:25,"Thanks!
",jcrugzz,2016-01-26 20:56:58
933,2016-01-12 04:44:13,"I use these settings in Ngnix for a proxy:

<S_CODE_TOKEN>

And It's all fine when I use node-http-proxy to do this until it come cross a session lost issue. So I wan't to know what's the solution to set the ""proxy_cookie_path"" in node-http-proxy.
",konieshadow,
932,2016-01-04 04:40:38,"clarify proxy type to be reverse proxy in the introduction
",afriza,2016-02-02 04:59:49
931,2015-12-29 07:07:10,"- browser access https through forward proxy1
- proxy1 will accept connect request
- proxy1 will proxy to proxy2 by upgrade/websocket
  - proxy1 will set headers[x-method-ori] to the original request method
  - proxy2 may be deployed in cloud behind a reverse proxy
  - the reverse proxy in cloud may only allow normal and websocket request
  - and forbid connect request
  - proxy2 is located in a free net env, it's not under network restriction
- proxy2 will connect to the target site, its https
- proxy2 will response with 101 switch protocol
- proxy2 will response with Connection Established next
- when proxy1 accept 101, it can not auto response with 101, but ignore it
",kaven276,
931,2016-02-02 05:00:47,"@kaven276 this sounds interesting, is it possible to test case? Is this a standard header?
",jcrugzz,
930,2015-12-27 20:34:53,"I just got a very strange error. The proxy tries to send the header twice and I have no idea why.

<S_CODE_TOKEN>

My `proxy.js` file: https://gist.github.com/xolf/f79a1f939d7dc64c9894
",xolf,
930,2016-01-04 19:11:56,"+1 I'm having the same problem.
",adambiggs,
930,2016-01-05 02:52:52,"This situation happens when request() call throws an error.  It looks like you have a race condition between your response error function and the web proxy.  What is happening is the request() call is failing and the custom error handler and the proxy are fighting over the same response object.  res.headersSent will not provide you protection because after both times you use them there is many asynchronous callbacks past them.   The stack trace I am getting is indicating the error is originating in the proxy which mean the header flush was likely triggered by res.end() on line 31.  This f‚Äôd up the proxy since it can no longer write headers itself because the headers were sent there.  You have to rethink the fundamental structure of this app to account for the for asynchronous nature of node and http-proxy.
",pyper,
930,2016-03-09 20:48:53,"+1 I'm having the same problem
",jasonniebauer,
930,2016-03-09 22:44:57,"Is there a way to ignore this error and force the server keep on running?
",xolf,
930,2016-07-25 07:12:22,"+1
",bubenshchykov,
929,2015-12-27 16:58:52,"Hi all,

I have a huge performance issue with node-http-proxy, maybe I'm missing something, hopefully someone can point out what's wrong.
Here's the code I'm using for the proxy (listening on 9000):

<S_CODE_TOKEN>

and here's the code of the server listening on 8000:

<S_CODE_TOKEN>

I used wrk to benchmark the performance of the proxy.
First, I test the http server to see how many requests it can handle:
wrk -c 64 -d 15s http://127.0.0.1:8000
Requests/sec:  26255.78

Now when I test the proxy:
wrk -c 64 -d 15s http://127.0.0.1:9000
Requests/sec:    543.84

Something is clearly wrong, so I inspected the cpu usage during the benchmark and I noticed that when I directly test the http server (port 8000), the cpu usage of the server's process stays very close to 100% for the duration of the test (which is expected), but when I test the proxy, the proxy's process gets to 100% but quickly (1-2 seconds after the beginning of the test) drops to 0%
Note that wrk, the proxy and the hello world server run on different threads, this issue is not related to insufficient resources (I have 8 thread on my machine).
I have also tested nginx and HAProxy, and both did fine.

The main reason I want to use http-proxy is for load balancing, but so far it looks like it's gonna be a bottleneck more than anything else.
",kar1m,2016-01-05 19:05:23
929,2016-01-05 10:17:03,"Try ending the proxied response:

<S_CODE_TOKEN>
",peol,2016-01-05 19:05:23
929,2016-01-05 11:10:35,"@kar1m what version of node are you using? Can you compare your results against `0.10`, `0.12`, and `4.2`? 
",indexzero,2016-01-05 19:05:23
929,2016-01-05 18:03:40,"I just ran @kar1m example and I am seeing the same issue here.  Requests per second drop by a factor of 10-20x when using the proxy.  @indexzero I tested on versions v0.10.36 and v5.2.0.
",pyper,2016-01-05 19:05:23
929,2016-01-05 18:19:00,"You probably want a shared Agent.
",indexzero,2016-01-05 19:05:23
929,2016-01-05 18:39:41,"Thanks @indexzero, that made a huge difference.  @kar1m You need to create an agent with keepAlive set to true and pass it the agent option when you create the server.  You might need to play with some of the other agent options too.
",pyper,2016-01-05 19:05:23
929,2016-01-05 18:52:09,"Thanks @indexzero and @pyper, It made a huge difference (10x previous performance), although it's still much slower than HAProxy. I'll try playing with the agent options and let you know if I can get a better performance.
",kar1m,2016-01-05 19:05:23
929,2016-01-05 19:05:23,"We're not going to beat HAProxy. That is not the goal of this project. Thanks for reporting this issue, going to close it now. This will be a good FAQ discussion. 
",indexzero,2016-01-05 19:05:23
929,2016-03-02 15:58:05,"@indexzero, what do you mean by shared Agent?

Can you link to some resources?
",ronaldocpontes,2016-01-05 19:05:23
929,2016-03-02 18:36:46,"@ronaldocpontes you'd want to pass in an `http.Agent` or `https.Agent` on a per request basis based on the `target` URL. Check out the node docs [here](https://nodejs.org/api/http.html#http_new_agent_options)
",jcrugzz,2016-01-05 19:05:23
929,2016-03-02 19:28:08,"Locking this issue now that the entirety of the FAQ resources are here. 
",indexzero,2016-01-05 19:05:23
928,2015-12-21 21:40:39,"I'm trying to create a proxy to an https server that is setup for client certificate authentication.  I'm passing the certificate and the key to the proxy via the ssl object, but the connection is not being established.  Here's my code:

var pcert = fs.readFileSync('./client_cert.pem');
var pkey = fs.readFileSync('./private_key.pem');

proxy = httpProxy.createProxyServer({
  target: 'https://my.backend.server',
  json: true,
  ssl: {
    key: pkey,
    cert: pcert
  }
}.listen(8000);

The following code (written by someone else) creates a stand-alone server that passes client requests to the same backend server, with the same certificate/key, and it's working:

http.createServer(onRequest).listen(3030);

function onRequest(client_req, client_res) {
  var pcert = fs.readFileSync('./portal_client_cert.pem');
  var pkey = fs.readFileSync('./private_key.pem');

  var options = {
    key: pkey,
    cert: pcert,
    agent: false,
    host: 'my.backend.server',
    method: client_req.method,
    path: client_req.url,
    json: true,
    headers:{
         Host: 'my.backend.server'
    }
  };

  var proxy = https.get(options, function(res) {
    res.pipe(client_res, {
      end: true
    });
}

I'd like to create a proxy server instead of a standalone server, so that I could pass it to the Gulp server we're using.  I tried passing the cert and the key as part of the target object instead, but that doesn't work either:

  target: {
    host: 'my.backend.server',
    port: 443,
    protocol: 'https:',
    key: pkey,
    cert: pcert,
  }

What am I missing? 
",atalis,
928,2016-09-20 19:46:12,"Did you find any resolution to this I am having a similar problem and the target server keeps telling me that the cert is missing when I set the options in an object and pass the object to createProxyServer
",SkiGeek82,
928,2016-09-20 19:47:53,"Or when specifying the options like this: 

`var proxy = httpProxy.createProxyServer({
        target: 'https://targetserver/',
        ssl: {
            key: privateKey,
            cert: certificate,
            ca: [ caChain ],
        },
        secure: false
    }).listen(3002, function(){
    console.log('proxy server listening on port 3002');
});`

I get:

`{ [Error: read ECONNRESET] code: 'ECONNRESET', errno: 'ECONNRESET', syscall: 'read' }`
",SkiGeek82,
928,2016-09-20 20:46:58,"Actually, I don't quite remember.  I left the project several months ago, and some requirements changed before then, so the code was rehashed.  I think I ended up doing something like this (but don't quote me on this):

<pre>
var httpProxy = require('http-proxy');
...
var app = express();
// Initialize backend server proxy
var proxyOptions =
    {
        target: {
            host: backendServer,
            port: 443,
            protocol: 'https:',
            cert: fs.readFileSync('./certs/client_cert.pem', 'utf8'),
            key: fs.readFileSync('./certs/client_key.pem', 'utf8'),
            path: '/backend server URI prefix to redirect requests to/'
        },
        changeOrigin: true
    };
var backendProxy = httpProxy.createServer(proxyOptions);
backendProxy.on('error', function(e) {
    console.log(e);
});
app.use('/URI prefix to be redirected to the backend server/', function(req, res) {
        console.log('redirecting to backend server: ' + req.url);
        backendProxy.web(req, res);
    }
);
...
https.createServer(<some options>, app).listen(443, function(){
    console.log('Express server listening on port ' + 443);
});
</pre>
",atalis,
928,2016-09-22 13:59:36,"Yes, moving the client certs to the target (which makes sense) works. I got my solution working. 
",SkiGeek82,
927,2015-12-21 20:49:34,"I know this issue has been resolved 
https://github.com/nodejitsu/node-http-proxy/commit/152d258ea00dddfaed28ef934c540169899c1736
But, I just installed the latest version of http-proxy 
 ""http-proxy"": ""1.12.0""
and I am still getting the error from squid proxy
""HTTP/1.1 Expect: feature is being asked from an HTTP/1.0 software.""

<S_CODE_TOKEN>

My code

<S_CODE_TOKEN>
",yousafsyed,
926,2015-12-18 20:47:22,"This works for some sites but for others, it does not. Basically, some of the URLs in the HTML pages give a 404 not found error when visited through the proxy but work fine otherwise. What am I missing here? 

<S_CODE_TOKEN>

Example, cnbc.com. Works fine, click on any link and its a 404 not found. Why?
",n-samir,
926,2016-01-15 12:46:03,"`xfwd` does not add the `X-Forwarded-Host` header (https://github.com/nodejitsu/node-http-proxy/issues/886)

Could that be the issue?
",chimurai,
925,2015-12-14 09:45:44,"Hi,
The proxy server is throwing error ""CERT_HAS_EXPIRED"" for ssl. How it can be solved?
",vaibhavatul47,2016-01-29 00:57:33
925,2016-01-28 20:57:51,"I'm Getting this problem too:
Error: certificate has expired
",caioquirino,2016-01-29 00:57:33
925,2016-01-29 00:18:31,"I need a form to send the parameter rejectUnauthorized: false to https request. Does anyone know?
",caioquirino,2016-01-29 00:57:33
925,2016-01-29 00:57:33,"You need a new certificate.
",indexzero,2016-01-29 00:57:33
924,2015-12-11 17:28:08,"Hey everyone,

This is in regards to an issue I brought up in #915 yesterday.  I was having an issue with incorrect port selection and assumed @BadBoy20 might be having the issue too.  Anyhow, the problem for me was explicit declaration of the port was not taking precedence over the port implied by the protocol.  The unit test I created was failing before I made the fix.  Also, I did not check the getPort() function in common.js as it‚Äôs only purpose is setting ‚Äúx-forwarded‚Äù headers in web-incoming.js and ws-incoming.js so it seemed out of scope for this issue.

Cheers.
",pyper,
924,2016-03-17 00:58:18,"Anyone going to merge this?
",pyper,
924,2016-03-17 05:24:53,"@pyper this adds another option which does handle a case where we want to pass it in explicitly which is great, but I dont think this fully solves the problem discussed. Could you see if you can fix the bug where the port in the `target` URL itself is properly used? Thanks for your help!
",jcrugzz,
923,2015-12-09 06:03:17,"Hi~

I get error when run the post data to gateway, the problem is that proxy work excellent in case of get requests but in case of post requests it results in socket hang up exception ,no post body is ok!

<S_CODE_TOKEN>
",PanYuntao,
923,2015-12-31 09:28:53,"also I have similar error, but not related to `POST` data
Here if user redirect frequently, e.g. click back button frequently in a 302 redirected page, error below:

<S_CODE_TOKEN>
",futurist,
923,2016-01-04 13:58:44,"@yjm  Thanks for your help. I find the problem that I add body parser  js
file  in `ROOT` folder. :(

2015-12-31 17:29 GMT+08:00 yjm notifications@github.com:

> also I have similar error, but not related to POST data
> Here if user redirect frequently, e.g. click back button frequently in a
> 302 redirected page, error below:
> 
> /root/node-proxy/node_modules/http-proxy/lib/http-proxy/index.js:119
>     throw err;
>     ^
> 
> Error: socket hang up
>     at createHangUpError (_http_client.js:209:15)
>     at Socket.socketCloseListener (_http_client.js:241:23)
>     at emitOne (events.js:82:20)
>     at Socket.emit (events.js:169:7)
>     at TCP._onclose (net.js:469:12)
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/nodejitsu/node-http-proxy/issues/923#issuecomment-168156405
> .
",PanYuntao,
922,2015-12-07 00:37:09,,aaronmaturen,2015-12-07 20:58:22
922,2015-12-07 20:58:19,"Awesome thank you @aaronmaturen 
",jcrugzz,2015-12-07 20:58:22
921,2015-12-03 19:50:21,"It works for a period of time and then I get an error in the browser console: ""net::ERR_INCOMPLETE_CHUNKED_ENCODING""‚Ä¶ after this it stops working.

Works perfectly if I load the site directly (i.e. not through the proxy).

Code I'm using to proxy request/responses is simply:

<S_CODE_TOKEN>

Previous issue was: #357
",davej,
921,2015-12-03 23:13:00,"@davej would love to have a test case for this. Can you reproduce in a node only test so we could add that to our test suite? Thanks!
",jcrugzz,
921,2015-12-07 00:37:49,"Hey friends, 

SSE seems to be working for me, but I created a test and example for SSE here: #922 
",aaronmaturen,
921,2015-12-07 01:33:38,"@aaronmaturen: Thanks for that.

I was able to figure out what the issue is. node-http-proxy is timing out the response after 2 minutes of inactivity.

If you change the connection handler on line 57 of the sse example to the code below then you should be able to recreate it:

<S_CODE_TOKEN>

On the proxy (8003), it times out after about 2 minutes (Chrome 46), with `net::ERR_INCOMPLETE_CHUNKED_ENCODING` and the second message is **not** received.

On the raw SSE server (9003), it doesn't time out and the second message **is** received.

Is there a way to get the proxy to respect the timeout characteristics of the SSE server
",davej,
921,2015-12-07 01:53:33,"It looks like the ws proxy prevents the connection from timing out by setting the timeout option to 0; you may be able to the same with this one. I tried setting the timeout to 1000ms and it threw the error when I expected. When I set the timeout to 0 and the interval to 150000, chrome didn't throw the error again but the tab stopped showing the loading ticker after ~2minutes 

<S_CODE_TOKEN>
",aaronmaturen,
921,2015-12-07 02:20:55,"Yes, it's easy enough to fix when you know what's wrong, thanks for your help.

I guess I can close this issue unless it's worth considering setting the timeout to `0` for websocket and SSE connections? Or is that a bit too magical?
",davej,
921,2015-12-07 02:48:34,"There is a `setupSocket` method in `common.js` that not only sets the timeout but also sets no delay and keep alive on the current socket. This is currently called in `ws-incoming.js` after the `upgrade` event has been emitted for web-sockets.

SSE has a specified Content-Type of `text/event-stream` but you wouldn't have that header until the server already had given you a response. It may be possible to look at what the request accepts and upgrade it based  on that header, but it seems like somewhat of a specialized case.
",aaronmaturen,
921,2016-09-30 21:38:19,"Any outlook for a fix or is a workaround available?
",jimjaeger,
920,2015-12-02 17:49:17,"Is it possible to build a http/2 proxy and fordard the requests to a normal https server? Example please :-)
",m1stegmann,2015-12-02 17:51:51
920,2015-12-02 17:51:51,"Using http/2 is not currently possible. Pull-request for this support would be welcome. I believe the SPDY module from @indutny might support http/2 now.
",indexzero,2015-12-02 17:51:51
920,2015-12-02 17:57:56,"@indexzero @m1stegmann i had an exchange with @indutny that it just requires passing an agent from his `spdy` module which supports `http2` for this to work
",jcrugzz,2015-12-02 17:51:51
920,2015-12-07 00:39:04,"I had a working version of this project with HTTP2 for node >= 0.12.0 here #919 unfortunately node 0.10 isn't supported by the HTTP2 module.
",aaronmaturen,2015-12-02 17:51:51
919,2015-12-02 02:53:16,"Hey Friends, 

I think I've got HTTP2 support for the three use cases working correctly:

HTTP -> HTTP2
HTTP2 -> HTTP
HTTP2 -> HTTP2

Any feedback would be appreciated.

Thanks for everyone's hard work on this great project!
",aaronmaturen,2016-04-21 14:53:22
919,2015-12-06 23:32:56,"I realized that I forgot the example and tests that I had working locally. Unfortunately the HTTP2 module [requires >= 0.12.0](https://github.com/molnarg/node-http2/issues/67) which might be a requirement that isn't aligned with this project, but it is causing the 0.10.2 test to fail in travis-ci here. 
",aaronmaturen,2016-04-21 14:53:22
919,2015-12-08 05:51:46,"This actually looks pretty interesting. @dmai or @jcrugzz: comments?
",indexzero,2016-04-21 14:53:22
919,2015-12-08 17:58:49,"@indexzero @aaronmaturen the reason I'm hesitant on this is due to the conversation I had with @indutny where `http2` based on his implementation in [`node-spdy`](https://github.com/indutny/node-spdy) only requires the proper `agent` to be passed in to enable proxying via `http2`. So this really has to do with what we want to support. 

Personally, I'm not a fan of of actually spinning up a server as part of `http-proxy` since that makes us biased on implementation in this case. But in terms of the actual bit that is proxying, I like @indutny's approach because it leverages the `agent` rather than requiring a separate `http` like library in order to make the request.
",jcrugzz,2016-04-21 14:53:22
919,2015-12-09 06:16:18,"@indexzero ah, calling @dmai doesn't work on public git

Hm, I don't think it would be that bad if we supported the `http2` library since the docs for that library saids that `http2` has an api very similar to that of `https` and we support passing in options to `https`

I can see @jcrugzz 's point about not using a particular userland `http2` module though, and those who have read up on HTTP2 already would most likely know how to use our provided interface to spin up a `http2` web server w/o createProxyServer().listen() using the mentioned userland library or `spdy`
",donasaur,2016-04-21 14:53:22
919,2016-03-22 08:03:22,"Any progressing? I get a problem using with http2 library https://github.com/molnarg/node-http2/issues/158#issuecomment-199682445 And this PR fix the problem.
",muzuiget,2016-04-21 14:53:22
919,2016-03-25 23:00:54,"Hi Friends, 

@jcrugzz suggested that the node-spdy module by @indutny is a better way to spin up a new HTTP2 server. It made sense to me at the time, and it's fairly easy to get setup if you actually have an SSL cert to get past the browser security... 

Here is a small example for HTTP2 -> HTTP proxying without any changes to http-proxy.

<S_CODE_TOKEN>

![screenshot 2016-03-25 18 23 24](https://cloud.githubusercontent.com/assets/507070/14055864/bd5f27c6-f2bb-11e5-9027-b2052855aeb0.png)
",aaronmaturen,2016-04-21 14:53:22
919,2016-04-21 14:51:17,"I hope this gets merged soon, or atleast added to an new branch.
BTW, IIRC Node v0.10 support will end in 2016-08, So Travis' error can be ignored.
",tomByrer,2016-04-21 14:53:22
919,2016-04-21 14:53:21,"@tomByrer please see the [last response](https://github.com/nodejitsu/node-http-proxy/pull/919#issuecomment-201569021), there is nothing preventing you from using `http2` using the `node-spdy` module which is a better way to do this.
",jcrugzz,2016-04-21 14:53:22
919,2016-09-18 08:35:06,"@aaronmaturen I am new to http2 so please indulge me. How would your example code work if the target server is also HTTP2, and what about things like push streams, would they also work? In other words, would be able to get all of the http2 features without loosing any? 
",manast,2016-04-21 14:53:22
918,2015-12-01 07:46:21,"URLÔºö
http://blog.csdn.net/cteng/article/details/50113815
http://www.cnblogs.com/yjq-code/p/AuthoryDesign11.html

Both urls use chunked encoding, seems http-proxy lib doesn't support this?
",chenzx,2015-12-01 08:48:51
918,2015-12-01 07:50:40,"my script:

<S_CODE_TOKEN>
",chenzx,2015-12-01 08:48:51
918,2015-12-01 08:48:51,"https://github.com/gagern/node-http-proxy/commit/35000fc0d7dc0a6073ac37db097b73575a861d34

need to set prependPath: false;
",chenzx,2015-12-01 08:48:51
917,2015-12-01 07:09:20,"i use `target`, and build a local http proxy to let the browser access websites via my local proxy,
but when i goto some web sites, result is error/empty

does the `target` option remove the original request headers from the browser client?
",chenzx,
916,2015-11-30 00:32:14,"I am using this module to do the following:
1. Parse the req URL
2. Add a new header to the request using the token from the URL
3. Update the actual request URL (remove the token from the URL)

I am trying to do that with the following code:

proxy.on('proxyReq', function(proxyReq, req, res, options) {
  console.log(""intercepting ... "")
    proxyReq.setHeader('x-replica', '123');
    req.url = ""/newurl"";
});

Now, the header setting works but the setting the URL does not. How to achieve this with node HTTP proxy ?
",karthikus,
915,2015-11-28 01:35:17,"I have set up a proxy node-http-proxy server on port 8009. and my actual http server on port 3000. But it seems like they are not working. My code looks like this:

<S_CODE_TOKEN>

Now I have used wireshark to sniff the traffic and there was a post field that was sending data to the https://localhost:8009/ server and it was viewable in plain text on the localhost loopback interface.
Not only that, the wireshark protocol detected was http (not TLS/SSL like its supposed to show). there was no indication of TLS handshake or anything like that. I have tested with other legitimate webpages with wireshark and what I found was those webpages have a TLS key handshake like the client hello/server hello stuff but that was not seen when I used wireshark on a request to localhost:8009 https server. So I would like to know what I could do to fix the issue and go through the steps of the TLS server hello/client hello handshake and make sure the data is not being sent on plaintext but rather, encrypted.
",BadBoy21,
915,2015-12-09 22:24:29,"@BadBoy20 I think it is the port.  I had all kinds of issues trying to get it to connect ports that weren‚Äôt 80 or 443.  Once I switched to those it worked fine.  You can have your proxy listening on 8009, just trying changing your test server upstream from 3000 to 443.

If it fixes it, it looks the issue is under:

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js

Selection of port seems to be in multiple places and inconsistent.
",pyper,
915,2015-12-09 22:44:00,"Oh I see what you mean @pyper. Because the port number is hardcoded in there to be either 80 or 443 to determine if it is encrypted or not it does not work with any other user given port to listen to. It doesn't know what to do with them? I see what you're saying. If that is the case, could that be reported as a bug? Implying I have to have root access to test run node code? I was actually hoping to have it listen for https on port 8009 then have an iptables rule on 443 to route it to 8009.

I'll try to change it and test it when I get home. Also something I had to run by to clarify, did you say to have the proxy listen on 8009 and the 3000 one to 443? because 8009 was my https port and the 3000 was my http port. I guess I'll try.
",BadBoy21,
915,2015-12-09 23:00:37,"This looks like a bug. We should only default to `443` or `80` if we do not have a port in the target as well. Seems like this is not handling all cases since we only use the port if its in the header. Would love a PR to clean this up. @pyper seems like you are already on the right track if you want to take a stab at it :)
",jcrugzz,
915,2015-12-10 21:39:31,"@BadBoy20 Yes change 3000 to 443 or 80.  You could also confirm it further by trying it without any encryption.
",pyper,
915,2015-12-10 21:49:46,"@jcrugzz So your last name is Cruger and you want me to stab something? :)

I will give it a shot hopefully soon, cheers.
",pyper,
915,2015-12-10 23:07:42,"This might be a good time to mention my last name is scissorhands
",BadBoy21,
915,2015-12-17 18:18:04,"This is a pretty big bug! Right now it seems a lot of other reverse proxy modules for NodeJS are based on this module (such as node-reverse-proxy and rocky), so they are broken as well. Are you guys gonna push a patch release with this fix soon?
",chrismbeckett,
914,2015-11-24 14:51:52,"According to the documentation the `hostRewrite` and `autoRewrite` options only apply to 3xx responses. But the `Location`-Header is allowed in more than only the 3xx responses (e.g. in `201 Created`).

I don't understand why it is necessary to limit this functionality to specific response codes. Why couldn't just every `Location` header be analyzed and replaced if there is one present in the response?
",tillsc,
914,2016-06-13 16:57:53,"I agree, this is currently biting me. We are implementing an API that tries hard to follow this specification: http://jsonapi.org/format/#crud-creating-responses especially where it says ""The response SHOULD include a Location header identifying the location of the newly created resource.""

However this request returns a 201 status code and the location is not being rewritten.
",gabrielboucher,
914,2016-12-29 20:37:59,related: #845 ,jrnail23,
913,2015-11-24 06:07:52,"I use node-http-proxy to proxy GoogleÔºåthere is a problem with redirection(302), but when I add the Options hostRewrite, the proxy does not work too. When I check the source codeÔºåI find the following code:https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L49

<S_CODE_TOKEN>

why should we make sure the redirected host matches the target host before rewriting? 
For example, if I am from China, when i curl the google `curl www.google.com`, Google will redirect to www.google.com.hk; if i am from  Japan, when I curl the google, Google will redirect to www.google.co.jp.
Because the redirected host doesn't match the target host, the hostRewrite doesn't work. 
And when I remove the following code:

<S_CODE_TOKEN>

the proxy works.
Any idea please?
",yejijie,2015-12-29 18:53:26
913,2015-11-26 20:28:45,"You'll need to set `changeOrigin` to `true`.
",chimurai,2015-12-29 18:53:26
912,2015-11-23 17:48:47,"Added TOC to README and moved some stuff around/added some minor comments. See diff for details.
",donasaur,2015-11-23 18:12:37
912,2015-11-23 18:12:33,"This is great. Thanks @donasaur!
",indexzero,2015-11-23 18:12:37
911,2015-11-23 11:41:48,"Since the `http` module accept to listen for incomming connections on any object with a `fd` file descriptor field like `stdin` I would like to send the request there, but `http-proxy` target requires to be ""a string parseable by the `url` module"" (although I have seen in several place it to be defined as an object). Is there any way to define the `target` as anything other than an url, like a `child_process.stdin` pipe/stream or a domain socket? Since both process (proxy and web server) will run on the same machine there's no need to use an url and will be faster and more secure...
",piranna,2015-11-23 16:54:21
911,2015-11-23 16:54:21,"@piranna this is no longer `http-proxy`ing at that point so it is out of the scope of this module. you are better off using something like [`hyperquest`]('https://github.com/substack/hyperquest) and piping that directly to `stdin` of the child process. I wrote [`strong-parent`](https://github.com/jcrugzz/strong-parent) and [`strong-child`](https://github.com/jcrugzz/strong-child) to deal with situations similar to this.
",jcrugzz,2015-11-23 16:54:21
911,2015-11-23 21:48:21,"> @piranna this is no longer http-proxying at that point so it is out of
> the scope of this module.

Are you talking about the fact of using stdin, isn't? I have been thinking
that maybe this would be a somewhat complicated solution, so I'm going the
web server to start on a random port and notify it to the proxy, so I can
be able to still using http-proxy while being secure since the port is
unpredictable. Do you think is it a good idea?
",piranna,2015-11-23 16:54:21
910,2015-11-21 01:31:43,,donasaur,2015-11-22 19:19:09
910,2015-11-21 01:48:22,"@donasaur could you add some code samples as well? I think that will help a lot of users better understand what they are getting from `proxy-rules`.

_Related:_ we should do a pass at updating the `README.md` sometime in the next few cycles. For starters: a Table of Contents that highlights this feature more prevalently would help a lot of users as well.
",indexzero,2015-11-22 19:19:09
910,2015-11-21 02:25:40,"Sure. For the former, should I do something like list a more readable version of these [tests](https://github.com/donasaur/http-proxy-rules/blob/master/test/index.tests.js#L38-L64) on the `proxy-rules` README?
",donasaur,2015-11-22 19:19:09
910,2015-11-22 04:22:47,"@donasaur yeah that sounds good. 
",indexzero,2015-11-22 19:19:09
910,2015-11-22 17:42:38,"@indexzero Kk, I updated the README with a link to the relevant portion of the test, and made that portion readable with comments and a little name refactoring. See [here](https://github.com/donasaur/http-proxy-rules/commit/16d60201a929d6a3a8ffa3a5ef9f856490b7a272)
",donasaur,2015-11-22 19:19:09
910,2015-11-22 19:19:06,"Looks good :+1:. I agree this readme could use another walk through and have a proper table of contents. Good next steps
",jcrugzz,2015-11-22 19:19:09
909,2015-11-20 09:19:21,"Due to using node-http-proxy in the website, when I refresh a certain page constantly, a error came up as follows:

<S_CODE_TOKEN>

Using http-proxy in my code as follow:

<S_CODE_TOKEN>
",mario56,
909,2015-11-20 16:15:10,"@mario56 please see [here](https://github.com/jcrugzz/proxy-server/blob/master/index.js#L55-L66) for an example of how to prevent this. You cannot assume you can run `res.redirect` for every `error` that occurs because headers from the server you a proxying to may have been sent already.
",jcrugzz,
908,2015-11-16 22:58:33,"Right now, it looks like trying to do a `setHeader` on the passed in `proxyReq` for `POST` requests fails. (see below:)

<S_CODE_TOKEN>

The following error is thrown when the above tries to execute:

<S_CODE_TOKEN>

This seems to work totally fine for `GET` requests, just not `POST` requests. Managed to hack around it at first by wrapping the `.setHeader` call in check to make sure `proxyReq._header` was `null`, but it looks like that totally fails when Firefox tries to perform a `POST` request (the header doesn't get set).

The same thing appears to happen when trying to do `res.setHeader`, as suggested by #819.
",cdl,
908,2015-11-16 23:45:30,"@cdl what node version does this happen in? Could you write a reproducible test case? I want to establish if this is a deterministic issue and if not what conditions FULLY create it. Thanks!
",jcrugzz,
908,2015-11-16 23:57:45,"@jcrugzz Happens in node `4.2.1`. Will see about stubbing out a reproducible test case for it for sure.
",cdl,
908,2015-11-17 00:22:13,"@cdl can you upgrade to `node@4.2.2` there was an `http` bug in `4.2.1` that was resolved in the patch version. See if upgrading resolves this one as well. Let me know either way! Thanks
",jcrugzz,
908,2015-11-17 17:18:41,"@jcrugzz Just tested in `node@4.2.2`, issue still persists. Will write up a gist demonstrating the issue shortly.
",cdl,
908,2015-11-17 17:53:32,"@cdl sounds good, and if you can encapsulate it into a test that you can PR to this project that would get us closer to a solution :). Thanks for the update!
",jcrugzz,
908,2015-11-21 15:51:26,"I had the same issue after upgrading to 1.12.0, downgrading back to 1.11.3 resolved it for me.
",stickystyle,
908,2015-11-21 18:08:30,"@stickystyle could you post a sample of the code that you use for `http-proxy`? This doesn't seem like a bug in `http-proxy` since its part of the `http` semantic so this is very curious as nothing changed around [this code](https://github.com/nodejitsu/node-http-proxy/compare/1.11.3...master). 
",jcrugzz,
908,2015-11-21 22:14:28,"@jcrugzz I've just made a scrubbed gist of the `app.js` and `package.json` that I'm using. It's a simple proxy that serves to layer JWT and caching on top of a RESTful API.
I too did a compare of the tag to master and didn't see anything that stood out, so it makes me think that one of the `http-proxy` dependencies that got updated is triggering it. I'm on `node@4.2.2` as well.

https://gist.github.com/stickystyle/a35fa8bc7461018aad83
",stickystyle,
908,2016-04-08 12:28:48,"For me, this issue has gone away in the most recent v1.13.2
",stickystyle,
907,2015-11-14 13:14:17,"Hi, I need to use this library to proxy to a host with the variable target DEPENDING on the data received in the req, let's suppose that I need to find a tag and basing on this tag route to a host. My code is:

var http = require('http'),
    httpProxy = require('http-proxy'),
    proxy = httpProxy.createProxyServer({});  
        var miTarget='web:CountryName';
        var inicio = '<'+miTarget+'>';
        var fin = '</'+miTarget+'>';    

var server = http.createServer(function(req, res) {
        var miTag = '';
          req.on('data', function (data) { 
      miTag = data.toString().split(inicio)[1].split(fin)[0];
      });

<S_CODE_TOKEN>

});

console.log(""listening on port 80"")
server.listen(80);

This code is not working... Can anyone help me?
The most important for me is to execute thie proxy.web() AFTER the data is received miTag in the req...

Thanks in advance!

Best
",macscripter,
907,2015-11-15 12:08:46,"When in req.on('data') or req.on('end') I call proxy.web() I never receive any response but when I execute proxy.web OUT of the req.on('data') or req.on('end') everything is working well but as the req.on('data') is async I will not get the miTag before to execute proxy.web......

So I really need to put the proxy.web to be executed withing the req.on('data') or req.on('end') since depending on the miTag variable received from the data I will proxy to a different server. How can I sort out this problem?

Thank you!
",macscripter,
907,2016-01-17 20:57:30,"I am looking for a similar solution. I have found that if I put the proxy.web() into the req.on('data'), the following error occurs:

<S_CODE_TOKEN>
",ChrisBrandhorst,
906,2015-11-13 17:22:41,"I am using the following code as my proxy script:

<S_CODE_TOKEN>

It works pretty well, but I get the following error because I use websockets on `'http://localhost:8080` and `'http://localhost:4242`. 

<S_CODE_TOKEN>

Unfortunately I don't know how to fix it and the error doesn't appear if I add the port directly to the url.
Thanks for your support!
",Wikunia,2015-11-13 17:48:02
906,2015-11-13 17:25:57,"@Wikunia for proxying webscokets you also need to listen to the `upgrade` event on your `httpServer` and call `proxy.ws`. The documentation has an outline for how this can be done.
",jcrugzz,2015-11-13 17:48:02
906,2015-11-13 17:33:10,"Thanks for the quick response. I added these lines

<S_CODE_TOKEN>

and changed 

<S_CODE_TOKEN>

to 

<S_CODE_TOKEN>

but unfortunately it doesn't work.
",Wikunia,2015-11-13 17:48:02
906,2015-11-13 17:35:14,"@Wikunia you also need to add the `target` in this case as well, similar to what you do for the `proxy.web`
",jcrugzz,2015-11-13 17:48:02
906,2015-11-13 17:43:29,"I'm sorry. Don't know where to configure the `ws targets` :/
",Wikunia,2015-11-13 17:48:02
906,2015-11-13 17:48:02,"Ah okay now everything makes sense.
I have to add the following lines inside the upgrade function

<S_CODE_TOKEN>

Thanks @jcrugzz 
",Wikunia,2015-11-13 17:48:02
905,2015-11-12 19:42:22,"I have the following scenario: The target HTTP server is only reachable via SOCKS. So is there an easy way to hook a SOCKS client in-between node-http-proxy and the target HTTP server?

Kind regards.
",zorro765,
905,2015-11-12 20:08:02,"@zorro765 this would be accomplished by using an http/https Agent. I haven't tried it but try using [`node-proxy-agent`](https://github.com/TooTallNate/node-proxy-agent). I'd love to have a test using this agent to validate.
",jcrugzz,
904,2015-11-05 08:51:54,"npm v3 tries to dedupe the dependencies by default, and keeping dependencies up-to-date helps better deduplication.

And [`requires-port`](https://github.com/unshiftio/requires-port) v1.0.0 includes a small but important fix. https://github.com/unshiftio/requires-port/pull/2
",shinnn,2015-11-06 21:20:22
903,2015-10-30 21:14:42,"Adds example from #727 
",jcrugzz,2015-10-30 21:16:10
903,2015-10-30 21:15:07,"+1
",donasaur,2015-10-30 21:16:10
902,2015-10-30 21:09:29,"Adds an example from #727 
",jcrugzz,2015-10-30 21:14:21
901,2015-10-28 19:53:36,"This adds two tests that send payloads below and at the threshold for continuation frames. Using node 0.12.7 both tests pass. Using node 4.1.2 the test below the threshold passes but the other fails. Prompted by #881 .
",glortho,2015-11-09 22:53:05
901,2015-10-30 14:13:25,"Note: This issue appears to have been fixed in node v5. See http fixes section here: http://nodejs.org/en/blog/release/v5.0.0/
",glortho,2015-11-09 22:53:05
900,2015-10-26 13:39:15,"If, after being proxied to, my backend express server does: `res.status(403).send('Not logged in')`, an error event is not fired on the front facing server, from which the proxy originates. 

I'm listening for error events on the front facing server like this:

<S_CODE_TOKEN>

Why is no error event fired? Am I misunderstanding what qualifies as an error response from the proxy destination?
",super-cache-money,2015-10-28 18:13:23
900,2015-10-28 18:13:22,"@super-cache-money an error event wont fire because the backend express server was able to respond correctly. An error only happens when we are unable to proxy to the backend server.
",jcrugzz,2015-10-28 18:13:23
899,2015-10-25 05:47:06,"When using  proxy object to access both HTTP and HTTPS, HTTP works fine until an HTTPS request is sent through the object, at which point only HTTPS works and HTTP hangs with error: _Protocol ""http"" not supported.  Expected ""https""._  This behavior is confusing and costly to debug, and likely is caused by a state being set within http-proxy that cannot be reversed once an HTTPS request is initiated.

<S_CODE_TOKEN>
",spiritway,
899,2017-01-04 11:19:34,"I have the same issue here, seems not well explained in the docs. 

",davesnx,
898,2015-10-23 06:36:51,"I have a simple connect app setup with a proxy that points to a remote location (off server), and when I refresh the page a bunch of times really fast, I get this error: `{ [Error: socket hang up] code: 'ECONNRESET' }`. If it isn't caught with `proxy.on('error')`, then the entire app will crash. I know this is a weird use case, and it may not be a bug at all. If so, I would appreciate it if someone could help me understand this error. According to google, the error means ""the other side of the TCP conversation abruptly closed its end of the connection"". I'm not sure how this relates to the proxy. I just want to make sure it won't show up if my proxy starts getting thousands of requests per second. Here is the code for my sample app:

<S_CODE_TOKEN>
",jsonmaur,
898,2015-10-23 19:13:13,"@jdmaurer yea this is something id like to fix. The reason this happens in THIS specific case is because we don't disambiguate ""client-side"" request errors from ""proxy"" request errors. Errors that happen on the request that we receive as the proxy should be ignored because its something we have no control over. We cant even reply to it. This is a bug that needs to be fixed
",jcrugzz,
898,2015-10-29 20:09:25,"I'm seeing this too.  @jdmaurer why do you say this is a weird use-case?  I have the same use-case, seems like the ""meat and potatoes"" of what a proxy would do?

@jcrugzz is this likely to be fixed soon?  Thanks!
",philcockfield,
898,2015-10-29 21:45:23,"@philcockfield I said it was a weird use-case cause I thought the error may be tied to a single client refreshing over and over causing the connection to not properly close--not because of many clients requesting at once. That seems to be the case.
",jsonmaur,
898,2015-10-30 00:26:50,":+1: 
",philcockfield,
898,2015-11-20 09:24:43,"+1
",mario56,
898,2016-01-08 14:59:31,"+1
",lemonCMS,
898,2016-02-23 16:08:16,"+1
",gabadi,
898,2016-08-04 02:44:09,"+1
",bubenshchykov,
898,2016-08-04 18:55:59,"@bubenshchykov can we confirm this still happens with `1.14.0`?
",jcrugzz,
898,2016-08-05 04:30:47,"[Error: socket hang up] code: 'ECONNRESET' - yes, it's on 1.14.0
I think I reproduced it by setting a low proxyTimeout (like 10ms) - just for a test
I will add a code snippet or spec  later today :)
",bubenshchykov,
898,2016-08-05 12:49:42,"@jcrugzz this original issue (when client interrupts a request, eg by refreshing the page) is not reproducible on latest http-proxy - I think you can close this one! :)

PS I'm receiving {[Error: socket hang up] code: 'ECONNRESET' } when request times out - different story. Easy to reproduce by setting low proxyTimeout value. Dunno, is it by design? I would prefer some different error message for that, but that's not a big deal :)
",bubenshchykov,
897,2015-10-22 13:57:37,,lbrucher,2015-10-22 23:26:02
897,2015-10-22 14:29:54,"@lbrucher Looks good, will get it in a release later today :+1: 
",jcrugzz,2015-10-22 23:26:02
897,2015-10-22 16:39:42,"fixed, thanks for the checks!
",lbrucher,2015-10-22 23:26:02
897,2015-10-26 11:53:37,"=\

I suppose: https://github.com/nodejitsu/node-http-proxy/pull/883 can be closed along with https://github.com/nodejitsu/node-http-proxy/issues/882
",andrewpmartinez,2015-10-22 23:26:02
896,2015-10-22 13:55:39,"I see the proxyReq event for web connections but none for ws...
Could be handy in order to add headers for instance, the same way it is for regular web requests.
",lbrucher,2015-10-28 18:16:11
896,2015-10-28 18:16:11,"Fixed in latest release
",jcrugzz,2015-10-28 18:16:11
895,2015-10-22 02:04:10,"I am struggling to get http-proxy setup to forward https requests to http, here's what I have and it does not appear to work:

<S_CODE_TOKEN>

Any idea on what I am doing wrong ?
",diginfo,
894,2015-10-21 04:18:32,"In the example, there has a lot of `proxy.web(req, res, { target: 'http://host:port' });`

If the `req.url` is ""http://github.com/nodejitsu/node-http-proxy"", the target must be ""http://github.com/""?

Why `target` can not be empty, and ""http-proxy"" extract the `target` from `req.url`?
",sisyphsu,2016-02-27 09:26:51
894,2015-10-21 04:25:37,"By the way, the code blow could extract `target` from `req.url`:

<S_CODE_TOKEN>
",sisyphsu,2016-02-27 09:26:51
894,2015-11-27 22:34:01,"I think you are misunderstanding the purpose of this module. This module is meant to take a request and FORWARD it to another server. You must specify the URL to forward it to. In your example above, you would be forwarding the request to your own server, creating an infinite loop (not to mention that you [cannot get the protocol or the target from req.url](https://nodejs.org/api/http.html#http_message_url)). 
",codebling,2016-02-27 09:26:51
893,2015-10-18 20:09:04,"Previously, if target='http://localhost:9060/appEndpoint' and req.url='', the url the proxied request will hit is: 'http://localhost:9060/appEndpoint**/**'

With the change, if target='http://localhost:9060/appEndpoint' and req.url='', the url the proxied request will hit is: 'http://localhost:9060/appEndpoint'

This is helpful if the app endpoint is to a router that is sensitive to the trailing slash (e.g., a Rails router)
",donasaur,2015-10-18 21:15:53
893,2015-10-18 21:15:48,"+1
",indexzero,2015-10-18 21:15:53
892,2015-10-18 08:12:34,"Recently ran into a case where I had to upgrade the `http-proxy` version for an app, and that app was using a proxy table.

I'm not sure how many users are still using the 0.x.x version of `http-proxy`, but the added link (found from one of the GH issues) may encourage them to switch over to 1.x.x if they were using the old version due to its proxy table support and the activation energy to upgrade was too high.

Edit: There was some work involved in creating a proxy table to map paths to urls, disregarding the source's hostname, so I'm not sure if this would warrant creating a module (w/ source hostname support). Here's the relevant code if you also want to add it to the README:

<S_CODE_TOKEN>
",donasaur,2015-10-18 14:45:45
892,2015-10-18 14:45:30,"@donasaur yea a its been on my list to make a module to replicate some of the features that were lost in the `1.0.0` simplication so if you decide to write one, definitely send a PR to add it to the README. :+1:.

Thanks for the reference here!
",jcrugzz,2015-10-18 14:45:45
891,2015-10-16 22:04:48,"I'm trying to run a proxy server on port 8081 that can re-route http traffic and socket.io traffic.  I'm using express server because I use passport for authentication.

I can get http-proxy to route all http traffic on 8081 and all websocket traffic directed to 8082, but I cant figure out how to handle both protocols on one port.  Ideas?

This first technique just causes client-side xhr requests to hit the server at a rate of about 3 requests per second.

<S_CODE_TOKEN>

This second method catches the websocket request, but obviously doesn't get upgraded.

<S_CODE_TOKEN>

![ws](https://cloud.githubusercontent.com/assets/1218940/10554285/f355ba76-7416-11e5-8833-808c5d396f40.png)

I've tried a 3rd method using .ws method but no luck there either.

<S_CODE_TOKEN>
",that1guy,
891,2015-11-13 02:06:32,"+1
",andreabadesso,
891,2015-12-19 14:48:01,"@that1guy Did you see the example in the readme, that listens on ""upgrade""?
",kevinsimper,
891,2016-01-12 02:15:37,"did this get resolved? I'm having similar issues. Upgrade didn't catch the /socket.io request and thus was never reached.
",fullstackwebdev,
891,2016-01-14 13:35:23,"I was also having similar issues proxying socket.io connections, which I've now solved! Heres an example that might help: https://github.com/MethodGrab/socketio-proxy-boilerplate.
",MethodGrab,
890,2015-10-14 09:42:07,"Hi, I am trying to proxy a WebSocket to an endpoint which requires digest authentication.

<S_CODE_TOKEN>

The first attempt gives a 401 (the digest challenge) which is never returned to the browser. How can I hook in / configure http-proxy to pass the 401 back to the browser when using websockets?
",oskbor,
889,2015-10-03 15:06:41,"The example 

<S_CODE_TOKEN>

from the readme doesn't seem to work. It just uses the header from the req (or leaves it out if the request header was empty).
",caske33,
889,2015-10-30 23:05:55,"Hi there,

It works with my code. There should be something else. I'm using it like..

<S_CODE_TOKEN>
",tanaydin,
889,2015-10-31 14:00:41,"does this also work with custom headers? And should it be all lower cases? Or should the example in the [README](https://github.com/nodejitsu/node-http-proxy/blob/master/README.md#setup-a-stand-alone-proxy-server-with-proxy-request-header-re-writing) work like it's explained there?
",caske33,
889,2015-10-31 19:27:08,"In node, headers are automatically lowercased.
https://nodejs.org/api/http.html#http_http

On Sat, Oct 31, 2015 at 10:00 AM, Jens Claes notifications@github.com
wrote:

> does this also work with custom headers? And should it be all lower cases?
> Or should the example in the README
> https://github.com/nodejitsu/node-http-proxy/blob/master/README.md#setup-a-stand-alone-proxy-server-with-proxy-request-header-re-writing
> work like it's explained there?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/nodejitsu/node-http-proxy/issues/889#issuecomment-152738582
> .

## 

Jarrett Cruger
Software Engineer at GoDaddy https://www.godaddy.com/ Inc.
",jcrugzz,
889,2015-10-31 19:58:18,"But would it work if you override headers with caps, as is done in the readme and in the description of my issue?
",caske33,
889,2015-12-07 07:32:26,"Got to the same point. Blindly trusted README
",uicoded,
888,2015-09-30 08:28:35,"Would be nice if you could have something similar to nginx's ""proxy_cache_use_stale"". 
",michaellujan,
887,2015-09-28 11:27:39,"Hi,

I need to proxy requests from `/api` to the root of other site: `http://test.com`:

`/api/users` -> `http://test.com/users`
`/api/users/1` -> `http://test.com/users/1`

But all my requests lead to `http://test.com/api/*`
How to ignore `/api` prefix but not to ignore other path?
When I use `ignorePath` settings all my requests lead to `http://test.com`.

Config:

<S_CODE_TOKEN>
",borNfreee,2015-12-03 07:03:44
887,2015-11-26 02:18:13,":+1: Just ran into this too.

@borNfreee Find a suitable workaround since you posted this?
",joeyespo,2015-12-03 07:03:44
887,2015-11-26 02:27:00,"@borNfreee you may need use http-proxy with middleware like express.js or connect.js
",sequoiar,2015-12-03 07:03:44
887,2015-12-02 20:42:27,"@borNfreee's question has been answered in: https://github.com/chimurai/http-proxy-middleware/issues/31#issuecomment-143770591
",chimurai,2015-12-03 07:03:44
887,2015-12-03 07:03:44,"Thanks @chimurai You are right
",borNfreee,2015-12-03 07:03:44
887,2016-01-22 09:03:03,"I have the same problem, but I can't use the @chimurai's solution because I don't use the middleware. I use the [webpack dev server](https://webpack.github.io/docs/webpack-dev-server.html).

Would this be possible with just `node-http-proxy` options? Or do I need to request the feature from webpack guys?
",mik01aj,2015-12-03 07:03:44
887,2016-01-22 09:34:26,"@mik01aj 
`node-http-proxy` doesn't offer path rewrite through options;
It's some sugar added by `http-proxy-middleware`.

Good news for you perhaps, HPM is now being used by `webpack-dev-server`.
https://github.com/webpack/webpack-dev-server/pull/359

It is not push to npm yet, so you'll have to wait a bit...
`pathRewrite` option will be available there too (soon).
",chimurai,2015-12-03 07:03:44
887,2016-01-22 09:39:23,"That's some very good news, thanks!
",mik01aj,2015-12-03 07:03:44
886,2015-09-24 15:56:52,"Should `X-Forwarded-Host` be added when `xfwd` is set to true?

Current x-forwarded-\* fields:
- x-forwarded-for
- x-forwarded-port
- x-forwarded-proto

`x-forwarded-port` is probably redundant as `x-forwarded-host` includes the port number.
See [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)

Implementation of [xfwd code](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/ws-incoming.js#L54-L69)
",chimurai,
885,2015-09-23 20:10:22,"When I receive a response from a target, what's the best way to send another request to it?
Basically I'd like to cancel a response, send another request from the proxy, and return a response to it to the client.

Is there any way to do that currently?
",nderkach,
885,2015-11-22 11:31:52,"Hi,
I have the same question. Did anyone sort out this issue?

Regards
",macscripter,
885,2016-01-18 08:45:47,"+1
",AAudusseau,
885,2016-07-25 11:55:15,"+1
",ixrock,
884,2015-09-20 18:56:56,"I keep getting socket hangup error on a meteor app.
Here's the error I keep getting 

<S_CODE_TOKEN>
",morrismukiri,2015-10-15 01:04:51
884,2015-10-14 23:17:36,"Having the same issue, using it on a meteor server that makes use of this package. Any suggestions ?
",sylido,2015-10-15 01:04:51
884,2015-10-15 01:04:38,"@morrismukiri @sylido the meteor package using this is not handling errros. They must listen on the `error` event or use the callback api to handle errors. See [here](https://github.com/jcrugzz/proxy-server/blob/master/index.js#L29-L29) for an example.
",jcrugzz,2015-10-15 01:04:51
884,2015-10-15 01:40:53,"Thanks jcruggz I found the solution after searching here, but that just handles the error right ? Is that enough or is there something else that must be done to prevent the actual socket hang up from happening.
",sylido,2015-10-15 01:04:51
884,2015-10-15 01:50:19,"@sylido socket hangup is something node emits internally when a socket is no longer usable or something happens. Could be a symptom of a single server handling too much but its hard to say. Best you can do when it happens is just tell the caller it errored
",jcrugzz,2015-10-15 01:04:51
884,2016-04-06 11:09:29,"We are having the same issue and can recreate very easily when running latency tests. This is caused when the requesting client (browser) is no longer available to receive the response.

Steps to recreate.
1. Create a proxy to another endpoint that has a latency and longer running process on it. (3 sec timeout in the response works)
2. Call the proxy from the webpage and refresh before you get a response back, the ""socket hang up"" will happen every time.

In our situation we are only using this proxy during local development and using nginx for production. 
",jasonfutch,2015-10-15 01:04:51
883,2015-09-18 18:17:17,"Adds a proxyWsReq event that can be used to modify the outgoing
websocket handshake.
",andrewpmartinez,2015-11-05 09:42:51
883,2015-09-18 20:32:21,"Thank you for your contribution. I am +1 on this once the minor style things are addressed.
",indexzero,2015-11-05 09:42:51
883,2015-09-19 08:10:47,"Style issues addressed.

The last change require changing the previous 'var httpProxy' to 'var wsPasses'. Name chosen after seeing the 'var webPasses' for the similar include in the web tests.
",andrewpmartinez,2015-11-05 09:42:51
883,2015-09-22 14:09:51,"If there is anything else you need done before this is accepted; let me know.
",andrewpmartinez,2015-11-05 09:42:51
883,2015-10-02 18:24:49,"When is the next release scheduled?
",andrewpmartinez,2015-11-05 09:42:51
883,2015-11-05 04:54:45,"@donasaur @jcrugzz thoughts on this?
",indexzero,2015-11-05 09:42:51
883,2015-11-05 06:37:45,"stylistically it looks good. i'm not familiar with this websocket handshake that takes place

the test does show that its able to listen to that proxyres event and add the header tho, and it looks like the destination/source is able to receive that header
",donasaur,2015-11-05 09:42:51
883,2015-11-05 06:44:51,"@donasaur it's actually not about the Websocket handshake itself. It is mirroring similar `proxyRes` functionality which I am fine with. See https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L147

@jcrugzz thoughts? 
",indexzero,2015-11-05 09:42:51
883,2015-11-05 09:37:14,"ah ok @indexzero , actually it looks like jarrett already merged in a similar PR already:
https://github.com/nodejitsu/node-http-proxy/pull/897/files

can you double check?
",donasaur,2015-11-05 09:42:51
883,2015-11-05 09:42:51,"@donasaur excellent. Then this is a duplicate of #897. Closing :100: 
",indexzero,2015-11-05 09:42:51
882,2015-09-18 17:16:51,"I have been working with web sockets in node-http-proxy and I didn't see any path that would allow one to modify the HTTP headers of the proxy request used to conduct the web socket handshake.

The web socket protocol allows the server to fail the connection and make application level decisions based on any other part(s) of the HTTP request (i.e. pre-handshake-response authentication that is not supplied from the incoming request in my case).

It would seem that emitting an event named 'proxyWsReq' with the proxyReq as arguments would be a valid use case.  This could be done right before proxyReq.end() is called in the ws-incoming.js passes.
",andrewpmartinez,2015-11-05 09:43:06
882,2015-11-05 09:43:06,"Fixed in #897 
",indexzero,2015-11-05 09:43:06
881,2015-09-17 19:43:12,"After upgrade to nodejs 4.0.0 I see that the proxy is not forwarding WS trafict that contains continuation frames, tested with nodejs 4.0.0 and 4.1.0 and see the same behavior with both. Everything works fine with node 0.12.7.

Is there any incompatibility issues with node >= 4.0?
",pepone,
881,2015-10-28 17:40:38,"We're seeing the same issue. Works fine on 0.12.7 but not in iojs or node 4.x.
",glortho,
881,2015-10-28 18:02:50,"@pepone @jedverity seems like it. Could you provide a complete console output of what you're seeing? Is there a reproducible test case that you've found? This will help us narrow down the problem.
",indexzero,
881,2015-10-28 18:12:09,"yea this would be super helpful in troubleshooting. I know things related to `http` changed in `iojs` and `node@4` so this could make sense. 
",jcrugzz,
881,2015-10-28 18:14:10,"Thanks @indexzero @jcrugzz - we're working on putting together a reproducible test case for you right now. Stay tuned.
",glortho,
881,2015-10-28 18:39:31,"@jedverity awesome :). A failing test PR is my favorite thing
",jcrugzz,
881,2015-10-28 19:22:31,"@jcrugzz I'll see what I can do about a failing test. In the meantime, here is a reproducible set-up: https://github.com/jedverity/http-proxy-test
",glortho,
881,2015-10-28 19:40:53,"Think I have a (kludgy) test for you @jcrugzz @indexzero . Coming in 5 mins.
",glortho,
881,2015-10-30 14:14:19,"@indexzero @jcrugzz @pepone I've confirmed this is fixed in node v5. See http fixes section here: http://nodejs.org/en/blog/release/v5.0.0/
",glortho,
881,2015-10-30 17:00:01,"@jedverity hmm well we should see if whatever fix can be backported if it is not a breaking change. Have you tried it in `4.2.1`? That is the LTS release so we should get this fixed in that release
",jcrugzz,
881,2015-10-30 17:03:48,"@jcrugzz I did try it in 4.2.1 and no dice. Same results as other 4.x versions. I assumed this was the fix but haven't evaluated closely: https://github.com/nodejs/node/pull/3342
",glortho,
881,2015-10-30 17:54:54,"@jedverity i think you might be right, looks like its on target for `4.2.2` if you are correct. See if you can test the `4.2.2` release candidate for confirmation. Either way your tests are still good :). Will add them anyway
",jcrugzz,
881,2015-11-05 18:35:16,"@jcrugzz Confirmed 4.2.2 works
",glortho,
880,2015-09-17 15:24:40,"I am trying to build an end-point in my node app allowing the client running in the browser to proxy an arbitrary request. The both my Node.js server and the endpoint it is proxying to are HTTPS servers.

I am using 

<S_CODE_TOKEN>

where sslOptions point to the public and private key.

At the point of proxying the request I call

<S_CODE_TOKEN>

The problem is that the target server responds with an error stating the it did not receive the certificates in the proxied request. Do I need to pass certificates in web() function invocation? Why would certificates not be sent to the target?
",msmolyak,
880,2016-07-28 17:34:15,"I am encountering the exact same issue. I have tried passing the cert from the request socket into the options parameter for the web

`{ target: url, cert: request.socket.getPeerCertificate() }` 

However, the server the request is being proxied to is complaining that there was no certificate present in the request. 
",predhme,
879,2015-09-16 01:16:50,"Whatever I try to do I get errors trying to install this module, likely because I'm a noob with node.

However, when I attempt to run node install http-proxy --save after downloading the zip file and extracting contents to a project folder I receive the following error:

node refusing to install http-proxy as a dependency of itself.

When I start to mess with package.json I get all sorts of issues when I run npm install again related to installing dependencies, specifically ws.

Any assistance is greatly appreciated.

Regards,

Jeff G
",goldbergjeffrey,2015-09-16 01:32:30
878,2015-09-15 15:56:17,"Hi,

Last couple of days I've been trying to implement (with node-http-proxy) a proxy for a simple chat app with http and websocket.

I noticed a lot of TCP retransmits packets generated by the proxy server.

![capture](https://cloud.githubusercontent.com/assets/4066470/9881876/2c7dcc7e-5bd2-11e5-9a54-d8cd3c68c48b.PNG)

I've searched in the code and it seems that there is a problem with the setKeepAlive call in lib/http-proxy/common.js

<S_CODE_TOKEN>

The current line is enabling keepalive with zero millisecond delay which can be disastrous regarding performance.

I've commented setKeepAlive line and I have no more TCP reteransmits..

Is there a reason for setting TCP keepalive to 0 ms delay ?

It may be better to leave this setting to default value (ie: setKeepAlive(false,0) ) ?

Best
",kristofen,
878,2015-11-16 16:10:08,"Hi,

I have the same problem on Windows 7 Ultimate Service Pack 1

under Linux and Windows 10 no problem !!!

Best
",pascalStm,
877,2015-09-10 06:58:37,"I use this module to implement a websocket proxy server. Normally after the websocket is established, the data flow is ""client -> proxy server -> target server"". And there will be two connections hold in proxy server, one is for client and another for target server.
However, when the websocket is not normally established, say the target server rejects the upgrade request with a 404, the connection between the proxy server and the client is closed. While the connection between the proxy server and target server is still hold even after the client process exits.
This is very dangerous!
I have this patch to fix this, but I'm not sure if it is reasonable. Please help me to check it.
file: lib/http-proxy/passes/ws-incoming.js
line: 94
use:
if (!res.upgrade) {socket.end();this.abort();}
instead of:
if (!res.upgrade) socket.end();
",poxzlm,
876,2015-09-09 23:56:56,"Time to time I'm getting this error, no clear steps to reproduce:

<S_CODE_TOKEN>
",ro31337,
876,2015-09-09 23:59:28,"For temp workaround I modified writeHeaders function in web-outgoing.js to

<S_CODE_TOKEN>
",ro31337,
876,2015-09-10 00:19:57,"@ro31337 interesting, im curious as to what header caused this type of error? Could you `console.dir(proxyRes.headers)` for me?
",jcrugzz,
876,2015-09-10 18:13:48,"@jcrugzz I'll try, but it's hard to catch. I'll modify my code to catch that, and we'll wait
",ro31337,
876,2015-10-23 19:25:38,"Once I updated to node 4, I started to look at this error. It wasn't there before. 
",VarunBatraIT,
876,2015-10-23 20:20:14,"@VarunBatraIT will start testing on `node 4`, I'd love to have a PR for a failing test case though if one doesn't exist already. Thanks for the heads up
",jcrugzz,
875,2015-09-06 16:45:10,"Hello :-)

I have the problem, that all HTTP-Requests are loosing their PATH

`curl http://localhost:PROXYPORT/PATH`

On the target server all Requests are going to `/` instead of `/PATH`
What am I doing wrong?

<S_CODE_TOKEN>
",dreampulse,
874,2015-08-29 16:26:44,"After the fix, the benchmark can finish with proper socket errors.

‚ûú  node-http-proxy git:(master) ‚úó wrk -c 1000 -d1m -t 8 http://127.0.0.1:8000
Running 1m test @ http://127.0.0.1:8000
  8 threads and 1000 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     1.05s   489.87ms   2.00s    61.01%
    Req/Sec    56.42     49.24   320.00     80.89%
  14983 requests in 1.00m, 1.79MB read
  Socket errors: connect 0, read 1692, write 0, timeout 365
Requests/sec:    249.32
Transfer/sec:     30.43KB
",tyrchen,
873,2015-08-29 16:24:19,"When I use 100 connections with 8 threads:

‚ûú  node-http-proxy git:(master) ‚úó wrk -c 100 -d1m -t 8 http://127.0.0.1:8000

The proxy server will quit after a while:

‚ûú  node-http-proxy git:(master) ‚úó node benchmark/scripts/proxy.js
/Users/tchen/projects/startup/study/node-http-proxy/lib/http-proxy/index.js:119
    throw err;
          ^
Error: read ECONNRESET
    at exports._errnoException (util.js:746:11)
    at TCP.onread (net.js:559:26)

Probably the proxy.js shall silently drop the errors to let the benchmark finish.
",tyrchen,
873,2015-12-25 01:43:27,"I hit the same issue when benchmarking http-proxy. Does anyone know if the same will happen in a real life production environment with a high request volume or if this issue is tied to the fact that the connections are created from the same client?
I tested with nginx and the npm module 'loadbalancer', no problem there.

@tyrchen @jcrugzz
",kar1m,
872,2015-08-29 04:51:46,"I want to request data from port 8080, It returns ""XMLHttpRequest...Access-Control-Allow-Origin"".
So I use node-http-proxy on port 8000 whick swithc to 8080, but I meet the same problem of cors on 8000.
This is my code, Looking forward to geting help from you, thanks~

<S_CODE_TOKEN>
",lgzhang,
872,2015-08-29 09:27:28,"You don't need http-proxy for CORS. CORS is applied on requests from browsers.

If you node server must accepts AJAX queries you need to prepare it adding the ""Access"" to the response headers. There are some modules for express/connext that does it: https://github.com/expressjs/cors

Cheers.
",acanimal,
872,2016-08-25 21:45:24,"Having the same problem.

Having a proxy is necessary for the core of my application which proxies an external site. However certain resources (especially fonts) are always blocked by ACAO. I'm not sure how to compensate for this using node-http-proxy but I know it can be done.

For example using the proxy that ships with browser-sync, proxies external sites perfectly fine with no ACAO problems.
",oraneedwards,
872,2017-02-02 19:25:16,"For those who stumble upon this ticket, here's how I solved it:

<S_CODE_TOKEN>",melalj,
871,2015-08-27 09:58:12,"Set-Cookie headers are parsed into single header with cookies in array.
This messes up the Set-Cookie headers, because browser receives multiple Set-Cookie headers as single with cookies separted with comma.
",ArGGu,2015-08-30 21:28:56
871,2015-08-27 09:59:32,"Would need a test to verify this is fixing a bug.
",indexzero,2015-08-30 21:28:56
871,2015-08-27 10:06:13,"You mean a test application to verify that it fixes the bug or what?
",ArGGu,2015-08-30 21:28:56
871,2015-08-27 10:08:36,"A [mocha-based test](https://github.com/nodejitsu/node-http-proxy/blob/master/test/lib-http-proxy-passes-web-incoming-test.js#L61-L84) which assets that the correct headers are written. Based on your comment the test would assert that a single `set-cookie` header is returned and not multiple, correct?
",indexzero,2015-08-30 21:28:56
871,2015-08-27 10:15:22,"Yes browser would receive single set-cookie header with cookies separated with comma.
Because the set-cookie headers are parsed into single header with cookies in array.

There is no problem when server sends a single cookie, but this won't work when server sends multiple cookies.

So if raw headers are used instead parsed, then browser will received all set-cookie headers sent by the server.

This is the first time I have heard of mocha, I will check it out on the weekend.
",ArGGu,2015-08-30 21:28:56
871,2015-08-27 10:18:56,"Alright. Thanks. The other tests in the code should point you in the right direction.
",indexzero,2015-08-30 21:28:56
871,2015-08-30 17:03:27,"I added test to lib-http-proxy-test.js.
But I don't understand why the rawHeaders is undefined  when Travis Ci, runs the test.
",ArGGu,2015-08-30 21:28:56
871,2015-08-30 17:13:33,"http.IncomingMessage in node 0.10 does not have rawHeaders, so it won't run the test with it.
",ArGGu,2015-08-30 21:28:56
871,2015-08-30 17:27:39,"If it needs to work with node 0.10, then I guess the best solution would be to loop the headers and generate array with checking if the header name is set-cookie.

And if it is then looping the set-cookie array and populate the new array with all set-cookie headers.
",ArGGu,2015-08-30 21:28:56
871,2015-08-30 18:25:05,"Yes this needs to work with `0.10.x` still
",jcrugzz,2015-08-30 21:28:56
871,2015-08-30 19:35:54,"I did quick fix and accidently used Object.keys().map instead for in loop.

But yeah it now loops the parsed headers and checks if the header value is array.

If it is, it loops the array and pushes all the header values with the header name to writeHead array.
If not then just pushes the header name with header value.
",ArGGu,2015-08-30 21:28:56
871,2015-08-30 21:28:54,"@ArGGu cherry-picked :). Thanks!
",jcrugzz,2015-08-30 21:28:56
870,2015-08-24 19:24:09,"Punctuation
",justsml,2015-08-24 19:38:27
869,2015-08-24 19:14:20,"Apologies if this isn't the right place, I've surfed the issue list and  have adapted some stuff I read here: https://gist.github.com/richardkazuomiller/9087254 to my code example here: https://gist.github.com/rlemon/20766c7fde298a26d3c3

running 
node ws.js
node webserver.js
node app.js

then navigating to localhost I can see that the upgrade event is never sent. It falls back to long-polling always.

Is there something staring me in the face that I am missing? Is this a ignorance issue on my part? socket.io?
Again, apologies if this is the wrong place for this type of support.
",rlemon,2015-08-24 20:48:23
869,2015-08-24 20:48:23,"Disregard, I was doing something silly. 
",rlemon,2015-08-24 20:48:23
868,2015-08-24 06:59:45,"In my use case, I want to proxy request to forward_host only after i get a successful response (200) from the target_host.

I am wondering if there is a easy way to achieve this functionality.

Any pointers would be helpful.

var server = http.createServer(function(req, res) {
  proxy.web(req, res, {
    target:  {
               host: target_host,
               port: target_port
             },
    forward: {
               host: forward_host,
               port: forward_port
             }
  });
",vggg,
867,2015-08-21 15:49:13,"In this portion of the code : https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L148...L157, there is no verification if the headers of the response have already been sent to the client.
It happens in my case when an error is fired and after I return an error 500 to the client.

Fix :
This portion of code can be wrapped by `if(!res.finished){}` to prevent the exception `Uncaught Error: Can't set headers after they are sent.`.
",abarre,
867,2015-08-23 17:54:09,"@abarre could you show me the full code where this happens? This shouldn't happen to you as the consumer but I'm guessing you are writing your own headers in a non error case?
",jcrugzz,
867,2015-08-23 20:18:30,"My error handler is something similar to the example below : 

<S_CODE_TOKEN>

A response is returned to the client in the error handler.
",abarre,
867,2015-08-24 05:40:24,"@abarre so this happens in a case where both `response` and `error` events get emit? Does it throw specifically on `res.writeHead(globals.TIMEOUT_ERROR, ""socket hang up);`?
",jcrugzz,
867,2015-08-24 05:41:32,"If so your fix seems like it would be correct. I just want to establish why this is happening exactly :).
",jcrugzz,
867,2015-08-24 07:32:59,"Hum, I don't remember well, I think that an `error` event is also emitted when we call the proxyReq.abort method.
",abarre,
867,2015-08-25 22:51:43,"I am also experiencing very similar issue, but on lines 112-115.
In my case I am trying to remove cookie header from the request, before submitting the request to the proxyed server. The code is working with GET requests, but not with POST. According to ""http"" manual, this is expected as with GET it is not usual that headers are sent before end() function is called, while with POST requests, headers are sent as soon as the first data are sent.
Moreover my understanding is that the listener code and the rest of the code are executed asynchronously, so there is no success guarantee with GET method as well, but it is just much more probable to succeed. Am I right?

In my specific case headers are sent immediately during http.request creation. In this case it would be more useful to add an event (hopefully a synchronous one) at the end of common.setupOutgoing(), so that it would be possible to modify options instead of the request.
",giuliopaci,
867,2016-07-25 07:35:50,"having smth similar
the difference is that my host app is doing nothing, no additional handling
and error comes from proxied app

<S_CODE_TOKEN>

<S_CODE_TOKEN>

It started to happen only http-proxy introduced. Would be nice to have web-outgoing.js functions wrapped in try catches with some error events emitted
",bubenshchykov,
867,2016-11-17 00:31:30,"I forked this project into https://github.com/HBOCodeLabs/node-http-proxy and created a synchronous callback hook like @giuliopaci described.  Here is the PR:  https://github.com/nodejitsu/node-http-proxy/issues/1091
",rick-kilgore,
866,2015-08-20 01:27:15,"What is the point of the 'secure' if the module only works (in https) when it is set to false ??

In an https.request, when we set rejectUnauthorized to true we also have to set the ca (certificate authority file), otherwise the certificate will fail validating. But there is no way to set https.request ca option in http-proxy.
",Marc477,
866,2015-08-20 02:08:53,"Fixed it by adding:

if(options.ca){
    outgoing.ca = options.ca;
  }

in common.js inside function common.setupOutgoing

Now it is working, but this should really be added to this project
",Marc477,
866,2015-08-20 02:40:42,"@Marc477 pull-requests very much welcome
",jcrugzz,
866,2015-08-20 10:33:45,"I just found out that if a put all the certificate chain in my .crt file, I don't need to add it as ca parameter to https request !  But self-signed certificates are still a mystery for me since i always get the error: UNABLE_TO_VERIFY_LEAF_SIGNATURE, even after adding it to ca param
",Marc477,
866,2015-08-20 12:02:05,"Ok we need to add CA to server too, so we need to add CA option to http-proxy for self-signed certificates
",Marc477,
866,2016-07-28 12:36:14,"I created a pull request here: https://github.com/nodejitsu/node-http-proxy/pull/1042

Forgive me as I am unfamiliar with the projects setup, but this change I can assert fixes the problem that @Marc477 originally reported. I was encountering the same issue when using HTTPS to HTTPS with `secure: true`. 
",predhme,
865,2015-08-19 11:42:11,"Hi,

This is my scenario:
1) I have an internal server that is being proxied via node-http-proxy.
2) When I go to the login page on my app in my browser the page loads fine.
3) On logging in, the browser sends a POST request which gets proxied to the internal server.
4) The internal server responds with a 302 redirect.
5) node-http-proxy doesn't seem to do anything.
6) I end up getting a 408 timeout on the browser.

It appears as though node-http-proxy is not able to handle 302 redirect on a POST method.

Regards,
Roy
",reallyroy,
864,2015-08-17 06:23:40,"Hey guys,

Is there an example of a completely dumb/transparent/logic-less http proxy using `node-http-proxy` that does not make assumptions about [headers](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/forward-proxy.js#L47) and does not alter [response bodies](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/forward-proxy.js#L48)?

I want a 100% pure and stateless proxy where the only thing that is ""variable"" is the host URL where the requests get sent to and respond from.

It's a pretty simple scenario

<S_CODE_TOKEN>

All the [examples](https://github.com/nodejitsu/node-http-proxy/tree/master/examples) appear to do more than this.

Kind regards,

Michael
",iMerica,2015-08-19 09:02:05
864,2015-08-17 07:24:23,"Maybe you could be interested on: http://stackoverflow.com/questions/20351637/how-to-create-a-simple-http-proxy-in-node-js or http://www.catonmat.net/http-proxy-in-nodejs/.
",acanimal,2015-08-19 09:02:05
864,2015-08-19 09:02:05,"Thanks @acanimal !

For anyone coming back to this issue, I was able to achieve this with the following:

<S_CODE_TOKEN>
",iMerica,2015-08-19 09:02:05
863,2015-08-14 16:02:57,,stuartpb,2015-08-14 19:30:42
862,2015-08-11 01:46:38,,atian25,
861,2015-08-07 08:49:57,"Hi,

I'm trying to use this proxy to redirect domain and subdomain to the correct server. I have 2 sails.js server with http and websocket so I have make a proxy like this : 

<S_CODE_TOKEN>

But after some request I have this error : 

<S_CODE_TOKEN>

How can I fix this ? 
",jaumard,2015-08-10 06:01:52
861,2015-08-10 05:58:42,"You need to listen for errors on your `proxy` instance and return an error
to the requester when it happens. See [`proxy-server`](https://github.com/jcrugzz/proxy-server/blob/master/index.js#L55-L67) for
an example.
",jcrugzz,2015-08-10 06:01:52
860,2015-08-06 11:45:28,"<S_CODE_TOKEN>

Problem on this part code

<S_CODE_TOKEN>

When END event is triggered it's too late to change content-length.
",gangstaJS,
860,2015-12-11 11:45:59,"Any updates on this..
I am facing similar issue's
",shivambarsaley,
860,2015-12-11 12:27:06,"I am solved this removed `content-length` header
",gangstaJS,
859,2015-08-02 17:44:43,"https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L45

Without agent specified:
Browser <-> Proxy - connects with keep-alive
Proxy     <-> Target server - connects without keep-alive
If target server sends `Connection: close` the first keep-alive connection is broken.

Maybe better logic would be to do by default:

<S_CODE_TOKEN>

Other option is to simply always use the agent with `keepAlive: true` which was implemented in Node 0.12 - but as I understand, this would be much more resource hungry.
",Rush,
858,2015-07-24 22:09:56,"I have the following code in my heroku app:

<S_CODE_TOKEN>

And then I'm trying to use this server along with a browser (e.g. Chrome) using appname.herokuapp.com:80 or using the port returned by console log function but only using the port 80 works yet it only says that the app doesn't exists when it does.
",TelmoNeves,
858,2015-07-24 22:32:51,"When running in the Heroku environment, your app is already behind a proxy. The Heroku proxy is bound to appname.herokuapp.com:80, and forwards requests to your app dyno, which is bound to some randomly assigned port.

What exactly are you trying to do? Setting target to req.url seems quite odd.
",keithmo,
858,2015-07-24 22:41:15,"What I'm trying to do is to setup a caching proxy server like squid in heroku. Then I want to be able to use that proxy server on any browser like 111.222.333.444:80.

I don't know exactly what I'm doing since I never used nodejs but from what I can see, that piece of code makes a request from the url I'm trying to access, say google.com, and then returns the response to heroku and so to my browser right?

I'm aware that heroku already use a proxy yet I don't know how it works.
",TelmoNeves,
858,2015-07-25 02:21:35,"Other people already questioned about this: https://github.com/nodejitsu/node-http-proxy/issues/301
",TelmoNeves,
857,2015-07-24 17:22:41,"Great job with node-http-proxy!

I'm was able to successfully integrate that to my project, but there is a scenario that I'm not sure how to fix.

My current server is like this:

<S_CODE_TOKEN>

If my path is `http://localhost:8000/sample-app/` it does work fine. But, if we remove the forward slash from the path it fails (`http://localhost:8000/sample-app`). When I look at the browser console, all the requests from 8010 are actually sent to 8000.

Any idea how to fix that? Thanks!
",alansouzati,2015-07-24 18:25:41
857,2015-07-24 18:02:12,"I do something like this:

<S_CODE_TOKEN>
",keithmo,2015-07-24 18:25:41
857,2015-07-24 18:25:41,"Sweet, thank you so much @keithmo! 
",alansouzati,2015-07-24 18:25:41
857,2015-07-24 20:47:08,"Hi @alansouzati 
see the `strict` property in the router configuration on Express http://expressjs.com/api.html#router

By default `/sample-app/` and `/sample-app` are handled as different resources.
",acanimal,2015-07-24 18:25:41
857,2015-07-24 22:21:40,"Thanks for the info, @acanimal -- I was not aware of the strict property on the router. 
",keithmo,2015-07-24 18:25:41
857,2015-07-27 18:10:53,"Thanks for the insight @acanimal !

I haven't had a chance to test this entirely, but adding strict option in my server did not work. Maybe it is also necessary to add strict option inside proxy server as well?

I will try this soon and will update you guys!
",alansouzati,2015-07-24 18:25:41
856,2015-07-16 06:26:50,"Hi, I wanted to know how to proxy an incomming https requests:443 to for example :7000. At :7000 then will be a program running that has the files to decrypt the https connection.

Also I wanted to add multiple programs each of them having their own https certificate. 

So the end result should look like:

Certificate 1 https://test.example.com -> 443 proxy -> 7000 decrypts https -> program does stuff

Certificate 2 https://test2.example.com -> 443 proxy -> 7010 decrypts the https -> program2 does other stuff

Certificate 3 https://test3.example.com -> 443 proxy-> 8001 decrypts the https -> program3 does super special stuff

I couldn't find how to do this. Only how to accept a 443 connection and send it along internally as an unencrypted connection. 
",hawkerboy7,
855,2015-07-13 10:00:27,"Hello,
I'm trying to figure out how to proxy a request of a pdf file generated at runtime with `pdfkit`.

Response headers of the backend service are set to 

<S_CODE_TOKEN>

This allows to view the pdf inside browser (by just sending out the first header) or download it by also sending the second header. 

While `pdfkit` generates the file it is piped to the response.
If I try it by contacting the backend directly it works, while using the proxy it's raising a `ECONNRESET` error.

I guess it might depend on the client terminating the request before to receive the chunked response, how can I allow the backend service to pipe the request as the backend is processing the pdf?

I'm surely missing something... thank you!!
",lexor90,
854,2015-07-12 05:00:31,"Hello, 
I set up a simple proxy server on express and tried to observe the `on('proxyRes')` event. However for some reason the event is being called more times than I expected.
This is `""express"": ""^4.13.1""` and `""http-proxy"": ""^1.11.1""`

<S_CODE_TOKEN>

By sending 4 consecutive GET request I expected to get one `on('proxyRes')` event for each request.

<S_CODE_TOKEN>

but I got the following log.

<S_CODE_TOKEN>

Am I doing something wrong? I tried to add a `proxy.close()` at the end of the code, but it made no difference. 
",han4wluc,2015-07-12 14:40:40
854,2015-07-12 09:10:43,"You must register the `proxy.on('proxyRes'...)` outside the `app.get(...`, otherwise you are registering multiple listeners.
",acanimal,2015-07-12 14:40:40
854,2015-07-12 14:40:40,"I see, you are right. Thank you.
",han4wluc,2015-07-12 14:40:40
853,2015-07-09 15:25:15,"I was attempting to use this module with the proxy:
https://github.com/kwhitley/apicache

It works by monkey patching `res.send` to first write the response into cache and then bypass the server on subsequent requests.

That doesnt work, since this module does not use `res.send()`, but even changing the code to use `res.end()` does not work. 

I suspect that I might need to write my own cache layer, which is why I'd like to know what would be the best place to start?

It seems like you use streams, which id have to buffer first. Am I on the right track?
",mkoryak,2015-07-09 16:15:09
853,2015-07-09 16:15:09,"I was over thinking it when I decided to use a 3rd party module. Its as simple as:

<S_CODE_TOKEN>
",mkoryak,2015-07-09 16:15:09
852,2015-07-09 11:03:41,"Added missing config options for httpProxy.createProxyServer. Updated to include all options listed in `lib/http-proxy.js`
Addresses nodejitsu/node-http-proxy#851
",jpatters,2015-07-09 13:55:36
852,2015-07-09 13:55:35,"Thanks!
",jcrugzz,2015-07-09 13:55:36
851,2015-07-08 09:43:16,"This cost me many hours to figure out....I might be stoopid, but more ppl like me could lost valuable time over this.

Why isn't this option enabled by default? It would serve 99% of the use cases out there.
",Morriz,2015-11-05 06:41:41
851,2015-07-08 15:10:53,"I also just wasted several hours on this. 
+1 for adding it to the docs
",jpatters,2015-11-05 06:41:41
851,2015-07-08 20:05:43,"I will definitely take a pull-request for it :)
",jcrugzz,2015-11-05 06:41:41
851,2015-07-08 20:14:25,"Sure. Who will put that extra line in the docs? Last one in line? I will do it when I have the time ;)

> On 08 Jul 2015, at 22:05, Jarrett Cruger notifications@github.com wrote:
> 
> I will definitely take a pull-request for it :)
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
",Morriz,2015-11-05 06:41:41
851,2015-07-08 20:20:54,"I'd do it but I have no idea where it should go. Any suggestions? The readme is kind of all over the place on doesn't really document anything. It just gives examples. Should it be its own example?
",jpatters,2015-11-05 06:41:41
851,2015-07-09 06:56:32,"Just mention it in the list of options with a short explanation. Thats enough

> On 08 Jul 2015, at 22:21, Jordan notifications@github.com wrote:
> 
> I'd do it but I have no idea where it should go. Any suggestions? The readme is kind of all over the place on doesn't really document anything. It just gives examples. Should it be its own example?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
",Morriz,2015-11-05 06:41:41
851,2015-08-05 23:06:48,":+1: also lost quite a bit of time until i found this in the docs. i'm not sure why it's not true by default!
",bdefore,2015-11-05 06:41:41
851,2015-11-05 06:10:28,"+1, changeOrigin should be defaultly set to true
",kdepp,2015-11-05 06:41:41
851,2015-11-05 06:41:40,"@bdefore @kdepp that is not the purpose of this issue. It should have been closed with #852. If you feel strongly about `changeOrigin` please open a new issue if one does not exist. 

I am not opposed to it.
",indexzero,2015-11-05 06:41:41
850,2015-07-06 17:01:08,"It'd be nice to have the ability to manipulate or abort a proxyRes.  This is a solution for #737.

Not the prettiest but is 100% backwards compat and has almost [non-existent perf penalty](https://gist.github.com/cmawhorter/2fb412a799f474b4e721).  Test included.
",cmawhorter,
850,2015-07-06 21:51:54,"Guess I should include an example:

<S_CODE_TOKEN>
",cmawhorter,
850,2016-01-20 22:27:12,"+1  we needed this in order to transparently follow 307 redirects in the proxy for the client
",prust,
850,2016-01-20 22:28:42,"@indexzero, @jcrugzz: I can rebase this on the latest master if you guys are open to merging it. 
",prust,
850,2016-07-24 05:08:40,"Guys,

I think exactly like that, but I would like to have control over the continuation of the flow as between sending the response from the server to the client I want to run some asynchronous code.
",euprogramador,
850,2016-07-24 09:01:31,"@euprogramador I don't know if it is exactly what you need, but some time ago I was working on ClydeIO project (now stopped due I have no free time to spent on it) which allows to configure a set of middlewares before/after sending request to http-proxy. See image: https://github.com/clydeio/clydeio/wiki/Data-Workflow
",acanimal,
849,2015-07-05 14:59:07,"I have the following code that works great in my local environment. However, when I try to run the same code from a Docker container (via Boot2Docker), I simply cannot get to https://<boot2docker_ip>:4000

I tried updating the target value in the code below with all these options but none of them seemd to do the trick:

`target: 'http://localhost:' + (process.env.PORT || 3000),`  
`target: 'http://0.0.0.0:' + (process.env.PORT || 3000),`  
`target: 'http://127.0.0.1:' + (process.env.PORT || 3000),`  
`target: 'http://<boot2docker_ip>:' + (process.env.PORT || 3000),`

<S_CODE_TOKEN>

I would really appreciate if someone can please point me into the right direction here.
",munjalpatel,2015-11-13 17:30:49
849,2015-11-13 16:13:36,"I have the same problem here.
I also tried the hosts docker0 ip 
",FallenRiteMonk,2015-11-13 17:30:49
849,2015-11-13 17:30:49,"This is not an `http-proxy` issue, this question would be better asked on stack overflow relating to dealing with docker networking. Docker remaps ports and has certain semantics for linking containers since it takes over the OS network overlay.
",jcrugzz,2015-11-13 17:30:49
848,2015-07-05 04:59:31,"So, I have a proxy server running on my machine (privoxy); What I wanna do is redirect all the requests from a NodeJS custom proxy built with this library to that proxy. What I have done so far is this:

<S_CODE_TOKEN>

And it works as expected, if I ""proxify"" my browser via **127.0.0.1:5050** requests are handled by my privoxy proxy. The problem is, I only can do HTTP requests. If I try to visit a site via **https://** then I get an _empty response_ error in the browser, and nothing useful in the logs.

I would like to know 2 things:

1) How can I handle HTTPS requests the way I need?
2) How can I ""force"" HTTP requests even when the user requested HTTPS?

Thanks!
",Jmlevick,2015-07-07 07:03:07
848,2015-07-06 19:06:40,"You need to tell `https` to listen and pass in your certificate info.  The SSL tunnel is created with your proxy server, so the proxy must know about your certificates and such so that a secure connection is established. From there, you can make an insecure `http` connection to the destination server if you so choose (not recommended). Here's an example using express:

http://stackoverflow.com/questions/8355473/listen-on-http-and-https-for-a-single-express-app#answer-11234616

Express is just a wrapper to node's connect module, so I'm sure you can extrapolate what you need.
",DesignByOnyx,2015-07-07 07:03:07
848,2015-07-07 07:03:07,"So, from what I understand, I have to create both a http and https servers to make this happen and pass to them the connections selectively? Humm, I'm starting to think this particular project isn't suitable for NodeJS and my MEAN Boilerplate... I'm going to do it with Volt (the new isomorphic ruby framework) as I'll be needing other features this particular framework has built-in and the proxying part it's way easier with some ruby gems available.

Thanks!
",Jmlevick,2015-07-07 07:03:07
848,2015-07-07 18:46:19,"> So, from what I understand, I have to create both a http and https servers to make this happen

You make this sound like a chore. It's like 2-3 more lines of code. I mean, I guess you _can_ serve both http and https requests from the same port - I've never done it. Either way you need to tell this module about your certificates, [which is trivial](https://www.npmjs.com/package/pem). 
",DesignByOnyx,2015-07-07 07:03:07
848,2015-07-07 19:23:06,"It's not only that, it's just a lot of things for this project I'm working on ""feel"" like have to be built from scratch if I use NodeJS (My MEAN Stack boilerplate as always); For example the proxying part is just a little portion of the issues, there's a gem (em-proxy) that does the transparent proxying I need without me needing to mess around with certs or two different HTTP servers and selective requests. I'll be needing a websockets implementation with permissions enabled, I have code written for NodeJS with something similar working but it is not ""modularized"" to be part of a different app. Volt has a websockets implementation with permissions handled via the models built-in. Another thing that comes to mind is that I'd like to open source a piece of this project I'm building for handling the in-browser sessions that are created when 'stealth' users hit the app, but if I work with my usual stack I might end up with such code tightly coupled in to the overall project so I'd need to extract it later to another whole new independent project making me work twice. In Volt (for what I've seen these couple of days); Everything in the app it's a ""component"" (everything it's modularized) and extracting a piece of the app into a gem for publishing it's very trivial (you just have to run one command and ""poof"" you've successfully built an independent ruby gem ready for publishing from a piece of your project); So there's that...

TL;DR it's not the problems with this particular npm module itself, the whole project doesn't seem to fit with my regular stack and I have other things to build, so I'd rather do it quickly than go all ""trial and error"" on this one.
",Jmlevick,2015-07-07 07:03:07
848,2015-07-07 19:42:23,"For future reference, this is why this module was written [`create-servers`](https://github.com/indexzero/create-servers). @Jmlevick word of advice, don't get too attached to your stack but it seems like you are more comfortable with ruby so I understand why you might go that route. :).

For anyone else looking for ways to do websockets that could integrate with `http-proxy`, checkout [`primus`](https://github.com/primus/primus)

Cheers to all!
",jcrugzz,2015-07-07 07:03:07
847,2015-06-30 09:52:39,"I am using this module with express framework. All http GET requests are proxying correctly but facing problem with POST request.
",sanket-mindstix,
847,2015-07-04 15:55:17,"See more: https://github.com/nodejitsu/node-http-proxy/issues/843
",WHK102,
846,2015-06-29 16:57:43,"I would like to replay a some HTTP incoming request in background. 
I believe that a possible fit for this could be creating a new `net.Socket` to avoid collision between the forwarded request and the replayed one.

Here is an example code:

<S_CODE_TOKEN>

Any possible idea about how to achieve this in a reliable way?
",h2non,2015-07-06 19:47:43
846,2015-07-06 19:33:28,"Your code should work as you have it written, however there will be no feedback to the user if the replayed request doesn't work. If the replayed request causes an error it could put your app in a bad state. Using this module might not suit your use case because this module will automatically resolve the response (as a proxy should). However, it's pretty easy to proxy a request manually (without this module). You can add your own custom logic however you see fit. You can kick off two separate requests and when both are done you can call `res.end()` with your custom response.

<S_CODE_TOKEN>
",DesignByOnyx,2015-07-06 19:47:43
846,2015-07-06 19:47:43,"Thanks! I already solved this using a similar approach ([code here](https://github.com/h2non/rocky/blob/develop/lib/replay.js#L50)). Also I'm using the [setupOutgoing](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L33) function like http-proxy does.

The challenge here is about avoiding side-effects with the duplex net socket stream of the original request and response, since it only could be used from the initial request instead of the replayed one.

I believe that this is clear and solved from my side. Closing.
",h2non,2015-07-06 19:47:43
845,2015-06-29 16:08:31,"My backend implements a `POST` to `http://api.domain.com/resources` with the following response : 
- `Status Code : 303 See Other`
- `Location header : http://api.domain.com/resources/resourceId`

I use node-http-proxy (through grunt-proxy) to bypass SOP on my single page app (hosted on localhost:9000), but when I `POST` on `/resources` I keep having rejected request because of SOP, even using the hostRewrite option as follows :

<S_CODE_TOKEN>

Digging into node-http-proxy code I found this test on response code in `setRedirectHostRewrite` precondition : 

<S_CODE_TOKEN>

Why not add `303` to this condition ?
",abanctelchevrel,
845,2016-06-29 11:22:39,"+1
",stanislav-grin,
844,2015-06-29 05:29:50,"Hi

I'm using proxy.web to forward client requests. 
When destination server is up, my code works as expected. 
When destination server is down, ECONNREFUSED error is catch and printed to console.log. I would like to send that error back to the client, and tried using the sample provided here. Unfortunately, the error response does not arrive to the client (tried both chrome and firefox). Please find below code. Why does the response not sent to the client ? 

<S_CODE_TOKEN>
",oprince,
844,2015-07-17 09:46:11,"+1
",IGZjaviernieto,
844,2015-07-17 10:59:56,"+1
",igzdavidsuarez,
844,2015-07-17 12:16:09,"I'm using http-proxy as a middleware and works fine returning any kind of error: `connect ECONNREFUSED`, `getaddrinfo ENOTFOUND`, etc.

<S_CODE_TOKEN>

Your code at the `else` seems fine maybe your request is entering in the `if` part.

Cheers.
",acanimal,
844,2015-07-19 05:45:09,"Hi acanimal,
""If"" part is reached, and the error is printed to the console log. I have found a partial solution on client side, it is documented in: http://stackoverflow.com/questions/31260825/node-js-http-proxy-error-response-not-sent-to-client.
It works well once or twice while listening server is up. But socket gets corrupted and server should be restarted to recover.
",oprince,
843,2015-06-26 06:22:37,"Create a simple express app and try to do proxy. 

Proxy working fine when request is GET but it getting hang on post XHR call

<S_CODE_TOKEN>

Googled and got this solution https://github.com/nodejitsu/node-http-proxy/issues/180

<S_CODE_TOKEN>

but now application not hanging. I am getting response 404 not found. and getting below error

<S_CODE_TOKEN>
",elankeeran,
843,2015-06-29 03:17:57,"Same problem with reverse proxy and jQuery ajax post call:

/home/whk/demo/node/node_modules/http-proxy/lib/http-proxy/index.js:119
    throw err;
          ^
Error: socket hang up
    at createHangUpError (http.js:1473:15)
    at Socket.socketCloseListener (http.js:1523:23)
    at Socket.emit (events.js:95:17)
    at TCP.close (net.js:466:12)

Talk this:
http://stackoverflow.com/questions/18692580/node-js-post-causes-error-socket-hang-up-code-econnreset#answer-18693340
",WHK102,
843,2015-06-29 14:31:32,"I tried this solution. Content-Length is already correctly set in request object. In the above code, the request object is coming from the browser, so it should directly go to http-proxy and get the response.
",prashantbaid,
843,2015-06-29 14:33:35,"it can work but it's a bug.
",WHK102,
843,2015-06-29 15:52:23,"I would try and not parse the body when proxying a request. Errors are also not being handled so you cannot gracefully respond to the client when the remote server you are proxying to is down or something happens when communicating with said remote server.
",jcrugzz,
843,2015-06-29 16:12:05,"Crash in:

POST /test/?id=42 HTTP/1.1
Host: facilmed.cl
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:38.0) Gecko/20100101 Firefox/38.0
Accept: application/json, text/javascript, _/_; q=0.01
Accept-Language: es-CL,en-US;q=0.7,en;q=0.3
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest
Referer: http://.../?id=42
Content-Length: 107
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache

do=calendarioMes&datetime=2015-06-01+00%3A00%3A00&profesionalId=268188&user-token=xxx&type=json
",WHK102,
843,2015-07-15 19:32:04,"I was trying to use it for a specific endpoint instead of a middleware but that didn't work. it doesn't even throw an error, just says can't get/**\* and fails. Am I doing something wrong or there's an issue with express compatibility?

Here's my code for the reference:

<S_CODE_TOKEN>
",tarkeshwars,
843,2015-07-16 08:38:23,"body-parser middleware is causing the problem. If you remove it, then it will work. This is just a hack, we need to find a solution to this problem.
",prashantbaid,
843,2015-07-16 09:13:17,"Hey @prashantbaid! I tried what you suggested. Removed both the body-parser and cookie-parser. It still doesn't work. It still fails without any error. Any idea why? Here's the exact code that I'm using:

<S_CODE_TOKEN>
",tarkeshwars,
843,2015-07-16 12:07:47,"Got it to work. For others facing the same issue, the 'changeOrigin' option must be set to true. And @prashantbaid was right about the body-parser. On adding it, http-proxy doesn't work.
",tarkeshwars,
842,2015-06-23 16:50:39,"That could be useful for some scenarios when you have to deal with multiple proxy instances and react to particular states based on the specific proxy request instead of using global event handlers.

I would like to do something like this:

<S_CODE_TOKEN>

Is there another way to achieve that?
",h2non,2015-06-23 17:13:06
842,2015-06-23 16:54:45,"@h2non theres nothing stopping you from making a proxy instance on a per request basis if you wanted to have different handlers based on those particular requests. 
",jcrugzz,2015-06-23 17:13:06
842,2015-06-23 17:06:24,"May be it was my fault explaining this... but actually `proxy.web()` returns `undefined`. How do you handle the events for a specific proxy request only?. Thanks
",h2non,2015-06-23 17:13:06
842,2015-06-23 17:13:06,"Creating new instances. All clear.
",h2non,2015-06-23 17:13:06
842,2015-06-23 17:13:25,"@h2non to be more clear, you would have to instantiate a proxy instance on each request. e.g.

<S_CODE_TOKEN>
",jcrugzz,2015-06-23 17:13:06
842,2015-06-23 17:14:14,"Perfect, thank you!
",h2non,2015-06-23 17:13:06
841,2015-06-23 08:57:55,"Hi

I'm trying to imitate Apache ProxyPass with this module, and I'm not sure what I have to do. Is the docs lacking or am I just way off?

This is the code I have:

<S_CODE_TOKEN>

I've read through some old issues and they mention `pathnameOnly` but there is nothing in the docs about this. I've also read https://blog.nodejitsu.com/node-http-proxy-1dot0/ from where my above code is.
",benjick,
841,2015-06-24 15:29:55,"@benjick im not sure exactly what apache `ProxyPass` does but you can implement a reverse proxy using `http-proxy` without issue. You should also make sure you are sending the `host` header you think you are sending. Usually host headers do not correspond to a `/routeName`. Just add some console.logs, an error handler and see what you can do.
",jcrugzz,
841,2015-06-25 08:25:44,"You most likely meant to do:

<S_CODE_TOKEN>

And parse the pathname out of the request URL.

<S_CODE_TOKEN>
",3rd-Eden,
840,2015-06-20 12:39:00,"Hey,

I would like to use node-http-proxy to set Link headers based on response body so if I have pagination info in the body, I would add them as Link headers to the response.

An example response would be:

<S_CODE_TOKEN>

I would like to extract the `next_page_url` property of the json response and set an header with the value.

How would you implement that without impacting response time (or at least make the impact minimal)?

Also, do you think there's a streaming way to implement this without reading the entire body, parse it and then set the headers?

Thanks!
",motymichaely,
840,2015-06-21 17:48:54,"@motymichaely So there is a couple of problems with this currently.
1. There's no way to parse the response body before the stream is finished proxying.
2. The parsing of the response body in order to grab the value to set on the header will inherently impact response time.

While I'm still looking at a way to be able to inject in a transform/duplex stream into the post proxy response, I haven't had the time to explore that territory which could potentially be a solution to my first point. There is no solution for the second point.

The current solution for this is do manually proxy and parse your response stream without using this module, until i figure out a way to do the modification streams.
",jcrugzz,
840,2015-06-21 18:20:42,"@jcrugzz - I've created a gist to explain what I am trying to achieve. I've been using JSONStream to try to address the performance hit you mentioned:

https://gist.github.com/motymichaely/0b0982522d8b9da1200d

Now what I am missing is the ability to set the headers after I get the required info out of the body.

Any idea?
",motymichaely,
840,2015-07-06 20:22:03,"I just did this for a project I am working on. It's pretty complicated.

You are on the right track, but there are a couple things you are missing (this took me hours to figure out):
1. When you call `proxyRes.pipe(jsonStream);` - the proxy server needs a reference to this new stream so that it can pipe the `res` onto it... which is not currently possible. To make it possible, you can use my version: https://github.com/DesignByOnyx/node-http-proxy/commit/56b85380802411a4fee202cda3fb5e0dcdffa12c. I recommend you create your own fork, create a custom branch, copy my changes over, and then install it like so:
   
   <S_CODE_TOKEN>
2. To use it, you need to do the following:
   
   <S_CODE_TOKEN>
3. With your use case, things get a little tricky. The nature of streams is to allow data to continue flowing through. With this module, the `proxyRes` is streamed right into the `res`.  The headers go first followed the body of the response.  Since your headers are contingent of the response body, you must buffer the entire response into memory (sort of like crimping a hose), process the data, and then flush the data (release the crimp).  In order to do this, I recommend using the [through](https://github.com/dominictarr/through) module in leu of the jsonStream module. You will buffer all the data into memory, parse the JSON, write your headers, and and `emit` it all once you are done. If you need assistance, post back here. 

###NOTE:
Buffering the entire response into memory like this is nice to be able to modify the response sent back to the client.  However **this completely kills the performance of the response and should be used sparingly, only when needed, and ideally on small responses.**
",DesignByOnyx,
839,2015-06-10 20:44:42,"As I need to rewrite the request URL as it does not map perfectly to the applications under the proxy, I've set ignorePath to true.

Then I proceeded to define the target as a full doctored url (a valid URL for my applications), but as in common.js:82 it does not truly ignore the path. It sets it to '/' and them proceeds to append it to target / forward.

Is there any way around that? Is there a better way to do what I need?
",mereghost,2016-01-28 19:58:35
839,2015-06-11 17:37:55,"Hmmm... the only current way (that I found) to bypass this behavior is rewriting the proxied request path using the callback 'proxyReq'

<S_CODE_TOKEN>
",mereghost,2016-01-28 19:58:35
839,2015-08-05 23:11:36,"thanks @mereghost i was looking for just this. to prepend, you can do i.e. `proxyReq.path = '/api/' + proxyReq.path`. certainly would be nicer if `ignorePath` was better documented.
",bdefore,2016-01-28 19:58:35
839,2015-08-19 23:55:08,"Thanks @mereghost - just ran into this issue myself, but it didn't surface until dealing with proxying requests with query parameters. Glad to see I'm not going insane. :+1:
",cdl,2016-01-28 19:58:35
839,2015-09-20 20:14:09,":+1: 
",RickWong,2016-01-28 19:58:35
839,2015-09-23 16:18:39,":+1: `/` appended to end of querystring when using `ignorePath`
",darrenmce,2016-01-28 19:58:35
839,2015-11-14 15:14:39,"i need to rewrite the target path too for the exact same reason (the target URL structure does not match the source URL structure). 

[this appended trailing slash](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L91) breaks the ability to rewrite the target path as a specific resource.. could we remove it and update the docs for `ignorePath` stating that, if required, we must manually append our own `target` trailing slash?
",75lb,2016-01-28 19:58:35
839,2016-01-28 19:31:38,"Should be resolved by this: https://github.com/nodejitsu/node-http-proxy/pull/934
",niclic,2016-01-28 19:58:35
839,2016-01-28 19:58:35,"@niclic should be, thanks :)
",jcrugzz,2016-01-28 19:58:35
838,2015-06-10 18:05:37,"Hi!
How i can get the response body(json) in proxyRes event?

<S_CODE_TOKEN>
",poluyanov,2015-10-13 17:15:44
838,2015-06-12 13:15:40,"Here a little code example for your situation. But don't forget, this gets only if response in clear text. you have to make in unzip if it's zipped etc.

<S_CODE_TOKEN>
",tanaydin,2015-10-13 17:15:44
837,2015-06-10 02:26:09,"### The situation

Hi everyone, I have an app running on heroku and I made the HUGE mistake of hardcoding the heroku URL to the app. Now I'm migrating my API to another server with another URL.
### What I'd like to do

Since I can't be sure that all of my users WILL actually update their up when I roll out the update, **I'd like to** use `node-http-proxy` to do a **reverse proxy** so all traffic goes to my new server.
### What I've got so far

I've got to the point where I can actually redirect traffic to the new server, but that server is in a cluster with a bunch of other apps hosted in it, and the URL it resolves to, has a Varnish VirtualHost which uses the URL to resolve to my hosted API. So I'm getting an `Error 503 Service Unavailable` because the URL that the Varnish Server is getting (presumably) is the one from heroku (or localhost on my testing machine) which doesn't resolve to any valid existing VirtualHost inside Varnish.

This is what I'm using.

<S_CODE_TOKEN>

---

IMO what I need is a way to preserve the host URL, but not sure if there's a way to do that with node-http-proxy.

Thanks!
",danazkari,2015-06-29 19:40:04
837,2015-06-11 09:19:44,"This has worked for me previously

<S_CODE_TOKEN>
",alfonso-presa,2015-06-29 19:40:04
837,2015-06-26 13:24:04,"Real sorry for not posting a response before, and thanks for your help! I've been dealing with all sorts of craziness this past couple of weeks in other areas of my API, will try your solution today and report back.

Cheers!
",danazkari,2015-06-29 19:40:04
837,2015-06-29 19:40:04,"@alfonso-presa worked like a charm, thanks so much for your help!

FYI, I removed the args.url and args.host, nonetheless, works perfectly.

Closing!
",danazkari,2015-06-29 19:40:04
837,2015-06-29 21:42:08,"I'm glad it helped :-).
",alfonso-presa,2015-06-29 19:40:04
836,2015-06-02 11:55:38,"- Removed constraint that prevented rewrites when the target and redirected host did not match.
- Removed associated tests.

This constraint was added between v 1.9.x and 1.11.x and broke an implementation that was being used to proxy localhost requests to a another server.

If there's a good reason to keep preventing proxying between hosts that are not the same, I'd be interested to understand why and if there's a workaround for my specific use case. 
",whatknight,2015-09-03 20:13:14
836,2015-06-02 16:41:00,"@matthauck could you provide clarification for the commit here https://github.com/nodejitsu/node-http-proxy/commit/26029ba7ac948b5dc0befb2091cc9a5862d0641c? I personally don't have a strong opinion either way I just don't want to break it again and would like to find a way for this to work for both your cases
",jcrugzz,2015-09-03 20:13:14
836,2015-06-02 23:55:26,"Ah yes. That was actually important. The justification was in the commit you mentioned. If the website is sending back a redirect to an external server, that should not be rewritten by the reverse proxy... This is similar to what apache does with ProxyPassReverse.
",matthauck,2015-09-03 20:13:14
836,2015-06-05 12:13:02,"I would say that if you're explicitly setting a host rewrite, it's inferred that you want to rewrite the host with the value provided. 

Apache will rewrite incoming requests to make sure redirects always have the same host as `target`, so how about if we fall through the configurable options, we can set `u.host` to `target.host` if they don't match? 
",whatknight,2015-09-03 20:13:14
836,2015-06-09 04:50:11,"Hmm. My personal opinion is that it only makes sense to do the rewrite if it is a redirect to the same backend host, so that the external view remains constant. This is especially true for the ""autoRewrite"" feature.

I can maybe see a case for `hostRewrite` option always setting the specified value regardless of the redirected target. If you were going to do that, however, I would suggest putting it under `autoRewrite` instead of a fall-through case, since it isn't really a third option. ...And I would add back the proper test cases and add new ones. =)
",matthauck,2015-09-03 20:13:14
836,2015-06-09 05:48:08,"@whatknight I'm with @matthauck, make it an explicit behavior
",jcrugzz,2015-09-03 20:13:14
836,2015-06-09 19:01:39,"@matthauck The issue I take with with your change is that you are viewing this proxy just like `mod-proxy`. The ability to create custom server logic means that there's no longer a 1-1 mapping of frontend-backend. A developer has the flexibility to build the backend target on the fly (as we have done).

I also take issue with the fact that your change A) silently fails and B) is completely undocumented (same with `autoRewrite`, but that's outside this scope).

I think our use case and the issues we are seeing are getting lost in translation.

@whatknight and I are on a team that's developing a single-page application. During development, the app is served on `localhost`. As we need to interact with backend APIs on different domains, we are using this proxy on the server side to proxy XHR calls out to the various APIs. Custom proxy logic allows us to extract the intended endpoint via a parameter and set that as the proxy target.

As `Host` is `localhost` for these requests, we were manually building the correct `redirectHost` and utilizing the `hostRewrite` functionality to ensure things stayed in line.

We can solve this problem by rewriting the `Host` header to the `target` host. This is reasonable enough, except that you are technically supposed to set `X-Forwarded-Host` to the original `Host` value. Frameworks like Rails, however, will default to using `X-Forwarded-Host` as the base for the `Location` header, which leaves us back at square 1.
",wingrunr21,2015-09-03 20:13:14
836,2015-06-11 08:22:47,"Granted, node-http-proxy is not mod-proxy, but it is still a reverse http proxy. I believe the constraint I added is valid for something functioning as a reverse proxy.

I don't believe the constraint I added prevents you from doing what you want to do. The basic reason for the constraint is that a reverse proxy should rewrite `Location` header responses only for the things it is proxying. If the thing it is proxying to sends a redirect to a third-party site, which site is not being reverse-proxied, the proxy should not rewrite the URL in such a way that would cause the client to try to request it via the proxy, which request would fail.

**Scenario 1**: Here's the workflow in my mind for your scenario:

<S_CODE_TOKEN>

This is how your reverse proxy should work in my opinion. This allows the host constraint to stand. It would need some more nuanced handling of paths, however, to support mapping ""/foo"" to ""/site1/foo"". That is the change I think you should make. Or, to make it super-customizable, change it so that it can take a callback function as a config parameter, and do whatever you want in your app for the host redirect.

**Scenario 2**: Here's a workflow that would violate my constraint and which I'm trying to avoid:

<S_CODE_TOKEN>

Note step 4 there, it should not rewrite that redirect since it did not just proxy to that domain. 

Granted, my solution was imperfectly done and probably was poorly documented, but it helped node-http-proxy behave more naturally w/ less configuration as a reverse proxy (rather than hard-coding a global `hostRewrite`, and also handling ports, if memory serves correctly), and in this scenario, the controversial constraint was necessary to add and fixed a bug that was happening for me when scenario 2 above became a reality. 

All that said, I'm not working on this project anymore, and so I don't have much vested interest in keeping the behavior as it is today, and I don't desire much to keep arguing for it. But I am still convinced it is the correct approach. You guys do what you think is best.
",matthauck,2015-09-03 20:13:14
835,2015-06-02 07:46:29,"I've got node running on http://localhost:8001 and have http-proxy configured to proxy https://localhost:8002 back to http://localhost:8001.

This works fine as long as I'm connected to the internet, but when I'm disconnected from the internet http://localhost:8001 still works, but when I access https://localhost:8002 I get this error:

<S_CODE_TOKEN>

Which makes it hard for me to work with this while on the road (I want to be able to work without internet connection)

Is there some setting I should set or should it be fixed?
",flyon,
835,2015-09-30 09:08:55,"I ran into this yesterday.

Try using 127.0.0.1 instead of localhost.

See: https://github.com/nodejs/node-v0.x-archive/issues/25338
",peterhodges,
834,2015-05-31 14:05:56,"Hi, 
I'm working with connect (like samples does) and my intention is to execute http-proxy within the chain of middlewares. The samples shows how to use http-proxy as middleware but always as a final middleware, for example:

<S_CODE_TOKEN>

Here the last middleware has no `next` parameter. What I need is to execute proxy as a middleware and when proxy was finished execute the `next` function, something like:

<S_CODE_TOKEN>

If I use the `proxyRes` event within the middleware that means I'm registering a listener each time there is a request:

<S_CODE_TOKEN>

and if I put the `proxy.on('proxyRes'...` outside middleware I have no access to the `next` function.

The problem is how to know proxy has finished and how to call the `next` function. 

Thanks.
",acanimal,2015-07-01 06:04:01
834,2015-06-01 15:41:49,"@acanimal why do you need to call the next function after the proxy has finished? Middleware is only supposed to be used as a series of functions to execute on a single request. When you proxy a request, the proxy takes over the responsibility of the request and calling the response. You don't want to continue the middleware chain in these cases as it will most likely have unintended side effects. What are you trying to accomplish?
",jcrugzz,2015-07-01 06:04:01
834,2015-06-01 19:48:49,"Hi @jcrugzz,
my idea is to execute a chain of middlewares where http-proxy is within them, so I want, once the proxy has make the request and get a response, continue to the next middleware, for example, to change some response headers or body content.

I think I have achieved what I want listening for `finish` on the `res` object, similar to this:

<S_CODE_TOKEN>

Do you think is this fine or can have side effect? Thanks in advance.
",acanimal,2015-07-01 06:04:01
834,2015-06-03 14:38:37,"@acanimal at that point it might be too late to change headers but see if it works for you. The reason I suggest against this is because any of the middlewares after the proxy completes will have to know that the response has already been returned and there is not much you can do at that point.
",jcrugzz,2015-07-01 06:04:01
834,2015-06-11 23:56:36,"From my own experimentation, it's indeed already too late to modify the headers when you're trying to change them after the 'finish' event is thrown.

As to your previous statement:

> If I use the proxyRes event within the middleware that means I'm registering a listener each time there is a request:

You can use the `once` function to avoid this.

I'm using something like:

<S_CODE_TOKEN>

You can catch the error further down the middleware stack by adding a error middleware handler.
",gillesdemey,2015-07-01 06:04:01
834,2015-07-01 06:04:01,"Hi,
simply if you can be interested I was using http-proxy in an API-Gateway project:https://github.com/acanimal/clyde

For the moment it is a simply proof of concept but hope it can attract more people.

Cheers.
",acanimal,2015-07-01 06:04:01
833,2015-05-29 02:00:07,"Global options are being overwritten with every request causing per-request options to leak into the next call.
",efokschaner,2017-01-16 00:05:19
833,2015-05-29 05:17:33,"@efokschaner thanks for this! Could you provide a test case so we can defend against this?
",jcrugzz,2017-01-16 00:05:19
833,2015-06-13 04:31:59,"@jcrugzz Sorry for taking a while to get back to you. I cannot commit to adding tests for this as it is low priority for me and a non-trivial investment of my time given my lack of familiarity with node and javascript.

If I can, I will look at submitting some tests at a later date, but for now, please consider this PR for merge as is.
",efokschaner,2017-01-16 00:05:19
833,2017-01-16 00:05:18,Closing in light of #1074.,efokschaner,2017-01-16 00:05:19
832,2015-05-27 13:19:23,"i have anodejs application that uses http-proxy to create a proxy to send the incoming requests for example: https://localhost/api/login to https://server1/api/login. here is the code used :

var httpProxy = require('http-proxy');

var proxy = httpProxy.createProxyServer();

self.routes['/api/*'] = function(req, res) {
            proxy.proxyRequest(req, res, 
            {
                target: ""https://server1"",
                changeOrigin: true
            });
        };
 this is working just fine in my machine.
Now when i deploy this on a server, i get error
 { [Error: getaddrinfo ENOTFOUND] code: 'ENOTFOUND', errno: 'ENOTFOUND', syscall: 'getaddrinfo' }
the problem is that there is another proxy let say (corporate proxy let call it: localProxy) between myserver and server1.
I don't know where to set the localProxy in my code above. and where to set the server1 url?
and is there is a way to use http-proxy in this case
",ahmedabbas11,
832,2015-06-10 11:22:27,"If you are using HTTPS, wich it seems so, you should use https-proxy-agent. You can provide a proxy server to https-proxy-agent:

var HttpsProxyAgent = require('https-proxy-agent');
var proxyServer = process.env.http_proxy;

var proxy = httpProxy.createProxyServer({
    agent: new HttpsProxyAgent(proxyServer)
});
",alfonso-presa,
831,2015-05-26 21:11:31,"if I use node-http proxy and I set certs and hit a server, the main page will load but anything else from the website (css, images, etc) don't load because they're trying to be loaded over http. is there a flag I need to pass to get these to load over https?
",thehindenburg,
830,2015-05-26 18:32:12,"Hi guys! I'm writing a proxy to change the responses of the webs the user is visiting (of course its browser is pointing to our proxy). I'm using Harmon as suggested in the doc and everything seems to work fine :smile: but I'm having a problem which I resume here:
- If I visit example.com it works well.
- If I go to nodejs.org it freezes. The problem is that the browser is sending me to ""http://nodejs.org"" instead of the ""https"" site (it also works forcing the target, like it's shown in the comments). They are returning a 301 and the problem is there. I suppose I'm losing something here, I've tested with the commented options but I didn't have luck.
- Moreover the parsed response includes a 200 code instead a 301 one, so I'm a bit confused.

Any idea please?

<S_CODE_TOKEN>

<S_CODE_TOKEN>
",jesusprubio,
830,2015-11-24 05:14:54,"I also encounter the issue when I proxy google, you should add the options--autoRewrite:true.
",yejijie,
829,2015-05-23 14:12:03,"Hi,
I'm interested on using http-proxy and I'm reading the source code to understand how it works.

From what I see, in the `web-incoming.js` file the `stream` method does the real job _clonning_ the request and sending to the target server. This clonning action is made through the `common.setupOutgoing` function which returns the options to be passes to the `http.request`.

I can see how options like port, method, headers, etc are added to the outgoing request but where is the body copied? How is the incoming data passed to the target server?

Thanks in advance.
",acanimal,2015-05-25 18:12:21
829,2015-05-25 18:12:21,"Yep, sorry. I think I get it. In https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L144 you are piping from client req to proxy req.
",acanimal,2015-05-25 18:12:21
828,2015-05-22 20:44:40,"From what README.md describes, node-http-proxy redirects stuff like:
http://localhost/abc to http://target/abc

However, I would like to use it as a real proxy server. Like the ones you configure into your web browser any will proxy any websites you access through it. For example:
http://myrealsite -> proxy (requests myrealsite) -> returns result.

Can node-http-proxy be easily adapted to fit this scenario?

Thanks!
",MihaiValentin,
828,2015-06-26 16:23:22,"yes, this can :)
",jpacora,
827,2015-05-20 20:26:55,"I used to have code like this:

  router: {
    'a.com': '127.0.0.1:3334',  
    'b.com: '127.0.0.1:3334',         

so I could have several websites on one machine. It seems like the 'router' field in options has gone away. Is there some other way to do this?
",talkingtab,
827,2015-05-21 03:27:53,"Check out my https://github.com/encharm/http-master which uses node-http-proxy to implement router and more
",Rush,
826,2015-05-20 16:04:38,"I'm trying to perform a proxy to an url that needs a client certificate. The context is:
- I've installed a p12 file in the browser and after that I can access to the endpoint https://aaa.com/webservice:4278
- I've extracted the key and the certificate of the p12 file installed in the browser

Now, I've defined an object like that

<S_CODE_TOKEN>

and the, I create the proxy

<S_CODE_TOKEN>

But, it doesn't work, the request always returns a 403 status code.

Am I doing something wrong? Any help?
Thanks
",javierpavon2000,
826,2015-05-21 16:37:31,"I'm curious if there's a way to do this too. I opened a Stack Overflow question on it the other day: http://stackoverflow.com/questions/30331618/node-http-proxy-to-https-server-with-client-certificate
",kjlaw89,
826,2015-07-04 23:00:36,"For sure it's possible for http-proxy to use a client certificate. I just answered that Stack Overflow question, although I used the `key`, `cert`, and `ca` options instead of the `pfx` option. I think the example will still work if you use the `pfx` option instead.

Here's a working demo: https://gist.github.com/briangreenery/e2f03c0058e3589a9acf
",briangreenery,
825,2015-05-18 23:31:16,"Adds example of how to create a reverse proxy.
",pose,2015-12-30 04:53:21
825,2015-12-29 23:02:30,"Is it possible for this to work from the browser, not by issuing a curl request from the command line?
",TKMacmillan,2015-12-30 04:53:21
825,2015-12-30 04:53:39,"@TKMacmillan no since it relies on node libraries, not `XMLHttpRequest`.
",indexzero,2015-12-30 04:53:21
824,2015-05-15 01:07:57,"I get the following error when I use http-proxy .
Error: socket hang up
    at createHangUpError (http.js:1477:15)
    at Socket.socketOnEnd [as onend](http.js:1573:23)
    at Socket.g (events.js:180:16)
    at Socket.emit (events.js:117:20)
    at _stream_readable.js:944:16
    at process._tickCallback (node.js:442:13)
thanks
",my541619352,2016-01-17 08:44:57
824,2016-01-17 08:44:29,"fixed. 
found solution in 
hanging POST requests #180
",my541619352,2016-01-17 08:44:57
823,2015-05-13 02:41:13,"Installation process may be something obvious but is better if are documented.

I am creating this PR because I tried to install it using the package name `node-http-proxy` as the readme stands, but it happens to be the wrong name.

The correct name is `http-proxy`.
",montogeek,2015-05-13 17:24:09
823,2015-05-13 17:24:07,"thanks! :smile: 
",jcrugzz,2015-05-13 17:24:09
823,2015-05-13 22:04:16,"You are welcome!
",montogeek,2015-05-13 17:24:09
822,2015-05-11 16:52:28,"I include this library https://github.com/nodejitsu/node-http-proxy to my project. I can run nexe to create my single file successfully, but when I ran the binary file. It gives the following error at the bottom.

I then exclude the module by using the dynamic require technique mentioned in this page https://github.com/crcn/nexe, and put it alongside with the single file, it works then. 

New to node.js. Is it because this is an ""native module"" so I can't include it? It doesn't look like one.

---

[root@seludevserver linguo-ui-lite]# ./linguoui.bin
nexe.js:25123
  module.exports.createProxy = function createProxyServer(options) {
                             ^
TypeError: Cannot set property 'createProxy' of undefined
    at Array.call./home/selu/linguo-ui-lite/node_modules/http-proxy/lib/http-proxy.js.http (nexe.js:25123:30)
    at initModule (nexe.js:29:11)
    at nexe.js:31:64
    at Array.call./home/selu/linguo-ui-lite/node_modules/http-proxy/index.js../lib/http-proxy (nexe.js:25095:18)
    at initModule (nexe.js:29:11)
    at nexe.js:31:64
    at Array.call./home/selu/linguo-ui-lite/app.js.http (nexe.js:52:17)
    at initModule (nexe.js:29:11)
    at Array.forEach (native)
    at nexe.js:39:8

---
",lhy0512,2015-05-11 16:54:41
822,2015-05-11 16:54:41,"This is not a bug in `http-proxy`, its a bug in this `nexe` loader you are using. There should never be a case where `module.exports` is `undefined`
",jcrugzz,2015-05-11 16:54:41
822,2015-05-11 16:55:40,"sorry I meant to post this in nexe's git. My bad.
",lhy0512,2015-05-11 16:54:41
821,2015-05-08 07:54:16,"Hi!
I use http_proxy as Websocket proxy layer. 
Sometimes i get a error like ""object proxySocket has not method unshift..."".
And it is true, see https://nodejs.org/docs/v0.8.0/api/net.html#net_class_net_socket: object net.Socket has no method unshift
Why you do this? Is there some hidden sense to do this?
May be I don't understand...
",kspiridonov,
821,2015-05-11 16:56:45,"@kspiridonov This version of `http-proxy` (post `1.0.0`) only works with node versions `0.10.x` and above. 
",jcrugzz,
821,2015-05-11 18:02:05,"Ok. But in https://nodejs.org/docs/v0.10.0/api/net.html#net_class_net_socket there is no unshift method too. And in 1.0.0 this instruction (proxySocket.unshift(...)) is.
",kspiridonov,
821,2015-05-11 18:36:06,"@kspiridonov [`net.Socket`](https://github.com/joyent/node/blob/v0.10.38-release/lib/net.js#L151) is a [`stream.Duplex`](https://github.com/joyent/node/blob/v0.10.38-release/lib/_stream_duplex.js#L32-L44) which has an [`unshift`](https://github.com/joyent/node/blob/v0.10.38-release/lib/_stream_readable.js#L132) method.
",jcrugzz,
821,2015-05-11 18:36:48,"@kspiridonov please provide a reproducible test case which displays this as an issue
",jcrugzz,
820,2015-05-06 07:36:43,"from the top of guide page: http://mongoosejs.com/docs/guide.html

> from 3.x to 4.x please take a moment to read the [migration guide](http://mongoosejs.com/docs/migration.html).

but the content of ""migration guide"" starts with:

> Migrating from 2.x to 3.x ...

Very confusing.
",neekey,2015-07-13 01:39:02
820,2015-07-12 05:13:58,"what does this have to do with node-http-proxy?
",smazurov,2015-07-13 01:39:02
820,2015-07-13 01:39:02,"Sorry, this is so embarrassing, I opened this issue here carelessly and haven't realized it until now! I'll move it to the mongoose repo LOL
",neekey,2015-07-13 01:39:02
819,2015-05-02 18:24:25,"The example to create a proxy to rewrite headers didn't work for me.  The documented:

proxy.on('proxyReq', function(proxyReq, req, res, options) {
  proxyReq.setHeader('X-Special-Proxy-Header', 'foobar');
});

instead seems to work better as:

proxy.on('proxyReq', function(proxyReq, req, res, options) {
  res.setHeader(header, ""*"");
});
",dale6john,
818,2015-04-30 11:50:13,"hi all,

i using this code :

//
// Create a proxy server with custom application logic
//
httpProxy.createServer(function (req, res, proxy) {
  //
  // Listen to the `proxyResponse` event. Make note that 
  // the first two arguments to this handler are the `req`
  // and `res` in the existing scope and I'm indicating that 
  // they are meaningless by assigning them the var name `_` 
  //
  req.on('proxyResponse', function (_, _, proxyRes) {
    proxyRes.on('data', function (chunk) {
      //
      // This is the data from the target server, but modifying
      // it will not affect the outgoing `res`. 
      // 
    });
  });

  //
  // Put other custom server logic here
  //

  // Now make the proxy request.
  proxy.proxyRequest(req, res, {
    host: 'localhost',
    port: 9000
  });
}).listen(8000);

my problem i getting only half of the data on this event :
 proxyRes.on('data', function (chunk) 
is there a way to get all the data 
i know it only after sendin the data but i need the fully replay data 

thanks in advanced
shlomi
",shlomihassan,
817,2015-04-30 08:20:26,,klammbueddel,2015-05-09 21:23:03
817,2015-05-09 21:23:10,"thanks!
",jcrugzz,2015-05-09 21:23:03
816,2015-04-29 02:25:17,"Greetings!

I'm quite fond of the idea of adding latency in some places for testing purposes. However, I would like to make the latency conditional on the response of the target. Could not figure out an elegant / short way to implement this given the existing API - unless I missed something. 

Cork/Uncork the response stream would not work, as calling `end()` on it will push the data to the client anyway.

Suggestions appreciated.
",mrzor,
815,2015-04-28 16:15:35,"...tart event for this
",simone-sanfratello,2015-05-09 21:26:47
815,2015-05-09 21:26:47,"Sorry this is a huge breaking change that I don't agree with. I would like to find a way to support this use case outside of http-proxy. There should be other modules to handle this async dance to make it work. I appreciate the contribution but will be closing this as I don't believe this is the right direction. For future contributions please try and follow the style in the project :). Thanks!
",jcrugzz,2015-05-09 21:26:47
815,2015-05-13 09:27:20,"Thank you for your answer, I understand your point of view
",simone-sanfratello,2015-05-09 21:26:47
814,2015-04-28 09:12:25,"The latest version of `EventEmitter3` has removed the aliases on the exported Object:

https://github.com/primus/eventemitter3/commit/43211e9a9050887530421e8e2d8b9e1aa2506cc4

This of course breaks `http-proxy`'s require:

<S_CODE_TOKEN>

<S_CODE_TOKEN>

Would be great if we could get semvers in `http-proxy`'s package.json to prevent future breakage due to major version changes in the required modules.
",BonsaiDen,2015-04-28 09:31:06
814,2015-04-28 09:31:06,"@BonsaiDen that happens in **old** and **out of date** versions of the http-proxy. Update to the latest version and it will work as intended. 

Duplicate of #810 
",3rd-Eden,2015-04-28 09:31:06
813,2015-04-27 15:23:16,"I'm using node-http-proxy for a while now, and I think I'm using it quite right catching errors like this

<S_CODE_TOKEN>

But I can have two cases that make a ""socket hang up"" error happen.
1. Crash behind
2. Client cancelling the request

Watching at my log I can make no differences between those two cases and it's quite frustrating. Before knowing about request abort (thank #527) I really though I have an error going on.

So, what's the best practice to filter the request.abort case out?
",JSteunou,
813,2015-04-28 15:07:18,"+1
",theoephraim,
813,2015-07-16 09:36:07,"+1
",FoghostCn,
813,2015-12-01 22:27:33,"You should be able to use the proxy error event or the error callback and check for res.socket.destroyed === true and error.code  === ECONNRESET which means the request was canceled
",vvo,
813,2015-12-02 08:37:34,"Merci @vvo ;) Will try that asap
",JSteunou,
813,2015-12-02 09:48:39,"It works very fine, thank you again @vvo 

@jcrugzz should I let this issue open? Maybe http-proxy should filter those error inside the library, or maybe it's better to let it unopinionated...
",JSteunou,
813,2015-12-02 09:49:25,"> or maybe it's better to let it unopinionated...

Yes it depends on the use case, sometime you will want the error to pop out if the client canceled the request.
",vvo,
813,2015-12-02 09:55:16,"What I thought. Closing it then.
",JSteunou,
813,2015-12-02 10:51:10,"Quick question again: I want to use [request abort](https://nodejs.org/docs/v0.12.8/api/http.html#http_request_abort) to prevent the underlying server to handle that client cancelled request. But, very surprisingly, `req.abort` is `undefined` O_O

Any thoughts?
",JSteunou,
813,2015-12-02 10:59:56,"nope sorry, 
",vvo,
813,2015-12-02 11:09:29,"I think the `req` I got is the received request, not the request currently sent by http-proxy
",JSteunou,
813,2015-12-02 11:26:55,"Ok for the record, in case anyone was interested at doing the same thing

### How to catch request client cancelled and abort ongoing proxied request

<S_CODE_TOKEN>
",JSteunou,
813,2015-12-02 14:59:47,"This is a bug and should be fixed within `http-proxy` itself. Currently we are emitting an error on the client request when we should only be cancelling the proxy request when this happens.
",jcrugzz,
813,2015-12-02 15:02:42,"Which one? Getting all errors even from client cancelled request or be forced to tricky save `proxyReq` to be able to `abort`?
",JSteunou,
813,2015-12-02 15:06:50,"@JSteunou To put it simply, your workaround here should be handled within `http-proxy` for the `req.on('error')`
",jcrugzz,
813,2015-12-02 15:30:22,"Would be nice :) 
",JSteunou,
813,2015-12-02 15:38:12,"@JSteunou Pull requests always welcome if you want to take a stab at it! :)
",jcrugzz,
813,2015-12-02 15:43:50,"also @vvo if you want the error handled, you could handle the error directly on `req.on('error')`. Im of the opinion that we need to cleanup our `proxyReq` regardless and if you want it as an error in your code the error can be handled there. Does this seem reasonable?
",jcrugzz,
813,2015-12-02 15:55:47,"Yep makes sense
",vvo,
813,2015-12-02 17:28:10,"@jcrugzz I'm afraid I have the necessary solution and motivation but not the time to do it.
",JSteunou,
813,2015-12-02 18:01:01,"@JSteunou it would be a simple change right around [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L130-L132). You may be overestimating the time :). It would be a good opportunity for first contribution
",jcrugzz,
813,2016-02-08 12:53:41,"Fairly old thread, but still an issue afaik. Resolving it by comparing the error code to `ECONNRESET` and ignoring the error as suggested before.

Would be happy to submit a PR to handle this exception internally, but aren't there any use cases where you'd actually want to handle this manually? At the very least you'd need to emit a new event instead (`abort` perhaps?). Any thoughts?
",Lapixx,
813,2016-06-03 10:25:31,"mark
",cycold,
812,2015-04-27 13:10:24,"Hi,
I have two major issues.
1. some proxied sites that i've tried using are giving the following response(tried google and ebay and some other sites):
                               ""The requested URL / was not found on this server.""
1. in the cases that the proxy is displaying the actual page, most of the links are not overwritten with the proxy url so if i click on links it will either go to 404 or redirect to the original server not the proxy.

Here is the code i used:
var http = require('http'),
    httpProxy = require('http-proxy');

var proxy = httpProxy.createProxyServer({
});

proxy.on('proxyReq', function(proxyReq, req, res, options) {
  proxyReq.setHeader('X-Special-Proxy-Header', 'foobar');
});

var server = http.createServer(function(req, res) {
  proxy.web(req, res, {
    target: 'https://www.google.com'
  });
});

console.log(""listening on port 80"")
server.listen(80);
",theDude30,
812,2016-03-31 15:07:08,"@theDude30 hey man did you ever fix this? I appear to be having the same issue.
The below block works as intended and I'm seeing the console logs as expected. However, in the browser console I get a 404 error on the request that the proxy should kick in on. http://localhost:4000 is the url, when it should be http://dolly.testing.com as per my proxy setup below.
Proxy setup

<S_CODE_TOKEN>

proxy middleware function each request passes through:

<S_CODE_TOKEN>

Thanks,
Dave
",beazergood,
812,2016-03-31 18:09:35,"if you are using this as an a desktop network level proxy for accessing webpages through, try the `toProxy` option. I cannot discern from the information given HOW you are trying to use this and if the issues are even the same.
",jcrugzz,
812,2016-04-01 10:29:09,"@jcrugzz sorry for lack of detail, a bit out of my depth with all this. I will give that a go, thanks.
",beazergood,
811,2015-04-25 23:50:15,"Hi, I'm trying to get the proxy server to work but I'm having some troubles.

So just for testing, I have this little proxy server setup.

<S_CODE_TOKEN>

So pretty straightforward. What I would expect here is if I call `http://localhost:5050` I would get proxied to `https://api.github.com`.

<S_CODE_TOKEN>

And the server crashes with:

<S_CODE_TOKEN>

Now, if I try with 

<S_CODE_TOKEN>

I correctly get proxied to `google.com`, but if I try with

<S_CODE_TOKEN>

it doesn't

<S_CODE_TOKEN>

and server crashes with

<S_CODE_TOKEN>

Any idea what's going on or what am I doing wrong?
Thanks
",emmenko,
811,2015-04-26 00:14:53,"Ok, I actually made it work if I pass the target when I proxy the request instead of when I create the proxy server.

<S_CODE_TOKEN>
",emmenko,
810,2015-04-24 17:33:56,"I ran into an issue when trying to running grunt-connect-proxy which relies on http-proxy. Looks like http-proxy/index.js has this line:

EE3       = require('eventemitter3').EventEmitter,

Which sets EE3 to undefined. Changing it to this:

EE3       = require('eventemitter3'),

fixed the issue.
",cthorner,2015-04-24 17:42:38
810,2015-04-24 17:42:38,"@cthorner update to newest version which has this fix and has no breaking changes :)
",jcrugzz,2015-04-24 17:42:38
810,2015-04-28 18:34:02,"Thanks!
",cthorner,2015-04-24 17:42:38
809,2015-04-22 12:41:44,"Because of eventemmiter version change to 1.0.0 the ""Cannot read property 'prototype' of undefined"" error pops up when trying to run grunt build or grunt -v on project your library. Here is the listing:

<S_CODE_TOKEN>

http-proxy with eventemmiter version 0.1.6 works fine. As you can see I'm using grunt-connect-proxy which is using the http-proxy library, but as I mentioned eariler the problem is with eventemmiter3 dependency.
",mupakoz,2015-04-22 14:54:02
809,2015-04-22 13:02:33,"Equal error, http-proxy v.1.1.6.

In gulpfile.js:

<S_CODE_TOKEN>
",Kroid,2015-04-22 14:54:02
809,2015-04-22 13:09:54,"I am also using 1.1.6 version
",mupakoz,2015-04-22 14:54:02
809,2015-04-22 13:11:28,"Same
",jondubois,2015-04-22 14:54:02
809,2015-04-22 13:17:18,"Upgrading to 1.11.0 fixed the issue for me without apparent side effects.
",jondubois,2015-04-22 14:54:02
809,2015-04-22 13:32:54,"My problem's source was: https://github.com/drewzboto/grunt-connect-proxy/issues/95
",mupakoz,2015-04-22 14:54:02
809,2015-04-22 14:54:02,"Glad you guys found a solution! Not an issue currently as the dep is pinned so anyone seeing this now please use the latest version.
",jcrugzz,2015-04-22 14:54:02
809,2015-04-22 15:36:02,"@jondubois this is how semver is supposed to work! :smile: 
",jcrugzz,2015-04-22 14:54:02
809,2015-04-29 15:23:30,"Why wouldn't you tie a specific release version of http-proxy to more precise dependency versions? That would prevent this from happening in the future.
",joe-spanning,2015-04-22 14:54:02
809,2015-04-29 18:47:38,"@joe-spanning this is currently the case. A point in the past it was not properly versioned which caused this issue.
",jcrugzz,2015-04-22 14:54:02
808,2015-04-17 19:23:02,"Hi,

I' am trying to build a reverse proxy with expressjs and node-http-proxy.
UI and API Services should be dynamically mounted with expressjs and requests should be forwarded via node-http-proxy.

e.g.
UI: source.com/service/ui ---> sometarget.com/some/path/ui
API: source.com/service/api --->  othertarget.com/some/other/path/to/api

forward.js (middleware using node-http-proxy)

<S_CODE_TOKEN>

app.js (using expressjs)

<S_CODE_TOKEN>

**My problem**
One time api and ui request are forward correctly, but if I have an ui that has some link (a href='/internal/link/of/that/ui') following that link results in a Cannot GET '/internal/link/of/that/ui' because the '/service/ui/' is not prepended.

How can this be fixed? Do I need to ""regexp the response.body"" myself? if yes, how to do this? or is there some option I can provide to proxy.web()? 

Thank you very much in advance!
",pwasem,
808,2015-05-26 15:41:40,"Hi there,

I workaround this problem with playing with proxyRequest.path value like so

<S_CODE_TOKEN>
",tanaydin,
808,2015-06-24 22:25:28,"I've a similar scenario that you and I've just made this package to deal with that kind of requirements. 

Hope it could be useful in some or other way:
https://github.com/h2non/rocky
",h2non,
807,2015-04-16 20:40:08,"Really nice for development purposes would be the feature to use self signed certificates for proxied urls. Assume you develop a Java/.Net/PHP/Python app on backend and a Front End client running on node.js proxying requests to back-end. Backend uses self-signed certificates in development. So to be able proxy from http to https with self-signed cert we could use:

<S_CODE_TOKEN>
",EvgeniGordeev,
806,2015-04-13 18:53:28,"Document the option: ""headers"", as seen in existing example:
https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-http-to-https.js

This options will add provided map of headers to requests to target.
",chimurai,2016-02-16 23:05:28
806,2016-01-22 14:21:00,"@jcrugzz @indexzero 
Any plans to merge this PR?
",chimurai,2016-02-16 23:05:28
806,2016-02-16 22:56:57,"+1
",caseyWebb,2016-02-16 23:05:28
806,2016-02-16 23:05:39,"Sorry about that :+1:. Thanks for contributing!
",jcrugzz,2016-02-16 23:05:28
805,2015-04-13 10:05:15,"I use code below but when the proxy server and actual hosting server are not in same LAN, I can see the client connection to proxy for  files with size more than 1 MB goes to stale state and download rate is almost zero.
Any help on how to prevent this situation?
[code]
var httpProxy = require('http-proxy'),
        http = require('http');

var proxy = new httpProxy.createProxyServer({
  target: {
    host: 'abc.com',
    port: 80,
        hostname : 'abc.com',
protocol : 'http'
  },
  changeOrigin : true
});
proxy.listen(88);
var proxyServer = http.createServer(function (req, res) {
        req.headers['user-agent']=""mybot"";
  proxy.web(req, res);
});
[/code]
",asyncer,
805,2015-05-20 05:51:10,"Any help on this issue?
Anyone else seeing stale connection while using node-http-proxy ?
",asyncer,
805,2017-01-06 12:30:02,+1,trsrm,
804,2015-04-11 22:31:30,"Harmon/Trumpet allow you to replace HTML elements, but how do you insert elements?
",akshayl,
803,2015-04-09 09:20:38,"I want to proxy a POST.When I poxy this POST with upload file,I want to add some stream after the file,how to do it?thanks
",EricPoker,
802,2015-04-07 10:43:00,"I need to do some requests(eg. authorization) before proxying. Is there some api support as was before ?

<a href ='https://github.com/nodejitsu/node-http-proxy/issues/168'>https://github.com/nodejitsu/node-http-proxy/issues/168</a>
<code>proxy.buffer(req)</code>

Thanks.
",kovacspeter,2015-04-17 07:36:02
802,2015-04-07 18:07:53,"@kovacspeter Since node `0.10.x` buffering is built into streams so this is no longer necessary. You can do any async call before calling `proxy.web` as long as you don't need to read data from the `req` itself.
",jcrugzz,2015-04-17 07:36:02
802,2015-04-07 19:54:26,"I do need to read data request body. I use bodyParser + restreamer + connect as shown in example <a href='https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/bodyDecoder-middleware.js'>here</a>.  I read body and based on that on that I will send request(on database), depending on answer I will proxy request. Can you give me hand here and advise me how to do it?

Thanks.
",kovacspeter,2015-04-17 07:36:02
802,2015-04-17 07:35:47,"Its easy, you just need to restream it again. 
",kovacspeter,2015-04-17 07:36:02
802,2016-05-04 09:50:05,"@kovacspeter  i am in a similar situation can you please post working code , i didn't quite understood restreaming it again part . Any help would be greatly appreciated
",gvp-adityapraveen,2015-04-17 07:36:02
801,2015-04-06 14:26:01,"I can't find any documentation on this.
",srossross,2015-04-06 21:18:42
801,2015-04-06 21:18:42,"Sorry, I figured this out. 

<S_CODE_TOKEN>
",srossross,2015-04-06 21:18:42
800,2015-04-06 09:17:01,"I'm a newbie to `node-http-proxy` module.

**my aim**

I need to use the module provide multi-SSL for multi-subdomain.
For example; 
if a user call `process.localhost:1443` then I should route the call to `process.localhost:2443` and
if a user call `api.localhost:1443` then I should route the call to `api.localhost:3443`

**what's happening**

I wrote the below server.js codes. 
_If I change `httpProxy.createServer(options)` line with `httpProxy.createServer({target:'http://process.localhost:2443'})` then it works properly!_ <br>
Otherwise when I try to call `process.localhost:1443` I get the following error;<br>
`D:\Work Space\...\http-proxy\node_modules\requires-port\index.js:13`
  `protocol = protocol.split(':')[0];`
`TypeError: Cannot call method 'split' of undefined`

 `protocol` seems as `undefined`. 

<S_CODE_TOKEN>

What should I do? <br><br>

**server.js**

<S_CODE_TOKEN>
",efkan,2015-04-07 09:29:42
800,2015-04-06 18:44:49,"@efkan It's possible the source of your woes is `options.target` being an object that maps `target` string to `forward` string. The comment says it expects a string:
https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L33 
",damonmcminn,2015-04-07 09:29:42
800,2015-04-06 18:57:03,"Thank you very much,

I've spent 11 hours today but  I guess I have to spent much more time to learn the use. 
I'm studying on a regarding `target`and `forward` file.
https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/forward-and-target-proxy.js

I just want a simple conditional route operation.
If `api.mydomain.com:1443` is called route `api.mydomain.com:2443` 
and If `process.mydomain.com:1443` is called route `process.mydomain.com:2443`

Because I have to use only one port [iptables 443 -> 1443] for two different subdomains (with two certificates). But I couldn't the most basic this operation yet! 

Actually I read comment that you've indicated. But unfortunately I couldn't understand.
",efkan,2015-04-07 09:29:42
800,2015-04-07 07:30:43,"I've simplified my question and I added my new experiences..
",efkan,2015-04-07 09:29:42
800,2015-04-07 08:51:46,"@efkan It's necessary for you to write the logic yourself. For example:

<S_CODE_TOKEN>

I have had a similar use case, but using a single domain and the first path to identify where to proxy requests. You can read it here: https://github.com/damonmcminn/api-proxy
",damonmcminn,2015-04-07 09:29:42
800,2015-04-07 09:29:42,"Really thanks @damonmcminn :star2: !

I understood `http-proxy` module now conceptually. 
And your API-Proxy application will be a guide for me.

Thank you again for your helps..

**ps:** I got an error as `Must provide a proper URL as target` :sob: however _really it is not important_ now 
",efkan,2015-04-07 09:29:42
800,2015-04-07 09:37:13,"@efkan No problem!

The error is because `targets` do not have a protocol. Woops!
Change them for example: `process.localhost:2443 -> http://process.localhost:2443`
",damonmcminn,2015-04-07 09:29:42
800,2015-04-07 10:16:18,"Thank you again! You made my day!

Probably there is another problem with my codes or `http-proxy` or anything else. Because I added the protocol but console gives the same error.

It indicates;

<S_CODE_TOKEN>

and server.js line 56 is;
     `proxy.web(req, res, options); // errorCallback is optional`

and my targets are;

<S_CODE_TOKEN>
",efkan,2015-04-07 09:29:42
800,2015-04-07 10:24:12,"Your targets should be in this form:

<S_CODE_TOKEN>

This is because `req.headers.host` is a string that represents the domain (i.e. it is not a URL) which is used as a key to retrieve the target URL.

For example:

<S_CODE_TOKEN>

Does this make sense?
",damonmcminn,2015-04-07 09:29:42
800,2015-04-07 10:36:30,"I see, OK. Thank you again...

I checked it and I saw `req.headers.host` returns hostname with port number. So I added the port number and it solved thanks to you 

I owe you a coffee :smiley: 

`{ 'api.localhost:1443': 'http://api.localhost:3443' }`
",efkan,2015-04-07 09:29:42
800,2015-04-07 10:48:14,"No problem :)

On 7 April 2015 at 11:36, efkan notifications@github.com wrote:

> I see, OK. Thank you again...
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/nodejitsu/node-http-proxy/issues/800#issuecomment-90502801
> .

## 

{
  name: Damon McMinn,
  what: JavaScript developer,
  tel: 07473119510,
  links: [GitHub https://github.com/damonmcminn, self
http://damonmcminn.com/],
  location: London
}
",damonmcminn,2015-04-07 09:29:42
799,2015-04-02 12:35:30,"With node 0.12.2, `common.getPort` was always returning a default port `80` even for HTTPS connections, because `req.connection.pair` is undefined on this version of node.

Here is a fix, along with some fixes for the HTTPS tests. It has been tested with node 0.10.38 and node 0.12.2 on windows.
",Volune,2015-04-02 16:05:03
799,2015-04-02 16:05:01,"@Volune this LGTM. Thanks for the thorough fix :+1: 
",jcrugzz,2015-04-02 16:05:03
798,2015-04-01 12:29:34,"https://github.com/nodejitsu/node-http-proxy/issues/747

If `req.url` is an empty string, `url.parse(req.url).path`  is `null` and `common.urlJoin` will raise a `TypeError`.
",damonmcminn,2015-04-01 15:07:42
798,2015-04-01 15:07:30,"@damonmcminn whats the use case of making req.url an empty string out of curiosity? Thanks for the fix!
",jcrugzz,2015-04-01 15:07:42
798,2015-04-01 16:10:17,"fix in `1.9.1`
",jcrugzz,2015-04-01 15:07:42
798,2015-04-02 09:06:03,"@jcrugzz No problem! I don't believe there is a use case for an empty string... It was an accidental discovery when I changed a regex that is used to strip the first path from `req.url`:
https://github.com/damonmcminn/api-proxy/commit/7dda2413535c5d5c1be0f574dde8ee69cd827fa7

The stripped path is used to identify what server to proxy the request to (so I can serve multiple APIs off a single validated domain i.e. api.damonmcminn.com) e.g.:
`api.damonmcminn.com/nutrition/green-turtle => localhost:50000/green-turtle`

The original regex only matched when a trailing slash was present, so `req.url` would be rewritten thus `'/path/' => '/'` but as I wanted to match regardless of trailing slash, I was erroneously rewriting `'/path' => ''`.

I am no longer rewriting `req.url` to an empty string but provided the fix in case someone else inadvertently does (or wants to).
",damonmcminn,2015-04-01 15:07:42
797,2015-03-29 21:58:01,"I'm able to reproduce this error on an HTTPS proxy, running Ubuntu 14.04:

<S_CODE_TOKEN>

**Reproduction Steps:**
1. Run HTTPS proxy,
2. Enable WebSockets,
3. Run `siege https://myserver.whatever`,
4. CTRL+C and observer error on server.
",martindale,2015-04-06 18:06:26
797,2015-04-01 00:56:36,"I am getting the exact same error, but it is seems like it is a recent development.
",lsvx,2015-04-06 18:06:26
797,2015-04-06 18:05:19,"Definitely due to not catching the proxy's emitted errors. Adding a basic:

<S_CODE_TOKEN>

fixes the issue.
",lsvx,2015-04-06 18:06:26
797,2015-04-06 18:06:26,"Yeah, I fixed the same thing this morning.  Thanks!
",martindale,2015-04-06 18:06:26
797,2015-04-06 18:07:15,"Rock on!
",lsvx,2015-04-06 18:06:26
796,2015-03-25 14:21:42,"how to change the contents of html,when the page is received from proxy?
my aim is to add some html code to the page,when the page returns to client
the code is like followings:

<S_CODE_TOKEN>
",dabeike,
796,2015-03-26 08:46:30,"+1
",betlab,
796,2015-03-26 08:53:12,"I'm not at all sure what's the best way to do this, but this is a scrip we've used successfully to inject a script into a page.

<S_CODE_TOKEN>
",kokarn,
796,2015-06-30 14:06:59,"This solution must be modified to avoid the use of end( ... modify ) which uses implicilty the write() method which has been rerouted into collecting the chunks. So you finish having another chunk which is your own.

Fix:

<S_CODE_TOKEN>

...

<S_CODE_TOKEN>
",xtof78,
796,2015-11-22 10:07:02,"Question, I would like to do the same but for request. That's, before proxyng, I need to put an extra parameter to the body and after proxy the request. How can I do it?
",macscripter,
795,2015-03-20 15:28:45,"When the `target` of the following node-http-proxy server points to an origin that serves gzipped responses to clients sending `Accept-Encoding: gzip`, node-http-proxy prepends garbage bytes to the response causing decoding errors:

<S_CODE_TOKEN>

When `changeOrigin: true` is removed, the problem goes away, but we rely on keeping it there.

Can you confirm that this is a bug in node-http-proxy, and if so, give any pointers on how to fix it?

Thanks for taking a look and for the great work on node-http-proxy.
",requiredfield,
795,2015-03-20 19:30:27,"In case anyone else is hitting this and is looking for a workaround, stripping requests' `Accept-Encoding` header effectively disables gzip on the origin, avoiding the bug:

<S_CODE_TOKEN>
",requiredfield,
795,2015-03-20 20:12:45,"@requiredfield This is fascinating that this is only when `changeOrigin: true` option is used. Could you submit your example as a failing test so we can get started in finding the proper fix? 
",jcrugzz,
795,2015-03-21 01:57:30,"@jcrugzz  This only happens to some of our sites ,e.g.  set $origin = http://fw.m.pingfan.pw/ , only when set changeOrigin to true and enabled gzip encoding. The gzipped output body has been prepended  three  garbage bytes e.g. ""22f"" and ""\r\n"",total five bytes,that caused decoding error.If I strip these five bytes then it can be decoded correctly but missed the last five bytes,usually are ""html>"" .

PS: I've found `xfwd` option also affects the gzip output. When switch xfwd between true and false,the three garbage bytes varies.
",Behemouth,
795,2015-03-21 04:30:59,"@Behemouth hmm it has to be because the headers are changing, its not able to correctly gzip the entire request. This is something that I would definitely need to dig deeper into but would love some help. What node/io.js version are you using?
",jcrugzz,
795,2015-03-21 04:50:43,"Using latest release of Node (0.12.0) and latest release of node-http-proxy. Would it help if we tried older versions?

> On Mar 21, 2015, at 00:31, Jarrett Cruger notifications@github.com wrote:
> 
> @Behemouth hmm it has to be because the headers are changing, its not able to correctly gzip the entire request. This is something that I would definitely need to dig deeper into but would love some help. What node/io.js version are you using?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
",requiredfield,
795,2015-03-21 05:11:15,"@requiredfield yes I'd be interested to see if it represents the same behavior in `0.10.37` and I would also test [`io.js@1.6.1`](https://iojs.org/en/index.html) if you have the chance. I just know that node `0.12.0` has bugs so I want to eliminate that as a variable.
",jcrugzz,
795,2015-03-21 05:51:21,"@jcrugzz  

My Node.js version has this bug too:

<S_CODE_TOKEN>
",Behemouth,
794,2015-03-19 03:48:43,"I have a node-http-proxy-based proxy server running on Azure Websites at https://cdtwam49.azurewebsites.net (currently proxying to http://www.example.com), and it looks like there's an issue with gzip encoding.

This, for example, works:

<S_CODE_TOKEN>

But this does not:

<S_CODE_TOKEN>

When you hit the origin directly with the Accept-Encoding header, it works as expected:

<S_CODE_TOKEN>

See https://github.com/requiredfield/nodeproxytmpl for the code running at https://cdtwam49.azurewebsites.net. (Just imagine ""http://www.example.com"" interpolated into the ""%s"" in server.js.tmpl, and server.js.tmpl renamed server.js.)

Is this a bug in node-http-proxy? Somewhere in the interaction with Azure Websites? /me dusts off mnot's ever-true https://www.mnot.net/blog/2011/07/11/what_proxies_must_do and rolls up sleeves.

Thanks in advance for any insights.
",requiredfield,2015-03-19 04:27:52
794,2015-03-19 04:27:52,"Was neglecting to pass curl the `--compressed` option, so unfortunately my minimal reproduction example above is bogus. Still seeing an issue in my real deployment. Will be back with a better minimal reproduction if I can narrow one down.
",requiredfield,2015-03-19 04:27:52
793,2015-03-14 11:34:13,"Hi all, I'm sorry if this may sound stupid but I am still new to proxies and the techniques used in them...

I am having difficulty setting up a proxy with node-http-proxy that allows one to change a request header but at the same time allow the website to be viewed as it is live.

Until now all the examples I tried seem to re-direct the proxied request to a target server which is not what I want. Is there a way to just have a man in the middle proxy that still ends up serving you the targeted website?

Thank you for your help.
",zalow517,
793,2015-03-14 17:02:43,"@zalow517 code always helps with comments to explain the exact semantics you expect :). If you have a request come in to the proxy server, you will proxy the request to whatever target you specifiy. The proxy itself is always a mitm. I need more specifics to see whats going wrong and understand what you are trying to accomplish.
",jcrugzz,
792,2015-03-12 20:41:26,"On the basis of https://nodejs.org/api/https.html#https_https_request_options_callback
",ashubham,2015-03-12 22:58:06
792,2015-03-12 21:05:14,"It could use a test to ensure that the Authorization header is actually set instead of checking if the options are supplied. 
",3rd-Eden,2015-03-12 22:58:06
792,2015-03-12 22:58:04,"LGTM
",jcrugzz,2015-03-12 22:58:06
791,2015-03-11 16:04:59,"I am wondering is there anyway to use body parse before proxy request. Here is my scenario: 
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: false }));

proxy.on('proxyReq', function(proxyReq, req, res, options) {
    //Need to write custom logic to check for the parameter inside the body. -- so that it can add custom header or modify proxyReq body, etc...
    //for example: var userId = req.param(""userId"") -> this one only available with bodyParser declared   //before this one (see abover) 
});
app.all(route, function(req, res){ 
       //proxy request to target url
        return proxy.web(req, res, { target: config.localUrl + ""/api""}, function(e) {
            return res.json(501, e.stack || e.error || e);
        });
    });

The web application at target also uses its own bodyParser. But it seems that because the body parser being used twice, no response arrived after proxy the request to target.  I am wondering if there is any way to work around that issue? Thank.
",nguyenxuantuong,
790,2015-03-11 13:46:18,"To reach some `https` sites SSLv3 needs to be explicitly set. I don't get why because it's used by default, but it just does. In `curl` you can force this using the `-ssl3` flag (see below).

Can we make this proxy do the same?

---

Some sites cannot be reached e.g. using `curl`:

<S_CODE_TOKEN>

Yet all it takes is explicitly setting `SSLv3`:

<S_CODE_TOKEN>
",Redsandro,
789,2015-03-11 07:34:07,"The way to detect TLSSockets in node 0.12 and iojs has changed. You can
just check `socket.encrypted` now :)

Fixes #772
",feross,2015-03-12 01:07:38
789,2015-03-12 01:07:36,"@feross awesome thanks! :)
",jcrugzz,2015-03-12 01:07:38
788,2015-03-10 18:29:32,"Hello !
I have a problem when I'm trying to handle my error ""by hand"", for example:
`proxy.web(request, response, { target: 'http://127.0.0.1:8081' }, function(e) { response.end('Yolo'); });`
My webserver is running on the 8082 port and is calling an API on 8081.
When the API is answering an error (like 500 or 404), the callback function isn't called and I get a infinite loading.
How can I fix it ?

(I've tried to use `proxy.listen(8082)` and, then, proxy.on('error'). It works, but I really need to use proxy.web because the proxy is called in only one specific case)

Thanks !
",lonk,2015-03-14 21:58:52
787,2015-03-09 20:41:01,"- Add support for auto host rewriting and protocol rewriting
- Only rewrite URLs when the redirected host matches the original target
",matthauck,2015-04-01 16:20:37
787,2015-04-01 16:20:35,"LGTM.
",jcrugzz,2015-04-01 16:20:37
787,2015-04-01 17:45:50,"sweet, thanks!
",matthauck,2015-04-01 16:20:37
786,2015-03-07 10:49:09,"Hello! I would like to create a forward proxy that can filter our requests to certain restricted domains, but forward all other requests to the corresponding url in the internet and send the response back to the client - something like a web filter. Is this possible with this module? Couldn't find an example on the examples folder to do this. Is there any detailed documentation?
",ranode,
786,2015-04-20 09:28:31,"+1
I'm also confused about this, in my opinion, ""node-http-proxy"" is aiming at reverse proxy, but we are looking for a forward proxy module
",valaxy,
786,2015-08-10 04:57:50,"+1
",chbdetta,
786,2015-12-19 04:58:39,"I feel the same... all examples in node-http-proxy refer to hard-wired target URLs giving an indication that it is targeted as a reverse proxy. I did not see a single example anywhere of its use as a forward proxy. And when I tried, had all kinds of problems.
",n-samir,
786,2016-06-28 09:57:22,"Hi, a little late to the party but I am currently achieving this with the following code:

<S_CODE_TOKEN>

Unfortunately I am seeing some strange issues where CDNs are sending me 404s for certain files yet the requests from the proxy are identical to those coming from the browser - it's very odd.

*\* UPDATE: *\* I resolved the 404s, it appears some wierdness within the path config was causing a duplication of the path so `domain.com/path` was becoming `domain.com/path/path` adding the ignorePath config prevents this.
",Illizian,
785,2015-02-27 21:16:12,"Much of the documentation I have read has either been using the old api, using express and middleware, or it doesn't work.

I am suggesting producing a small code sample that uses `node-http-proxy` to re-route a POST request to another address using whatever chunking/buffering/response is simple and straightfoward.

I have read previous bugs on this proxy software and POST and I have not found it useful, personally. 
I am not familiar enough with `node-http-proxy` to do it myself or write up a patch. I solved my issue by utilizing the `request` module for POST and this software for GET. 

(I use plain `http` on nodejs and no middleware in my code.)

This documentation would be greatly appreciated! Thank you.
",NucleaPeon,
785,2015-12-20 21:19:27,"Hi,
I ended up doing exactly the same thing.
Can someone please give a clear example on how to handle POST?
Thanks
",hatembr,
784,2015-02-27 16:56:49,"Hi,

I would like to log to file the full http request and response, including the body. Is there a simple mechanism to do this? I have added a listener on 'proxyRes' but can not find the body of either the request or the response.

My purpose is to use this for debugging problems as well as to record data that can be used later in testing.

cheers,
Florian
",zenwork,
783,2015-02-27 09:55:54,"I use this module to implement a websocket proxy server. Normally after the websocket is established, the data flow is ""client -> proxy server -> target server"". And there will be two connections hold in proxy server, one is for client and another for target server.
However, when the websocket is not normally established, say the target server rejects the upgrade request with a 404, the connection between the proxy server and the client is closed. While the connection between the proxy server and target server is still hold even after the client process exits.
This is very dangerous!
I have this patch to fix this, but I'm  not sure if it is reasonable. Please help me to check it.
file: lib/http-proxy/passes/ws-incoming.js
line: 94
use:
if (!res.upgrade) {socket.end();this.abort();}
instead of:
if (!res.upgrade) socket.end();
",poxzlm,
782,2015-02-21 01:03:12,"I have an incoming request for `mydomain.com` which I want to proxy on the private network to `10.0.10.5`.

<S_CODE_TOKEN>

It fails with this error:

<S_CODE_TOKEN>

I find that a little weird because the certificate _does_ match _mydomain.com_. But for some reason it doesn't like that I'm accessing it as `10.0.10.5`. I would have thought that the fact that the `Host` header is set correctly to _mydomain.com_ would have made addressing it directly by IP not an issue.

However, if I manually edit `/etc/hosts` on the web-facing `mydomain.com` so that it sees `mydomain.com` as `10.0.10.5` like this, it works:

<S_CODE_TOKEN> javascript
<S_CODE_TOKEN>```

The best thing I can think of to do (aside from `secure: false`, which I do not want to do) is to give a subdomain `proxyable.mydomain.com` and on the server that receives the request I just strip out `proxyable` before the vhost middleware gets a chance to handle it (otherwise the json api might return strings with _proxyable.mydomain.com_ back out to the user and cause api problems in the web interface).

Is there an option that can be passed to tell it to verify against the Host header instead of the hostname?
",coolaj86,
782,2015-03-11 12:56:08,"I'm having same issue with node.js 0.12, it works fine on 0.10.33 and 35. I'm just proxy-ing http to https, without certs. 
",talamaska,
782,2015-03-11 16:21:09,"Check out [`ssl-root-cas`](https://github.com/coolaj86/node-ssl-root-cas). That along with including your intermediate CA in the ca array as an option to your server will probably work just fine.
",coolaj86,
782,2015-04-11 20:50:01,"Having the same issue. Using Node.js 0.12.2
",tamsler,
782,2015-07-14 08:31:43,"Please try to use 
var proxy = httpProxy.createProxyServer({secure:false});
",vovinh,
782,2015-12-07 19:48:33,"Any more thoughts on how to resolve this?  We just ran into this today after upgrading from 0.10 to 0.12.  :(
",jplock,
782,2015-12-07 20:04:34,"This issue is also causing me trouble. It seems the DNS name of my NodeJS application is being checked in the list of altnames in the upstream's certificate. This is a defect introduced between NodeJS 0.10 and 0.12.x
",russellballestrini,
782,2015-12-07 20:42:58,"@indutny any idea what could have caused this? Would love to know if its a bug in `http-proxy` that im not accounting for based on a node core change.
",jcrugzz,
782,2015-12-07 20:47:11,"@jcrugzz there are two options for `tls.connect`: `hostname` and `host`. Former one specifies TLS hostname, and the latter one DNS host to connect to. I suppose that `hostname` should be `mydomain.com` and `host` should be that IP address.
",indutny,
782,2015-12-07 20:54:13,"Thanks for the quick reply @indutny :), that makes a lot of sense. I'm guessing this check wasn't happening in 0.10 for whatever reason. I know you were optimizing a lot of TLS between then. Does this fix the issue you all are seeing? cc @coolaj86 @russellballestrini 
",jcrugzz,
782,2015-12-07 21:21:45,"The issue we saw was:

<S_CODE_TOKEN>

The issue only appears when switching to node v0.12.x and up. We only use `http-proxy` to proxy HTTPS->HTTPS websocket connections and we don't see this issue for the other portions of the application that use `hapi` and `h2o2`.
",dhm116,
782,2015-12-07 21:23:36,"So is the suggestion to define the proxy target using the `host` parameter instead of the `hostname`?
",dhm116,
782,2015-12-07 21:53:35,"Relevant parameters to the WS proxy call:

Request Headers:

<S_CODE_TOKEN>

Proxy options:

<S_CODE_TOKEN>
",dhm116,
782,2015-12-07 23:24:52,"@dhm116 The suggestion is that you may want to use the object form of `target` so you can specify the specific `host` as well as the `hostname` since the mismatch has to do with the `hostname`. When you `url.parse()` a string `target`, the host and hostname are derived from each other. 

If this does not work I would follow the suggestion of making sure you have the entire chain of `ca`'s necessary
",jcrugzz,
782,2015-12-08 01:20:20,"Thanks @jcrugzz, we'll try that out in the morning and follow up!
",dhm116,
782,2015-12-09 14:36:23,"@jcrugzz We were able to confirm that modifying the original request Host header value fixed our issue - changes to the target seemed to have no impact. :+1: Thanks!
",dhm116,
782,2016-05-24 03:41:11,"I came across this same issue in a different way.  We needed to specify our root CA in the outgoing requests because we had some new certificates whose root didn't appear to be in the Node.js default.  We ended up creating a new `https.Agent` with the `ca` set, and then passed it in the `createProxyServer` options, as we couldn't find any other place to specify the ca that would actually work.  We then started getting the Hostname/IP matching error until we set `changeOrigin: true` in the `createProxyServer` options

We never had any Hostname/IP matching issues before we started passing an agent in the options.   Anyone have an idea why that might be?
",archa347,
782,2016-08-16 23:28:06,"I'm having the same issue with http-proxy 1.14.0 and nodejs 6.3.1. It appears to be checking the hostname of the proxy (localhost) against the certificate of the proxy target (secure.gravatar.com)

<S_CODE_TOKEN>

<S_CODE_TOKEN>

Any ideas?

@russellballestrini
@indutny 
@jcrugzz 

Much appreciated :)
",aianus,
782,2016-08-17 00:11:59,"@aianus - sorry you are having trouble - @jplock and I opt'd to terminate TLS on our reverse proxy instead (nginx). Thus we no longer have this issue because we are no longer using NodeJS to deal with TLS.

As a result we were also able to gain an A+ on some TLS checkers.
",russellballestrini,
782,2016-08-17 00:57:17,"For anyone running into this in the future:

The fix was to set the `changeOrigin: true` flag in the proxy options.
",aianus,
782,2016-11-01 07:51:18,"Thanks @aianus  - That did it for me
",shaialon,
781,2015-02-20 14:11:12,"On some webpages css files are not loaded, because they have the wrong contet-type header. 
In the response of the proxy they have the value ""text/html"" instead of ""text/css"". I think the proxy overwrites this header field. The strange thing is that this does not happen on all websites. 
Here's my code:

<S_CODE_TOKEN>

An example for a webpage where this does not work ist http://www.kicker.de
",nikolaifischer,
780,2015-02-20 09:26:47,"If privacy is important during transit, then it is important during transit the whole way through (many a hack has been accomplished from the inside of ""safe"" networks).

The problem with self-signed certs is that most tutorials are incorrect - the blind leading the blind (I've written one of those myself back in the day).

However, I'd like to suggest linking to a working example of self-signed certs rather than discouraging them (because it's hard to justify a $30 cert on the ""inside"" of the network).

Here's an example I wrote, complete with article and screencast: https://github.com/coolaj86/nodejs-ssl-example

Or perhaps this example would be better: https://github.com/coolaj86/nodejs-self-signed-certificate-example
",coolaj86,2015-03-21 04:24:33
780,2015-03-20 19:54:39,"+1.
",EvgeniGordeev,2015-03-21 04:24:33
780,2015-03-20 20:08:09,"Self signed certs can be used without issue when using the `secure: false` option. Will definitely take a pull-request with docs if you feel strongly about it :).
",jcrugzz,2015-03-21 04:24:33
780,2015-03-20 21:34:02,"They can be used without issue using `secure: true` (if you simply provide the appropriate ca). It would be a very bad idea to do `secure: false` - kinda defeats the point of using certificates.
",coolaj86,2015-03-21 04:24:33
780,2015-03-21 04:24:33,"@coolaj86 Sure. Again a PR is more than welcome :). Closing as `docs`
",jcrugzz,2015-03-21 04:24:33
779,2015-02-19 23:30:17,"The following code successfully creates a reverse proxy server on localhost:8000 which reverse proxies to httpbin.org:

<S_CODE_TOKEN>

However, if you change http://httpbin.org to any CloudFlare-enabled site (including http://www.cloudflare.com itself), you get ""Error 1003 Direct IP access not allowed"". Is there some way to configure the proxy server so it can successfully front CloudFlare-enabled sites? Sorry if I'm missing something obvious.
",requiredfield,2015-02-19 23:36:14
779,2015-02-19 23:36:14,"Never mind, seem to have figured it out:

<S_CODE_TOKEN>
",requiredfield,2015-02-19 23:36:14
778,2015-02-19 16:18:01,"There seems to be some problem with the redirecting or parsing paths in the target url.
",swogger,
778,2015-02-24 07:03:18,"@swogger Could you show me code to reproduce what you are talking about? There shouldn't be any problem proxying to any website.
",jcrugzz,
777,2015-02-19 06:18:52,"When I upgraded to node v0.12.0, performing proxied PUT / POST requests gave errors like this:
node_modules/http-proxy/lib/http-proxy/index.js:119
    throw err;
          ^
Error: write after end
    at ClientRequest.OutgoingMessage.write (_http_outgoing.js:413:15)
    at IncomingMessage.ondata (_stream_readable.js:540:20)
    at IncomingMessage.emit (events.js:107:17)
    at /Users/bill/Source/LN/impactscore_client/node_modules/connect-restreamer/index.js:15:13
    at process._tickCallback (node.js:355:11)

Rolling back to node v0.10.36, everything is working fine.
",billmccord,
777,2015-02-21 16:34:09,"Same here, from atom-shell, i think same node version

<S_CODE_TOKEN>
",diimdeep,
777,2015-03-26 09:41:50,"hi guys,

i having the same problem 
have you managed to solve the problem ?
",shlomihassan,
777,2015-04-14 19:46:39,"I'd love to have a failing test case added in tests so we can get this resolved. 
",jcrugzz,
777,2015-07-09 01:04:01,"I had the same problem with connect-restreamer.  I found a fix ([https://github.com/dominictarr/connect-restreamer/issues/8]).  Not the best solution, but it works for me :)
",leejefon,
777,2015-07-30 19:30:44,"I came across the same error message in code not using `node-http-proxy`. Not sure if this helps you guys, but what caused this bug in my case was `http.get` being used instead of `http.request` for POST requests. Seems like it was an alias in Node 0.10 but the behavior changed in 0.12. Replacing `http.get` with `http.request` fixed it for me.
",trustmaster,
776,2015-02-17 19:10:48,"{ [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }

<S_CODE_TOKEN>
",mike-aungsan,
776,2015-02-17 22:01:34,"@mike-aungsan this is not a bug, the endpoint you were proxying to timed out and it was logged exactly how you expected in the code. You may want to handle the error in these cases to your client via something like [this](https://github.com/jcrugzz/proxy-server/blob/master/index.js#L53-L65).

If you have an actual question or concern please note that when you submit an issue.
",jcrugzz,
776,2015-02-17 22:34:07,"It was working fine and it stop working. The issue might come from dependencies or from the update version.

Another concern that I have is that, there is http_proxy in the network env. 
By default, all the http request are routed tho http_proxy.
But the target host is not behind proxy. So the target host is in no_proxy list and also in browser ignore proxy list.

In this case, my guest is that http-proxy is ignore no_proxy list and ignore proxy list.

P.S Not good at writing. Hope you get it.
",mike-aungsan,
776,2015-02-17 23:34:18,"@mike-aungsan Can you answer these questions for me?
1. What version did you update from?
2. What dependencies did you update?

`http-proxy` does not read anything from the environment when making its proxy decisions. You provide the target to it explicitly. If there are cases that require http_proxy env variable, you will need to use something like [`node-tunnel`](https://github.com/koichik/node-tunnel), but if it worked before, idk what to tell you with the information you have given.
",jcrugzz,
776,2015-10-28 20:38:42,"I have a similar an error, I can see this since I updated to NodeJS4, the proxy sometimes returns data and other times this returns  { [Error: connect ETIMEDOUT] code: 'ETIMEDOUT', errno: 'ETIMEDOUT', syscall: 'connect' }, Does http-proxy have support for NodeJS4?
",wmanriques,
775,2015-02-15 08:25:45,"If an url contains multiple slashes like /test**_//**_test2 it will be automatically converted to /test**_/**_test2 before proxing.

Is this a bug or feature? 
If it's a feature, is it possible to disable this? :-)
",luke-,
775,2015-02-15 09:05:18,"I changed

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L82

to

<S_CODE_TOKEN>

Now it works for me, but I think the problem still exists when prependPath is enabled.
",luke-,
775,2015-02-17 17:36:40,"@luke- There are some old issues where we had a lot of people complaining about double slashes which is why the urlJoin method was created. Could you give me the example your using which currently fails? I'd like to cover all the cases as cleanly as possible. Showing me in the form of a test case would be great :smile: 
",jcrugzz,
775,2015-02-19 14:14:36,"@jcrugzz Imo the the proxy itself shouldn't modify the url, also when it's strange :-) My problem was related to a web app which uses path style parameters e.g.http://example.com/controller/action/param1/value1/param2/value2 if value1 is empty in a special case the produced url was http://example.com/controller/action/param1//param2/value2 which couldn't proxied.
",luke-,
775,2015-06-25 16:44:32,"Another problem is that `url.parse('http://something.com/foo/bar?next_url=http://something.com/baz')` results in:

<S_CODE_TOKEN>

Notice that the path contains the querystring. The logic that does double slash replacement mucks up the `http://` in the querystring and turns it into `http:/`.

[RFC-3986 section on Query](http://tools.ietf.org/html/rfc3986#section-3.4) states that / is an allowed character in the query string so it does not need to be percent escaped. The replace code in question should not touch these slashes.
",parente,
775,2015-06-25 16:48:52,"@parente if you can wire up a failing test for me in the tests ill take a stab at making this work for all cases
",jcrugzz,
775,2015-06-28 01:06:21,"I'll take a crack at a test. I do need to amend my comment above, however: the code does special case the correction of `://` in the query string after replacing `//` to `/`. But other cases like `comment=//testing` will still break.
",parente,
774,2015-02-12 17:17:16,"It would be nice if one could easily use the module to proxy not just for one target, but for any target the incoming connection requests. I.e. do normal web cache behaviour, not reverse proxying. Here is a setup to do so. Since several examples in the README use `{}` as the configuration, i.e. without `target` or `forward` setting, these examples will currently fail. With my addition, they will work and simply forward the requests.

Perhaps you might want to make people aware that proxying without a fixed target and without a bind restriction to localhost, any incoming request might query pages from the local LAN or even localhost. Depending on configuration, that may or may not be a security issue. If you consider this an issue, write examples in such a way that copying them will work (or fail due to an invented domain name) but will not cause such security problems.
",gagern,
774,2015-04-01 16:15:08,"I'm not sure I understand the use case. If you are not proxying to a particular target, why the extra request overhead? Could you elaborate? Also please point out any examples that do not function :). All of them seem to specify a target in the constructor (for only proxying to one place) or in `proxy.web` where you can specify a target only using 1 instance.
",jcrugzz,
774,2015-04-01 18:41:59,"My use case was the following: I had some JavaScript deployed at a client's site, and wanted to try a newer development version in that environment. So I configured my browser to use a local proxy, and wrote that proxy such that it forwards all requests _except_ for those matching a specific regular expression, which were served from a local file instead. The problem is that the moment I configure my browser to use that process as a proxy, _all_ my web traffic goes through it, which is annoying if I want to look up some documentation while experimenting with the modified environment.

The way I did this was using `proxy.web(req, res, {target:req.url, prependPath:false})`. So yes, if you take `proxy.web` arguments into account, it seems that the `README.md` is more correct than it appeared to me. Sorry for the false alarm there. I guess I mixed some parts which were not intended to be mixed. If you don't want to merge my branch, then perhaps you should at least document the fact that a line like the one I mentioned will make the proxy behave like a web cache, forwarding any request it receives. It took me quite a while to work that out.
",gagern,
774,2015-12-01 08:15:21,"This is what situation i face: i'm a browser kernel developer from Lenovo, sometimes a specific page renders broken, we need to investigate the reason: whether it is some js file execution fails?

So i need to deploy a local http proxy server scripts, and forward all the requests to external web sites, except the hesitated js file request, which i will use a local served modified version.

I found https://github.com/substack/bouncy, but it is only used for load-balancing, hope http-proxy can support this feature, currently it seems not being able to deal with chunked-encoding?
",chenzx,
774,2016-01-20 20:51:12,"> If you don't want to merge my branch, then perhaps you should at least document the fact that a line like the one I mentioned will make the proxy behave like a web cache

+1 for closing this PR and making it clearer in the docs that `target` is optional in the `createProxyServer()` options and that it can be passed in to `proxy.web()`. Like @gagern, I thought `target` was required; it took me a while to discover it could be generated dynamically and passed to `proxy.web()` for each request.
",prust,
774,2016-01-20 22:21:15,"@prust Would happily accept a PR with updated Docs :+1: 
",jcrugzz,
773,2015-02-11 18:46:02,"After reading the docs and examples, the purpose and distinction between `forward` and `target` is still not clear to me (including `forward-and-target-proxy.js` example - I can't tell what this is actually demonstrating).  After implementing a very simple single-step `target` proxy behind Express, I wanted to place a transparent forward proxy in between Node and backend server in order to cache some large, expensive API requests.  I was not successful with any permutation of `forward` or `target` options.  My intuition was that `target` would be used to ""fix up"" the outbound request (`setupOutgoing`), while `forward` would be the immediate server to hand off to (the local caching proxy).  It appears that `changeOrigin` will use the `forward` host, not the `target` host.  This is likely due to logic in `stream` and `setupOutgoing` that appears to modify the request for both cases.  I'm not sure I understand the precedence of the piping.  Also `forward` will not convert a relative path request to an absolute URL request required by an upstream transparent HTTP proxy.

It would be nice to have a some more docs on how to use `forward` and `target` in combination or separately, and whether handoff to transparent proxy is supported out of the box (e.g. inference from combination of `forward` and `target` would be nice).

I managed to manually perform these fixups when in 'transparent handoff' mode as advised on StackOverflow:

<S_CODE_TOKEN>
",ahamid,
773,2015-04-07 06:28:53,"Citation from **damonmcminn**'s an answer;

<S_CODE_TOKEN>
",efkan,
773,2015-12-01 12:44:23,"+1, the documentation should definitely explain the difference between `target` and `forward`.
",eladnava,
773,2016-01-20 21:15:35,"+1 on putting this:

<S_CODE_TOKEN>

in the readme.
",prust,
772,2015-02-11 02:55:34,"I upgraded node to 0.12.0 and it looks like the https detection logic isn't working any more.

It looks like the issue is on line 70 of /lib/http-proxy/passes/web-incoming.js: req.connection.pair is evaluating to undefined even though it's an https connection.

I'm creating a server like so:

<S_CODE_TOKEN>
",jphaas,2015-03-12 01:07:38
772,2015-02-11 05:27:45,"@jphaas Ill see what the right thing to do is now and start testing on 0.12 so we can see that status. Thanks for the report
",jcrugzz,2015-03-12 01:07:38
772,2015-03-11 07:10:20,"This is confirmed on iojs 1.5.1 as well.
",feross,2015-03-12 01:07:38
772,2015-03-11 07:34:47,"Just sent a PR to fix this issue: https://github.com/nodejitsu/node-http-proxy/pull/789
",feross,2015-03-12 01:07:38
771,2015-02-10 01:16:13,"Is there a way to proxy a server running on another local IP instead of using http? It seems to be a bit of a performance implication.

Thank you
",btmdave,2015-02-10 02:52:22
771,2015-02-10 02:26:50,"@btmdave I'm not sure if I understand your question, could you give an example ideally with code? You can proxy to a local IP address (usually localhost) listening on a different port with no issue. If you are trying to proxy over a protocol that is not `http`, you have found the wrong module.
",jcrugzz,2015-02-10 02:52:22
771,2015-02-10 02:52:22,"Sorry, my mistake, local ip works fine.
",btmdave,2015-02-10 02:52:22
770,2015-02-05 20:20:38,"auto host rewriting allows rewriting to work as expected in most
cases without extra cumbersome configuration

protocol rewriting allows node-http-proxy to be able to listen
over HTTPS and properly reverse-proxy to sites running over HTTP
(to avoid doing SSL twice)
",matthauck,2015-03-09 20:39:58
770,2015-03-09 20:39:58,"cancelling. going to resubmit from other account.
",matthauck,2015-03-09 20:39:58
769,2015-01-31 13:09:03,"Hi,

I need to do following and wondered if it's possible to do using your library.
1. Proxy all http/https requests transparently no MITM
2. Perform a simple background check for either the http or https url's based on the host name
3. If certain conditions are met redirect the url
4. If conditions not met transparently proxy all traffic especially https, again no MITM

Best regards,
",carlskii,
769,2017-02-10 15:36:24,Did you figure out how to do this @carlskii ,Jonovono,
768,2015-01-30 21:00:48,"If I listen on :8000 and target different.domain:8000 it works fine. But if I listen on :3003 and target different.domain:8000, I get:

<S_CODE_TOKEN>

I can get it to work by manually modifying `req.headers.host` to have the same port as the target port before sending on to the proxy but isn't there a better way?
",glortho,2015-02-02 14:23:15
768,2015-01-31 03:04:09,"@jedverity you can use the [`changeOrigin`](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L43) that is passed when you instantiate the proxy
",jcrugzz,2015-02-02 14:23:15
768,2015-02-02 14:23:15,"Excellent thank you @jcrugzz .
",glortho,2015-02-02 14:23:15
767,2015-01-27 16:48:43,"I'm running several express apps via this proxy. But http://www.webpagetest.org/ test complains about `Keep-Alive not Enabled`. I assume that it's an issue with proxy, is there a way to enable keep-alive?
",voronianski,2015-01-27 18:47:36
767,2015-01-27 17:42:37,"@voronianski use something like [`keep-alive-agent`](https://github.com/ceejbot/keep-alive-agent) or [`agentkeepalive`](https://github.com/node-modules/agentkeepalive) or even the standard `http.Agent`. Just make sure you pass in `maxSockets: 100(+)`

For a why explanation...

We default to `connection: close` when there is no `agent` passed in to work around a bug in node core when we set `agent: false`. We default to setting `agent: false` to begin with as it enables the operating system itself to handle the number of sockets that get opened.
",jcrugzz,2015-01-27 18:47:36
767,2015-01-27 18:47:36,"Marked as FAQ and closing. Let me know if there are any more questions on this.
",jcrugzz,2015-01-27 18:47:36
767,2015-01-27 20:00:24,"@jcrugzz could you help with the right place to add the agent? 

From the docs I see that it's used in `http.request` options, but how it could be passed on http create server?

<S_CODE_TOKEN>
",voronianski,2015-01-27 18:47:36
767,2015-01-27 20:23:56,"@voronianski its one of the options you pass into the `http-proxy` constructor. So you would change the above to...

<S_CODE_TOKEN>
",jcrugzz,2015-01-27 18:47:36
767,2015-01-27 21:58:47,"@jcrugzz thanks!
",voronianski,2015-01-27 18:47:36
767,2015-02-26 04:04:26,"@jcrugzz, I'm trying to wrap my head around why one would want to specify `maxSockets`? It seems that it is not a `maxSockets` value which is making connection to change to 'keep-alive'. It is enough to just have http.Agent instance. I tried to debug core http module, but stuck on what exactly is causing it to pick keepAlive setting even when it is not set to true on the agent instance. Can you please give me a hint? Thanks.
",szarouski,2015-01-27 18:47:36
767,2015-02-27 01:01:09,"@szarouski this is because the default `maxSockets` value is `5` which is insanely low and not recommended for production use at all. The agent itself is in charge of handling `keep-alive`
",jcrugzz,2015-01-27 18:47:36
767,2015-02-27 13:39:32,"Oh I see. It [changed](http://nodejs.org/docs/v0.11.6/api/http.html#http_agent_maxsockets) at v0.11.6 to `Infinity`. It is a bit confusing that agent will maintain keep-alive even if `keepAlive` property was never set and therefor is set by default to `false`.
",szarouski,2015-01-27 18:47:36
766,2015-01-27 05:51:19,"I've been trying different things for about a week now. I'm using http-proxy to proxy web sockets to socket.io. I've tried several different ways to restructure this, and I'm just completely out of ideas. Is request being loaded into memory when I set a header and not being released when the socket disconnects? My socket.io server never goes above 150MB, yet this code seems to reach around 300-350mb after about 6-8 hours or so. Has anyone else had a similar issue and can offer some sort of advice? I really need a web socket proxy that I can use logic with (and node is perfect..), but if this high memory usage keeps climbing at the rate it does, I'm going to have to scrap this project.

<S_CODE_TOKEN>

After reading the docs one more time, I noticed there's a close event for proxies.
Should I be doing something within the close event?
such as:

<S_CODE_TOKEN>

Any help would be greatly appreciated.
",Mewte,2015-01-27 15:28:13
766,2015-01-27 15:06:55,"@Mewte hmm this might be something specific to websocket proxying but this still seems odd. @goldfire have you seen anything like this? @3rd-Eden do you have any ideas? Could socket.io somehow cause a leak on the proxy level? Im very interested to see where the issue lies. Could you also list what node version you are using? I'd recommend the latest `0.10.35`.
",jcrugzz,2015-01-27 15:28:13
766,2015-01-27 15:28:13,"@jcrugzz Thanks for the response, after further running for 10 hours, the memory usage has stabilized at around 135-150mb. Previously I was doing 

<S_CODE_TOKEN>

inside the proxyServer web request, which I think was causing the memory leak. After moving it to the proxyReq event (as seen in my first post) it seems to be fine. (I must have forgot to git pull on the server I was testing on) Thanks for your help!
",Mewte,2015-01-27 15:28:13
766,2015-01-27 15:57:40,"@Mewte glad to hear it and no problem!
",jcrugzz,2015-01-27 15:28:13
765,2015-01-22 17:24:23,"I get the following error when i try to use a simple HTTPS -> HTTP proxy same as sample code in main page
It works fine at first, but the exception gets throw after 5-6 https requests.

> v0.10.33
> _stream_readable.js:748
>     throw new Error('Cannot switch to old mode now.');
>           ^
> Error: Cannot switch to old mode now.
>     at emitDataEvents (_stream_readable.js:748:11)
>     at IncomingMessage.Readable.pause (_stream_readable.js:739:3)
>     at IncomingMessage.ondata (/home/nodejs/cache/node_modules/http-stale-cache-proxy/node_modules/http-proxy/lib/node-http-proxy/http-proxy.js:361:20)
>     at IncomingMessage.emit (events.js:95:17)
>     at flow (_stream_readable.js:614:9)
>     at IncomingMessage.pipeOnReadable (_stream_readable.js:642:5)
>     at IncomingMessage.emit (events.js:92:17)
>     at emitReadable_ (_stream_readable.js:426:10)
>     at emitReadable (_stream_readable.js:422:5)
>     at readableAddChunk (_stream_readable.js:165:9)

but there is no problem when node is downgraded to v0.8.28
I think that it may be an incompatibility issue with node v0.10

There is also a [related issue](https://github.com/componentjs/component/issues/364) that may help.
",faridz88,2015-01-29 19:32:45
765,2015-01-22 21:27:30,"@faridz88 are you using version `1.x.x`?
",jcrugzz,2015-01-29 19:32:45
765,2015-01-23 09:23:58,"Yes, I am currently using http-proxy@1.8.1
The other error when not using [http-stale-cache-proxy](https://www.npmjs.com/package/http-stale-cache-proxy) as my http webserver:

> /home/nodejs/cache/node_modules/http-proxy/lib/http-proxy/index.js:119
>     throw err;
>           ^
> Error: socket hang up
>     at createHangUpError (http.js:1477:15)
>     at Socket.socketCloseListener (http.js:1527:23)
>     at Socket.emit (events.js:95:17)
>     at TCP.close (net.js:466:12)

My Code:

<S_CODE_TOKEN>
",faridz88,2015-01-29 19:32:45
765,2015-01-23 09:29:38,"The problem is that you don't handle errors first and foremost.

Here's an example of some REALLY basic error handling

<S_CODE_TOKEN>

and [here](http://stackoverflow.com/questions/10814481/how-to-debug-a-socket-hang-up-error-in-nodejs) is a good answer on SO about it.
",kokarn,2015-01-29 19:32:45
765,2015-01-23 20:09:48,"@faridz88 your first error was from using  `http-stale-cache-proxy` which uses an old version of `node-http-proxy` that does not work on `0.10.x` properly. The second error is related to the remote server you are proxying to breaking the socket connection. An example of how to handle errors in these cases is [here](https://github.com/jcrugzz/proxy-server/blob/master/index.js#L53-L65)
",jcrugzz,2015-01-29 19:32:45
765,2015-01-27 06:24:22,"@jcrugzz You are right. I'l discuss the first error on `http-stale-cache-proxy`'s  page and the second error has been handled properly.
Thanks a lot.
",faridz88,2015-01-29 19:32:45
765,2015-01-29 07:03:22,"Unfortunately the problem has not been solved yet. And as i see `http-stale-cache-proxy` is using `node-http-proxy ""0.10.4""`

P.S I used npm to install `http-stale-cache-proxy` and it installed this version here `./node_modules/http-stale-cache-proxy/node_modules/http-proxy`
",faridz88,2015-01-29 19:32:45
765,2015-01-29 19:32:45,"@faridz88 its using an OLD version of `http-proxy` that does not run on `node 0.10.x` or later. it can only be used on `0.8.x`.
",jcrugzz,2015-01-29 19:32:45
765,2015-01-29 19:33:13,"So http-stale-cache-proxy would need to upgrade to the newest version if it wants to support node `0.10.x`
",jcrugzz,2015-01-29 19:32:45
764,2015-01-20 14:32:18,"<S_CODE_TOKEN>

works well but 

<S_CODE_TOKEN>

can't work, and no error log. can someone help me to solve this problem
",xiaok,2015-01-21 16:29:24
764,2015-01-20 17:34:36,"@xiaok can you turn this into a failing test? it should not matter if you are doing anything asynchronous before proxying if you are running on `0.10.x`+. 
",jcrugzz,2015-01-21 16:29:24
764,2015-01-21 03:11:27,"@jcrugzz very strange, when I removed ""server.use(express.limit('5mb'))"" , the proxy worked well.
",xiaok,2015-01-21 16:29:24
764,2015-01-21 16:29:24,"@xiaok this is due to the middleware in question buffering the entire stream into memory in order to assess the length. This breaks the proxy as the request stream you are trying to proxy no longer has any data in it.
",jcrugzz,2015-01-21 16:29:24
763,2015-01-19 09:15:50,"After upgrading from 10.3. I can no longer get websockets to proxy.

Following the advice of this page.

http://blog.nodejitsu.com/node-http-proxy-1dot0/
ProxyTable API
I have the following setup
var routes = {  
  'foo.com': 'website.com:8001',
  'bar.com': 'website2.com:8002'
}
http.createServer(function(req, res) {
    var host = routes[req.headers.host];
    if(host){
        proxy.web(req, res, {
            target: ""http://""+host,
            xfwd : true
        });
    }
}).listen(port);

In the previous version I did not have to provide a protocol in the target url.
Now, unless I do so the server will crash.
What I want to do is target all protocols to the matching host in the route table.

I hope my explanation makes some sense.
",bazjapan,
762,2015-01-12 00:20:37,"This line https://github.com/nodejitsu/node-http-proxy/blob/9ece52fac4b232aeeb8443f3d983107b2af22ed1/lib/http-proxy/passes/web-incoming.js#L70 assumes that if a request has a `isSpdy` flag on that is set to `true` then the connection was mode over TLS/SSL and thus the  protocol is set to `https`.

SPDY doesn't have to be over TLS when it's operating in PLAIN mode.
",sandfox,
761,2015-01-04 05:54:42,"Simple case: I have app1 - which is an install of ghost (`site-blog.herokuapp.com`). I have app2, which is a custom express.js app (`site.herokuapp.com`).

I want to serve the blog from `site.herokuapp.com/blog`.

For Ghost, here's part of my `config.js`

<S_CODE_TOKEN>

`BLOG_IDENTIFIER_URL` is set to `site.herokuapp.com/blog`.

For the express.js app, I have the following routing (for `/blog`):

<S_CODE_TOKEN>

This works absolutely fine locally, but when I push both the repos to heroku, and try to visit `site.herokuapp.com/blog`, I get just a blank page and nothing in the logs. The request fails though:

![Imgur](http://i.imgur.com/PkIGpKV.png?1)

I have tried a lot of stuff, both from SO and from the rest of the visible internet. Nothing seems to work. I'm stuck here for the last 4 hours. If you have anything that might help, please please leave a comment or an answer.
",karan,
761,2015-04-01 09:25:34,"Have you managed to get this to work? Same issue here..
",arturkiulian,
761,2015-04-01 14:06:11,"Nope.
",karan,
761,2015-04-01 15:11:17,"@Karan is there a `bodyParser` in the middleware chain somewhere? the proxy needs to happen before that if there is. See if thats the issue first. My only other thought is that it has to do with how heroku does their host based routing
",jcrugzz,
760,2015-01-02 15:00:06,"Multiple attempts to proxy multi-part using both the browser and curl.  

Might be something really small but cannot seem to figure it out.  The curl command sends the expect header and the browser does not.  However, both do not proxy the request.   Might be easier to see the first issue with the curl command and then narrow the issue down for the browser.

Curl command
curl -v --upload-file ./cam_espn.jpg  http://127.0.0.1:3000/todkap%40us.ibm.com/cam_espn5.jpg

Output
todkapmacbookpro:bluemix_objectstorage_bug todd$ curl -v --upload-file ./cam_espn.jpg  http://127.0.0.1:3000/todkap%40us.ibm.com/cam_espn5.jpg
- Hostname was NOT found in DNS cache
-   Trying 127.0.0.1...
- Connected to 127.0.0.1 (127.0.0.1) port 3000 (#0)
  > PUT /todkap%40us.ibm.com/cam_espn5.jpg HTTP/1.1
  > User-Agent: curl/7.37.1
  > Host: 127.0.0.1:3000
  > Accept: _/_
  > Content-Length: 197616
  > Expect: 100-continue
  > 
  < HTTP/1.1 100 Continue
  < HTTP/1.1 100 Continue
- We are completely uploaded and fine
  < HTTP/1.1 404 Not Found
  < X-Powered-By: Express
  < SkipProxyWeb: true
  < X-Content-Type-Options: nosniff
  < Content-Type: text/html; charset=utf-8
  < Content-Length: 46
  < Date: Fri, 02 Jan 2015 14:55:39 GMT
  < Connection: keep-alive
  < 
  Cannot PUT /todkap%40us.ibm.com/cam_espn5.jpg
- Connection #0 to host 127.0.0.1 left intact

Node script
todkapmacbookpro:bluemix_objectstorage_bug todd$ cat app.js 

<S_CODE_TOKEN>

Server side log
Logging inbound request PUT /todkap%40us.ibm.com/cam_espn5.jpg
request body {}
request files {}
request had an expect in it... skip proxy call
",todkap,
760,2015-01-02 15:06:23,"Main areas of confusion are..
1) How do deal with 100 Continue when it appears that express supports this inherently.
2) Do you need to have a mutli-part form parser (such as multer) for simple proxy scenarios or can I just populate the request body and pass this in the buffer for the proxy API call
3) Can I still use the connect-restreamer?

There are lots of docs out there via google searches but most of the content predates the express connect redesign that happened last year.
",todkap,
760,2015-01-02 16:21:16,"@todkap 
1. Check the node [docs](http://nodejs.org/api/http.html#http_event_checkcontinue)
2. If the server you are proxying to is handling the actual form data (not your proxy server), you only need to parse it with that destination server. You can avoid the dance with the multi-part parser in the proxy itself
3. If 2 is true, then there would be no need for `connect-restreamer`. 

Otherwise the code looks like it would behave appropriately but your test case did not even test if it did.
",jcrugzz,
760,2015-01-02 16:29:05,"Let me simplify this scenario a bit then since I think we are headed in 
the right direction (note i layered in multer and connect-restreamer after 
hitting many issues).

Here is the updated code.  I have removed the checks for the continue 
since as you note, Node should be handling this for me.  The moment I try 
to do this with a request that has an expect header, I get an immediate 
exception about unable to set headers.   There must be some strange timing 
window here (note this is just a single command line client so no 
threading issues should exist).

Console Output
Example app listening at http://0.0.0.0:3000
Logging inbound request PUT /todkap%40us.ibm.com/cam_espn5.jpg
request body undefined
request files undefined
RAW request headers from client {
  ""user-agent"": ""curl/7.37.1"",
  ""host"": ""127.0.0.1:3000"",
  ""accept"": ""_/_"",
  ""content-length"": ""197616"",
  ""expect"": ""100-continue""
}

http.js:689
    throw new Error('Can\'t set headers after they are sent.');
          ^
Error: Can't set headers after they are sent.
    at ClientRequest.OutgoingMessage.setHeader (http.js:689:11)
    at ProxyServer.app.use.proxyURL 
(/Users/todd/Documents/workspace/mobilecloudsamples/bluemix_objectstorage_bug/app.js:17:13)
    at ProxyServer.emit 
(/Users/todd/Documents/workspace/mobilecloudsamples/bluemix_objectstorage_bug/node_modules/http-proxy/node_modules/eventemitter3/index.js:75:35)
    at ClientRequest.<anonymous> 
(/Users/todd/Documents/workspace/mobilecloudsamples/bluemix_objectstorage_bug/node_modules/http-proxy/lib/http-proxy/passes/web-incoming.js:113:27)
    at ClientRequest.emit (events.js:117:20)
    at http.js:1762:9
    at process._tickCallback (node.js:419:13)

thanks!
todd

todd kaplinger
STSM, Mobile Cloud Platform Architect (IBM MobileFirst for iOS)
ibm master inventor

From:   Jarrett Cruger notifications@github.com
To:     nodejitsu/node-http-proxy node-http-proxy@noreply.github.com
Cc:     Todd Kaplinger/Durham/IBM@IBMUS
Date:   01/02/2015 11:21 AM
Subject:        Re: [node-http-proxy] Unable to proxy multi-part form 
(#760)

@todkap 
1.      Check the node docs 
2.      If the server you are proxying to is handling the actual form data 
(not your proxy server), you only need to parse it with that destination 
server. You can avoid the dance with the multi-part parser in the proxy 
itself
3.      If 2 is true, then there would be no need for connect-restreamer. 
Otherwise the code looks like it would behave appropriately but your test 
case did not even test if it did.
‚Äî
Reply to this email directly or view it on GitHub.
",todkap,
760,2015-01-02 16:47:12,"Well it seems because the middleware stack is still executing, even if it does send the 100 response automatically you need to handle the case because it won't stop the middleware chain. I also have no idea where the error is coming from in your code so I can't point out exactly whats wrong. But you are probably doing a `res.setHeader` after you have already sent the response or the `http-proxy` logic was given a request and response where the response had already been replied to (this is kind of my feeling with the middleware chain still executing). I'd keep digging into this problem and open an issue if you find a bug in `http-proxy` but this just seems to be an implementation issue atm. Stackoverflow will be a good place to post next if you can't figure it out :). Good luck!
",jcrugzz,
760,2015-01-02 17:09:34,"I do not mind going to stack overflow.  There must be something strange 
here since the failure to set the header is on the ""REQUEST\* not the 
response and is happening in htis method.    Do you not have testcases for 
multi-part form?

// Append Swift security token to all proxied outbound calls
proxy.on('proxyReq', function(proxiedReq, req, res, options) {
        console.log('RAW request headers from client', 
JSON.stringify(req.headers, true, 2));
        proxiedReq.setHeader('TestHeader', 'foo');
});

Note I am not doing anything special in this code, I have pretty much 
removed all of the app logic with the failure happening prior to the 
actual proxy call.

thanks!
todd

todd kaplinger
STSM, Mobile Cloud Platform Architect (IBM MobileFirst for iOS)
ibm master inventor

From:   Jarrett Cruger notifications@github.com
To:     nodejitsu/node-http-proxy node-http-proxy@noreply.github.com
Cc:     Todd Kaplinger/Durham/IBM@IBMUS
Date:   01/02/2015 11:47 AM
Subject:        Re: [node-http-proxy] Unable to proxy multi-part form 
(#760)

Well it seems because the middleware stack is still executing, even if it 
does send the 100 response automatically you need to handle the case 
because it won't stop the middleware chain. I also have no idea where the 
error is coming from in your code so I can't point out exactly whats 
wrong. But you are probably doing a res.setHeader after you have already 
sent the response or the http-proxy logic was given a request and response 
where the response had already been replied to (this is kind of my feeling 
with the middleware chain still executing). I'd keep digging into this 
problem and open an issue if you find a bug in http-proxy but this just 
seems to be an implementation issue atm. Stackoverflow will be a good 
place to post next if you can't figure it out :). Good luck!
‚Äî
Reply to this email directly or view it on GitHub.
",todkap,
760,2015-01-02 17:29:44,"@todkap Ahh ok. So it seems that when you don't handle the `write-continue` case when the client sends a 100 request, it must fast-laned even when proxied where the .`on('socket')` event doesn't even allow headers to be set. Im looking to see where this happens in node core as this is kind of interesting. 

But my recommendation here is to put back the logic you had detecting the expect 100 request which was the problem I was inferring previously. I mistakenly made you change the code so that the 100 request was being proxied (because of how middleware works I guess or the writeContinue not happening automatically). You want to proxy just the payload and have your proxy-app tell the client to send the payload so that it can be proxied to the proper destination. I believe that is what is causing the setHeader error. 
",jcrugzz,
760,2015-01-02 17:35:35,"Also we do not have multi-part form tests (though I would love to!) But in this case it shouldn't make a difference as we will proxy any binary data that comes down the pipe as we just simply make a new request and use the `.pipe()` method internally. It should be because of the writeContinue dance as we do not handle specially handle expect 100 requests innately. 
",jcrugzz,
760,2015-01-02 21:33:23,"I was able to get the browser to work successfully for me (issue with the 
back end server and how it handles PUT versus POST).    I am not super 
concerned about the 100 Continue but if you have time to investigate that 
would be fine with me :)

thanks!
todd

todd kaplinger
STSM, Mobile Cloud Platform Architect (IBM MobileFirst for iOS)
ibm master inventor

From:   Jarrett Cruger notifications@github.com
To:     nodejitsu/node-http-proxy node-http-proxy@noreply.github.com
Cc:     Todd Kaplinger/Durham/IBM@IBMUS
Date:   01/02/2015 12:35 PM
Subject:        Re: [node-http-proxy] Unable to proxy multi-part form 
(#760)

Also we do not have multi-part form tests (though I would love to!) But in 
this case it shouldn't make a difference as we will proxy any binary data 
that comes down the pipe as we just simply make a new request and use the 
.pipe() method internally. It should be because of the writeContinue dance 
as we do not handle specially handle expect 100 requests innately. 
‚Äî
Reply to this email directly or view it on GitHub.
",todkap,
760,2015-10-29 20:43:32,"I ran across this issue with ember-cli and had a bit of trouble decoding what has been said here: for anyone who runs across this, here is my decoding:

When sending a multipart/form-data POST the browser may not send the form data right away. It instead sends what I'll call a request-for-continue, consisting of just the headers that will be sent and an extra header:
  `expect: 100-continue`

To avoid large amount of unintelligible data being sent, the server must respond with an HTTP 100 acknowledging that it will be capable of decoding the multipart/form-data.

Since express.js does support this type of decoding, part of its functionality consists of automagically responding to this request with the requisite HTTP 100 response.

The problem is that express still allows middleware to operate on the request-for-continue after it has been responded to, and thus the proxy forwards the request-for-continue along. This is bad.

The solution is to insert a bit of middleware that runs before the http-proxy in the middleware stack and which does NOT continue through the stack if it detects the request is a request-for-continue. The solution is flawed in a proxying sense as the user is no longer protected from the expense of sending multipart form data to a server which cannot decode it.
",conartist6,
760,2016-12-22 16:14:46,Is there an example of the middleware that needs to be made and how it gets integrated with http-proxy?,RangerMauve,
760,2016-12-22 16:34:46,"Disregard that, apparently it works out of the box with the default config. Awesome software, by the way. Big thanks to the creators and collaborators for making something this easy to use.",RangerMauve,
759,2014-12-23 18:25:33,"...incoming request when proxying to the target server

cc @yleemj
",jcrugzz,2015-04-20 20:47:27
758,2014-12-22 08:22:32,"If the income request url is http://example.com/abc, and then we call 

<S_CODE_TOKEN>

the request will be proxied to http://target.com:8080/abc, can it be proxied to a different path, e..g  http://target.com:8080/something_else/xxxx, or just http://target.com:8080?
Thanks!
",yleemj,2015-04-20 20:47:28
758,2014-12-22 16:28:59,"@yleemj use the [`prependPath`](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L41) and set it to `false`. Then just provide the path you want to proxy to in the target URL.
",jcrugzz,2015-04-20 20:47:28
758,2014-12-23 09:26:25,"After I set prependPath to false, the problem still exists.  Here is my code:

<S_CODE_TOKEN>

I'm using expressjs. The req.originalUrl is '/user/A',  req.baseUrl is '/user', and req.url is '/A'. the request is proxied to http://target.com/A, which doesn't exist. What I really want is http://target.com/. But if I set req.url to '/' manually, the path for the  the static files in target server will be changed to '/user/'. E..g, http://target.com/static/app.js will be changed to http://originalSite.com/user/static/app.js. It should be http://originalSite.com/user/A/static/app.js, and then proxied to the target server.
",yleemj,2015-04-20 20:47:28
758,2014-12-23 17:22:08,"@yleemj Just for posterity, `req.originalUrl` and `req.baseUrl` have zero impact on how the request is proxied. `http-proxy` only cares about the `req.url`, the options you give it and the `target`. Now I'm still unsure why manually setting the req.url to `/` changes other behavior but I have provided an `ignorePath` option which will ignore the path that is given by the incoming request. Will this solve your use case? Your latest description honestly made your use case less clear.
",jcrugzz,2015-04-20 20:47:28
758,2015-04-11 01:03:43,"I have the same usecase. I want to run a proxy that forwards to a remote server, but changes the target path:

So for eg:

http://proxy.com/foo -> http://target.com/bar

I have tried ignorePath=true, and prependPath=false and none of them seem to work.

Here are my results:

prependPath: false, ignorePath: true -> http://target.com/foo
prependPath: true, ignorePath: true -> http://target.com/bar/foo
prependPath: true, ignorePath: false -> http://target.com/bar/foo
prependPath: false, ignorePath: false ->  http://target.com/foo

How do I get it to forward to just the target Url I specify:

<S_CODE_TOKEN>

Essentially, I am trying to write a general purpose forwarding proxy, that will use the path of the incoming request to forward to any number of target applications.
",ferozed,2015-04-20 20:47:28
758,2015-04-18 15:54:41,"I have the same use case and issue right now. =/

The only way I got this working was to reassign req.url to the path I wanted.
",mereghost,2015-04-20 20:47:28
758,2015-04-18 16:30:45,"How and when did you reassign req.url? Could you post some code snippet please? Thank you!
",pwasem,2015-04-20 20:47:28
758,2015-04-19 22:22:29,"ignorePath is currently an unmerged PR. @ferozed did you use that branch? Let me merge the pull-request and bump the version and see if this fixes the issue you guys are having.
",jcrugzz,2015-04-20 20:47:28
758,2015-04-20 20:50:22,"please try `1.11.0` with `ignorePath` option. Otherwise open a new issue as this should be fixed.
",jcrugzz,2015-04-20 20:47:28
757,2014-12-21 03:38:29,"I've run into a strange issue with websocket proxying that has had me pulling me hair out for several weeks. Everything had been running smoothly on 1.5.1, but many users starting reporting disconnect problems after upgrading to ~~1.5.3~~ 1.5.2. Clearly something in one of the two following commits is the issue, but I'm not sure if the cause is http-proxy or my implementation.

https://github.com/nodejitsu/node-http-proxy/commit/bcd8a564a802512c90df20353ca341a1d8c84501
~~https://github.com/nodejitsu/node-http-proxy/commit/c62766391e54069c7cf82f0135536aeabad7cd90~~

What has made it exceptionally frustrating is that I haven't been able to reproduce the problem, nor have I been able to find anything in commone with the users that reported the issue happening. It also didn't happen 100% of the time for those users, it seemed to come in bursts. If anyone even had any clues of where to keep looking, that would be a huge help as I've run out of ideas.

<S_CODE_TOKEN>
",goldfire,
757,2014-12-22 17:00:41,"@minrk Since you were doing a bunch of testing here, any ideas? The two commits that were made only seem to properly close sockets in cases where they were bad. I don't see it causing issues.

@goldfire What node version are you running on? I'm curious if an upgrade there had anything to do with it or just the upgrade of the `http-proxy` dep. 
",jcrugzz,
757,2014-12-22 17:04:58,"Running 0.10.32, and haven't changed that throughout this process. We had 20+ people from all over the world that were reporting the same exact issue (and we were able to confirm it through logs as well), and as soon as we downgraded to 1.5.1, it 100% went away.
",goldfire,
757,2014-12-22 17:12:12,"@goldfire did you try, `1.5.2` at all? I'd like to narrow it down to one of these commits.
",jcrugzz,
757,2014-12-22 17:15:31,"No, I'll try that out and report back with results.
",goldfire,
757,2014-12-22 17:20:57,"@goldfire awesome, thanks for the work here, I appreciate it :). I'd like to do what I can to help you get on the newest version with full stability.
",jcrugzz,
757,2014-12-22 21:10:38,"@goldfire sorry for causing you trouble, since it seems like these were my changes. One difference appears to be that `socket.end()`  is called in the error callback, which you do as well, so I think `socket.end()` is called twice. I'm not sure if that would be an issue, though. Can you see any other details about the circumstances of the failure? Does it disconnect when failover is happening, or during normal working operation? Can you find any commonality among users seeing the issue (e.g. browser or OS)?

It's definitely possible that one or more of the conditions under which sockets are closed is too general. My guess is that it would be bcd8a564a802512c90df20353ca341a1d8c84501, since you already had the change in c62766391e54069c7cf82f0135536aeabad7cd90 in your own error callback. I can't think of circumstances where that would be the wrong decision, but you might instrument the code (read: console.log) to see which of these is causing your disconnects, and then maybe we can figure out why the disconnects are incorrect.
",minrk,
757,2014-12-30 21:51:12,"We release an update tody that included upgrading to 1.5.2 to test this. I can confirm that the issue is happening again, so it is clearly related to bcd8a56. I also removed the `socket.end()` from the error check in our code, but that doesn't appear to have changed anything.

There doesn't appear to be any correlation with OS or browser (we are seeing it across the board...except on our end of course). I also added some new logging for fallbacks, and I'm not seeing anything to indicate failover is related.

I've instrumented the code with some new logs to see if we can figure out what is going on here. I'll report back when some results come in.
",goldfire,
757,2014-12-30 22:36:14,"@goldfire thanks for the update. It looks like that is the commit we can get revert. I understand what you were going for there @minrk but it seems there are some edge cases where that isn't set yet it is still successfully used for websocket handshakes. Could be a browser related thing I suppose, but anyways this is super weird. Please let us know if you get anymore insight into when this happens, I'd love to understand the why :). 
",jcrugzz,
757,2014-12-31 07:34:26,"So, I'm getting very odd results so far (please let me know if I'm no longer thinking straight). I downgraded back to 1.5.1 and updated `ws-incoming.js` in my `node_modules` folder with the following in place of  bcd8a56:

<S_CODE_TOKEN>

The odd thing is that the problem appears to still be happening, but nothing is getting logged.
",goldfire,
757,2014-12-31 16:54:00,"I'm not sure if this is related or not, but I added some more logs last night and am seeing large numbers of the following:

<S_CODE_TOKEN>

Some line up with the issue, but others don't, so it is again hard to say if that is related at all.
",goldfire,
757,2014-12-31 18:45:54,"@goldfire hmm it may have to do with just listening to the response event in general but thats still kind of weird. Socket hang up usually has to do with a forced disconnection on the destination server
",jcrugzz,
757,2014-12-31 20:11:29,"I would like to identify the issue and find a fix, because I believe my use case will unavoidably exhaust FDs in the proxy if either commit is just reverted.
",minrk,
757,2015-01-02 23:46:54,"After two days of monitoring this, having simply removed the `proxyReq.on('response')` listener seems to have fixed it. However, I can't think of how that would have an impact. Any ideas?
",goldfire,
757,2015-01-03 00:20:01,"@goldfire thanks for confirming my thought. I'll see what node core has to say about those cases in `http.js` Just to confirm, are you running on `0.10.35`? (just for reference when I go to look at the internals)
",jcrugzz,
757,2015-01-03 03:56:47,"I'm running 0.10.33 on a Joyent SmartOS instance. They don't appear to have updated their repo to 0.10.35 yet, but I can try 0.10.35 on a different instance if needed.
",goldfire,
757,2015-01-03 05:03:54,"@goldfire no worries, theres probably no big changes there. thanks for the reference.
",jcrugzz,
756,2014-12-20 14:40:49,,PanMan,2014-12-22 17:02:36
756,2014-12-22 17:02:39,"thanks!
",jcrugzz,2014-12-22 17:02:36
755,2014-12-17 13:39:42,"Let's say I want to proxy:
- requests coming from `www.domain1.com`  => localhost:3001
- requests coming from `www.domain2.com`  => localhost:3002

Is this correct ? :

<S_CODE_TOKEN>

Could we add a such a simple example in the README ?
",josephernest,
754,2014-12-16 13:54:24,"The example at `examples/middleware/gzip-middleware.js` does not work anymore since `connect` has changed
",Tarang,
754,2014-12-16 17:26:10,"@Tarang would love a PR for an update :)
",jcrugzz,
753,2014-12-16 10:52:27,"Hi,
my client has two websockets of which one is going to another port via http-proxy. The other should not be proxied and stay on the same server. I use the following two code snippets for the first socket:

<S_CODE_TOKEN>

<S_CODE_TOKEN>

How would I tell http-proxy to not proxy the second socket. That one is used for live-reload functionality (Mimosa). Changing 'resource/path'? The first socket uses a specfific namespace, but where would I retrieve that info?
Thanks a lot.
",olingerc,
753,2016-01-07 07:44:58,"You can just add that same logic in the `server.on('upgrade', ...` callback.

However, `socket.io` adds its own `server.on('upgrade', ...` callback seen [here](https://github.com/socketio/engine.io/blob/391ce0dc8b88a6609d88db83ea064040a05ab803/lib/server.js#L440).

You will notice an option called `destroyUpgrade` which will close the connection if there are no handlers found for that upgrade request.

You need to disable this option if you are using http-proxy as well.

It can be disabled during initialisation: `io = require('socket.io')({destroyUpgrade: false})`.
",vjpr,
752,2014-12-13 18:46:07,,ezhdan-sugarcrm,2014-12-13 21:34:45
752,2014-12-13 21:34:23,"lgtm
",indexzero,2014-12-13 21:34:45
751,2014-12-11 16:02:13,,seanhussey,2014-12-11 16:26:24
751,2014-12-11 16:26:21,"Thanks for your contribution!
",3rd-Eden,2014-12-11 16:26:24
750,2014-12-07 23:19:26,"According to the HTTP spec, the port needs to be included in the host header if it's not the default port. It can be included even if it is the default port, so the easiest thing to do is always include it.
",magicalhobo,2014-12-08 21:15:12
750,2014-12-08 19:52:32,"@magicalhobo thanks for the contribution! Unfortunately we cannot make this assumption because the host property itself can include the port. (see how the [`url`](http://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost) module behaves.) There will need to be something that better fits the type of inputs we get from a user.
",jcrugzz,2014-12-08 21:15:12
750,2014-12-08 21:15:42,"@magicalhobo you can see the fix I made above, just want to make sure it works as expected in all cases
",jcrugzz,2014-12-08 21:15:12
749,2014-12-03 11:49:30,,kailan,2014-12-03 11:51:11
749,2014-12-03 11:51:05,"Oh wow. That was awful. Thanks for the fix. Will have to be more careful reviewing PRs in the future!
",indexzero,2014-12-03 11:51:11
748,2014-12-01 17:24:09,,samccone,2014-12-02 17:26:19
748,2014-12-01 17:24:44,"Composite PR of 

#744 
#746 
",samccone,2014-12-02 17:26:19
748,2014-12-03 00:20:32,"ah sorry for the delay @jcrugzz I was traveling for the last 24 hours but it looks like this was resolved :+1: 
",samccone,2014-12-02 17:26:19
747,2014-11-30 16:05:59,"After recent upgrade my tests break:

<S_CODE_TOKEN>
",Rush,2015-04-01 15:07:44
747,2014-11-30 23:08:42,"@Rush can you pinpoint whats being passed in? There should be a test here to prevent these types of failures and I would love to add one.
",jcrugzz,2015-04-01 15:07:44
747,2014-12-01 20:42:51,"`proxy.web(req, res, options);`
where options are:

<S_CODE_TOKEN>

Target is preparsed
",Rush,2015-04-01 15:07:44
747,2014-12-01 21:23:37,"@Rush hmmm thats weird, could you turn this into a failing test case. That would be amazing <3 
",jcrugzz,2015-04-01 15:07:44
747,2014-12-01 22:08:39,"Hmm, not really cause that's how I use `node-http-proxy`, as in I don't
want to pass a string as a target since I need to parse the url first
myself.

2014-12-01 22:23 GMT+01:00 Jarrett Cruger notifications@github.com:

> @Rush https://github.com/Rush hmmm thats weird, could you turn this
> into a failing test case. That would be amazing <3
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/nodejitsu/node-http-proxy/issues/747#issuecomment-65137006
> .
",Rush,2015-04-01 15:07:44
747,2014-12-01 23:03:31,"@Rush Im not saying that you should be passing a string as the `common.setupOutgoing` function accepts `target` as an object. It gets preparsed before this function. What I don't understand is how this object is causing your tests to fail because nothing should be `null` which is why I'd love for you to take this object and any other aspects of your test that are contextually relevant and produce a failing test so we can get to the bottom of this.

It seems to center around [this](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L61-L74) logic which to me seems impossible to be `null` but I'd love to be proved wrong :).
",jcrugzz,2015-04-01 15:07:44
747,2014-12-08 20:31:11,"@Rush are you still experiencing this? Im looking to make the data input validation a bit more robust but I'd really like to see the full test case here :)
",jcrugzz,2015-04-01 15:07:44
747,2015-04-01 12:30:53,"I also experienced this. The problem was a result of rewriting `req.url` to an empty string:

`/path/ => /`
`/path => ''`

So `url.parse('').path => null` which means `common.urlJoin` was being passed `null` as it's last argument.

I have written a fix and submitted a pull request: https://github.com/nodejitsu/node-http-proxy/pull/798
",damonmcminn,2015-04-01 15:07:44
747,2015-04-06 14:19:48,"Hey @Rush , 

Did this fixing solve your problem?
Despite `common.js` file had fixed I get same error.

Is there any one in my case?
",efkan,2015-04-01 15:07:44
747,2015-04-06 14:41:09,"@efkan can you give more information?
",damonmcminn,2015-04-01 15:07:44
747,2015-04-06 15:58:58,"Thanks @damonmcminn ,

I've opened a new issue;
https://github.com/nodejitsu/node-http-proxy/issues/800
",efkan,2015-04-01 15:07:44
746,2014-11-27 13:03:26,"Supply the last case content in the `common.setupOutgoing` function for existed many '?' in a url.

Hope you could revise it.

ref: [the previous pull request](https://github.com/nodejitsu/node-http-proxy/pull/744)
",koolc,2014-12-02 17:26:51
746,2014-11-27 15:38:20,":+1: this is the failing spec indeed
",samccone,2014-12-02 17:26:51
746,2014-11-28 21:35:04,"Can we get a PR with this test and the code changes from #744?
",indexzero,2014-12-02 17:26:51
746,2014-11-29 02:23:11,"Yeah, of course. Any questions, please leave message. I think you should have the access and merge permission if I had not set my permission control.
",koolc,2014-12-02 17:26:51
746,2014-12-01 15:21:46,"@koolc he meant to put this test case in the same PR as your fixes to show that both the test case and the changes made pass. Just makes for cleaner merging but its not a huge deal.
",jcrugzz,2014-12-02 17:26:51
745,2014-11-26 19:36:56,"I have a simple express app with a request function

<S_CODE_TOKEN>

the output I get is unexpected after it has been sent via the proxy
:

<S_CODE_TOKEN>

Everything in the original request is as expected:
but after the proxy.web call is made the URL is a strange concatenated mess of the expected URL with the URL concatenated again on the end.
.
",codeuniquely,2014-12-03 11:18:01
745,2014-11-26 23:33:46,"The path of the URL is already added for you unless the `prependPath` option is explicitly set to false. It was argued this should be the default behavior when the feature was implemented. See [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L61-L65) in the code to what you are seeing.

In regards to not having the body of the request, if your express app (which seems to be using bodyParser) parses the body of the request before you proxy it, there will be nothing to proxy. Please see the [example](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/bodyDecoder-middleware.js) of what you need in this case and the [`connect-restreamer`](https://github.com/dominictarr/connect-restreamer) module that does it for you
",jcrugzz,2014-12-03 11:18:01
745,2014-11-27 05:22:25,"thanks for the quick reply,

So when you say that its adds the URL for you, that the target should be he hostname of the intended recipient and nothing else?

I wasn't aware that express removed the body contents. and thanks for the restreamer code 
but how does that work when there are multipart req.files in the content too, as you tend to get a Error: stream ended unexpectedly on the req.emit('end'); line
",codeuniquely,2014-12-03 11:18:01
745,2014-12-01 03:27:02,"@codeuniquely For the first point, that is correct. The path of the incoming request will be used.

it seems like what you want here is to conditionally use the `bodyParser` rather than on EVERY request that comes through your express server. When the body of a request gets parsed, its no longer contained in the `req` stream object so that data does not get passed along when you proxy the request. Try avoiding using the `bodyParser` and `connect-restreamer` at all and see if you can successfully proxy the request as you intend.
",jcrugzz,2014-12-03 11:18:01
744,2014-11-25 09:51:33,"Bugfix: outgoing url is wrong when the source url is 'http://a.b.c/d/??e/a.js,f/b.js,g/c.js?t=123456' (a combo url).
",koolc,2014-12-02 17:26:45
744,2014-11-25 09:54:54,"When you merged the changed codes and update to a new version, please leave a message! Thank you!
",koolc,2014-12-02 17:26:45
744,2014-11-25 16:12:20,"@koolc is there a failing test this is compensating for? To be fair this logic is still not 100% correct but this change doesn't look like the right fix.
",jcrugzz,2014-12-02 17:26:45
744,2014-11-26 07:17:28,"@jcrugzz @samccone 
This is a online url 'http://g.tbcdn.cn/??kissy/k/1.4.0/seed-min.js,kissy/k/1.4.0/base-min.js,kissy/k/1.4.0/json-min.js,kissy/k/1.4.0/dom/base-min.js,kissy/k/1.4.0/event/base-min.js,kissy/k/1.4.0/event/custom-min.js,kissy/k/1.4.0/event/dom/base-min.js,kissy/k/1.4.0/event/dom/focusin-min.js' on the Alibaba CDNs.  You can take it
for test.

This is a combo url(This is a technical measures that multiple requests will be merged into one in order to reduce the number of requests), and '??' is a combo tag.

I mainly think of this case, so maybe the changed logic is still not 100% correct, hope you can revise it. 
",koolc,2014-12-02 17:26:45
744,2014-11-26 12:49:10,"@koolc could you write a test case using this type of URL? I will look closer at the logic
",jcrugzz,2014-12-02 17:26:45
744,2014-11-27 03:38:23,"A bin test file content:

<S_CODE_TOKEN>
",koolc,2014-12-02 17:26:45
744,2014-11-27 03:56:22,"@koolc In terms of a test case, could you add a test case to test of the `common.setupOutgoing` function in [here](https://github.com/nodejitsu/node-http-proxy/blob/master/test/lib-http-proxy-common-test.js)
",jcrugzz,2014-12-02 17:26:45
744,2014-11-27 13:03:30,"I think the test case(exists many '?') below in the `common.setupOutgoing` function could enough test out the problem. The codes:

<S_CODE_TOKEN>

I have sent a [pull request ](https://github.com/koolc/node-http-proxy/compare/nodejitsu:master...patch-2?quick_pull=1), you can see my changes.
",koolc,2014-12-02 17:26:45
744,2014-11-28 17:15:24,"Excuse me, but I want to know when to support the change? My component will recently publish and it requires the 'http-proxy' module. So I expect the fresh version very much. Thank you!
",koolc,2014-12-02 17:26:45
744,2014-12-01 03:28:26,"@koolc sorry for the late reply, once that change you already suggested is done, this should be merged. If you have anymore URL test cases for this function, it would be awesome to get more tests around this.
",jcrugzz,2014-12-02 17:26:45
744,2014-12-01 09:13:11,"Sorry, I didn't fully understand what you mean, but the previous test case modified by me has been provided at  [https://github.com/nodejitsu/node-http-proxy/pull/746](https://github.com/nodejitsu/node-http-proxy/pull/746) last week, and I'm sorry I have the only one application scene to use the function, so it's difficult for me to get more tests around this. Though, even if no more test cases, I'm sure that the function must be wrong. So, at least so far, I think it's the most important to correct it and the test cases can be accumulated slowly. Don't you think so? 
",koolc,2014-12-02 17:26:45
744,2014-12-01 15:18:51,"@koolc test cases are not required, I was just curious if you had anymore crazy URLs that could be sueful for testing ;). Just make the change for `retSegs.push.apply(retSegs, lastSegs);` and I will merge.
",jcrugzz,2014-12-02 17:26:45
744,2014-12-02 03:27:25,"Thank you! I have seen the merged codes, but they doesn't seem to be completely right. Please see the message left by me on [https://github.com/nodejitsu/node-http-proxy/pull/748](https://github.com/nodejitsu/node-http-proxy/pull/748)
",koolc,2014-12-02 17:26:45
744,2014-12-02 04:22:07,"@koolc replied
",jcrugzz,2014-12-02 17:26:45
743,2014-11-25 05:38:03,"Allow to track the event when the proxied websocket connection has finished.
",jleal52,2014-12-17 07:54:13
743,2014-11-25 16:14:19,"@jleal52 i like this as an idea but it should have a different name. as there is `start` and `end` events for regular http proxying.
",jcrugzz,2014-12-17 07:54:13
743,2014-12-01 06:01:38,"In the websocket space, it's usually a ""close"" event, so maybe that's an option?
",bruce-one,2014-12-17 07:54:13
743,2014-12-09 03:43:12,"@bruce-one that seems reasonable. Maybe `open` `close` to complete the pairing?
",jcrugzz,2014-12-17 07:54:13
743,2014-12-09 04:24:02,"That sounds logical to me :-) (and consistent with other projects :-) )
",bruce-one,2014-12-17 07:54:13
743,2014-12-09 19:02:56,"Looks good. would you mind adding a test to ensure they are both called? Im sure you can use most of a websocket test case that is already in the tests
",jcrugzz,2014-12-17 07:54:13
743,2014-12-11 14:21:53,"Hello, I have added a test to ensure close event is called and updated documentacion. I hope it's all right.
",jleal52,2014-12-17 07:54:13
743,2014-12-11 15:13:54,"I have now read about the ""open"" event, but now the ""open"" event is emitted as ""proxySocket"" and changing the event name will break backwards compatibility.

What do you suggest??. I can change as you suggest and add to tests.
",jleal52,2014-12-17 07:54:13
743,2014-12-11 19:18:21,"Hmm, lets just emit both events for backwards compatibility and we can update the readme with a deprecation notice for the `proxySocket` event.
",jcrugzz,2014-12-17 07:54:13
743,2014-12-11 19:50:00,"Hi Jarrett, I have changed it as said.
",jleal52,2014-12-17 07:54:13
743,2014-12-17 07:54:13,"Cherry-picked the commits, thanks for the contribution!
",jcrugzz,2014-12-17 07:54:13
742,2014-11-24 22:34:04,"Note also that this change was previously suggested as part of the resolution of https://github.com/nodejitsu/node-http-proxy/pull/338, but it never made it to `master`.

I'm not so happy about special-casing individual HTTP verbs like this, and I doubt the maintainers are, either. A better solution would involve disabling the default Node.js behavior described in the commit message (below). That behavior might make sense to make the `http` and `https` modules more usable, but in the setting of an HTTP proxy, fidelity is much more important.

This seems possible via [the `useChunkedEncodingByDefault` attribute](https://github.com/joyent/node/blob/cfcb1de130867197cbc9c6012b7e84e08e53d032/lib/_http_outgoing.js#L275-L280), but that is undocumented and likely unstable. I wasn't able to get it working locally, likely because [this library uses `pipe` for _all_ ""incoming"" requests](https://github.com/nodejitsu/node-http-proxy/blob/aba505d159a7dd46e46dd3ceb1b9565308b4d6af/lib/http-proxy/passes/web-incoming.js#L142). When piping data, the `useChunkedEncodingByDefault` flag does not seem to be honored. This probably makes sense because a streaming interface would generally emit data in chunks... so maybe special-casing HTTP verbs is the best approach, after all.

Commit message:

> Web browsers automatically issue an OPTIONS request in advance of other
> HTTP requests when the document's domain does not match the target in
> order to facilitate Cross-Origin Resource Sharing. These requests are
> forbidden from specifying a body and typically do not specify an
> (unecessary) `Length` header.
> 
> Node.js automatically adds the `Content-Encoding: chunked` header value
> to requests that do not specify a `Length` header. This makes proxied
> OPTIONS requests from web browsers invalid.
> 
> Explicitly set the `Content-Length` header of all `OPTIONS` requests to
> ""0"", disabling the default ""chunked"" encoding behavior [2].
> 
> [1] http://www.w3.org/TR/cors/
> [2] http://nodejs.org/api/http.html
",jugglinmike,2014-11-25 16:15:46
742,2014-11-25 14:42:50,":+1: lgtm
",samccone,2014-11-25 16:15:46
742,2014-11-25 16:15:49,"Thanks!
",jcrugzz,2014-11-25 16:15:46
741,2014-11-21 05:19:58,"Hey all, really appreciate this great lib, here is a solution I implemented for host rewriting for redirects.

If you are interested in this I can add tests and docs. thanks again
",samccone,2014-11-25 22:08:54
741,2014-11-21 05:21:47,"related:
https://github.com/nodejitsu/node-http-proxy/issues/318
https://github.com/nodejitsu/node-http-proxy/pull/376
https://github.com/nodejitsu/node-http-proxy/pull/519
",samccone,2014-11-25 22:08:54
741,2014-11-21 17:08:56,"@samccone this looks good! Could you add a test for this and update the docs related to this option? Thanks for the contribution!
",jcrugzz,2014-11-25 22:08:54
741,2014-11-21 17:36:07,"awww snap sweet, I was also thinking about `options.hostRewrite` being a polymorphic argument and supporting a `fn` signature to allow for a more complex redirect logic flow (for some people this will be needed)

But I will save that work for another PR. 
",samccone,2014-11-25 22:08:54
741,2014-11-23 18:31:46,"hey @jcrugzz specs and docs are all added. 

thanks again for your time, and work on this handy lib.
",samccone,2014-11-25 22:08:54
741,2014-11-23 22:58:43,"@samccone looks great. I forgot the only one nit here that I will post on the code. Will merge once thats done. Thanks!
",jcrugzz,2014-11-25 22:08:54
741,2014-11-24 00:22:29,"all updated @jcrugzz :tanabata_tree: 
",samccone,2014-11-25 22:08:54
741,2014-11-25 14:41:31,"Hey @jcrugzz was there anything else you needed from me?
",samccone,2014-11-25 22:08:54
741,2014-11-25 22:08:50,"@samccone sorry got caught up with things so I didn't get to it. LGTM. Ill post back here with some style nits that I make for next time :). Thanks!

 Im also curious about the use of a `context` function as i dont see it anywhere in the mocha docs.
",jcrugzz,2014-11-25 22:08:54
740,2014-11-19 15:21:04,,tu1ly,2014-12-02 17:27:08
740,2014-11-19 20:26:16,"At first glance this doesn't look like the right solution.
",indexzero,2014-12-02 17:27:08
740,2014-12-02 17:27:08,"fixed in 9c0b869
",jcrugzz,2014-12-02 17:27:08
739,2014-11-19 14:37:47,,tu1ly,2014-11-19 14:42:08
738,2014-11-19 14:29:24,"hi,

<S_CODE_TOKEN>

path: 'http://www.google.com' becomes path: 'http:/www.google.com/' in https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L153 . 

Peter
",tu1ly,2014-12-02 17:26:19
737,2014-11-15 07:15:56,"I'm using this to enable following redirects from my application logic, added a simple example of how I'm using it. 

Before this change, it would ALWAYS try to pipe proxyRes into res, even if it was a 301 redirect etc.
",erupenkman,
737,2014-11-15 15:20:43,"@erupenkman hmm, this is something I'd consider. You mind adding a test? @indexzero you have any thoughts on this?
",jcrugzz,
737,2014-11-17 10:58:38,"@jcrugzz yes, tests are definitely a must. There are a lot of error cases in this scenario that could leak fds I think.
",indexzero,
737,2014-11-18 03:17:50,"hmm I tried to expand my use case (following 301 redirects) and i'm not sure that this is even the correct approach for my need now... I will add a test as another pull request later today though.
",erupenkman,
737,2015-06-23 20:34:19,"I am implementing a very similar feature, but it adds a very crucial ability to allow the outside world to pipe onto the response stream and return that new stream.  This would allow users to easily modify the response from the origin server if they so choose.  It would look something like this:

<S_CODE_TOKEN>

<S_CODE_TOKEN>
",DesignByOnyx,
737,2015-07-04 22:59:54,"i'm in need of this myself.  i wish there were a way to just do something like this below.  

didn't dive too deeply into the code but it looks like by the time proxyRes emits res is already sent/sending? (headers at least)

if proxyRes events fired sync before res sending started it should be possible to do this without leakage since the original proxyRes is torn down prior to creating the followup proxied request.

this would also address @DesignByOnyx 's usecase since you could abort the original proxyRes and then just pipe your stream directly to the original http res.

<S_CODE_TOKEN>

if i can't find a hackaround i might take a crack at it if that solution sounds acceptable in theory.
",cmawhorter,
737,2015-07-06 16:32:32,"I built my version of this and am actively using it on a project.  It works quite well, but there is one caveat - I'll see if I can explain. The actual ""piping"" (eg. making the hose longer, if you will) happens synchronously, but the water flowing through the hose happens asynchronously. This is just normal ""piping"" kind of stuff, but the drawback is that as soon as the the final `res` is piped, the response headers are written - even if the water hasn't reached that portion of the hose yet (is this hose analogy working?). You can see my changes here: https://github.com/DesignByOnyx/node-http-proxy/tree/proxy-response-pipe.

**Usage**

<S_CODE_TOKEN>

The above example works well without issue assuming that your new pipe emits data events periodically **and the length of the data doesn't change** - the way streams _should_ work. In my situation, however, I have a handful of responses that I need to modify and the end result may or may not be longer or shorter than the original. This requires that the ""content-length"" header gets updated as well.  The problem I ran into that as soon as data started flowing through my custom section of the pipe, the response headers had already been written. The only way I could get around this was to overwrite `res.writehead` and call it when I emitted the ""end"" event. The only way to do this reliably was to buffer the entire response into memory (crimp the hose), make the changes I want, update the ""content-length"" header, and finally flush all the data down the pipe (release the crimp). I hope that helps. I have code I can share too - just let me know.
",DesignByOnyx,
737,2017-01-15 21:51:06,Is this still under consideration? It would be quite nice to be able to hook into `proxyRes` and manipulate the stream before sending on to the client...,maxcountryman,
736,2014-11-12 20:24:23,"Currently `common.setupOutgoing` uses a reference to the original request headers, which causes `Connection` to be overwritten in some cases, and `Host` to be overwritten when `changeOrigin` is set to `true`. If you use the `proxyReq` to look at the original request and the proxy request you will find that those headers have been modified on the original request object.

I modified one test case that set the request headers to a string because using `utils._extend` on a string doesn't work. As far as I know `req.headers` will always be an object so I think what I did is fine but if there's a reason that was a string, I'll fix it so it checks the type.
",richardkazuomiller,2014-11-12 21:46:51
736,2014-11-12 21:37:24,"I've updated my branch - please have a look (^_^)

Also, I admire your team's strict adherence to your style guide. I'm usually much lazier than I should be haha. I did some Googling and found [this](https://gist.github.com/indexzero/5368926). Should contributors be following that?
",richardkazuomiller,2014-11-12 21:46:51
736,2014-11-12 21:46:06,"@richardkazuomiller yea essentially, good find! That should just be linked somewhere. @indexzero just hasn't formalized a [`jscs`](https://github.com/jscs-dev/node-jscs) for it yet. 
",jcrugzz,2014-11-12 21:46:51
735,2014-11-12 14:47:46,"This modification allow to use error callback function on proxy.web function and also maintains the server events start / proxyReq / end
",jleal52,2014-11-12 18:05:04
735,2014-11-12 18:05:02,"@jleal52 awesome thank you! :).
",jcrugzz,2014-11-12 18:05:04
734,2014-11-10 04:37:48,"In `v1.6.1`, when the agent option is not given, `common.setupOutgoing` overwrites the `Connection` header of the client request with `Connection: close`.  This occurs when setting `outgoing.headers.connection` at [common.js:58](https://github.com/nodejitsu/node-http-proxy/blob/v1.6.1/lib/http-proxy/common.js#L58) because `outgoing.headers` is an alias of `req.headers`.

The effect, which may or may not be intended, is that all proxied responses where the origin server did not send a `Connection` header will default to `close`, even when the client requested `keep-alive` due to the logic in `setConnection` at [web-outgoing.js:42](https://github.com/nodejitsu/node-http-proxy/blob/v1.6.1/lib/http-proxy/passes/web-outgoing.js#L42) since `req.headers.connection` is always `close`.

In addition to this behavior, it makes it much more difficult for callers to determine the `Connection` value sent by clients in `proxyReq`/`proxyRes` event listeners since the original header value is not preserved anywhere.

Assuming that overwriting the client request header value is unintentional, should the current keep-alive behavior be preserved or is it an unintended consequence?  I would vote for changing the behavior and keeping the connection alive where possible, but there may be issues I'm unaware of.

Thanks for considering,
Kevin
",kevinoid,2014-12-02 17:02:40
734,2014-11-12 10:00:33,"It looks like that only happens when `Connection` is not set. I don't understand the reason for it completely but it looks like defaulting to `Connection: close` is being done for a reason, so I think it should be kept this way. If you need to change the default you could always modify the request before passing it to the proxy.
",richardkazuomiller,2014-12-02 17:02:40
734,2014-11-12 14:09:05,"I agree that `Connection: close` is being set for a reason on the outgoing request to the origin server (when an agent isn't specified, Node core should set this header but the comment suggests there is/was an issue with this).  But I disagree that setting `Connection: close` on the incoming request is intentional, since there's no clear reason to do so and you have to read the code quite carefully to even realize that headers is aliased between the two at this point.

I do have a workaround in place.  I consider it a bit ugly, but it works.  However, most users won't realize that they need to explicitly set `Connection: keep-alive` if they want it for client responses when they are not using keep-alive for the proxied requests.
",kevinoid,2014-12-02 17:02:40
734,2014-11-12 18:02:49,"I guess you're right that using a copying the headers to proxyReq as opposed to using a reference and overwriting them would be good. I imagine that could cause other problems. I like the keeping `Connection: close` as the default but clearer documentation would be helpful.
",richardkazuomiller,2014-12-02 17:02:40
734,2014-11-12 18:08:50,"I understand.  Feel free to close this issue or retitle it to reflect the documentation issue as you see fit.  Thanks for considering it.
",kevinoid,2014-12-02 17:02:40
734,2014-11-12 18:09:10,"Because we default to having `agent: false`, there is a bug in how node `http` works in `0.10.x` where it will leak sockets when anything is set to `keep-alive` from a connection. This is what is indicated in the comment [here](https://github.com/nodejitsu/node-http-proxy/blob/v1.6.1/lib/http-proxy/common.js#L50-L53). If you need `keep-alive` for your proxy uses, I suggest using something like [keep-alive-agent](https://github.com/ceejbot/keep-alive-agent) and passing that in when you create the proxy instance 

<S_CODE_TOKEN>

Documentation should be updated around this and I would gladly take a Pullrequest!
",jcrugzz,2014-12-02 17:02:40
734,2014-11-12 18:22:25,"Thanks @jcrugzz, I appreciate the suggestion.  I actually have keep-alive disabled between the proxy and the origin server intentionally due to the current architecture and some issues with the origin server but would like to have keep-alive between clients and the proxy server for efficiency.

My current workaround is to listen for the `proxyRes` event and set `Connection: keep-alive` on the proxy response (so it will be copied to the client response) when possible.  Overwriting the `Connection` header in the client request had caused my checks for client compatibility to fail (since it always appeared that the client was sending `Connection: close`), but after discovering this issue I just set another property on the request with the original value of the `Connection` header which I can test in the `proxyRes` listener.  It seems to work well.

So I'm set, but it may take users with less debugging and HTTP experience a while to figure out what is going on, or to even realize that they are not getting HTTP keep-alive to clients.
",kevinoid,2014-12-02 17:02:40
734,2014-12-02 17:02:40,"Closing as this is expected until `0.12`
",jcrugzz,2014-12-02 17:02:40
733,2014-11-08 23:52:05,"Fix the issue of multiple consecutive slashes being replaced by a single slash referenced in #703 and #710 by separating the query string from the rest of the URL in `common.urlJoin`. I tried removing trailing slashes as suggested by @yulesyu in #703 but that still caused issues if the query string ended in `//`
",richardkazuomiller,2014-11-11 03:29:16
733,2014-11-10 00:33:25,"Except for minor style things this lgtm @jcrugzz. It even has a new test :+1:
",indexzero,2014-11-11 03:29:16
733,2014-11-11 03:29:15,"@richardkazuomiller this is a good start. I think this function still needs some more love to handle the other edge cases but thank you very much! I'll merge and fix the stylings. Just not that we like less `var` statements ;)
",jcrugzz,2014-11-11 03:29:16
733,2014-11-11 07:02:12,"Thanks! I'm a long time node-http-proxy user and happy to finally be able to contribute. I checked your last commit I'll keep the `var` thing in mind for next time (^_^)
",richardkazuomiller,2014-11-11 03:29:16
733,2014-11-11 07:03:47,"User becomes contributor :+1:  :100: 
",indexzero,2014-11-11 03:29:16
732,2014-11-07 17:26:20,"I am trying to create a simple reverse proxy.

Firefox Browser -> Node Proxy -> Proxy 1 (LimeProxies.com) -> Target
Firefox Browser -> Node Proxy -> Proxy 2 (LImeProxies.com, or some other provider) -> Target
Firefox Browser -> Node Proxy -> Proxy 3 (LImeProxies.com, or some other provider) -> Target

Very straight forward. The problem comes in with requesting a secure website, ""https://bing.com"" for example as compared to ""http://bing.com"", which has no problems.

<S_CODE_TOKEN>

When I request a secure website, jp.process doesn't even fire. Through research, I found that server.on('connect', function(){}); was required. By adding this, I was able to see the request for a secure website ""https://bing.com"".

<S_CODE_TOKEN>

I've tried both the ws and web methods, with no luck. It attempts to proxy the request, but it fails for some reason through a timeout without any helpful error message.

I've tried dozens of proxies, even SOCKS proxies for the WS method, but I cannot get the request to process successfully.

If I put something like this in the connect method, it works, but the request obviously comes from the nodejs server instead of a 3rd party proxy.

<S_CODE_TOKEN>

I am just trying to create a simple reverse proxy, but have been unable to do so for weeks now. Any help is greatly appreciated. Thanks!
",odmarkj,2014-11-07 17:30:12
732,2014-11-07 17:30:12,"This seems like a bug in your implementation. There are samples for all of this:
- [http-to-http proxying](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-http-to-https.js)
- [https-to-http proxying](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-https-to-http.js)
- [https-to-https proxying](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-https-to-https.js)
",indexzero,2014-11-07 17:30:12
732,2014-11-07 17:37:56,"None of those options work, because when you request a secure website, it always requires listening to the connect event, which I am then unable to proxy successfully.
",odmarkj,2014-11-07 17:30:12
732,2014-11-07 17:56:40,"I don't understand what you mean by ""a secure website"". If you're talking about HTTPS then the https proxying examples above do work.
",indexzero,2014-11-07 17:30:12
732,2014-11-07 18:00:43,"Ok scratch that, with this code, I do not even see the request.

https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-https-to-http.js

This is the code I am using. If I point Firefox (network.proxy.ssl, network.proxy.ssl_port) at the port for the http.createServer, with the connect listener, it sees the request. If I point it at the port for httpProxy, nothing ever happens. No connect event is received, and the target never receives any communication.

<S_CODE_TOKEN>
",odmarkj,2014-11-07 17:30:12
732,2014-11-07 18:03:33,"@indexzero I apologize if I am not describing this properly.

I am really trying to do something simple, I just want to proxy a request to the website ""http://bing.com"" as well as ""https://bing.com"". I can get the ""http://bing.com"" to work, but I cannot get a request to work for ""https://bing.com"".

I don't need the actual nodejs proxy server to be HTTPS, unless that is required.

I am just trying to put together a simple reverse proxy.

If I configure Firefox with the IP and PORTS for the code above, a request to ""https://bing.com"" does not succeed. I don't see the request in the nodejs logs, and Firefox never receives a response.
",odmarkj,2014-11-07 17:30:12
732,2014-11-07 18:04:29,"You are creating only one server, `https`. If you want your proxy server listening on both `https` and `http` server you need to create two different servers and listen on different ports. So _two_ calls to `httpProxy.createServer()`
",indexzero,2014-11-07 17:30:12
732,2014-11-07 18:39:25,"@indexzero Thank you for your patience with this. I understand why that would be necessary, but I still cannot get it to work. When the website is ""https://bing.com"", my script does not see the request. If I use ""http://bing.com"", it works as expected with the code below.

<S_CODE_TOKEN>

I should also note that the request appears to hang indefinitely until I control+c to kill it in the terminal request when I try to visit ""https://bing.com"" with this nodejs proxy configured in Firefox.
",odmarkj,2014-11-07 17:30:12
732,2014-11-07 18:44:13,"If you handle the `connect` event you need to do something with it (See [the node docs](http://nodejs.org/api/http.html#http_event_connect)). This is why your request is hanging. I'm sorry, but this simply isn't a bug in `node-http-proxy`. If you can't figure it out on your own I suggest StackOverflow as a way to get your question answered.
",indexzero,2014-11-07 17:30:12
732,2014-11-07 18:55:49,"I do not wish to handle the connect event, but it is the only way I could make it work.

I think I am confusing the issue.

https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-https-to-http.js

This code does not work for me. If I configure Firefox to use the IP of the server with that script, and this port ""8009"", the target does not see the request when I type ""https://bing.com"" into the browser address bar, it just sits there waiting for a response.

And when I monitor the nodejs script on the command line, it does not see any incoming request.

I have already verified that the ports are open.
",odmarkj,2014-11-07 17:30:12
732,2014-11-07 19:02:05,"@indexzero i think the confusion here is related to HOW a proxy is used by a browser and what changes in those situations. This is why I made the toProxy option because I was able to confirm that by not cutting the path in those cases, it worked. There is definitely some other complexity associated with properly using this as THIS type of proxy and proxying https traffic, especially when the server being created is HTTP.
",jcrugzz,2014-11-07 17:30:12
732,2014-11-07 19:06:23,"@jcrugzz Now we're talking.

Do you have any examples of that?

When I add the toProxy option, it doesn't seem to change anything.

<S_CODE_TOKEN>
",odmarkj,2014-11-07 17:30:12
732,2014-11-07 19:16:08,"@odmarkj this is the other complexity im unsure of when proxying https. I believe you may have to tunnel the request like i suggested in the other issue #700. Do some more investigation on how this is supposed to work because your http server cannot sign for `https://bing.com` obviously since it does not have authority.
",jcrugzz,2014-11-07 17:30:12
732,2014-11-07 19:26:20,"I really just want to forward the request, I don't want to do anything with it. I am just trying to setup a dead simple reverse proxy, but it seems this library was not designed to handle that, or at least, not when a majority of the traffic is to HTTPS websites.

I really wanted to make nodejs work for this, but it looks like I will just have to go back to more robust and well supported software such as Squid.

Thanks for your time. @jcrugzz If you would be interested in helping me fix this, I would be more than willing to pay. I am in a real tight bind. Thanks.
",odmarkj,2014-11-07 17:30:12
732,2015-05-18 23:19:02,"Hi @odmarkj, I'd a similar issue and I could make it work. I've created a gist with a https capable reverse proxy: https://gist.github.com/pose/397be6f20433a1346004 . Hope that helps!
",pose,2014-11-07 17:30:12
732,2016-09-26 15:37:44,"Hi @odmarkj,

Were you able to accomplish this eventually?  

@pose your example will work for one proxy, but not in case of a chain as @odmarkj specified.
",pronskiy,2014-11-07 17:30:12
731,2014-11-07 08:02:52,"direct download file from the server A is right,
but when user sever B to `proxy` A,  the downloaded file is blank. and the `proxyRes` header is below.

<S_CODE_TOKEN>
",zhang-ning,
731,2014-11-07 17:26:59,"@zhang-ning need more information to go on. Could you provide a complete code sample?
",indexzero,
731,2014-12-20 15:29:32,"It looks similar to https://github.com/drewzboto/grunt-connect-proxy/issues/73.
It seems that binary files are always converted to UTF-8.
",reda-alaoui,
730,2014-11-06 20:35:32,"Has this been tested on Elastic Beanstalk? I am trying some of the basic examples and I am not having very much luck

<code>(function() {
    var httpProxy = require('http-proxy');
    var http = require('http');

<S_CODE_TOKEN>

</code>
",mlindeboom,2014-11-06 21:02:09
729,2014-11-04 22:54:31,"A simple change to make secured web socket connections respect `options.secure`. Before, this was throwing `[Error: Hostname/IP doesn't match certificate's altnames]`
",ming-codes,2014-11-04 23:13:26
729,2014-11-04 23:00:04,"@lightblade LGTM. Mind if you implement it like the one above? just makes it a bit shorter and cleaner :)

e.g `~['https:', 'wss:'].indexOf(options[forward || 'target'].protocol` will be true if we are dealing with SSL
",jcrugzz,2014-11-04 23:13:26
729,2014-11-04 23:07:09,"Sure. Amended the commit.
",ming-codes,2014-11-04 23:13:26
729,2014-11-04 23:13:24,"Thanks!
",jcrugzz,2014-11-04 23:13:26
729,2014-11-04 23:21:46,"@lightblade published as 1.6.1
",jcrugzz,2014-11-04 23:13:26
729,2014-11-04 23:25:01,"Great! Thanks!
",ming-codes,2014-11-04 23:13:26
728,2014-11-01 14:31:51,"I am doing ember dev and use http-proxy to proxy request from ember to server.
the code is as below.

<S_CODE_TOKEN>

the req header and body seems ok from the log output:

<S_CODE_TOKEN>

but after proxy, the rails get params as below:

<S_CODE_TOKEN>

the correct params should like 

<S_CODE_TOKEN>

it seems the proxy parsed the form data in url in a ""error"" way that rails treat the params before ""passwor"" as a entire string. BTW, why ""password"" lost a ""d"" ...

could someone help? thanks.
",feitian124,
728,2014-11-03 15:39:39,"it seems express bodyParser and connect-restreamer problem.
somehow after two transform, the data is not correct anymore for proxy..
",feitian124,
727,2014-10-31 21:56:12,"NTLM authentication sends a challenge and response which translate to www-authenticate fields which are concated into a single string. When you send the response back proxied you need to split the string and send it back as an array. You will still need to create a keepalive agent to use this. So I used the library agentkeepalive like so..

To actually use this code a relevant code snippet might be:

<S_CODE_TOKEN>

/*
",mburbea,2015-10-30 21:03:08
727,2014-10-31 21:58:00,":+1: 
",jonnii,2015-10-30 21:03:08
727,2014-10-31 22:08:48,"There should be a way to do this without injecting this logic here. Perhaps exposing a way to mutate headers before they are written?
",indexzero,2015-10-30 21:03:08
727,2014-10-31 22:43:06,"@mburbea you can listen for the `proxyReq` event and modify/add headers before the request is sent. 
",jcrugzz,2015-10-30 21:03:08
727,2014-11-01 04:28:09,"Perhaps I could, but I don't know if this is the best way to resolve this. Proxying NTLM is a very common scenario in corporate settings. This is not some oddball case and most other proxies can actually handle this scenario just find.  It is also extremely hard to find documentation on this, and other people who use this tool and need to proxy ntlm would have a much easier time if this was added and certainly documentation about this case would be great. The fact that out of the box, keepalive wasn't configured was actually alarming (without using the agent but using this patch you will get a 400 bad-request on the challenge part of ntlm). I think that the issue in that the two request headers `www-authenticate` are mangled into a single string when received but need to be sent back to the proxied header as an array of the components. There might be other such mangling. Just like x-headers are supported, I'd be ok with a ""ntlm"" switch something that makes it obvious to use without being something entirely custom.
",mburbea,2015-10-30 21:03:08
727,2014-11-06 16:52:33,"How exactly could I go about doing this with proxyReq? I can't seem to figure it out and proxyRes I assume is too late in the pipeline to be relevant. 
",mburbea,2015-10-30 21:03:08
727,2014-11-06 17:06:59,"@mburbea I realized you do want `proxyRes` as the event is emitted right before we go through the function you have modified in the PR. So while not elegant, the solution would be as follows.

<S_CODE_TOKEN>

The rest is taken care of by the exact function you modified since you were able to touch the headers before hand. I will still consider your PR if this use case is large enough, I just dislike the custom logic bit as it seems niche to me.
",jcrugzz,2015-10-30 21:03:08
727,2014-11-06 17:16:40,"Thanks that does indeed work. I was able to visit my proxied site.
NTLM-SSPI  authentication is not very niche in corporate intranet/internal app development. For now, I will happily switch to using this in my proxying code, but I would like to remove it as it a hack as you said.   #362 is an outstanding issue  is actually where I got the logic for the code change and the second half of the puzzle (requiring to switch to an agent that supports keepalive).
",mburbea,2015-10-30 21:03:08
727,2014-11-07 17:21:57,"@mburbea I still believe there should be no agent by default but we should be clear in the documentation that this disables keepalive and to suggest using this module for that particular case. I'd definitely take a PR for the documentation :smile: 
",jcrugzz,2015-10-30 21:03:08
727,2015-06-11 15:18:48,"+1
",robertlevy,2015-10-30 21:03:08
727,2015-10-30 21:03:08,"This shouldn't be handled in `http-proxy`. Adding my example to the examples folder as we speak
",jcrugzz,2015-10-30 21:03:08
726,2014-10-30 07:39:00,,JIoJIaJIu,2014-10-30 07:40:22
726,2014-10-30 07:40:22,"If we're going to implement this then we should implement it for real. In this implementation it is shared auth between the forward and target proxy settings. Also, please respect the project style (2-space soft tabs).
",indexzero,2014-10-30 07:40:22
726,2014-10-30 08:26:23,"Execuse me, I've founded option.ssl for resolve my problem
",JIoJIaJIu,2014-10-30 07:40:22
725,2014-10-29 21:19:13,"In http-proxy.js around line 241, url.parse is used to extract the request path:
    outgoing.path       = url.parse(req.url).path;
For example, an URL like /xxx/Tenant('xxx') is proxied as /xxx/Tenant(%27xxx%27).

We have consumers that cannot handle the encoded URL, and I cannot find a way to monkey-patch that method.  Would it be possible to make this encoding optional?  Use req.path in that case instead?
",smill01,
725,2014-10-30 05:24:50,"I think you are using an older version of `http-proxy` since that line number doesn't exist. Based on the variable name I believe the code in question is [now located here.](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L68-L73)

We would accept a pull-request that:
1. Accepted an optional `urlParser` option to new `HttpProxy` instances, defaulting to `url.parse`
2. Passed that to `setupOutgoing` in the `options` parameter
3. Used that parameter instead of `url.parse`.
",indexzero,
724,2014-10-29 03:13:57,"A little fix for docs.
",whitecolor,2014-10-29 14:52:10
724,2014-10-29 14:52:14,"Thanks!
",jcrugzz,2014-10-29 14:52:10
723,2014-10-29 02:31:20,"Added changeOrigin option with test and some docs
",whitecolor,2014-10-29 02:52:50
723,2014-10-29 02:52:48,"@whitecolor awesome thanks!
",jcrugzz,2014-10-29 02:52:50
723,2014-10-29 02:54:11,"published as `1.6.0`
",jcrugzz,2014-10-29 02:52:50
722,2014-10-28 08:30:48,"Add changeOrigin option that changes host in request headers
",whitecolor,2014-10-29 02:31:59
722,2014-10-28 15:25:58,"@whitecolor LGTM. If you could add a simple test and some docs around this it would be great :).
",jcrugzz,2014-10-29 02:31:59
722,2014-10-29 02:31:59,"Add new pull with test and docs https://github.com/nodejitsu/node-http-proxy/pull/723. Closing this one.
",whitecolor,2014-10-29 02:31:59
721,2014-10-28 03:43:36,"It seems that proxyReq event is not emitted for HTTP proxy:

https://github.com/nodejitsu/node-http-proxy/blob/3e8ee042fb8ac93e6f8c347aa4ce49eeec968645/lib/http-proxy/passes/web-incoming.js#L114

no other emits in the code.
",whitecolor,
721,2014-10-29 20:17:38,"@whitecolor what do you mean? the event is emit before anything happens. The only caveat here is that you must be using the event emitter interface and not passing a callback. this should be fixed in later versions.
",jcrugzz,
721,2014-11-08 18:44:59,"@whitecolor The `proxyReq` event (or any event for that matter) will not be emitted if you provide an error callback to either the `proxy.web` or `proxy.ws` methods.

This behavior is not documented anywhere, to my knowledge. I had to read the code to figure it out.
",hgwood,
721,2014-11-09 03:40:19,"@hgwood yes its remanent of when the callback use case used to not be an event emitter. This will be changed, if you want to take a stab at it, go for it :).
",jcrugzz,
720,2014-10-27 07:28:43,"Trying to proxy request to /api to external server:

<S_CODE_TOKEN>

But proxy returns (client gets) 404. Where `someexternalserver.com` is hosting server.

This works with localhost. It should be simple. What is the problem?
",whitecolor,2014-10-29 09:31:14
720,2014-10-28 03:34:06,"this is due to https://github.com/nodejitsu/node-http-proxy/issues/696
",whitecolor,2014-10-29 09:31:14
720,2014-10-29 09:31:14,"Fixed with https://github.com/nodejitsu/node-http-proxy/pull/723
",whitecolor,2014-10-29 09:31:14
719,2014-10-23 23:31:15,"Sockets are ballooning within the node proxy when handling the websockets. A port gets allocated for each one between node and the proxy targets.

<S_CODE_TOKEN>

Ref: https://github.com/jupyter/configurable-http-proxy/issues/18
Ref: https://github.com/jupyter/tmpnb/issues/73
",rgbkrk,
719,2014-10-23 23:32:28,"That's how web sockets work, they retain connection for as long as they're active.
",Rush,
719,2014-10-24 00:03:05,"> That's how web sockets work, they retain connection for as long as they're active.

This is certainly true, but does one client really need a new port for each connection between the proxy and the proxy target?
",rgbkrk,
718,2014-10-21 15:19:05,"Hello,

I've set proxyTimeout options, but I'm unable to identify canceled requests from timedout ones. Is there a way to find if the request timedout ?

Or could we had an information to the request when it timeout, something like that :

<S_CODE_TOKEN>
",juliendangers,
718,2014-10-21 15:22:21,"@juliendangers the `error.code` should tell you. it should be `ETIMEDOUT` in timeout cases. Hmm if that code block is pulled from the code, we should technically let the proper error propagate instead of aborting in these cases. Play around with this if you can until I have time to look at it.
",jcrugzz,
718,2014-10-21 15:50:53,"@jcrugzz the above code is from web-incoming.js and this is the reason why the error code is ECONNRESET
",juliendangers,
718,2014-10-21 18:00:06,"@juliendangers if you could add a failing test for this, that would be super helpful! 
",jcrugzz,
718,2014-10-22 12:25:55,"@jcrugzz there is already a test, which ensures that error code is ECONNRESET : 

<S_CODE_TOKEN>
",juliendangers,
718,2014-10-22 12:47:07,"@juliendangers thanks for doing the legwork for me. Fix will be out momentarily
",jcrugzz,
718,2014-10-22 13:04:35,"hmm error doesn't seem to trigger appropriately when its the middle stream. This will take a bit more digging
",jcrugzz,
718,2014-10-24 16:03:14,"<S_CODE_TOKEN>

When proxyReq is aborted it triggers proxyReq.on('error', proxyError);

<S_CODE_TOKEN>

Since the request has been aborted the error is ECONNRESET

So we need to change the way the timeout is handled I think
",juliendangers,
717,2014-10-15 04:49:45,,waded,2014-10-15 05:35:41
716,2014-10-15 01:02:02,"As mentioned here https://github.com/nodejitsu/node-http-proxy/pull/384 
and the topic came up again here https://github.com/nodejitsu/node-http-proxy/issues/685
I thought I would make this pull req
Samples and test in harmon are connect 3 compatible so hope it's all OK :)   
",No9,2014-11-28 17:02:39
716,2014-11-28 17:02:47,"Thanks @No9 sorry for the wait!
",jcrugzz,2014-11-28 17:02:39
715,2014-10-14 21:39:13,"The answer here shows how that can be done: http://stackoverflow.com/questions/22453782/nodejs-http-and-https-over-same-port
",fresheneesz,
714,2014-10-11 14:14:17,"Is it possible to use node-http-proxy to proxy two back ends through one proxy server? I need the ability to proxy one or more websocket servers AND one web server. Is this possible? Thanks
",stodge,
714,2014-10-14 21:38:30,"You should try it, I think it can do that. Just use the `proxy.web` call to the same target in the request handler for both servers.
",fresheneesz,
713,2014-10-09 22:55:57,"The readme is just a bunch of examples. This needs real documentation that defines exhaustively what is returned from functions and what those functions can take as arguments. 

I'm coming across behavior where proxy.web is causing my script to die when i target ""http://localhost:undefined"", even tho i'm catching exceptions from it. I see that there's an error handler now that I search for it, but the paragraph style you're using to ""document"" this is incredibly difficult to visually parse. Its very difficult for me to figure out if I have reviewed all the available functionality without reading the entire page (ie i shouldn't have to read the examples to review the API).
",fresheneesz,
713,2014-12-01 18:22:01,"+1, I can't figure out for the life of me what's really included in the proxyReq and the proxyRes objects when listening for those events.

For example, the docs have the example

<S_CODE_TOKEN>

Except that `proxyReq.headers` is null.  I'm in a situation in which I REALLY need to look at the response body within proxyRes and the finalized headers in proxyReq except these things are undefined, and logging the entire object to try to find them turned up little of use.
",runspired,
713,2014-12-01 18:58:10,"@runspired `proxyReq.headers` will be null because headers are stored in a ""private property"" (_headers) of the [`OutgoingMessage`](https://github.com/joyent/node/blob/v0.10.33-release/lib/http.js#L683-L697). I agree that we need more documentation here and I would love a pull request to help this along :).
",jcrugzz,
713,2014-12-01 19:01:45,"And to clarify, the `proxyReq` event is called before the request is proxied to the target server. The `proxyRes` event is called when a response is received from the target server before responding to the client.
",jcrugzz,
713,2014-12-01 19:06:35,"@jcrugzz I know the order of events, specifically I've got an issue where a photo upload that was proxied to our API was working before a server migration but not after.  The API returns ""method not allowed"" when sending through the proxy but sending the POST request directly works.  Suspect it's something to do with an added or altered header, so trying to see the final state of the request just before it's proxied and the unmodified response before it's send back.

is the private property ""private"" (meaning OutgoingMessage._headers) or is it a scoped var I'm not going to be able to get access to?
",runspired,
713,2014-12-01 19:11:52,"@runspired there shouldn't be any reason you cannot output the headers when specifying the `proxyReq._headers` variable
",jcrugzz,
713,2014-12-01 20:23:17,"@jcrugzz when I log `proxyReq._headers` I see the `host` is the location of the proxy, not the location being proxied to.  Is this changed later, or is this mistakenly not updated?
",runspired,
713,2014-12-01 21:24:09,"@jcrugzz that in fact turned out to be my issue.  The ""host"" header is not updated to match the host of the host the proxy is pointing to.
",runspired,
713,2014-12-01 23:05:28,"@runspired that is expected, it seems you may be looking for the [`changeOrigin`](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L43) option if you want to modify the host of the request based on the `target` you get it. Or you can manually set it on the request itself as it is copied over.
",jcrugzz,
712,2014-10-09 06:31:52,,zhudan,2014-10-09 13:48:08
712,2014-10-09 09:56:49,":+1: thank you for your contribution @zhudan. What are your thoughts @jcrugzz? You've been looking this over most recently.
",indexzero,2014-10-09 13:48:08
712,2014-10-09 13:24:40,"@zhudan LGTM. My only question is why the custom re-streamer rather than using `connect-restreamer`. Just curious as it is the same logic.
",jcrugzz,2014-10-09 13:48:08
712,2014-10-09 13:33:18,"@jcrugzz yes, same logic, but just for json body.  his code has bug, https://github.com/dominictarr/connect-restreamer/blob/master/index.js#L15  should be: req.emit('data', req[options.property]).
when the body is xml, it can not use JSON.stringify(req.body), because it will be escaped, then the content-length (https://github.com/nodejitsu/node-http-proxy/issues/704#issuecomment-56791176)

Forgive my bad English .
",zhudan,2014-10-09 13:48:08
712,2014-10-09 13:48:06,"@zhudan gotcha, it looks like you would have to pass it a no-op stringify function for that particular case.
",jcrugzz,2014-10-09 13:48:08
711,2014-10-08 22:58:46,"My reverse proxy didn't like my requests because I needed to specify the protocol on the proxy config and include a colon on the end of the string. I wonder if the colon is over zealous code, a typo or really needed. 

Error:
    400 Bad Request
    The plain HTTP request was sent to HTTPS port

https://github.com/nodejitsu/node-http-proxy/blob/e7d50b1a376035a50c82db38605e99feb30afd36/lib/http-proxy/common.js#L28

https://github.com/nodejitsu/node-http-proxy/blob/fcdbf46e4d1301ac78da05eeeac583339a5dc43a/lib/http-proxy/passes/ws-incoming.js#L87

Note: connect does NOT require a colon on the protocol option. The server will fail to start with a fatal error message stating invalid protocol.

The grunt-connect-proxy settings needed to make http-proxy work:
![image](https://cloud.githubusercontent.com/assets/1424580/4568754/234995d0-4f3e-11e4-9bff-7bff415cc3a8.png)
",javadoug,2014-12-09 04:04:53
711,2014-10-09 00:45:43,"@javadoug we expect to receive a full URL string or an object that has been parsed by [`url.parse()`](http://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost). This is why I just deal with URL strings when it comes to config as it simplifies it infinitely.
",jcrugzz,2014-12-09 04:04:53
711,2014-10-09 03:02:17,"@jcrugzz thanks for getting back. pls consider an alternative, perhaps, checking with regex /^https:?/.test(protocol). And if the code construct urls from the parts, the url class supports protocol with and without the colon.
",javadoug,2014-12-09 04:04:53
711,2014-10-09 13:23:12,"@javadoug I'd take a PR with a proper regex :). I'd export a protocol regex from `common` so it can be used in both places. Should be something like `exports.protocolRegex = /^https|wss/`. This also makes sure its precompiled.
",jcrugzz,2014-12-09 04:04:53
711,2014-12-09 04:05:19,"@javadoug implemented in 1.7.3
",jcrugzz,2014-12-09 04:04:53
711,2014-12-09 14:29:42,"thank you.

On Dec 8, 2014, at 11:05 PM, Jarrett Cruger notifications@github.com wrote:

> @javadoug implemented in 1.7.3
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
",javadoug,2014-12-09 04:04:53
710,2014-10-07 22:39:34,"Hello
I just started using this module and really like it.

I am having an issue with following code:
      var proxy = httpProxy.createProxyServer({});
      proxy.web(req, res, { target: ""https://myserver"" }) 
if req.url has something like http://someServer/someService?config=http://server2.com/a.json, the outgoing URL becomes http://someServer/someService?config=http:/server2.com/a.json.  I traced the code and it looks like common.urlJoin converts multiple '/' to single '/'.  How can I avoid this issue?

Thanks
",wenjunche,2014-12-02 17:28:53
710,2014-10-09 22:51:03,"This is what I had to do with the same problem: https://github.com/nodejitsu/node-http-proxy/issues/703#issuecomment-58553894

I just commented out the problem line and manually set outgoing.path = outgoingPath
",odmarkj,2014-12-02 17:28:53
710,2014-12-02 17:28:53,"Should be fixed
",jcrugzz,2014-12-02 17:28:53
709,2014-10-01 02:57:29,"adds `socket.end()` to `on('error')` handlers for proxyReq and proxySocket

covers a case that I thought I was testing for in #708, but missed because the client `error` event simply didn't fire.
",minrk,2014-10-01 11:10:22
709,2014-10-01 11:10:20,"@minrk good looks! Thanks again.
",jcrugzz,2014-10-01 11:10:22
708,2014-09-30 23:15:53,"avoids leaving client sockets open when upstream connections are rejected before the upgrade event fires.

I'm not 100% sure about the style or logic of the patch, but the added test cases and my own code suggest that it is doing the right thing. Guidance would be appreciated.

closes #624
closes #627
",minrk,2014-10-01 00:55:38
708,2014-09-30 23:37:44,"Hm, on further testing, this isn't quite sufficient to fix my use case. I'll dig in some more.
",minrk,2014-10-01 00:55:38
708,2014-10-01 00:00:55,"Okay, this PR now actually fixes my problem. The key is handling the proxyReq response when `upgrade` won't fire. I think `on('request')` when `response.upgrade` is false is the right way to handle this.
",minrk,2014-10-01 00:55:38
708,2014-10-01 00:55:34,"@minrk based on what i understand [here](https://github.com/joyent/node/blob/v0.10.32-release/lib/http.js#L1608-L1621) this looks like the correct behavior. Awesome job!
",jcrugzz,2014-10-01 00:55:38
708,2014-10-01 00:58:27,"@minrk my only question is if we should do something about the response as well in the case where it is not an upgrade request.
",jcrugzz,2014-10-01 00:55:38
708,2014-10-01 02:47:58,"Since the `on('upgrade'...` event registered just below fires in that case, I can't think of anything extra that you would do, but I'm new to this stuff.
",minrk,2014-10-01 00:55:38
707,2014-09-30 18:48:26,"After upgrading to 1.5, my code started failing with:

<S_CODE_TOKEN>
",minrk,2014-09-30 19:27:35
707,2014-09-30 19:27:35,"@minrk whoops, fixed this before i saw the PR. Thanks!
",jcrugzz,2014-09-30 19:27:35
707,2014-09-30 20:31:46,"No problem, just glad it's fixed. Thanks for the prompt release of 1.5.1.
",minrk,2014-09-30 19:27:35
706,2014-09-29 02:48:27,"Basically I need access to the proxySocket in order to listen to messages coming back.

I realize the implementation is a bit hacky, but it's the only way I could think of ATM. I'm open for other suggestions.

Here is an example use case taken from [chromium-remote-debugging-proxy](https://github.com/thlorenz/chromium-remote-debugging-proxy/blob/792e92a1fe3f8035dd6f78504c2d5880756ce340/index.js#L85-L89)

<S_CODE_TOKEN>

If there is an existing way to make this work, please let me know as well.
",thlorenz,2014-09-30 02:34:06
706,2014-09-29 20:38:06,"@thlorenz what if we emit the proxySocket in an event on the `httpProxy` instance to be handled separately. It seems like that could work.
",jcrugzz,2014-09-30 02:34:06
706,2014-09-29 20:48:21,"@jcrugzz that'd be even better cause then I'd know when I can subscribe to its event instead of having to test if its there yet or not.

Do you want me to update the PR to do that? Only question is what's our event emitter? The only one I see inside `ws-incoming.js` is the `server`. That'd also be hacky to emit things on the server I guess.

Any other emitters you see?
",thlorenz,2014-09-30 02:34:06
706,2014-09-29 20:51:04,"Well, I guess the `socket` is also an emitter, but that'd be almost equally hacky to emit some event from it.

> emit the proxySocket in an event on the `httpProxy` instance

obviously that'd be ideal, but I don't see that we have access to it from within `ws-incoming.js`.
",thlorenz,2014-09-30 02:34:06
706,2014-09-29 21:28:17,"@thlorenz naming is just terrible here. The `server` object thats passed in is the actual proxy instance.
",jcrugzz,2014-09-30 02:34:06
706,2014-09-29 21:31:08,"OK, will update the PR tonight (will just rewrite it). `.emit('proxy-socket', proxySocket)` is ok - I mean the event name?
",thlorenz,2014-09-30 02:34:06
706,2014-09-29 21:42:30,"@thlorenz make it `proxySocket` for consistency with other events. Other than that, just document the event in the readme and I'll merge when ready :).
",jcrugzz,2014-09-30 02:34:06
706,2014-09-30 00:09:12,"I updated the PR to emit the `proxySocket` and updated the Readme, but I used a method in the example (`hybiParseAndLogMessage`) to indicate that you can't just log raw websocket data.
However implementation of that method isn't shown in the example to keep it simple.

Hope that's ok.
",thlorenz,2014-09-30 02:34:06
706,2014-09-30 02:34:04,"LGTM
",jcrugzz,2014-09-30 02:34:06
706,2014-09-30 02:34:11,"@thlorenz thanks!
",jcrugzz,2014-09-30 02:34:06
706,2014-12-29 22:54:59,"I'm a little confused as to how people are making use of this feature (renamed to `open` event in a later release).  Am I missing something or is there no way of figuring out which call to `proxy.ws` this corresponds to (eg by also including `req` or something like that as an event argument, like the `error` event gets)?

(Use case: we're proxying to many backends, and want to place a `readable` event on the proxySocket so that we can learn if a given backend has had any recent traffic.)
",glasser,2014-09-30 02:34:06
706,2014-12-30 14:56:07,"@glasser id be ok with emitting multiple arguments on that event. Submit a PR with an ordering that makes sense.
",jcrugzz,2014-09-30 02:34:06
705,2014-09-26 03:54:54,"options.xfwd definitely works fine without using the .listen method, and, AFAICT, .toProxy should as well.  Only .ssl and .ws are referenced in .listen.
",Jimbly,2014-09-26 04:01:36
705,2014-09-26 04:01:35,"@Jimbly Thanks!
",jcrugzz,2014-09-26 04:01:36
704,2014-09-24 07:51:57,"https://github.com/nodejitsu/node-http-proxy/tree/caronte/examples/middleware

the connect is update to 3.2.0; your examples can not start up!
",zhudan,2014-10-09 06:50:35
704,2014-09-24 07:53:12,"@zhudan those are probably out of date to begin with. We could really use your help updating them :)
",indexzero,2014-10-09 06:50:35
704,2014-09-25 08:53:34,"@indexzero  when i post a xml body, i want modify this body, but the proxy post the xml is escaped ("""""" become ""\""""), so the content-length header is smaller than the length of body. it's can not post all xml.

the code is this line, https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/http-proxy/passes/web-incoming.js#L117 ; i modified this line to proxyReq.end(req.rawbody), it's work, but it can not work in all environment.

i really want to  know why ? can you tell me? thank you~
",zhudan,2014-10-09 06:50:35
704,2014-09-27 07:06:34,"done!
",zhudan,2014-10-09 06:50:35
704,2014-09-30 19:28:02,"Could you submit a pull request for this change?
",indexzero,2014-10-09 06:50:35
704,2014-10-08 09:07:51,"@indexzero Ok, i will update later.
",zhudan,2014-10-09 06:50:35
704,2014-10-09 06:50:35,"updated. https://github.com/nodejitsu/node-http-proxy/pull/712
",zhudan,2014-10-09 06:50:35
703,2014-09-23 07:38:41,"In the first place it's somewhat poorly documented, so perhaps I'm just doing it wrong.

Say I do this:

<S_CODE_TOKEN>

I should expect squidproxy:3128 to receive a `GET http://destination/yay HTTP/1.1`. Instead, it receives a `GET http:/destination/yay HTTP/1.1` - note the single slash after protocol. It looks like `common.urlJoin` is causing the munging here.
",samcday,2014-12-02 17:28:45
703,2014-09-23 14:12:06,"@samcday could you submit this in the form of a broken test case? It must be too simplistic. It may be fixed by [`url-join`](http://browsenpm.org/package/url-join) if you want to submit a fix with that broken test case. Otherwise I'll give it a look later today
",jcrugzz,2014-12-02 17:28:45
703,2014-09-25 13:16:06,"@jcrugzz not sure I'll have time to look into this further. I think the information I set out in the original issue description is enough to reliably reproduce the problem.

I ended up just rolling my own proxying using `mikeal/request`, since it handles client proxying pretty elegantly, and I didn't really need any of the other bells-and-whistles from `http-proxy`.
",samcday,2014-12-02 17:28:45
703,2014-10-09 18:20:59,"Just an FYI, this was the problem line for me: outgoing.path = common.urlJoin(targetPath, outgoingPath); in common.js.

This was returning an invalid URL.

targetPath = '/';
outgoingPath = 'http://joshuaodmark.com/proxy_test.php';

Was returning ""/http:/joshuaodmark.com/proxy_test.php"".
",odmarkj,2014-12-02 17:28:45
703,2014-11-04 12:58:21,"rewrite function common.urlJoin as follow:

common.urlJoin = function() {
  var args = Array.prototype.slice.call(arguments);
  // Join all strings, but remove empty strings so we don't get extra slashes from
  // joining e.g. ['', 'am']
  var arr = args.filter(function filter(a) {
      return !!a;
  });

  var i = 0;
  for(i = 0; i < arr.length; i++)
  {
      arr[i] = arr[i].replace(/([\s\S]_?)(\/_)$/, function(all, sec1, sec2){
          return sec1;
      });
  }

  arr = arr.filter(function(a){
      return !!a;
  });

  return arr.join('/');
};
",yulesyu,2014-12-02 17:28:45
703,2014-11-04 13:21:10,"@yulesyu will take a pull request with added test!
",jcrugzz,2014-12-02 17:28:45
703,2014-12-02 17:28:45,"Should be fixed
",jcrugzz,2014-12-02 17:28:45
703,2015-10-08 10:46:57,"I'm using 1.11.2 and trying to make my request hit a cntlm proxy.

I see the requests but the url is like:

<S_CODE_TOKEN>

Note the slash at the beginning of the URL.

I'm using the `toProxy=true` option, putting the proxy as my target and changing the req.url to contain the host part. 

If I disable it, the url becomes only the `<path>`.

Is this a regression ? Or am I badly miss-using the module ?
",callmemagnus,2014-12-02 17:28:45
702,2014-09-16 21:58:37,"""Is it then possible"" -> ""It is then possible""
",shebson,2014-09-16 22:21:35
702,2014-09-16 22:21:35,"Thanks!
",jcrugzz,2014-09-16 22:21:35
701,2014-09-16 08:36:18,"Code:

<S_CODE_TOKEN>

The server get two url params on every request:

<S_CODE_TOKEN>

1.4.3 on Mac/Windows
",devon,2014-09-16 08:57:23
701,2014-09-16 08:57:34,"My mistake, I use wrong target.
",devon,2014-09-16 08:57:23
700,2014-09-16 06:04:39,"Despite the awesome module, I can't get a proxy chain when using SSL, and I have try everything, so maybe here someone can help me:
- A proxy chain where a client sends to an HTTP proxy, and this to another HTTP proxy is not a problem and runs perfect with nodejistu proxy module, great!
- But in my case the client request for a HTTP final target (https://somewhere.com) so the client use a CONNECT against the proxy, and the proxy will not connect to somewhere; my problem is that I need to forward to another proxy that finally has to connect to somewhere.com
  In any case I can get the client connected and using the proxy-chain  and I do not found how to resolve this.

The main idea is that the first proxy is somehow like a balancer that gets the better 2nd proxy for each request.

Not sure if this post is appropiate as an issue but didnt find a better place :o(
",earroyoron,
700,2014-09-16 18:28:01,"@earroyoron could you give some code and maybe be more specific on the issue? If there is another proxy in the mix that is being tunneled through, you probably want to pass in something like [`tunnel`](http://browsenpm.org/package/tunnel) as an agent. This is common for corporate proxies. Otherwise I'm not quite sure what you are trying to do so more info would help :)
",jcrugzz,
700,2014-09-18 04:02:16,"@jcrugzz Trying to be more specific:

I have the below code working; in that scenario:
CLIENT --> PROXY --> TARGET (https://somewhere.com)
But I need that proxy do not connect to target. My proxy has a list of operative proxies and I have to use a different one for each client request so:
CLIENT --> PROXY --> PROXY2 --> TARGET 
Here I cannot manage that proxy will forward the client, I think due to the connect (proxies are http but final target is ssl)

This is my code working for the first scenario:

// Create an HTTP tunneling proxy
var proxy = http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('okay');
});

proxy.on('connect', function(req, cltSocket, head) {
  // connect to an origin server
  var srvUrl = url.parse('https://' + req.url);
  console.log(JSON.stringify(srvUrl) + "";""+srvUrl.port +  'host'+srvUrl.hostname
);
  var srvSocket = net.connect({'port': srvUrl.port, 'host':srvUrl.hostname}, function() {
    cltSocket.write('HTTP/1.1 200\r\n' +'Proxy-agent: Node-Proxy\r\n' + '\r\n');
    srvSocket.write(head);
    srvSocket.pipe(cltSocket);
    cltSocket.pipe(srvSocket);
  });
});
",earroyoron,
700,2014-10-04 07:14:27,"Have the proxy forward the request data to an http.request() method, and then in the callback function, pipe the response back to the proxy and that'll allow you to use node-http-proxy in the manner you're describing.

Also keep in mind that tunneling SSL is somewhat difficult. So, I suggest referring to the pem module for help in resigning the certificate for when the proxy communicates back to the client, it still shows as a trusted connection.
",gm112,
700,2014-10-21 20:14:39,"@gm112 I tried to email you, but it looks like your domain is down.

Can you give an example of what that would look like? A forwarded request using http.request?
",odmarkj,
700,2014-10-25 02:52:28,"http://nodejs.org/api/http.html#http_http_request_options_callback

This is the method you would use. So, add a listener on your HTTPS server, ""connect"", (http://nodejs.org/api/http.html#http_event_connect) and within this body, use the http.request method to call out to where ever you're going. 

Mind you, if you're trying to tunnel SSL to any site, you're going to have to generate SSL certs on your SNI callback method. Otherwise, you're fine just using whatever cert you provide the https.createServer() method. If I wasn't mobile I'd give you sample code but I tried my best to point you in the direction atm. ;)
",gm112,
700,2014-11-06 06:11:10,"I am still not 100% sure how to accomplish this. I looked at the http.request method, but it doesn't look like you can set a proxy on that. I am trying to do the same thing described above:

CLIENT --> PROXY --> PROXY2 --> TARGET 
CLIENT --> PROXY --> PROXY3 --> TARGET 
CLIENT --> PROXY --> PROXY4 --> TARGET 

Etc.
",odmarkj,
700,2014-11-06 06:25:39,"http.request(); itself doesn't proxy.

Here, take this really rough code for example. And it sounds like what you're doing can be accomplished by using node-cluster in conjunction with node-http-proxy and the http/https/url libraries.

Cluster would act as the main ""Proxy"" or ""load-balancer"", then Proxies 0 - 4 would be your worker processes, which would then forward the request to the target and finaly back around to the client.

// Setup HTTP server
        self.httpsServer = https.createServer(self.onRequest);
...
then you add a listener...

 self.httpServer.addListener('connect', function (request, socket, head) {
...
...
use node-http-proxy here and pass on the request,socket,and head.
}

var onRequest = function (request, response) {
var tunnelRequest = (request.url.protocol === 'https:' ? https : http).request(request.options, function (proxyResponse) {
...
add event listeners here. Refer to http://nodejs.org/api/http.html#http_http_request_options_callback

..

}

tunnelRequest.on('end', function () {
console.log('closing tunnel');
});

tunnelRequest.on('error', function(error) {
console.log('Oh noz' + error.message);
});

}
",gm112,
700,2014-11-06 06:55:53,"I think my problem is here: use node-http-proxy here and pass on the request,socket,and head.

I can catch the connect event, but no matter what code I put in there, I cannot get a successful response to the client. Even if I forget the PROXY2 or PROXY3 value.

proxy_server.ws(req, socket, head);

Would you be willing to consult for a quick period of time? I really want to get past this bug.
",odmarkj,
699,2014-09-12 16:54:13,"[This commit](https://github.com/nodejitsu/node-http-proxy/commit/ed73f06ed307ad2204e565781cc3154047941a8c) can completely break production apps and this or a similar hotfix needs to be deployed ASAP.
",STRML,2014-09-12 17:10:30
699,2014-09-12 16:57:14,"@STRML Could you add test so @jcrugzz doesn't break it again ;-)?
",3rd-Eden,2014-09-12 17:10:30
699,2014-09-12 16:57:59,"Yep - working on that right now, just figured I should get the fix in ASAP.

On Sep 12, 2014, at 12:57 PM, Arnout Kazemier notifications@github.com wrote:

> @STRML Could you add test so @jcrugzz doesn't break it again ;-)?
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
",STRML,2014-09-12 17:10:30
699,2014-09-12 17:01:30,"Yes, it should, but I can't release a new version anyways as I don't have publish rights (which is why I haven't merged it in yet either)
",3rd-Eden,2014-09-12 17:10:30
699,2014-09-12 17:08:45,"Ok. I have amended the commit to include a test.

On Sep 12, 2014, at 1:01 PM, Arnout Kazemier notifications@github.com wrote:

> Yes, it should, but I can't release a new version anyways as I don't have publish rights (which is why I haven't merged it in yet either)
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
",STRML,2014-09-12 17:10:30
699,2014-09-12 17:11:04,"Thanks a lot for contribution. Will make sure that is out as fast as possible.
",3rd-Eden,2014-09-12 17:10:30
699,2014-09-12 17:52:23,"Pubished as `v1.4.3`. Thanks for the reports and contributions.
",cronopio,2014-09-12 17:10:30
699,2014-09-12 20:24:31,"@STRML thanks a ton for the fix. I go and try and fix a windows bug and I do something terrible xD. Im very curious of the case that caused the path to be prefixed with `/`. Would you mind sharing?
",jcrugzz,2014-09-12 17:10:30
699,2014-09-12 20:56:53,"@jcrugzz It could happen two ways, possibly resulting in `///`. It is suggested, but not documented as a requirement, that there should be no trailing slash in the target or leading slash in the proxied path.

I had been using a target as a deep path, something like `http://localhost:3000/api/`, and my proxied paths were read from `req.url` so they were often something like `/user/login`. While `path.join()` handled this properly, your code would create `http://localhost:3000/api///user/login`.

Understandably there shouldn't be a trailing slash in the target, but it is very common for there to be a leading slash in the proxied path (from req.url), and this commit broke that case as well with a double slash.
",STRML,2014-09-12 17:10:30
699,2014-09-13 01:48:03,"Thanks for quickly responding to this issue.
",arnihermann,2014-09-12 17:10:30
698,2014-09-12 11:39:04,"Hi 
On the windows system the requests to targetDomain goes with double backslashes: ""GET \mypath\.."" and couses  ""Invalid URI in request"" error.
Under linux all works right.
The problem affects http-proxy@1.4.1
Under http-proxy@1.3.0 proxy works fine.

Example:
var express = require('express');
var httpProxy = require('http-proxy');

var apiProxy = httpProxy.createProxyServer();
var app = express();
var targetDomain = ""http://myserver/"";

app.get(""/mypath/*"", function(req, res){
    apiProxy.web(req, res, { target: targetDomain });
});

Regards

Bartek
",bbarni,2014-09-12 11:51:32
698,2014-09-12 11:44:31,"It seems to be the same issue: https://github.com/nodejitsu/node-http-proxy/issues/697
",bbarni,2014-09-12 11:51:32
698,2014-09-12 11:51:32,"fixed in `1.4.2`
",jcrugzz,2014-09-12 11:51:32
698,2014-09-12 15:32:53,"I've already tested it on windows and linux and there is still similar problem:
""POST ///wigeoweb/ProcessCmd HTTP/1.1"" 404
There are three times slashes in the url redirected to the targetDomain.
Windows and linux crashes as well.
",bbarni,2014-09-12 11:51:32
698,2014-09-15 16:51:37,"@bbarni this was fixed in `1.4.3`
",jcrugzz,2014-09-12 11:51:32
697,2014-09-12 07:19:56,"I try to build a simple proxy on windows with http-proxy, the following code works on mac, but it does not work on windows XP.

<S_CODE_TOKEN>

The nginx server didn't receive the header information, and respond 404 information.

<S_CODE_TOKEN>
- Node: v0.10.13
- http-proxy: 1.4.1
",devon,2014-09-12 11:51:01
697,2014-09-12 11:43:58,"It seems to be the same issue: https://github.com/nodejitsu/node-http-proxy/issues/698
",bbarni,2014-09-12 11:51:01
697,2014-09-12 11:51:01,"Fixed in `1.4.2`. `path.join` was the culprit. Thanks for the report!
",jcrugzz,2014-09-12 11:51:01
697,2014-09-12 11:52:58,"It works now. Thank you.
",devon,2014-09-12 11:51:01
696,2014-09-11 20:40:54,"Why was changeOrigin removed? It seems like it was killed in the v1.0.0 refactor with no explanation? Changelogs show nothing?

https://github.com/nodejitsu/node-http-proxy/commit/3330e125aaf85862399141bf0ad5af3aea4f1000
",solidspark,2014-10-29 02:57:02
696,2014-09-12 01:32:32,"@solidspark looking at that functionality, we can totally add that as an option with it defaulted to false. I will most definitely take a pull request :smile: 
",jcrugzz,2014-10-29 02:57:02
696,2014-10-28 04:09:08,"This needs to be fixed and its simple.
",whitecolor,2014-10-29 02:57:02
696,2014-10-28 05:07:02,"@whitecolor could you submit a simple pull request?
",indexzero,2014-10-29 02:57:02
696,2014-10-28 08:31:39,"https://github.com/nodejitsu/node-http-proxy/pull/722

Well I'm not sure if it is completly correct (it works for me). What about documentation and tests?
",whitecolor,2014-10-29 02:57:02
696,2014-10-28 14:58:53,":+1: Fork works for me
",jbender,2014-10-29 02:57:02
696,2014-10-29 02:57:02,"Fixed with #723 
",jcrugzz,2014-10-29 02:57:02
695,2014-09-11 11:21:44,,outime,2014-09-11 12:07:15
695,2014-09-11 12:07:13,"Thanks for your contribution.
",3rd-Eden,2014-09-11 12:07:15
694,2014-09-10 20:31:23,"setup: 6 node processes on 4 CPU. 1 node process for node-http-proxy

---

After hitting 64k connections. CPU on the proxy node process is STILL 20% usage.

---
## THEN

After hitting 80k connections. CPU on the proxy node JUMP to 100% and stays there forever. New connections takes massive amount of time to establish.
(NOTE: using HAProxy is fantastic in comparison, no such wierd performance problem, CPU stable low usage at a mere 4% even after hitting 200k, see attached top output for HAproxy in end)

top - 20:24:56 up 21:38,  3 users,  load average: 0.70, 0.58, 0.63
Tasks: 106 total,   2 running, 104 sleeping,   0 stopped,   0 zombie
Cpu(s): 25.4%us,  0.3%sy,  0.0%ni, 74.2%id,  0.0%wa,  0.0%hi,  0.1%si,  0.0%st
Mem:  15408156k total,  9025932k used,  6382224k free,   143280k buffers
Swap:        0k total,        0k used,        0k free,  4335988k cached

 4890 ec2-user  20   0 2414m 1.5g 6896 R 100.4 10.1   2:05.39 node
 4903 ec2-user  20   0 1168m 267m 7004 S  0.7  1.8   0:11.78 node
 4910 ec2-user  20   0 1169m 269m 7004 S  0.7  1.8   0:11.51 node
 1376 root      20   0  137m 2112 1064 S  0.3  0.0  24:52.71 redis-server
 4905 ec2-user  20   0 1168m 268m 7008 S  0.3  1.8   0:11.70 node
 4906 ec2-user  20   0 1168m 269m 7004 S  0.3  1.8   0:11.72 node
 4909 ec2-user  20   0 1168m 267m 7008 S  0.3  1.8   0:11.62 node
 4911 ec2-user  20   0 1167m 267m 7004 S  0.3  1.8   0:11.63 node

Proxy code as stolen from the docs and samples of the project github:

<S_CODE_TOKEN>

Note: HAproxy:

HAproxy load balancer setting tuned to serve 150k clients on m3 4 CPU machine 15G memory:
Each of 6 node processes uses an exact amount of 25% CPU and memory! That's AWESOME. very balanced. HAproxy uses 2% CPU after all connections are established and only chat messages are sent across node processes.

top - 19:27:42 up 20:41,  2 users,  load average: 2.18, 1.85, 1.57
Tasks: 103 total,   3 running, 100 sleeping,   0 stopped,   0 zombie
Cpu(s): 35.6%us,  1.6%sy,  0.0%ni, 61.8%id,  0.3%wa,  0.0%hi,  0.6%si,  0.1%st
Mem:  15408156k total, 12508056k used,  2900100k free,   140248k buffers
Swap:        0k total,        0k used,        0k free,  4287628k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 4136 ec2-user  20   0 1508m 641m 7020 S 26.3  4.3   7:32.35 node
 4137 ec2-user  20   0 1501m 626m 7020 R 25.6  4.2   7:35.79 node
 4128 ec2-user  20   0 1436m 629m 7020 S 25.3  4.2   7:32.33 node
 4134 ec2-user  20   0 1512m 643m 7020 S 24.3  4.3   7:33.69 node
 4132 ec2-user  20   0 1515m 648m 7024 R 23.0  4.3   7:29.56 node
 4130 ec2-user  20   0 1506m 632m 7020 S 21.0  4.2   7:35.93 node
 1925 root      20   0 52.3g 3.9g 3.9g S  3.7 26.6  43:53.58 mongod
 1376 root      20   0  137m 2104 1064 S  2.0  0.0  24:31.77 redis-server
 4115 haproxy   20   0 5313m 1.8g  560 S  2.0 12.1   1:14.04 haproxy
",ynkm169,
693,2014-09-08 21:24:51,"This completes the work started in: https://github.com/nodejitsu/node-http-proxy/pull/645
- Fixed tests
- Added a test for the path behavior
",EndangeredMassa,2014-09-08 22:23:42
693,2014-09-08 21:32:02,"@EndangeredMassa One thing I would do though is also support forward requests. Follow the convention we use of `options[forward || 'target']`. Otherwise this is great, thanks for the effort!
",jcrugzz,2014-09-08 22:23:42
693,2014-09-08 22:19:45,"I updated it, but I'm not really clear on how `forward` is supposed to be used here. Let me know if I need to tweak it.
",EndangeredMassa,2014-09-08 22:23:42
693,2014-09-08 22:23:39,"@EndangeredMassa its passed in as a variable so it does an undefined check relying on the `||` operator to default to `'target'` if its not a forward request. See [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L101).

And this looks great, thanks!
",jcrugzz,2014-09-08 22:23:42
693,2014-09-10 16:57:02,"Im realizing that this shouldnt necessarily be default behavior. This should be configured in some way. @EndangeredMassa naming suggestions? Seems like a boolean option is the best way to deal with this.
",jcrugzz,2014-09-08 22:23:42
693,2014-09-10 18:41:52,"Hrm. I expect this behavior to be default. In my mind, adding a url that includes a path in the `target` means that I want to use that full url, not just the host, port, and protocol.
",EndangeredMassa,2014-09-08 22:23:42
693,2014-09-10 20:23:18,"@EndangeredMassa Yea that's understandable. Im guessing our case at nodejitsu is the special case as it is more specific to how couchdb interprets the request. We currently proxy to couchdb instances with [`smart-private-npm`](https://github.com/nodejitsu/smart-private-npm) by setting the `host` to `registry.nodejitsu.com` for example and the URL is `https://myCouchdb.com/registry`. This change currently breaks the way we have been proxying. Ill think of a good option for this I suppose as that seems like it will be what is necessary.
",jcrugzz,2014-09-08 22:23:42
693,2014-09-11 08:25:59,"![](http://media.tumblr.com/tumblr_mcpond96Ff1qfontx.gif)

http://nodejsreactions.tumblr.com/post/66103133377/pull-req-that-fixes-a-bug-includes-docs-and-tests-and
",indexzero,2014-09-08 22:23:42
693,2014-11-11 09:05:55,"It should not be default unless a major version update, since this breaks backwards compatibility... we ended with such a problem in redbird, that already appends the target path if necessary: https://github.com/OptimalBits/redbird
",manast,2014-09-08 22:23:42
693,2014-11-11 20:20:07,"@manast it does not break backwards compatibility. It introduces a new feature that allows for the path to be part of the `target` when creating `HttpProxy` instances.
",indexzero,2014-09-08 22:23:42
693,2014-11-11 21:00:38,"@indexzero in my opinion that is not really the case, because even if not supported before, if you happen to have a path in the target, the new behaviour would break things. It is a bit in the grey zone, but I think the safest bet would have been to have it disabled by default, users wanting to use the new feature would have been forced to enable it manually. For instance, before this feature existed, many people created its own third party code for adding it, this code usually left the target with the complete path since it was not necessary to parse it just to remove it.
Anyway, it is too late now for anything so pointless discussion other than flagging that since http-proxy is so critical in many deployments, maintaining backwards compatibility should be taking very seriously.
",manast,2014-09-08 22:23:42
693,2014-11-11 21:40:44,"We do take backwards compatibility very seriously, and I will say it again: this is backwards compatible. Objects that `node-http-proxy` accepts should have only the properties that `node-http-proxy` expects and should be expected to be mutated by `node-http-proxy`. If a user was passing in superfluous properties that are now meaningful then they were using the library incorrectly to begin with. 

If you would like to update the documentation about this point I would greatly appreciate it.
",indexzero,2014-09-08 22:23:42
692,2014-09-07 13:10:53,"Hi,

So I'm using your proxy to split requests to Apache and socket.io:

<S_CODE_TOKEN>

However, now every user is showing up on Apache2 as coming from 127.0.0.1!

I need to know my users' IP address...

Here is the .php I'm using on Apache2:

<S_CODE_TOKEN>
",hynese,2014-09-08 02:42:02
692,2014-09-08 02:42:02,"@hynese use the `xfwd` option as seen [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L38). With that set to true you can check the `x-forwarded-for` header to see the original IP address.
",jcrugzz,2014-09-08 02:42:02
691,2014-09-02 04:26:24,"Firefox sends `keep-alive, upgrade`, not just `upgrade`, which was being turned into `close`.
",minrk,2014-09-16 19:42:41
691,2014-09-02 04:26:46,"closes #690
",minrk,2014-09-16 19:42:41
691,2014-09-16 03:58:38,"This is better fixed with a regular expression.
",indexzero,2014-09-16 19:42:41
691,2014-09-16 18:17:25,"Thanks, uses a regular expression now.
",minrk,2014-09-16 19:42:41
691,2014-09-16 18:25:00,"@minrk only problem I have here is that we will probably leak a socket with `keep-alive` true and having agent = false but firefox will be the only case. 

In regards to the regex, I think you might want `.test` to get a proper truthy value and to call it on the regex itself. Could you also add a test for this? Appreciate the contribution! :)
",jcrugzz,2014-09-16 19:42:41
691,2014-09-16 19:09:43,"Uses `.test` now, and includes a couple of tests.
",minrk,2014-09-16 19:42:41
691,2014-09-16 19:42:39,"@minrk excellent, thank you!
",jcrugzz,2014-09-16 19:42:41
691,2014-09-17 07:50:00,"Worth noting that the regular expression instance need not be constructed every time. It's a small perf optimization so I'm not sure how meaningful it would be.
",indexzero,2014-09-16 19:42:41
690,2014-08-29 19:03:23,"If I try to connect a websocket through a simple proxy from Firefox, it never triggers the upgrade event, nor proxies data to the server.

The Proxy:

<S_CODE_TOKEN>

Connect with the following js in Firefox:

<S_CODE_TOKEN>

<del>There is no output for a few seconds, no data is proxied, then the websocket fails, sending a request with the following headers, which *does* get proxied</del>

The 'Connection' header is converted from `keep-alive, upgrade` to `close`:

<S_CODE_TOKEN>

The same request proxies just fine from Chrome and Safari, so there's something different about how Firefox initiates websocket requests.

This is with current master (d16062bba20826a769782797f555189077c742be) node-http-proxy, and nodejs 0.10.30, and Firefox 31.

**Update: Fixed symptom description**
",minrk,2014-09-30 18:37:52
690,2014-08-29 19:21:57,"@minrk this feels like a bug in firefox's websocket implementation as the tests pass with the `ws` library that we use for testing. Browsers are notorious for having broken websocket implementations. @3rd-Eden what does this look like to you? (@3rd-Eden is realtime web expert)
",jcrugzz,2014-09-30 18:37:52
690,2014-08-29 19:29:40,"It might be a bug in FF's websocket implementation, but it's not a bug that affects any other ws app I have encountered, so there does seem to be something uniquely brittle in node-http-proxy.  Is there an event that fires on every incoming request, so I can start diagnosing the difference between the working and non-working requests?
",minrk,2014-09-30 18:37:52
690,2014-08-29 19:47:31,"@minrk @jcrugzz Firefox should implement the latest specification of the WebSocket protocol, so I don't see anything obvious that should be wrong here. 
",3rd-Eden,2014-09-30 18:37:52
690,2014-08-29 19:49:03,"@minrk Are you running firefox without any plugins?
",3rd-Eden,2014-09-30 18:37:52
690,2014-08-29 19:55:28,"My test code: 

<S_CODE_TOKEN>

Work fine on my firefox: `""Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:31.0) Gecko/20100101 Firefox/31.0""`
",3rd-Eden,2014-09-30 18:37:52
690,2014-08-29 22:16:17,"Intriguing. It appears to be relevant that my websocket server behind the proxy is Tornado. Your test runs fine for me, but when it's my Tornado websocket server behind the proxy on 8001, Firefox connections never succeed. Firefox connections directly to the Tornado server, bypassing the proxy, work just fine, but proxied connections are never established. What seems particularly strange is the proxy's HTTP server 'connection' event never fires in the tornado case. How does the backend server participate in the proxy's connection event? Is there an earlier / lower level event than 'connection' that I can look at?

It's never awesome when it takes the interaction of three projects to cause a problem:
- Tornado + FF = :ok:
- Tornado + proxy + (Chrome|Safari) = :ok:
- node-ws + proxy + FF = :ok:
- Tornado + proxy +FF = :bomb:
",minrk,2014-09-30 18:37:52
690,2014-09-02 04:38:22,"I submitted #691, which should fix the bug here.

A summary of the situation:

## Chrome
1. Browser sends `Connection: Upgrade`
2. Server receives `Connection: Upgrade`
3. :+1:

## Firefox
1. Browser sends `Connection: keep-alive, upgrade`
2. Server receives `Connection: close`
3. depends on server
   - Tornado doesn't see 'upgrade' in the connection header, and terminates the connection
   - node-ws ignores the ""Connection"" header, and proceeds as normal

If I understand the websocket protocol correctly, there are bugs in both the nodejs websocket package _and_ node-http-proxy, which cancel each other out.

The bug here:

Proxy shouldn't be setting `Connection: close` in this case.

The (possible) bug in ws:

Websocket server should probably not accept connections if `Connection` header doesn't contain `upgrade`, because that seems to be part of the protocol.

## Workaround

I found this workaround, which just forces the value to be 'upgrade', since that's the only value that will be handled correctly.

<S_CODE_TOKEN>

A safer version could split on ',', and check for upgrade.
",minrk,2014-09-30 18:37:52
690,2014-09-30 18:37:52,"This was fixed by #691
",minrk,2014-09-30 18:37:52
689,2014-08-28 07:15:59,"https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/forward-proxy.js

when i ran the example and it started both ""http"" (on port 9019)  and ""forward"" (on port 8019) servers.

When i opened http server directly on http://localhost:9019/ I am getting response.
But when i open forwarding server on http://localhost:8019/  I am getting zero bytes (blank) response.

I'm using version 1.3 of node-http-proxy with node 0.10.28
",palamccc,2014-08-28 07:56:52
689,2014-08-28 07:56:52,"This is actually working as expected. In this example there are two web servers:

<S_CODE_TOKEN>

The ""forward"" setting is designed to be a blind forwarding server that does not send anything back. You probably way to set both ""forward"" and ""target""
",indexzero,2014-08-28 07:56:52
688,2014-08-28 03:50:39,"I want a HTTP proxy and WebSocket proxy to support a deployd backend. I always received this
error Msg from the browser side. 
WebSocket connection to 'ws://localhost:8000/socket.io/1/websocket/Bw-GcrkRQecfNjOue7xi' failed: Connection closed before receiving a handshake response
# This is my code. I'm very new to this. So please help me. 

var http = require('http'),
    httpProxy = require('http-proxy');

//
// Create a proxy server with custom application logic
//
var proxy = httpProxy.createProxyServer({});
var defaultTarget = 'http://127.0.0.1:9000';      // this 9000 serves my AngularJs Client

var getTarget = function  (req) {
  console.log('req.url='+req.url);
  if (req.url.match(/node/)) {
     req.url = req.url.replace(/node\/api\//, '');
     console.log('updaded to='+req.url);
     return 'http://localhost:2403';                      // this 2403 is for deployd REST API
  }
  else if (req.url.match(/socket.io\//)) {
     console.log('visiting '+req.url);
     if (req.protocol == 'http') {
         return 'http://localhost:2403';                // for deployd SocketIO? 
     }
     else {
         return 'ws://localhost:2403';
     }
  }
  else if (req.url.match(/auth/)) {
     console.log('visiting '+req.url);
     return 'http://localhost:3000';
}

  else
   return defaultTarget;
}

//
var server = require('http').createServer(function(req, res) {
  proxy.web(req, res, { target: getTarget(req) });
});

console.log(""listening on port 8000"")
",ericq,
688,2014-10-20 21:19:27,"Socket.io's handshake requires the HTTP upgrade request and the websocket server to be on the same server. The handshake never completes because it will connect to another server (websocket server on port 2403) that doesn't share the same state as the plain ol' http server on port 3000.
You can get around this by using socket.io-redis.
",bjackson,
687,2014-08-26 21:40:39,"I'm running PM2 with 3 cores on a Node Proxy, and 3 cores on a Node App. The proxy takes the incoming request and throws it at either the Node app or Apache, depending on the URL.

This works fine until we hit high traffic. On the server I get the following error:

<S_CODE_TOKEN>

On my local machine running Apache Bench with thousands of concurrent requests I get:

<S_CODE_TOKEN>

Also when I run benchmarks against the Node app itself (skipping the proxy), I do not hit any errors.

Any ideas on what is causing this? 95%+ of the requests work fine.
",chuntley,2014-09-30 19:29:08
687,2014-09-24 17:10:37,"There are a few issues which address this. See my answer here: https://github.com/nodejitsu/node-http-proxy/issues/527
",jondubois,2014-09-30 19:29:08
687,2014-09-30 19:29:08,"Closing as a duplicate of #527. Thanks @jondubois!
",indexzero,2014-09-30 19:29:08
686,2014-08-21 21:04:15,"I was recently looking what parameters I can use in the `proxyRes` event. Added this to the README so others can know the same without having to look at the source code.
",joeyespo,2014-08-21 23:50:48
686,2014-08-21 23:50:54,"@joeyespo thanks!
",jcrugzz,2014-08-21 23:50:48
685,2014-08-21 07:19:56,"In great anticipation to the 1st of April (April Fools) I'm trying to setup an elaborate prank.

I need a proxy server that can inject some jQuery into the html part of the response - after searching I found [this gist](http://gist.github.com/amontalenti/4126144) but it runs into problems with:

`Error: Must provide a proper URL as target`

I've read over it and can't see why it's failing? I've not used node-http-proxy before though but I tested it and all made basic sense. I'm thinking somethings deprecated since it's 2 years old.

Any ideas?
",brod,2016-06-13 07:41:47
685,2014-08-23 19:01:32,"I think, [harmon](https://github.com/No9/harmon) could be interesting for you. It uses http-proxy and [node-trumpet](https://github.com/substack/node-trumpet) to manipulate HTML.
",philippotto,2016-06-13 07:41:47
685,2014-08-23 19:09:34,"@brod the example you found uses `http-proxy` `0.10.x` which had a different api. If you modify it to work with the new conventions, it seems like it should work. Checkout the readme.

@philippotto also has a good idea
",jcrugzz,2016-06-13 07:41:47
685,2014-10-15 00:36:00,"Just bumped harmon to work with connect v3 and trumpet 1.7.0
",No9,2016-06-13 07:41:47
684,2014-08-20 19:24:11,"When I attempt to target a different host as follows:

<S_CODE_TOKEN>

The proxy redirects without problems (albeit relatively slowly) but after a period of time, the connection closes and the following error occurs:

<S_CODE_TOKEN>
",anweiss,2014-08-21 14:51:21
684,2014-08-21 14:51:18,"@anweiss looks like a DNS lookup error. Could be based around your connection or the dns service you are using.
",jcrugzz,2014-08-21 14:51:21
683,2014-08-20 16:45:12,"I was wondering if it was possible to change the proxy timeout value via routes or middleware for the purposes of emulating different response latencies when a user clicks various links on a page. My guess is that I would have to create multiple proxy servers and route my requests appropriately instead of trying to do it all via one proxy instance.
",anweiss,
682,2014-08-20 02:13:54,"The following is an excerpt from https://github.com/nodejitsu/node-http-proxy/blob/ed9e12b0edb0fc206610e94bd696425619868474/lib/http-proxy/common.js#L49.

<S_CODE_TOKEN>

This code block deliberately turns off keep-alive by setting the `connection=close`. What does **this** mean in `node core doesn't handle this COMPLETELY properly yet`?
",kadishmal,2014-10-07 04:19:49
682,2014-10-06 19:10:53,"I also like to know about why the connection is set to close. I have a webserver that runs over https, each connection takes x-amount of time to perform SSL handshaking, closing each connection introduce a bunch of overhead. Multiple the SSL handshake overhead by a factor of 500 files downing from the server. It introduce up to 25-30 seconds delay for my application to completely loaded into the browser.
",pchuong,2014-10-07 04:19:49
682,2014-10-07 03:05:14,"Reading the code it looks logical and reasonable to disable it, I found out later. To enable keep-alive just provide a custom HTTP agent and/or pool or just use the default `globalAgent`.

On Tue, Oct 7, 2014 at 4:10 AM, pchuong notifications@github.com wrote:

> ## I also like to know about why the connection is set to close. I have a webserver that runs over https, each connection takes x-amount of time to perform SSL handshaking, closing each connection introduce a bunch of overhead. Multiple the SSL handshake overhead by a factor of 500 files downing from the server. It introduce up to 25-30 seconds delay for my application to completely loaded into the browser.
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/682#issuecomment-58075546
",kadishmal,2014-10-07 04:19:49
682,2014-10-07 04:19:49,"Thanks @kadishmal :grinning: 
",indexzero,2014-10-07 04:19:49
682,2014-10-07 14:48:56,"Thanks Kadishmal, I came to the same conclusion by creating a new agent object for the proxy.
",pchuong,2014-10-07 04:19:49
681,2014-08-18 06:59:09,"Hello,

I'm using this proxy to connect to HTTPS server. But I get an error of:

{ [Error: Parse Error] bytesParsed: 0, code: 'HPE_INVALID_CONSTANT' }

I have read a blog post which indicate this might be an issue of flashsocket.

http://www.evilprofessor.co.uk/533-an-error-has-occurred-bytesparsed0codehpe_invalid_constant/

But I don't know how to apply the configuration since the socket io is wrapped by http module and the proxy module.

Thanks,
Frank
",lfrankqy,2014-08-18 14:53:41
681,2014-08-18 14:46:54,"@lfrankqy You are correct, this is flashsocket causing this issue. You don't have access to configuring socket.io in your code? This shouldn't be possible
",jcrugzz,2014-08-18 14:53:41
681,2014-08-18 14:53:41,"Either way this is not a bug in http-proxy. If you run into an issue unrelated to socket.io, please open a new issue.
",jcrugzz,2014-08-18 14:53:41
680,2014-08-15 20:05:32,"Hi guys,

I was trying to sign a header (using its contents) but could not find a good way.
But setting the statusCode variable instead of using res.statusCode() function did the trick.

I was just wondering if there`s a reason why this is being done this way.
",banduk,
680,2014-08-15 20:07:43,"@banduk could you give me an example of how you are using it?
",jcrugzz,
680,2014-08-15 20:18:38,"Sure, here's my piece of code. 
The `signResponse` method sign the response based on req, res and data.

With `writeStatusCode` using `res.writeHead()` I cannot write into header once [it's closed for writing](http://stackoverflow.com/questions/7042340/node-js-error-cant-set-headers-after-they-are-sent?answertab=votes#tab-top).

<S_CODE_TOKEN>
",banduk,
680,2014-08-15 20:47:26,"@banduk in this case its the app that you are proxying to that would have already written the headers, not `http-proxy` itself. [This](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L144-L160) is all we do. `http-proxy` is just finishing the reverse proxy while you attempt to hijack it in the `proxyRes` event. What you are trying to do is not currently possible with the api. Its currently not possible to intercept the stream before its piped into the original response but this is something I have thought about.

Would allowing it to be possible to inject a transform stream before returning the response solve your problem?
",jcrugzz,
680,2014-08-15 21:17:45,"@jcrugzz, that's what thought; that this is not what  `http-proxy` do...

I'm using `http-proxy` as an OAuth Proxy, So I need to verify from the `req` and sign `res`. If the transformation your suggesting are like [this](https://github.com/nodejitsu/node-http-proxy/pull/660#issuecomment-46013477), I don't think it would be useful as it would not allow me to modify the header (am I right?)
",banduk,
680,2014-08-16 15:04:04,"@banduk well what i realized is that any of these custom transform streams would need to also inherit from an actual request and response object and automatically pass along headers on('pipe'). There needs to be a module around this to make it possible. I believe it would allow you to modify the header as there wouldn't be a race condition on whether they were sent already or not.
",jcrugzz,
680,2014-08-18 14:46:44,"@jcrugzz So I'm sure this solves my problem, yes..
I'm just starting to code on node and I'm not yet coding fluently. Could you please gimme some hints on how to make it work before this 'after hooks' are implemented into master branch?
",mbanduk,
680,2014-08-18 14:52:08,"@mbanduk there is no way to do that currently using this module since we strictly do a reverse proxy and thats it. You'd have to replicate the logic that you need in the reverse proxy until these hooks exist. 
",jcrugzz,
680,2014-08-19 17:24:53,"@jcrugzz , this code allow me to do what I want. Would it be a good alternative?

<S_CODE_TOKEN>

and then calling:

<S_CODE_TOKEN>
",banduk,
679,2014-08-14 17:15:15,"Added function to wrap closing the internal server. This function accepts an optional callback. The close will immediately cause proxy to stop listening on its current port but it will not close any pre-existing connections. Once all open connections are closed it will execute the given callback if one was supplied.

Closes issue: https://github.com/nodejitsu/node-http-proxy/issues/675
",unilaterus,2014-08-14 21:12:42
679,2014-08-14 17:40:01,"@unilaterus Thanks for the contribution! This looks good, the only thing I see potentially dangerous here is us nulling out the server object before the callback is executed (if one was passed in). I believe there should be a `server.once('close')` event that can be listened to to null the server after its fully closed or we could just wrap the callback and null the server before responding to the original callback that is passed in. 
",jcrugzz,2014-08-14 21:12:42
679,2014-08-14 20:00:33,"@jcrugzz Nice catch there. I hadn't thought of that. I pushed up a revision to correct that issue. I chose to go with the `wrap the callback` option because I'm not entirely sure if listening for close event will work since I think the callback passed in replaces the standard close event.
",unilaterus,2014-08-14 21:12:42
679,2014-08-14 21:12:48,"@unilaterus thanks!
",jcrugzz,2014-08-14 21:12:42
678,2014-08-14 15:42:50,"I've followed an example from some thread (can't find it now) on how to setup a multiple target http+websocket proxy. Basically I have two node apps running on internal ports and want to be able to route traffic to them, from port 80.

This is how my setup looks (in coffeescript):

<S_CODE_TOKEN>

This is working well, until you make a browser request for www.example.com, or any other subdomain not on the list. When I add them to the list, it's stable again.

I've hotfixed it with a condition:

<S_CODE_TOKEN>

in web-incoming.js. It works well, but I might be doing something the wrong way in the first place.
Thanks for looking into it.
",EskelCz,2014-08-14 16:19:34
678,2014-08-14 15:47:44,"Oh and this is the error I was getting

<S_CODE_TOKEN>
/root/proxy/node_modules/http-proxy/lib/http-proxy/passes/web-incoming.js:108
    var proxyReq = (options.target.protocol === 'https:' ? https : http).request
                                  ^
TypeError: Cannot read property 'protocol' of undefined<S_CODE_TOKEN>```
",EskelCz,2014-08-14 16:19:34
678,2014-08-14 16:16:39,"@EskelCz you have to do your own error checking or setup a regular expression matcher to handle `*.example.com` if thats what you want handled. If you pass in undefined as the target this error does occur, I will change it to emit a proper error in this case though.
",jcrugzz,2014-08-14 16:19:34
678,2014-08-14 16:19:27,"Ok, I guess that would be nice enough. :) Thanks
",EskelCz,2014-08-14 16:19:34
677,2014-08-05 21:20:37,"I was trying to use proxyReq and it wouldn't fire.  Checked http-proxy's source (@1.1.6), only to find that theres no such event, looks like its on the repo but not in the last npm build.  Probably shouldn't be part of the readme if it hasn't been deployed yet :(
",xtphty,2014-08-05 21:27:43
677,2014-08-05 21:27:42,"@xtphty thought i published it, available as `1.2.0`
",jcrugzz,2014-08-05 21:27:43
676,2014-08-01 16:04:07,"I currently have a HTTPS web server listening on port 443 on my host machine.

My goal is to set up another HTTPS web server on the same host machine, change ports on both web servers, and then set up a proxy server using node-http-proxy listening on port 443 instead.  The proxy server then delegates requests based on custom logic to the servers on other ports.

Below is the proxy server I adapted from one I successfully use when proxying plain HTTP requests on port 80.  However, when I try to run this code the browser displays the message 'Secure Proxy Server unable to handle your request at this time.' and console logs '[Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE]'  It does make it to the point where it tries to proxy the request to the server listening on a different port.

<S_CODE_TOKEN>

Couple thoughts:
1. I tried using node-ssl-root-cas in this file but nothing appeared to change.  My SSL certificate is from Network Solutions.
2. The targets for my proxy are localhost:444 and localhost:445 because those ports are not open externally and cannot be.  Not sure if the localhost in the host name is affecting the https proxy.
",ryanjarvis,
675,2014-07-24 10:50:21,"I was unable to do a server.close().

I figured out I needed to server._server.close(). Perhaps a helper function
`ProxyServer.prototype.close` can be added for this purpose.
",anilgulecha,
675,2014-07-24 15:53:06,"@anilgulecha sure, seems reasonable if the server exists. I would take a PR :).
",jcrugzz,
674,2014-07-20 12:17:27,"Hi 

I have just started evaluating http-proxy. I have tested the ‚Äôsimple load balancer for websockets‚Äô example and it fails with a WebSocket hangup error as follows:

Error: socket hang up
    at createHangUpError (http.js:1472:15)
    at Socket.socketOnEnd [as onend](http.js:1568:23)
    at Socket.g (events.js:180:16)
    at Socket.EventEmitter.emit (events.js:117:20)
    at _stream_readable.js:920:16
    at process._tickCallback (node.js:415:13)

I am using:

node 0.10.26
socket io 1.0.6
node-http-proxy 1.1.5

No errors occur if one proxy to address is used, but when mode than one address is used such as below, the socket hangup error occurs.
# The following is the load balancer. Its only difference to the provided sample is the addresses used and the listen port.

var http = require('http'),
    httpProxy = require('http-proxy');

//
// A simple round-robin load balancing strategy.
// 
// First, list the servers you want to use in your rotation.
//
var addresses = [
    {
        host: 'localhost',
        port: 8000
    },
    {
        host: 'localhost',
        port: 8001
    },
    {
        host: 'localhost',
        port: 8002
    }
];

//
// Create a HttpProxy object for each target
//

var proxies = addresses.map(function (target) {

  return new httpProxy.createProxyServer({
    target: target
  });
});

//
// Get the proxy at the front of the array, put it at the end and return it
// If you want a fancier balancer, put your code here
//

function nextProxy() {
  var proxy = proxies.shift();
  proxies.push(proxy);
  return proxy;
}

// 
// Get the 'next' proxy and send the http request 
//

var server = http.createServer(function (req, res) {  
  nextProxy().web(req, res);
});

// 
// Get the 'next' proxy and send the upgrade request 
//

server.on('upgrade', function (req, socket, head) {
  nextProxy().ws(req, socket, head);
});

server.listen(9000);
# 
# The basic http server is:

var http = require('http'),
    fs = require('fs'),
    io = require('socket.io');

var args = process.argv.splice(2);

var port = args[0] || 8000;

server = http.createServer(function(req, res) {

<S_CODE_TOKEN>

});

server.listen(port, function() {

<S_CODE_TOKEN>

});

io = io(server);

io.on('connect', function(socket){

   console.log('socket connected');

<S_CODE_TOKEN>

});
# 

If I reduce the addresses to one target then no errors occur. 

Please could some help in identifying the cause of the error.
",jonathanstone,2014-09-30 19:27:10
674,2014-09-24 10:27:29,"See my response in this issue (seems to be the same problem): https://github.com/nodejitsu/node-http-proxy/issues/527
",jondubois,2014-09-30 19:27:10
674,2014-09-30 19:27:09,"Closing as a duplicate of #527 
",indexzero,2014-09-30 19:27:10
673,2014-07-18 15:52:44,"### Problem Description

In some proxy scenarios, it's helpful to modify the outgoing proxy request before the headers are sent. For example, if a developer would like to add a few custom proxy-specific headers, the cleanest way to do this is to add the headers to the _http.ClientRequest_ **proxyReq** object. Unfortunately, there is no way to access the proxyReq object pre-flight.

The problem manifested itself when I attempted to digitally sign an outgoing proxy request. In order to perform a digital signature on the HTTP headers using the HTTP Signatures specification you have to have access to all of the finalized headers. Since http-proxy modifies/adds headers, the digital signature should only be performed after all such modifications have been made but before the data is piped. 
### Solution

Add a _proxyReq_ event that a proxy server can listen to in order to modify the request before it is sent. The event handler function has the following signature: function(_http.ClientRequest_ **proxyReq**, _http.IncomingMessage_ **req**, _http.ServerResponse_ **res**, _Object_ **options**). This enables the developer to modify the outgoing proxy connection in a variety of very flexible ways.
### Potential Issues
1. If **options.forward** is specified, modification isn't supported. I think that's how it should work, but core implementers may disagree with that approach.
2. There is currently no way to take the body of the HTTP message into account when the event is called, which means that performing a header modification on the body isn't possible. For example, it's not possible to add a header specifying a Digest SHA-256 sum for the body. Adding this feature could create scalability nightmares as one would need to do a full read of the data stream in some cases (which could be multiple megabytes or gigabytes of data).
",msporny,2014-07-20 19:15:49
673,2014-07-20 19:15:46,"@msporny thanks for making the changes! LGTM. Regarding the potential issue #2, this would need to be a transform stream of sorts that automatically modified headers and passed it along to the proxy. I haven't figured out how this would be done generically yet but its something I have in mind.
",jcrugzz,2014-07-20 19:15:49
673,2014-07-20 20:02:49,"Thanks for the merge @jcrugzz :).

@dlongley any thoughts on addressing issue #2 generically since we're probably going to need to do this at some point in the near future?
",msporny,2014-07-20 19:15:49
673,2014-07-22 16:12:09,"@msporny, well, from a quick glance at the code it seems like there are several options now just after this approach, for addressing number 2:
1. For producing something like a digest on message bodies that are too long to buffer into memory, you could attach an event listener to `proxyReq` and then attach a `data` event listener to the incoming request that will digest the data and, when finished, call `proxyReq.addTrailers` with the appropriate digest header.
2. For message bodies that can be buffered, you could do the same -- except set `options.buffer` in the `proxyReq` handler to some stream that also gets populated by listening to events from `req`. There may be a nicer API that could be exposed for this, but it seems like it would work as is if you needed this behavior. But again, that's just from a quick glance, I didn't write any code to test this.

Edit: Actually, it looks like some tweaking would need to happen to allow `options.buffer` to be set in the event handler. Maybe something similar to what @jcrugzz suggested could be added to allow a transform stream to be inserted between `options.buffer` or `req` and the `proxyReq` -- or this stream could always be present and, by default, it performs no transformation.
",dlongley,2014-07-20 19:15:49
672,2014-07-17 18:33:15,,msporny,2014-07-20 20:04:29
672,2014-07-20 20:04:29,"Strange duplicate due to a bug in github. This merge request was closed previously and the code was moved to a different upstream branch, which made the merge request reappear. 
",msporny,2014-07-20 20:04:29
671,2014-07-17 07:16:37,"Using `before` or `after` and providing the name of the first pass, the falsy check here: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/index.js#L146 will always indicate that the name could not be found.

Instead this should read something like `if(i === false)`.

The same issue is present in `after`.
",ghost,2014-07-17 14:56:53
671,2014-07-17 14:57:07,"@justin-summerlin thanks!
",jcrugzz,2014-07-17 14:56:53
670,2014-07-12 18:33:23,"Hi,

I'm trying test ""round-robin"" with your example:

<S_CODE_TOKEN>

But fails... why??
",soyjavi,2014-07-12 19:43:00
670,2014-07-12 19:42:58,"@soyjavi That is not the latest example. See [here](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/balancer/simple-balancer.js)
",jcrugzz,2014-07-12 19:43:00
670,2014-07-17 06:15:45,"Hi :)

@jcrugzz but ... is possible set different IP address (range)?

Best
",soyjavi,2014-07-12 19:43:00
669,2014-07-10 16:01:22,"The changelog is only useful if it's maintained :)

I'd love to see this file updated as releases are pushed out but In it's current state it's a dead file. Thoughts?
",baer,2014-09-11 12:08:50
669,2014-09-11 12:08:48,"I'm going to accept this pull request for now, changelogs are great thing when they are maintained. For now it makes more sense to just compare different tags to see what was changed.  
",3rd-Eden,2014-09-11 12:08:50
668,2014-07-10 08:01:33,"When a user set a server as proxy, every request go to nodejs. What I want is to forward that request to another proxy server, based on my algorithm.
For example: I want a user to set as proxy a server X(who running nodejs) and if it's monday all request go through external-proxy-server-1, if it's tuesday all request go through external-proxy-server-2.
It is posible to do this? If yes, how?
",george-dragnea,2014-12-22 17:07:10
668,2014-12-20 10:22:38,"I think this could be achieved either by applying a PROXY.PAC file on the client side, or add support of PROXY.PAC for node-http-proxy.

http://en.wikipedia.org/wiki/Proxy_auto-config
",shouko,2014-12-22 17:07:10
668,2014-12-22 17:07:10,"@george-dragnea If I'm understanding you correctly you would have to implement this ""algorithm"" of yours using `http-proxy` and send a `forward` request in the specific cases that you desire. 

In any case, this is not an issue pertaining to `node-http-proxy`, I would take the question to stackoverflow where you may get some help! Cheers.
",jcrugzz,2014-12-22 17:07:10
667,2014-07-07 18:38:07,"Hi all, I need to generate a signature based on the POST body. If I put the proxy.web on the request end method it simply does not work. Has anyone accomplished reading the POST body?
",dlabey,2014-11-06 18:50:42
667,2014-07-21 11:54:39,"I have the same issue. In fact, when trying to grab any data off the body (for example, Basic Authorization), you can't use the node paradigm of `on('data')` followed by `on('end', function() { proxy.web(req, res) }`.
",lwhorton,2014-11-06 18:50:42
667,2014-08-08 17:58:11,"I have the same problem. No way to grab POST body.
",Koka5,2014-11-06 18:50:42
667,2014-08-08 18:27:49,"In order for this to work, you need to buffer the entire request BEFORE proxying it. We don't support this innately in the API because everything is supposed to be streaming and happen ASAP. There is a `buffer` option in the `proxy.web(req, res, { buffer: bufferStream})` that should allow you to do this. There needs to be some better modules around this interaction. I will be trying to figure something out around this when I have some time but let me know how the testing goes!
",jcrugzz,2014-11-06 18:50:42
667,2014-08-16 21:36:53,"@jcrugzz Can you elaborate on how you can use the buffer stream to accomplish the task of grabbing the POST body in the response?
",seglo,2014-11-06 18:50:42
667,2014-08-18 14:55:06,"@seglo let me try and put together a working example today.
",jcrugzz,2014-11-06 18:50:42
667,2014-10-26 16:01:51,"@jcrugzz As you've probably noticed my project relies on this sort of functionality.  Right now it's a bit of a hack, so if you could share an example of how this might work it would be appreciated.  Thanks!
",seglo,2014-11-06 18:50:42
667,2014-11-06 18:01:45,"I was able to use bodyParser in combination with restreamer to access the body.  Here is an example authored by someone else:

https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/bodyDecoder-middleware.js
",gdw2,2014-11-06 18:50:42
667,2014-11-06 18:50:42,"Thanks for pointing everyone to the correct existing example @gdw2. I'm going to close this issue.
",indexzero,2014-11-06 18:50:42
667,2016-01-25 12:50:23,"@seglo I tried the `buffer` option suggested by @jcrugzz and it works like a charm. Idea is to retrieve the body by consuming the request stream, and to store the buffered result on a stream that we will pass to the `buffer` property when calling `proxy.web()`.

Example here, first with a middleware to retrieve the body (you will recognize part of your code as I work with connect-prism):

<S_CODE_TOKEN>

Then, when calling the proxy, just pass this stream:

<S_CODE_TOKEN>
",mrblackus,2014-11-06 18:50:42
667,2016-01-25 16:26:30,"I was in a similar situation where I need to load response. Hope it helps: http://www.acuriousanimal.com/2015/08/31/how-to-read-from-a-writable-stream-httpserverresponse-in-node.html
",acanimal,2014-11-06 18:50:42
666,2014-07-04 21:44:45,"The balancer example will only work for the first two requests, as the `target` that is pushed back to `addresses` has the form:

<S_CODE_TOKEN>

when should have the form:

<S_CODE_TOKEN>
",eiriklv,2014-07-08 16:08:51
666,2014-07-08 16:08:55,"Thanks!
",jcrugzz,2014-07-08 16:08:51
666,2014-07-08 16:24:01,"No problem! Happy to help :-)
",eiriklv,2014-07-08 16:08:51
665,2014-06-29 22:05:25,"### Problem Description

In some proxy scenarios, it's helpful to modify the outgoing proxy request before the initial connection is made. For example, if a developer would like to add a few custom proxy-specific headers, the cleanest way to do this is to add the headers to the _http.ClientRequest_ **proxyReq** object. Unfortunately, there is no way to access the proxyReq object pre-flight.

The problem manifested itself when I attempted to digitally sign an outgoing proxy request. In order to perform a digital signature on the HTTP headers using the HTTP Signatures specification you have to have access to all of the finalized headers. Since http-proxy modifies/adds headers, the digital signature should only be performed after all such modifications have been made but before the data is piped. 
### Solution

Add the **modifyProxyConnection** option to the **options** variable which takes a function. The function has the following signature: function(_http.ClientRequest_ **proxyReq**, _http.IncomingMessage_ **req**, _http.ServerResponse_ **res**, _Object_ **options**). This enables the developer to modify the outgoing proxy connection in a variety of very flexible ways.
### Potential Issues
1. If **options.forward** is specified, modification isn't supported. I think that's how it should work, but core implementers may disagree with that approach.
2. There is currently no way to take the body of the HTTP message into account when calling **modifyProxyConnection**, which means that performing a header modification on the body isn't possible. For example, it's not possible to add a header specifying a Digest SHA-256 sum for the body. Adding this feature could create scalability nightmares as one would need to do a full read of the data stream in some cases (which could be multiple megabytes or gigabytes of data).
",msporny,2014-07-17 17:00:19
665,2014-07-08 21:35:12,"@msporny I think this is doable but i think it should be implemented as an event people can hook into rather than an option. Maybe have a `proxyReq` event to accompany `proxyRes`. Thoughts?
",jcrugzz,2014-07-17 17:00:19
665,2014-07-17 17:00:19,"Ok, agreed that that's the right approach to take. I'll re-architect the solution and send a new, clean pull request.
",msporny,2014-07-17 17:00:19
665,2014-09-01 12:48:44,"@msporny Did you ever fully implement the solution for this? I'm looking to use it for Digest Auth.
",jenmak,2014-07-17 17:00:19
665,2014-09-02 13:50:16,"@jenmak there is now a `proxyReq` event you can listen on to handle the case that this PR was going to solve
",jcrugzz,2014-07-17 17:00:19
665,2014-09-15 00:55:00,"@jenmak see this commit: https://github.com/nodejitsu/node-http-proxy/commit/db5f2954b2b325818f7e52ed3cd68dab31d370ed

Feature is documented here: https://github.com/nodejitsu/node-http-proxy/blob/master/README.md#setup-a-stand-alone-proxy-server-with-proxy-request-header-re-writing
",msporny,2014-07-17 17:00:19
664,2014-06-24 02:56:00,"Trying to proxy https to https using custom logic.

<S_CODE_TOKEN>

However the response from app.ourdomain.com which is running nginx is:

<S_CODE_TOKEN>

Any ideas?
",nodesocket,
663,2014-06-17 00:52:42,"Based around the concept I outlined [here](https://github.com/nodejitsu/node-http-proxy/pull/660#issuecomment-46013477). This will allow arbitrary transformations of the request being proxied as well as the response we get back.
",jcrugzz,
663,2014-08-21 18:19:11,":+1: 
",smazurov,
663,2014-08-24 11:45:14,"I wrote a very simple middleware which can be plugged into http-proxy. It allows modifying the proxied data by providing a simple function. It is called [transformer-proxy](https://github.com/philippotto/transformer-proxy). Maybe someone finds it useful.

The modifyResponse-middleware.js-example didn't work for me, because the data is passed in chunks and not as a whole and the content-length becomes wrong when the data length is changed.
",philippotto,
662,2014-06-16 06:14:39,"Trying to test forwarding requests to **requestb.in**. Getting the following response:

<S_CODE_TOKEN>

However no requests are showing up in the requestbin.

<S_CODE_TOKEN>

Sending requests with:

<S_CODE_TOKEN>
",nodesocket,2014-06-24 02:52:21
662,2014-06-18 05:08:29,"Switching `forward` to `target` seems like what I want, except for some strange reason I am getting a 404 error and Heroku message:

<S_CODE_TOKEN>

Here is the code:

<S_CODE_TOKEN>
",nodesocket,2014-06-24 02:52:21
662,2014-11-13 09:49:49,"@nodesocket I'm running into the same issue with requestbin - getting a 404 - did to manage to resolve this?
",97-109-107,2014-06-24 02:52:21
662,2014-11-13 14:38:03,"@97-109-107 look at his second example and there might be a requirement of setting the host header. This is where the changeOrigin option can be used
",jcrugzz,2014-06-24 02:52:21
662,2014-11-13 14:42:09,"@jcrugzz thanks for the tip, I tackled this problem by writing an express server that makes a POST on behaf of the client, copying the POST body.

<S_CODE_TOKEN>
",97-109-107,2014-06-24 02:52:21
662,2014-11-13 14:49:13,"@97-109-107 gotcha, that is a reasonable solution. If you are at a point where performance matters, give my suggestion a try and let me know how it works out :). Just wanted to note here that in this case you do buffer the entire request to then send it again. Cheers!
",jcrugzz,2014-06-24 02:52:21
662,2014-11-13 22:50:33,"This ended up working for us:

<S_CODE_TOKEN>
",nodesocket,2014-06-24 02:52:21
662,2014-11-13 22:59:21,"@nodesocket thanks for the response! This is effectively the same as setting the `changeOrigin` option to true for anyone who comes here and wants reference.
",jcrugzz,2014-06-24 02:52:21
662,2014-11-13 23:00:44,"@jcrugzz is `changeOrigin` documented? Just doing a quick search on the README I don't see it.
",nodesocket,2014-06-24 02:52:21
662,2014-11-13 23:02:56,"@nodesocket gah looks like its NOT. its only documented [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L34-L51). Im always happy to take documentation PRs :)
",jcrugzz,2014-06-24 02:52:21
661,2014-06-12 10:08:58,"When I use this as a http proxy on IOS
I open the twitter.com but proxy this to localhost :-1:  

code like 

<S_CODE_TOKEN>

In my proxy [doji](npmjs.org/doji) has no problem with this and it's more clear to set the path rule
",lichenhao,
660,2014-06-12 07:32:52,"allow us to dump the request and response content with req.data and res.data on the proxy's event 'end'.
",wangzheng422,2014-06-16 02:20:45
660,2014-06-12 14:47:17,"@wangzheng422 why is this useful for your use case? This could result in huge performance problems 
",jcrugzz,2014-06-16 02:20:45
660,2014-06-12 16:44:07,"Never mind the use case. I for example would like to be able to rewrite proxyRes as I see fit. Couldn't we introduce some hook which could do the following:

<S_CODE_TOKEN>

This could for example return a custom stream that would wrap around original proxyRes. What do you think?
",Rush,2014-06-16 02:20:45
660,2014-06-12 16:49:05,"@RushPL yea this is the reason I have an issue with this api as there is no good way to hook into the streams themselves with any kind of transform. Its something I've been thinking about but haven't found the right way to do yet.
",jcrugzz,2014-06-16 02:20:45
660,2014-06-12 16:50:32,"Well, wouldn't that be a custom EventEmitter with a couple of events handled right? I am sure this can be easily done. (perhaps tricky to get all edge cases right)
",Rush,2014-06-16 02:20:45
660,2014-06-12 17:55:27,"@RushPL we can pass in two different transform streams in some manner. There may be a better api then just adding them to the options object. But yea its doable its just not as clean as I'd like it.
",jcrugzz,2014-06-16 02:20:45
660,2014-06-13 08:11:51,"@jcrugzz I want to analyze the http traffic goes through the proxy, especially the POST case. Now I add a dump flag into the option, which will not turn on the dump function in normal case.
",wangzheng422,2014-06-16 02:20:45
660,2014-06-13 13:53:41,"@wangzheng422 i still dont like this. This should be done with an optional stream that you can pass so we arent adding an arbitrary property to the request and you can do with the data what you want. For what you want to do, you would pass in something like this.

<S_CODE_TOKEN>

Now this is just speculative but this is the way that we would make this type of functionality work. This allows custom transformations of any type on the data which should be allowed. @RushPL this would satisfy your requirements correct?
",jcrugzz,2014-06-16 02:20:45
659,2014-06-10 18:42:43,"I'm trying to use http-proxy with node 0.10.28 as a websocket load balancer that uses HTTPS->HTTP with SockJS. Everything works perfectly, except that when I kill the websocket server (different node process from the proxy server), the client doesn't receive a disconnect event. If I use HTTP->HTTP, it works as expected. I've also tried HTTPS->HTTPS, but that had the same issue.

<S_CODE_TOKEN>
",goldfire,
659,2014-06-10 19:03:12,"That is curious. Can you see what the underlying socket is doing? _This is debugging code_

<S_CODE_TOKEN>
",indexzero,
659,2014-06-10 19:15:46,"Sure, I tested the output for HTTPS and HTTP, and I notice that HTTPS doesn't get the following 4 lines when I kill the websocket server:

<S_CODE_TOKEN>

**HTTPS:**

<S_CODE_TOKEN>

**HTTP:**

<S_CODE_TOKEN>
",goldfire,
659,2014-06-10 20:22:57,"@goldfire ok so based on your example you are actually trying to do HTTP -> HTTPS. Is this what you are actually intending on doing?
",jcrugzz,
659,2014-06-10 20:26:32,"I just updated the example, I didn't mean to have https in the hosts. The websocket server is HTTP (though I've tried having it HTTPS as well), but I want the client to connect on HTTPS. This part of it is working flawlessly, it is just that the connection doesn't close when using HTTPS on the client and it does when HTTP is used on the client. HTTPS (proxy server) -> HTTP (websocket server) is what I meant.
",goldfire,
658,2014-06-09 23:40:35,"Basically the new option would allow `http-master` to show a custom timeout page instead of simply hanging up the socket. The default timeout option is still there. I have added test for both cases since there was no test for the timeout at all. This feature has been tested on the application level so looks ok.
",Rush,2014-06-10 17:11:13
658,2014-06-09 23:51:54,"Travis shows it's testing properly on Node 0.10 which is better than what I encountered. :-)
",Rush,2014-06-10 17:11:13
658,2014-06-10 17:06:35,"@jcrugzz Changed the naming according to your comment.
",Rush,2014-06-10 17:11:13
658,2014-06-10 17:11:09,"@RushPL thanks!
",jcrugzz,2014-06-10 17:11:13
657,2014-06-09 23:13:54,"I wanted to add a new feature to node-http-proxy but how am I supposed to contribute it if the tests fail even on stable Node 0.10.28?

Latest master:

<S_CODE_TOKEN>
",Rush,2014-06-10 17:11:14
657,2014-06-10 06:05:00,"@RushPL the devDeps are \* depped so that was the root cause.
",jcrugzz,2014-06-10 17:11:14
657,2014-06-10 09:13:04,"Should I change them to ""--save-dev"" in my pull request?
",Rush,2014-06-10 17:11:14
657,2014-06-10 17:02:05,"@RushPL we might as well ensure our tests are up to date so lets keep living dangerously ;).
",jcrugzz,2014-06-10 17:11:14
656,2014-06-09 09:49:48,"I added an error callback as the fifth argument to `proxy.web`, and as a result `proxyRes` event will not emit anymore. That is because, for some reason, if the error callback is present, the `server` argument is omitted and thus `proxyRes` cannot be called anymore. See [`createRightProxy` in index.js](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/index.js#L78): `if(passes[i](req, res, options, head, cbl ? false : this, cbl))` (argument #4 is the `server` argument, which needs to be present for `proxyRes` to be called and argument #5 (`cbl`) is the error callback). That seems like a big bug?

Also the code does not match the comments above which imply that `pass` (`pass(req, res, options, head)`) only has four arguments (it probably used to?).
",Domiii,
656,2014-06-18 22:54:40,"+1 for a fix. I'm affected by this as well.
",calebcase,
656,2014-06-19 16:31:54,"The easy, straight-forward fix is to change that line in particular to: `if(passes[i](req, res, options, head, this, cbl))`. But there must be some sort of reason why the code looks that way?
",Domiii,
656,2014-06-19 17:25:10,"@Domiii It used to be that you could create a proxy that was not an event emitter when a callback was passed in. Now it is always an event emitter now but this piece obviously has not been changed yet. Our of curiosity, could you post your use case for the callback argument? Personally I've just never used it and purely handle the errors and anything else through the event emitter interface
",jcrugzz,
656,2014-06-19 20:07:19,"@jcrugzz  I simply did not know that error handling without that callback was possible. I started writing my app and was plagued by ""socket hang up"" exceptions, that I finally (thanks to [longjohn](https://github.com/mattinsler/longjohn)) found to be caused by http-proxy. I then must have seen a code snippet that passed the error handler as fifth argument to `web` (but can't quite find it right now). You are saying, errors should simply be handled through the `clientError` event?
",Domiii,
656,2014-06-19 20:30:13,"@Domiii listen on the `error` event on the proxy. See [here](https://github.com/nodejitsu/node-http-proxy#listening-for-proxy-events)
",jcrugzz,
655,2014-06-09 08:30:33,"According to HTTP/1.1 Spec:

The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections.
See: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html

I noticed that when sending agent: false this would also have the same behavior. With a non-node back-end such as apache, things work fine.

I have simple test cases available if you'd like to experiment with them.
",javruben,
655,2014-09-05 21:31:38,"@javruben id love to see a failing test for this in general. this was a terrible hack for node having broken http
",jcrugzz,
654,2014-06-08 11:41:00,"My code is:

var servProxy = require(""http-proxy"")
var dest = { target: { protocol:""http"", host:""www.rclibros.es"", port:80 } }
servProxy.createServer(dest).listen(8080)

When I write http://127.0.0.1:8080 at my browsers' url bar (I've tried Firefox and Epiphany) a page is shown with this message:

You are accessing an IP shared by several hostings, for this reason you cannot visualize the web page through this IP. Use the temporary URL that shows at the entrance to your Control Panel in your hosting to see the page in the case that the DNS of your domain have no yet propagated.

I don't understand anything: I've put the DNS name of the site: (www.rclibros.es)!!!

Thanks for your help
",q2dg,
654,2014-07-23 11:00:58,"This is similar to issue #621 which have an explanation. You need to provide host headers.

The following works:

<S_CODE_TOKEN>
",trygve-lie,
654,2014-07-23 13:41:08,"@trygve-lie great answer, I'd love to have this better documented if you'd like to submit the PR :)
",jcrugzz,
654,2014-07-23 14:03:10,"Sure can.

Though; I think the whole `options` object should be a bit better documented in the readme. The documentation in the readme are now just pointing [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L34-L51) on what properties one can set and it is missing the ""headers"" property.

Is it OK if I make a separate paragraph on the `options` object and put it there instead of pointing to the comment in the code?
",trygve-lie,
654,2014-07-23 14:53:23,"@trygve-lie yea that would be awesome :). Thanks!
",jcrugzz,
654,2014-12-14 19:35:28,"Would this node-http-proxy work on a hosted and shared Google drive just like you can host websites from GD nowadays?

Thanks for any input! Hi5 and the cool proxy program. This may be what I'm looking for.

Please see this as examples

http://youtu.be/BTen-UipDys

or 

http://youtu.be/mckYn7kd4YA
",dyingjedi,
653,2014-06-07 23:09:22,"While I am primarily doing proxying to localhost servers I have experimented today with proxying to a remote server and it seems DNS query is being done on every request substantially increasing the request time. Should I query the IP from DNS manually or is there a cleaner way?
",Rush,
653,2014-06-07 23:39:12,"On a side-note, what performance penalty should I be looking at while proxying to remote host?
Having put my dns name to `/etc/hosts` I expected to see not more than 10% penalty but I what I see is:
- Native request to remote server ~40ms
- Request proxied through node-http-proxy with host in /etc/hosts: ~80ms
  I am measuring the time both in chrome in code from doing request to getting `proxyRes`.
",Rush,
653,2016-12-20 16:43:48,"I found that by using https://www.npmjs.com/package/dnscache I'm able to get my performance tests to external domains down to about 6ms from 40ms... with just the default settings in the readme 

<S_CODE_TOKEN>",aaronmaturen,
652,2014-06-07 21:10:49,"Hi I'm trying the following, routing sub-domains to certain ports, and based on [this](http://stackoverflow.com/questions/10985350/how-do-i-use-node-js-http-proxy-for-logging-htttp-traffic-in-a-computer) and [this post inStackOverflow](http://stackoverflow.com/questions/10930564/default-route-using-node-http-proxy), I created the following script. But what happens is the following, It doesn't redirect to the port. Also I can't seem to get any logger to work directly to the console.

This is the script created:

<S_CODE_TOKEN>

Hope you guys can help, because I've been cracking my head for two days already... :-(
",cmpsoares91,2014-06-08 00:48:03
652,2014-06-07 22:41:40,"@cmpsoares91 these are examples of using the old `http-proxy` api that only works with node `0.8.x`.

If you would like to learn more about the new API, please checkout the readme or the blogpost found [here](http://blog.nodejitsu.com/node-http-proxy-1dot0/). 

Since we removed this particular functionality from `http-proxy`, this either needs to be done manually with an actual router or if you are looking for something that will do this out of the box, checkout @RushPL's [`http-master`](https://github.com/CodeCharmLtd/http-master)
",jcrugzz,2014-06-08 00:48:03
652,2014-06-07 22:48:09,"Damn... :-( I thought it looked as a very nice feature for me because as I
am using a aws server it is impossible to use a router... But anyway thank
you for the tip.

BTW Why has this feature been removed?
",cmpsoares91,2014-06-08 00:48:03
652,2014-06-07 23:55:16,"@cmpsoares91 When i refer to a router I mean something like [`mapleTree`](https://github.com/saambarati/mapleTree) or [`director`](https://github.com/flatiron/director). If you can run `node-http-proxy` on the server there shouldn't be an issue :).

The feature was removed due to simplicity. It belongs in a separate module and not in `http-proxy` itself as `http-proxy` is just responsible for the proxying bit. Its on my list to write this module I just haven't been able to get to it yet.
",jcrugzz,2014-06-08 00:48:03
652,2014-06-08 00:48:03,"yes because I find there's a lack on the net for this feature: routing subdomains to ports. Would love to see more of that! In the meanwhile I'me trying out http-master! ;-)
",cmpsoares91,2014-06-08 00:48:03
651,2014-06-06 18:27:07,"I have created an issue on node.js tracker as joyent/node#7733 because I believe this to be a node bug. There is a test case there so you could try it and see. I am creating the issue here as well for informative purposes and with hope that somebody may have any ideas. There is also a chance that this is node-http-proxy's bug ... caused somehow by changes in node.
",Rush,
651,2014-06-06 18:31:37,"@RushPL yea the tests for `0.11.x` have been consistently failing here for a while. I haven't spent time investigating this yet as I still considered it too unstable but thanks for the work you've done! Ill give it a read and see where the bug might lie. 

Its more likely a bug in node or we have to change our handling in some way based on their changes. Not sure what we would have to change here though as we are simply just using the `https` module. and piping the request.
",jcrugzz,
651,2014-06-06 18:35:34,"The weird thing is that I was unable to reproduce the problem locally (adding setTimeout in weird places) but it is consistently failing remotely. Also 0.11.10 is rock solid on production servers (viva forward secrecy) but it is a pain to maintain native dependencies for it. I am praying for our friend @indutny to chime in at some point with a brilliant idea. :-)
",Rush,
651,2014-06-06 22:41:41,"@RushPL smells like a race condition of sorts ;). And I'm sure fedor has his hands deep in it and will pull out some gold. I havent checked out the implementation since some of it was moved down into libuv land.
",jcrugzz,
650,2014-06-06 09:14:17,"The ""Host"" header field had been copied from the original headers that were received by the proxy may cause some problems.

If the backends uses hostname to distribute requests,  was wrong, because the request ""Host"" header points to the proxy server.
",stanzhai,2014-11-28 17:03:12
650,2014-06-06 17:52:20,"@stanzhai If you can figure out why the tests are failing I will consider this. I'm still not convinced we can make the assumption that this is ALAWYS a bad thing.

We currently manually set the host header as seen [here](https://github.com/nodejitsu/smart-private-npm/blob/master/lib/npm-proxy.js#L176-L184) so we would still need a way to set a custom host as well if I were to merge this. I'll think about what that might look like.
",jcrugzz,2014-11-28 17:03:12
650,2014-11-28 17:03:12,"This is now done using the `changeOrigin` option being set to true
",jcrugzz,2014-11-28 17:03:12
649,2014-06-05 17:22:20,"The issue was that when setting a timeout it was only getting set on the incoming socket, not on the outgoing http request. So the incoming request would get closed but the error handler wouldn't run, and the outgoing request would remain open.

This PR moves the timeout from the incoming socket to the outgoing one, and aborts the request on a timeout. The result is that error callbacks will run on a timeout, and that outgoing http requests won't remain open.
",mdirolf,2014-06-10 17:13:12
649,2014-06-05 18:16:10,"Wouldn't you want both a request and a response timeout instead?
",josegonzalez,2014-06-10 17:13:12
649,2014-06-05 18:43:29,"What is the use case for having a separate timeout on the incoming socket? With the above commit if the outgoing request times out the request aborts and the proxy server responds immediately.
",mdirolf,2014-06-10 17:13:12
649,2014-06-05 18:46:42,"First, this would be a backwards incompatible change. Second, you could have a client that opens a connection but doesnt actually send a request to the node proxy, which is what I think the original feature covers.
",josegonzalez,2014-06-10 17:13:12
649,2014-06-05 18:51:47,"Fair enough - I'll change the PR to just add a new option to set a timeout for the outgoing http request.
",mdirolf,2014-06-10 17:13:12
649,2014-06-10 16:49:09,"@mdirolf I like this, could you just change the `proxy_timeout` to `proxyTimeout`. My OCD wants camelCase ;). Otherwise LGTM
",jcrugzz,2014-06-10 17:13:12
649,2014-06-10 16:56:15,"Okay seems like my pull request #658 seems to achieve the same thing. I have `timeout` and `targetTimeout` there, if this pull request is gonna be pulled please take the test for original `timeout` as well.
",Rush,2014-06-10 17:13:12
649,2014-06-10 16:56:41,"Additionally the test for `socket.io` needs to be fixed, for which my pull request also has a change.
",Rush,2014-06-10 17:13:12
649,2014-06-10 17:01:25,"@RushPL yes i still wanted to steal your tests :). It all comes down to the naming so I will pull whatever PR that uses a `proxyTimeout` naming as they do accomplish the same thing.
",jcrugzz,2014-06-10 17:13:12
649,2014-06-10 17:13:12,"fixed with #658 
",jcrugzz,2014-06-10 17:13:12
648,2014-06-05 16:59:52,"See https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/index.js#L78.

If callback `cbl` is defined, the server parameter is `false`. Is there a reason to not support both the callback and the event simultaneously?
",jasonsanjose,
647,2014-06-05 08:49:08,"Hope this module can proxy any tcp flow, by implements the HTTP CONNECT protocol.

which forward any connection to target server

http://stackoverflow.com/questions/14080845/tunnel-any-kind-of-tcp-traffic-through-http-s
",ChinaXing,
647,2014-06-05 10:55:25,"Perhaps this is a scope for a third party module?
",Rush,
647,2015-12-01 05:57:09,"I have found that http-proxy supports http<-->https transform, but it cannot support https proxy via http CONNECTÔºüwhich is very pity

My code is:

var ProxyPort = 8888;
var server = http.createServer(function(req, res) {
  console.log(""req.url="" + req.url);
  var u = url.parse(req.url);
  //console.log(""req.url-parsed.path="" + u.path); 
  proxy.web(req, res, {
    target: req.url
  });
});
console.log(""listening on port ""+ProxyPort)
server.listen(ProxyPort);
",chenzx,
646,2014-05-31 09:41:20,"The final path is built in <a href=""https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L63"">common.js</a>. However, in the current version, it ignores the `target`'s path entirely.

<a href=""https://github.com/nodejitsu/node-http-proxy/pull/645"">This fix</a> merges target path and relative URL requested by the user. With this fix, I am able to reliably route all of mediawiki where the mediawiki path (on Apache) can be different from the express path where I installed the proxy.
",Domiii,
645,2014-05-31 09:35:34,"This fix considers the actual target path again (which has been ignored).
",Domiii,2014-09-08 22:24:23
645,2014-05-31 19:02:41,"@Domiii I can see this being valid but you need to handle the case where path is not defined. See the failing tests under `0.10.x`.
",jcrugzz,2014-09-08 22:24:23
645,2014-06-03 05:59:11,"Yeah. I suppose, we should also use `url.resolve` instead of `+`. I'll take a shot at it later today.
",Domiii,2014-09-08 22:24:23
645,2014-06-03 17:10:03,"@Domiii well it needs to be ignored in the case where the path is `undefined`
",jcrugzz,2014-09-08 22:24:23
645,2014-06-08 18:39:40,"I would instead like to see a hook so that is could be fixed manually.
",Rush,2014-09-08 22:24:23
645,2014-08-05 21:27:57,"I ran into a similar issue when using this in my project. Having the full path honored seems to be the expected functionality so hopefully this will be patch in a future release. 

For the time being, here is an example work around that doesn't require any updates to `http-proxy`, it expands on the [ProxyTable API example](https://blog.nodejitsu.com/node-http-proxy-1dot0/).

<S_CODE_TOKEN>
",greaterweb,2014-09-08 22:24:23
645,2014-08-05 21:36:41,"@greaterweb thanks for the example! I just modified your comment to have the correct api :).
",jcrugzz,2014-09-08 22:24:23
645,2014-08-05 22:00:24,"Thanks for the fix, @jcrugzz 

Copy and paste fail on my end :-) I coupled things from the ProxyTable example and my project (which uses express and does a few other things).
",greaterweb,2014-09-08 22:24:23
645,2014-09-08 19:42:13,"What's the next step for this? Just fix the tests?
",EndangeredMassa,2014-09-08 22:24:23
645,2014-09-08 19:50:08,"@EndangeredMassa yes it needs to be able to pass the current tests and there should be tests for the use case that this is a fix for.
",jcrugzz,2014-09-08 22:24:23
645,2014-09-08 19:51:46,"@Domiii do you plan on fixing up the tests for this? If not, I could take a look.
",EndangeredMassa,2014-09-08 22:24:23
645,2014-09-08 20:01:58,"@endangeredmassa that would be huge. 
",indexzero,2014-09-08 22:24:23
645,2014-09-08 21:25:21,"Submitted a new PR (that includes this original commit) to address the tests. Required some code changes.

https://github.com/nodejitsu/node-http-proxy/pull/693
",EndangeredMassa,2014-09-08 22:24:23
645,2014-09-08 22:24:23,"Fixed in #693 
",jcrugzz,2014-09-08 22:24:23
645,2014-09-13 15:14:18,"Thank you, EndangeredMassa! And sorry for the late response!
",Domiii,2014-09-08 22:24:23
645,2014-09-13 19:51:21,"No worries!
",EndangeredMassa,2014-09-08 22:24:23
644,2014-05-21 21:13:01,"Keep deployments as small as they can be.

https://www.npmjs.org/doc/developers.html#Keeping-files-out-of-your-package
",CaleyD,2014-09-11 12:09:53
644,2014-09-11 12:10:01,"Thanks for your contribution!
",3rd-Eden,2014-09-11 12:09:53
643,2014-05-21 12:59:04,"My proxy url will auto redirect to a different one. Is there an sample code to handle this scenario?
",liuxujim,
643,2016-06-02 10:34:53,"+1
",jacktuck,
642,2014-05-11 22:56:36,"Further to the pull request by @Domiii - #635 - this pull request adds the res object to the proxyRes event as well.

Also adding a test for the proxyRes event.

I wasn't about the specifics of updating other people's pull request, so just thought a new one might be a good option...
Apologies if that's less ideal :-s
",bruce-one,2014-05-11 23:01:05
642,2014-05-11 23:01:41,"@bruce-one its really the only way to do it. Also feel free to submit one with some docs around this :).
",jcrugzz,2014-05-11 23:01:05
642,2014-05-11 23:01:49,"Also Thanks!
",jcrugzz,2014-05-11 23:01:05
641,2014-05-11 09:56:43,"OS: Mac OSX 10.8
Node.js: v0.10.28
node-http-proxy: HEAD / 1.1.3

HTTP -> HTTP Proxying to a certain api server throws the following error:
/Users/.../node-http-proxy/lib/http-proxy/index.js:114
    throw err;
          ^
Error: Parse Error
    at Socket.socketOnData (http.js:1583:20)
    at TCP.onread (net.js:527:27)

The JSON data is dumped properly, but the proxy server crashes before closing the connection.  How do I debug this?
",fosstrack,
641,2014-06-01 05:19:36,"I have the same issue. It seems like it always happens on 304 with empty payload.
",piterfm,
640,2014-05-10 00:56:03,"As a patch to #488, do not override the connection header to 'close' if we are upgrading. Always overriding to 'close' prevents upgrades on agent-less sockets, as the proxy destination will never receive the upgrade request. With this change, we leave 'upgrade' requests alone, and let them do their thing.

This also addresses #638.
",jayharris,2014-05-10 03:25:45
640,2014-05-10 02:35:22,"@jayharris mind adding a test case for this? But thanks for the contribution!
",jcrugzz,2014-05-10 03:25:45
640,2014-05-10 02:52:41,"@jcrugzz Done.
",jayharris,2014-05-10 03:25:45
640,2014-05-10 02:54:32,"Not quite sure why Travis fails. It is green, locally.
",jayharris,2014-05-10 03:25:45
640,2014-05-10 03:25:37,"@jayharris awesome thanks! Tests are failing due to SSL things on `0.11.x`.
",jcrugzz,2014-05-10 03:25:45
640,2014-05-10 15:38:34,"Sweet! Any chance of this PR warranting a push to NPM? I have a few issues on @LinemanJS that I'm trying to get closed up.
",jayharris,2014-05-10 03:25:45
639,2014-05-08 09:50:22,"It's not a bug as I known, I just want request one resolve method for this problem.I think U may have more better than me to fix this. 
",lichenhao,2014-05-08 16:10:09
639,2014-05-08 16:10:09,"@lichenhao i would need to see some kind of reproducible example in order to even consider that this is a bug in `http-proxy`. It is more likely it is a bug in safari mobile browser on whatever iOS version you are running if it is not reproducible in other browsers.
",jcrugzz,2014-05-08 16:10:09
639,2014-05-15 08:50:06,"This is not the `http-proxy` going wrong. I read all this paper http://www.ietf.org/rfc/rfc2817.txt and this http://www.infoq.com/articles/Web-Sockets-Proxy-Servers.

When I set a proxy on my IOS WIFI's http proxy,I think this hold on a limited link, and if no response or upgrade from the http the IOS proxy will shut down this connection.  

I also have a question why don't use the `http(s).request` as a proxy server and pipe the response.

Thank you!
",lichenhao,2014-05-08 16:10:09
638,2014-05-06 17:27:09,,bkchain,2014-05-11 21:39:18
638,2014-05-08 01:02:15,"Note: noticed it might conflict with #579 (happens to me now...) and #488.
However, without it any standard websocket server won't like it (as they should be keep-alive).
I tried using http.globalAgent as well, but didn't help either.
",bkchain,2014-05-11 21:39:18
638,2014-05-11 21:39:18,"fixed in `1.1.3`
",jcrugzz,2014-05-11 21:39:18
637,2014-05-03 05:48:59,,volkovasystems,2014-05-03 21:29:27
637,2014-05-03 21:29:27,"@volkovasystems yes, it just fails HTTPS tests based on changes in the TLS implementation in `0.11.x`. Nothing to worry about
",jcrugzz,2014-05-03 21:29:27
636,2014-05-01 20:41:42,"I have a need which I suspect could be better handled at the node-http-proxy layer.

Imagine a site where requests to `http://site.com` return `200` but requests to `http://site.com/secure/` return `302` redirect to `https://site.com/secure/`.

I want to enable developers to transparently navigate using only `http://`.

Therefore, upon receiving a `302` to the same URL with different protocol, it should follow the redirect for the client and then proxy the response.

Is that possible? Where would that kind of option be implemented?
",firstdoit,2014-05-08 16:56:11
636,2014-05-08 16:30:06,"@gadr this particular example does not require a proxy of any kind. All you need to do is have your `http` server return the proper redirect. you can do this in express with something like [`force-secure`](https://github.com/nathan7/force-secure)
",jcrugzz,2014-05-08 16:56:11
636,2014-05-08 16:56:11,"I ended up implementing my own middleware: [connect-http-please](https://github.com/gadr/connect-http-please).

Thanks :)
",firstdoit,2014-05-08 16:56:11
635,2014-05-01 17:50:13,"The req object gives listeners of the proxyRes event access to the original client request, and thus allows accessing the session and identifying the user for whom we are doing the routing operation. Added the req object as second parameter, so it won't break existing code.
",Domiii,2014-05-11 23:02:29
635,2014-05-07 23:52:09,"I'd also find it very useful to have access to the req object in this situation :-)
",bruce-one,2014-05-11 23:02:29
635,2014-05-08 00:03:12,"Actually, further to this, it would be great to have access to the res object as well.
It used to be accessible as part of the 'proxyResponse' event (I'm not sure how long ago that was exactly - but I'm trying to update some code to the newer http-proxy) and hence am no longer able to access proxy responses as conveniently as previously.
",bruce-one,2014-05-11 23:02:29
635,2014-05-11 21:40:04,"@bruce-one id take an updated PR on this :)
",jcrugzz,2014-05-11 23:02:29
635,2014-05-11 22:58:19,"I created a new pull request - #642 - as I wasn't sure about updating other people's pull requests :-s
",bruce-one,2014-05-11 23:02:29
635,2014-05-11 23:02:29,"fixed in #642 
",jcrugzz,2014-05-11 23:02:29
634,2014-05-01 11:47:47,"I have the following code (which works perfectly)

<S_CODE_TOKEN>

I would like to add some logic to proxy websockets such as:

<S_CODE_TOKEN>

The above websocket proxy code doesn't seem to be working. Am I missing something ? Or the options for target is not even supported for proxying websockets ?

P.S I couldn't find any documentation about that feature, so I just took a wild guess to see if it works, or if somebody knows how to get it working.
",kurteknikk,2014-05-01 15:17:23
634,2014-05-01 15:11:22,"@kurteknikk See https://github.com/nodejitsu/node-http-proxy#proxying-websockets.

For proxying websockets you need to listen on the upgrade event where you have access to the socket when it receives the correct request. The web requests still need to be properly proxied as well (due to how the initialization works).
",jcrugzz,2014-05-01 15:17:23
634,2014-05-01 20:35:53,"@jcrugzz I read all the documentation on that page. I just couldn't find any documentation about how to proxy websocket requests using a dynamic target.

Could you please confirm that it's possible to proxy websocket requests dynamically ? And maybe direct me to an example or any other documentation somewhere ?
",kurteknikk,2014-05-01 15:17:23
634,2014-05-02 02:19:47,"@kurteknikk you have access to the same request that you do in a normal web proxy. You can proxy in the exact same way except you handle it in the `upgrade` event
",jcrugzz,2014-05-01 15:17:23
634,2014-05-02 13:51:05,"@jcrugzz first of all thanks for your help, i really think that i'm missing some here.

Could you please confirm that the below code should work ?
(assuming I have a socket listener setup on that port number of course)

<S_CODE_TOKEN>
",kurteknikk,2014-05-01 15:17:23
634,2014-05-02 16:10:26,"@kurteknikk yes that should work. It could also be `http://localhost:9999` as well
",jcrugzz,2014-05-01 15:17:23
634,2014-05-03 05:18:42,"I think my issue has to do with the fact that i'm behind an nginx webserver.
I will upgrade to the latest version of nginx, and hopefully that should fix it.
Thanks for your help.
",kurteknikk,2014-05-01 15:17:23
634,2014-05-05 17:43:05,"@kurteknikk Ahh that could make sense older versions of nginx did not support websockets. Open a new issue if you are still running into problems
",jcrugzz,2014-05-01 15:17:23
634,2014-05-06 06:57:07,"Sure, I knew i was missing something. Thanks for your support.
",kurteknikk,2014-05-01 15:17:23
633,2014-04-29 08:53:10,"When I try proxy to a site which requires basic authN, the code just hangs (i see no activity after my last log statement) and I am not sure how to debug it further:

<S_CODE_TOKEN>

Thoughts?
",pulkitsinghal,2014-04-29 09:17:30
633,2014-04-29 09:17:30,"Nevermind, the hanging part had to do with body-parser and connect-restreamer as outlined in #180 
",pulkitsinghal,2014-04-29 09:17:30
632,2014-04-29 07:19:23,"With this change, you can have a path following the target address and port, such as:

  {target: 'http://localhost:80/some/path/'}
",Domiii,2014-04-30 04:15:46
632,2014-04-29 09:30:41,"It appears the tests for Node 0.11 are broken. They fail on everybody (not just this request).
",Domiii,2014-04-30 04:15:46
632,2014-04-29 09:31:18,"Also note that without this patch, the path part of the target (or forward) URL is ignored.
",Domiii,2014-04-30 04:15:46
632,2014-04-30 04:15:46,"This works only in some cases, but it's not ideal yet.
",Domiii,2014-04-30 04:15:46
631,2014-04-26 09:46:50,"There is an example on how to ""migrate"" to version 1.0 and keep the same idea of the  ProxyTable API: 
https://blog.nodejitsu.com/node-http-proxy-1dot0/

But that example doesn't work, here is my scrip:

<S_CODE_TOKEN>

I get the following error:

<S_CODE_TOKEN>

I got a server running on port `3001` and `3002` and my `hosts` file have this two lines added:

<S_CODE_TOKEN>

What could be wrong?
",rodrigopolo,2014-04-30 17:57:24
631,2014-04-30 17:08:21,"Add http protocol to your options like below

<S_CODE_TOKEN>

If still not OK, check the value of req.headers.host by adding a line of console.log(req.headers.host) to the function createServer as following:

<S_CODE_TOKEN>

In this way, make sure the value of req.headers.host is ""test1.com"" or ""test2.com"".

Good Luck
",AlexZhouAA,2014-04-30 17:57:24
631,2014-04-30 17:57:24,"That did the trick! thanks a lot!
",rodrigopolo,2014-04-30 17:57:24
631,2014-04-30 22:50:29,"Sorry, any idea on how to add WebSockets support to the same code?

Previously the way to do it was adding this at the end of the server script:

<S_CODE_TOKEN>

But since we are doing the web routing manually, I got no idea how to do the same with the update event. If I create an update event function over the http server I obviously get a `TypeError` because the target is not defined on the server creation, the target it is ""dynamic"". 

<S_CODE_TOKEN>
",rodrigopolo,2014-04-30 17:57:24
631,2014-04-30 23:56:15,"@rodrigopolo you still have access to the `req` object so you can do the same exact thing. except with the `proxy.ws` function
",jcrugzz,2014-04-30 17:57:24
631,2014-05-02 08:28:55,"I know, I'm stuck on how to do a proxy that can handle multiple domains/paths with WebSockets.
",rodrigopolo,2014-04-30 17:57:24
630,2014-04-25 14:09:50,"I suspect this may be related to issue #623 .
When using a https->https configuration, the incoming response closes before all data has been received. 
I've narrowed it down to line 55 of common.js 

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L55

I have created a repo with simple source code (adapted from the https-https example) here...

https://github.com/walterhiggins/http-proxy-problem1
",walterhiggins,2014-04-25 15:59:57
630,2014-04-25 14:21:06,"I'm using Node 0.10.20
",walterhiggins,2014-04-25 15:59:57
630,2014-04-25 14:45:33,"This problem doesn't occur in Node 0.10.26
",walterhiggins,2014-04-25 15:59:57
630,2014-04-25 15:59:57,"@walterhiggins yea that line exists because of current bugs in how node core handles leaving sockets open. Glad this edge case works in the latest!
",jcrugzz,2014-04-25 15:59:57
629,2014-04-25 08:55:22,"In websocket server,i nedd client ip!
Please add header ""X-Forwarded-For""
",kd128,2014-04-25 09:11:19
629,2014-04-25 09:11:18,"@kd128 please see the [`xfwd` option](https://github.com/nodejitsu/node-http-proxy#options).

Code can be seen [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/ws-incoming.js#L54-L69)
",jcrugzz,2014-04-25 09:11:19
628,2014-04-23 23:22:03,"I want to load balance by using POST parameters. I wrote below code.

<S_CODE_TOKEN>

Request is this.

<S_CODE_TOKEN>

However, this didn't work I expected. I cannot get response from target server. I think that `req` has already received `end` event in this proxy server. So in the target server(in this case `google.com`) `end` event is never emitted. I use this alternative.

<S_CODE_TOKEN>

And request.

<S_CODE_TOKEN>

If it is needed just to read `headers`, `end` event will not be emitted in the proxy server. This alternative works properly.
But is there any way to load balance with POST parameter dynamically?

node version is 0.10.26 and http-proxy module version is 1.1.2.

<S_CODE_TOKEN>
",Lewuathe,
628,2014-05-08 17:00:15,"@Lewuathe It is not optimal to do something like this as you need to read the whole request into memory before proxying (makes proxying much less efficient). When I have time I can try and write up an example of how this is done. To explain briefly, you need to use something like my [`buffr`](https://github.com/jcrugzz/buffr) module in order to duplicate all the data since you will be parsing the whole request. An example of how this is used in a retry situation can be found [here](https://github.com/jcrugzz/buffr/blob/master/test/request-test.js)
",jcrugzz,
628,2015-11-15 22:58:20,"Hi, I have exactly the same problem..... How to sort it out? in my case I need to call a host dependindg ot the miTag:

var http = require('http'),
httpProxy = require('http-proxy'),
proxy = httpProxy.createProxyServer({});

var miTarget='web:CountryName';
var inicio = '<'+miTarget+'>';
var fin = '</'+miTarget+'>';

var server = http.createServer(function(req, res) {
var miTag = '';
req.on('data', function (data) { 
miTag = data.toString().split(inicio)[1].split(fin)[0];
});

  req.on('end', function () {
  console.log('miTag!!!!!!:'+miTag);
  if(miTag=='Portugal') {
  proxy.web(req, res, {target: 'http://www.webservicex.net'}); 
  }
  else { 
  proxy.web(req, res, {target: 'http://localhost:1337'}); 
  }

  });  
});

console.log(""listening on port 80"")
server.listen(80);
",macscripter,
628,2015-11-16 00:16:51,"@macscripter As I described before, I passed my routing parameter on HTTP header, not POST parameter. Even end event is emitted on proxy server side, we can read the items in HTTP header. 
This was the solution that I took. 

<S_CODE_TOKEN>

But I don't know whether latest node-http-proxy could resolve this issue or not even in POST parameter. So please check it.

Thank you.
",Lewuathe,
628,2015-11-16 10:13:47,"Thank you!
I understand this solution but I could not change the request from my
front, so I really need to get the parameter from the POST using the
req.on('data') or req.on('end') envent.
Anyway, I really appreciate your feedback regarding to this issue.

Thank you!

Warmest regards

2015-11-16 0:17 GMT+00:00 Kai Sasaki notifications@github.com:

> @macscripter https://github.com/macscripter As I described before, I
> passed my routing parameter on HTTP header, not POST parameter. Even end
> event is emitted on proxy server side, we can read the items in HTTP
> header.
> This was the solution that I took.
> But I don't know whether latest node-http-proxy could resolve this issue
> or not even in POST parameter. So please check it.
> 
> Thank you.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/nodejitsu/node-http-proxy/issues/628#issuecomment-156878273
> .
",macscripter,
627,2014-04-22 07:33:47,"it happen when sever dothing like

<S_CODE_TOKEN>
",kd128,2014-10-01 00:55:38
627,2014-04-22 07:34:40,"becasue socket.write(""HTTP/1.1 406 Not Acceptable\r\n""),the http proxy will just emit an response event other than upgrade event!
please fix this bug!
",kd128,2014-10-01 00:55:38
627,2014-04-25 08:09:57,"please fix this bug as soon as possible,because it will make socket leave!
",kd128,2014-10-01 00:55:38
627,2014-04-25 08:21:35,"@kd128 Can you see if running a `socket.destroy()` rather than a `socket.end()` behaves differently? But it is possible this is a bug. If you can add a fully working, minimal test case, this would expedite the process :). And ideally in the form of a pull request ;)
",jcrugzz,2014-10-01 00:55:38
627,2014-09-30 22:22:38,"I've added a complete test case for this bug [here](https://gist.github.com/minrk/6c5b02f4bdda6e991597). Switching between socket.end and destroy does not have any effect. Proxied websocket connections that are rejected are left open. This is particularly problematic in browsers (other than Safari for some reason) because a websocket stuck in the connecting state actually blocks other attempts to connect to the same server, even from other tabs.
",minrk,2014-10-01 00:55:38
626,2014-04-21 23:55:13,"I'm using node-http-proxy extensively.  The line

<S_CODE_TOKEN>

in [ws-incoming](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/ws-incoming.js) causes trouble, since server isn't defined (for me, at least).  I have to manually replace the above by

<S_CODE_TOKEN>

With that one change everything works well for me, so I don't think I'm just setting up the proxy incorrectly or misusing the library. 
",williamstein,2014-04-22 00:22:29
626,2014-04-22 00:22:29,"I realize that I'm using the caronte branch, and clearly not following the instructions for setting up proxy server in your README file.  Sorry for the noise. 
",williamstein,2014-04-22 00:22:29
625,2014-04-21 01:34:53,"Remove number of requests flag from `wrk` as it no longer exists. Swapped out for 5 minute duration.
",bkochendorfer,2014-12-19 09:01:53
624,2014-04-21 01:25:12,"websocket proxy,if the sever reject the connect with status other than 101,then the proxy req will not emmit an upgrade event,and the connection from client will hong on by the proxy for a long long time!
maybe the proxy should also catch the response event!
",iamzfj,2014-10-01 00:55:38
624,2014-04-21 02:24:16,"@iamzfj can you show me an example of this case? More test cases always help :)
",jcrugzz,2014-10-01 00:55:38
624,2014-04-21 03:30:06,"i have use another account name kd128 instead of iamzfj ^_^
recently,i am using https://github.com/Worlize/WebSocket-Node for ws server,
and found this bug!
in WebSocket-Node,before accept an ws request from client,ws server may reject it!
what about 
WebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {
    if (typeof(status) !== 'number') {
        status = 403;
    }
    var response = ""HTTP/1.1 "" + status + "" "" + httpStatusDescriptions[status] + ""\r\n"" +
                   ""Connection: close\r\n"";
    if (reason) {
        reason = reason.replace(headerSanitizeRegExp, '');
        response += ""X-WebSocket-Reject-Reason: "" + reason + ""\r\n"";
    }

<S_CODE_TOKEN>

};

code from 
https://github.com/Worlize/WebSocket-Node/blob/master/lib/WebSocketRequest.js
",kd128,2014-10-01 00:55:38
624,2014-04-25 08:10:43,"please fix this bug as soon as possible,because it will make socket leave!
",kd128,2014-10-01 00:55:38
623,2014-04-16 13:19:35,"When proxying HTTPS to HTTP, I am getting a lot of ERR_CONTENT_LENGTH_MISMATCH errors in Chrome.  For example, if I request an image from the web server through the HTTPS proxy, I get a content length of 50KB but the downloaded image is 30KB (and the image appears to be half-downloaded).  This is true for _any_ HTTPS request, not just images.  This is also true for _any_ web browser.  I am testing in a Windows environment with a fairly slow Internet connection.

Perhaps the connection is ending prematurely?  Any thoughts on this?
",bminer,2014-12-05 21:37:51
623,2014-04-16 18:30:19,"@bminer hmm interesting, is there anyway you could add a minimal failing test that reproduces this? That would be the easiest way to see where the potential bug might be.
",jcrugzz,2014-12-05 21:37:51
623,2014-04-21 16:04:55,"@jcrugzz Sure. I'll try to post back here by Thurs. next week.
",bminer,2014-12-05 21:37:51
623,2014-05-08 17:02:26,"@bminer was this able to be resolved?
",jcrugzz,2014-12-05 21:37:51
623,2014-05-10 18:40:26,"I don't know yet.  I am running Node v0.10.15, but I will try 0.10.26 to see if the problem has been fixed.
",bminer,2014-12-05 21:37:51
623,2014-05-11 04:27:45,"@bminer its safe to say you should be able to upgrade to `v0.10.28` without any problem. Let me know.
",jcrugzz,2014-12-05 21:37:51
623,2014-05-13 01:06:26,"@bminer Has your problem gone away since upgrading to 0.10.26? I started seeing this on straight http (no https). If I serve a web page straight from node.js its fine, but if I put it in front of hipache (which uses node-http-proxy) I start getting these ERR_CONTENT_LENGTH_MISMATCH errors for some of my assets. I originally experienced this on 0.10.25, but upgrading to both 0.10.26 and 0.10.28 didn't fix the issue.
",jkingyens,2014-12-05 21:37:51
623,2014-05-13 02:37:12,"@jkingyens if you can get a small reproducible example using the latest version of `node-http-proxy`, I would love to help figure out why might be happening! Failing tests are always a good addition to find a subtle problem :)
",jcrugzz,2014-12-05 21:37:51
623,2014-05-15 23:43:12,"@jcrugzz Understandable :) I couldn't isolate it to `node-http-proxy`. The best I could do was show the problem occurred behind hipache. Without hipache everything was fine. I was using an older version of hipache so I decided to try the latest release and the problem disappeared. But thanks anyway :) 
",jkingyens,2014-12-05 21:37:51
623,2014-06-05 00:14:40,"FYI net::ERR_CONTENT_LENGTH_MISMATCH and net::ERR_INCOMPLETE_CHUNKED_ENCODING may happen on Node 0.11.13 now. Node 0.11.10 works fine.
",Nowaker,2014-12-05 21:37:51
623,2014-07-10 21:59:19,"Using globalAgent seems to solve this issue for me : 

<S_CODE_TOKEN>
",nicolashenry,2014-12-05 21:37:51
623,2014-09-09 23:47:38,"Had this problem, too. Upgrading from Node v0.10.8 to v0.10.30 resolved it.
",pwfisher,2014-12-05 21:37:51
623,2014-09-09 23:51:54,"> from Node v0.10.8 to v0.10.30
> from Node v0.10.8
> v0.10.8

I hope you are kidding. ;) 0.10.8 was more than a year old.
",Nowaker,2014-12-05 21:37:51
623,2014-12-05 21:37:51,"I think this issue should be closed.  I am also no longer experiencing this problem.
",bminer,2014-12-05 21:37:51
622,2014-04-10 19:08:43,"When I try to add this module to my project I get the following output from npm:

<S_CODE_TOKEN>
",mtharrison,2014-04-10 21:22:35
622,2014-04-10 21:22:35,"@mtharrison this is a problem with `npm`. Try upgrading your `npm` client `npm install -g npm` and if the bug persists, post an issue on the project. 
",jcrugzz,2014-04-10 21:22:35
621,2014-04-09 16:52:16,"When passing a request through the proxy via proxy.web() the original ""source"" host header is copied into the proxyReq. This is incorrect behavior.

For reference: http://www.mnot.net/blog/2011/07/11/what_proxies_must_do
",suedama1756,
621,2014-05-26 06:29:46,"I encountered to the same problem. some websites does not work without setting the right host. For example, Google appspot.

The options.headers is somewhat not documented. (took me hours to figure out how to achieve this without changing the source ode.)

in common.js setupOutgoing()

<S_CODE_TOKEN>

So my fix is:

<S_CODE_TOKEN>
",edwardfung123,
621,2014-10-24 19:26:18,"I just ran into this too. Deleting `req.headers.host` worked in my case too.
",mhart,
621,2014-12-14 19:44:47,"Would this node-http-proxy work on a hosted and shared Google drive just like you can host websites from GD nowadays?

Thanks for any input! This may be what I'm looking for.

Please see this as examples

http://youtu.be/BTen-UipDys

or 

http://youtu.be/mckYn7kd4YA

Thanks guys Hi5

also I guess I should fork my own to be able to tweak etc..
",dyingjedi,
620,2014-04-08 14:26:37,"We have a need to support a backend service that is returning responses that are already gzip encoded.  

This PR enables the incoming handler to recognise that the content is in gzip format and unzip it so that it can pass through subsequent middleware as normal.  If backend service does not return gzip encoded header then no change is made to the stream.

Minimal change to the incoming request handler, have added a test case to demonstrate it works (though I do get failing tests that I am unsure to fix that appears to mirror failing tests in the master branch).
",cliftonc,2014-04-08 15:09:56
620,2014-04-08 15:09:56,"Apologies - missed a matching change in outgoing, will close.
",cliftonc,2014-04-08 15:09:56
620,2015-01-19 01:05:44,"@cliftonc I'm confused as to why this was closed?
",pdf,2014-04-08 15:09:56
620,2015-01-19 06:24:53,"I can't recall the specific reason, but I do remember that although this PR appeared to work I couldn't actually get the tests to pass and we encountered other issues.  In the end we just ended up not using http-proxy in the project, we just went down a more direct route:  https://github.com/tes/reliable-get.
",cliftonc,2014-04-08 15:09:56
620,2015-01-19 06:32:48,"Hrm, according to travis it looks like the tests passed fine on node 0.10, they only failed on 0.11 due to some (unrelated?) HTTPS issue.  I don't really deal with node stuff generally, really just wanted this to work for grunt-connect to proxy some stuff through to my API server, but perhaps I'll try and cherry-pick your commits to re-send this PR.
",pdf,2014-04-08 15:09:56
619,2014-04-08 12:03:07,"<S_CODE_TOKEN>

throws 

<S_CODE_TOKEN>

Any suggestions?
http-proxy 1.4.3
node v0.10.26
",stpdenis,2014-04-10 09:59:08
619,2014-04-08 16:04:36,"I had a similar issue lately when I try to proxy the requests to a virtual
web server.

Not sure if it's the same issue but it works for me after I change the host
from the header.

req.headers.host = 'hostname:80';

HIH,

-lianyi
_""Less isn't more; just enough is more.""_ -Milton Glaser

On Tue, Apr 8, 2014 at 8:03 AM, Denis notifications@github.com wrote:

> var options = {target: {protocol: 'http'}};
> var proxy = require('http-proxy').createProxyServer(options);
> proxy.on('error', function (err, req, res) {
>     console.log(err);
>     res.writeHead(500);
>     res.end();
> });
> proxy.listen(8888);
> 
> throws
> 
> { [Error: connect ECONNREFUSED]
>   code: 'ECONNREFUSED',
>   errno: 'ECONNREFUSED',
>   syscall: 'connect' }
> 
> Any suggestions?
> 
> ## 
> 
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/619
> .
",leoh,2014-04-10 09:59:08
619,2014-04-08 16:06:32,"@st-denis you need to give a host and a port as target in that object or make target a full URL string
",jcrugzz,2014-04-10 09:59:08
619,2014-04-09 18:26:31,"@jcrugzz what if i don't know target? i'm trying to implement simple proxy http server (anonymizer)
",stpdenis,2014-04-10 09:59:08
619,2014-04-09 19:51:07,"@st-denis you cannot proxy anything if you don't know the target. You have to grab a hostname or URL string from somewhere. Even if you are anonymizing, you need to have a pool of servers to pull from
",jcrugzz,2014-04-10 09:59:08
618,2014-04-07 17:12:03,"Hello.

I have a proxy-server only for development purposes, that proxies different routes to different servers. And one of routes is for socket.io server:

<S_CODE_TOKEN>

As you can see it is all on heroku, with websockets enabled for both proxy app and socket.io app.

Connection goes well, server can send data to client, and client receives it. But client cant send anything and respond to heartbeats.
Here's log:

<S_CODE_TOKEN>

Seems like socket.io client sends responses to heartbeats, and establishing socket connection through chromedevtools works, but on .send nothing goes to socket.io server.
Maybe there is a way to log this data (emits and sends from client) on proxy server?
And then it goes the same cycle, reconnecting due to heartbeat timeout.
Spent 4-5 hours on this problem already, cant find solution anywhere...
Versions:
socket.io -- 0.9.16
node -- latest / 0.10.26
node-http-proxy -- latest(must be)

UPDATE:
In local everything works fine, clients messages reach the server.
That must be some trouble with heroku?
",RavisMsk,
618,2014-07-29 18:16:22,"If you use https instead of http with the heroku url (instead of your custom domain url), then it will work. I am looking for a way to make it work with normal http.
",nlhkh,
617,2014-04-07 16:17:27,"http-proxy@1.0.3 is causing problems with trumpet. http-proxy@1.0.2 doesn't exhibit the problem

<S_CODE_TOKEN>
",cressie176,2014-04-08 15:10:39
617,2014-04-07 16:29:27,"1.0.2 doesn't work either when checked out cleanly from the npm registry. Trying to find out whether someone here patched it before committing node_modules
",cressie176,2014-04-08 15:10:39
617,2014-04-08 14:18:42,"Someone here has patched it (the problem is to do with zip support). I'll extract the patch and create a PR
",cressie176,2014-04-08 15:10:39
617,2014-04-08 15:10:39,"Someone beat me to it - https://github.com/nodejitsu/node-http-proxy/pull/620
",cressie176,2014-04-08 15:10:39
616,2014-04-05 18:05:21,"Fixing a typo
",hipstern,2014-04-06 06:41:27
616,2014-04-06 06:41:25,"@hipstern thanks!
",jcrugzz,2014-04-06 06:41:27
615,2014-04-04 19:22:48,"In an offline environment, whenever I try to enter an http website that is proxied to a https website, I get a CERT_UNTRUSTED error and the program crashes.
https to https and https to http proxies work fine. Only the http to https gives me problems.
How can I resolve this?
Thanks!
",shlatchz,
615,2014-10-14 19:32:15,"I'm having an issue along the same lines due to a corporate proxy/firewall that remaps SSL certificates so it can ""legitimately"" snoop on SSL encrypted traffic.
",normanhh3,
615,2015-06-25 08:51:33,"this is also a issue with https to https for a certificate verified by Entrust, Inc.
",nsiitk,
615,2015-06-25 09:34:08,"sorry its http to https.
when I test the certificate with openssl it says
Verify return code: 20 (unable to get local issuer certificate)

while for other working host it says
Verify return code: 0 (ok)
",nsiitk,
614,2014-04-04 17:11:10,"My current setup is as follows: I have a Node.js server that is serving http requests (let's call that the main server) and another Node.js server that is proxying requests to the main server (running node-http-proxy v1.0.3). If the main server and proxy server are both running on my machine, everything works great and I don't see any drop in performance when going through the proxy. However, as soon as the main server is running on an EC2 instance (and the proxy still on my local machine), I see the average response time go from 50-100ms to about 800-3000ms per request when I make requests through the proxy vs. directly calling the main server. I'm kind of at a loss because it seems like as far as EC2 (or the network/internet) is concerned, the actual request leaving my machine and coming back to my machine **should** be the same in both scenarios, correct? If that is the case, then if feels like the issue is somewhere in node/node-http-proxy. However, then why isn't the performance impacted when the main server is running on my machine? Honestly I'm not even sure about the right way to go about debugging the issue and if anyone can provide some guidance I'd be more than happy to run some more tests to help point people in the right direction.

Also, I saw issues #334, #305, and #491, but I didn't feel like any of those could have the same root cause as the issues I'm seeing; feel free to correct me though if that assumption happens to be wrong.
",sgerace,2016-01-13 10:24:39
614,2014-04-04 19:33:45,"Alright, so now I'm really confused...I wanted to confirm that the problem was, in fact, something in node-http-proxy, so rather than proxying the request I used mikeal's request module to make the same request, and wouldn't you know it, it too was way slower. Okay, I thought, it is probably an issue in Node's http module, so I tried just using http.get, and to my surprise the requests consistently came back in 50-100ms, rather than the 800-3000ms it is taking everything else. SO, I have no idea whats going on now. Clearly there is something in common between node-http-proxy and mikeal's request that is causing this delay to be introduced. I'll continue to investigate, but if anyone else has any bright ideas I'm all ears.

Oh, the other thing is that I'm now connecting to my EC2 instance using an Elastic IP, so I wouldn't think there is any DNS resolution going on here (and even if there was, I would think it should affect the http module as well).
",sgerace,2016-01-13 10:24:39
614,2014-04-04 19:44:32,"@sgerace Could you provide a reproducible test case that is not reliant on EC2? It is also quite plausible it is your internet provider's latency to amazon and you only have a minimal sample size that possibly consists of spurious results. I would try and test this from an EC2 machine to another EC2 machine to see if you get the same behavior. 

We run this in production on [joyent](https://joyent.com) with substantial traffic and see no latency issues.
",jcrugzz,2016-01-13 10:24:39
614,2014-04-04 19:59:46,"@jcrugzz The issue at the moment is that I'm only seeing it when going to EC2 (though the only other scenario I've tested against is a local server and I'm not sure that is a fair comparison to anything over the internet). I don't _believe_ that it is my internet since the response performance is fine both from my browser as well as node when I'm using http.get calls. To illustrate, when I run code like this:

<S_CODE_TOKEN>

The time reported is consistently between 50 and 100ms (same as if I make the request in my browser)

However, as soon as do something like this:

<S_CODE_TOKEN>

OR

<S_CODE_TOKEN>

The response time is always > 1s.

After further searching, it sounds awfully like [this Stack Overflow post](http://stackoverflow.com/questions/19844594/node-js-pipe-to-a-http-response-results-in-slow-response-time-on-ubuntu).
",sgerace,2016-01-13 10:24:39
614,2014-04-04 20:19:20,"...and possibly joyent/node#6481, though it doesn't exactly explain how to fix it and why it only effects higher-level interfaces (possibly because I wasn't piping the response in my http.get example?).
",sgerace,2016-01-13 10:24:39
614,2014-04-04 20:35:17,"Just tried adding 

<S_CODE_TOKEN>

to both the main server and proxy server to no effect.
",sgerace,2016-01-13 10:24:39
614,2014-04-07 14:45:45,"@jcrugzz So here is where I'm at after messing with this over the weekend; I've placed the following server code up onto a public EC2 instance so you can test it yourself (to rule out the possibility of internet effects):

<S_CODE_TOKEN>

The public ip address of the server is 54.209.167.233

When I request http://54.209.167.233:3000/ in my browser (I'm using the [Advanced REST Client](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo?hl=en-US) for chrome), I consistently get a response between 60-120ms. 

If I run the following code, both cases respond for me in roughly the same amount of time (about 100ms each):

<S_CODE_TOKEN>

However, if I run the following example, and then request the response from localhost, I get times in the 800-2000ms range:

<S_CODE_TOKEN>

For good measure, and it illustrate that I don't think the root cause is necessarily _specific_ to http-proxy (though certainly something it is doing is causing the delay over the base http implementation), I provide the following additional example which uses [mikeal/request](https://github.com/mikeal/request) to the same effect:

<S_CODE_TOKEN>

This is as simple as I can make the cases and still illustrate the problem. Clearly it has something to do with EC2, but the fact that the http requests come back in a reasonable amount of time makes me think that it also has something to do with the way http-proxy (and [mikeal/request](https://github.com/mikeal/request) for that matter) are handling requests at the Node.js level.

I'm going to go ahead and bring this up in the mikeal/request forum as well, to see if any others might have an idea what might be going on. I'll keep the server up and running as long as necessary to troubleshoot the issue.

Thanks!
",sgerace,2016-01-13 10:24:39
614,2014-04-07 18:53:28,"@sgerace This is very interesting. One test I think will be useful is to try it on `0.11.x` just to see if it is associated with the `http` fixes that will exist in `0.12.x`. 
",jcrugzz,2016-01-13 10:24:39
614,2015-03-20 05:20:25,"While doing pipe, when I set keepAlive=true for agent, I got the response in near time as direct call, around 3-5ms extra. 
",vkadam,2016-01-13 10:24:39
614,2015-05-08 18:21:54,"Is there a resolution to this? I am seeing the same issue.
",zoheb,2016-01-13 10:24:39
614,2015-08-05 15:53:55,"I've got the same issue, and for me setting up http.agent.maxSockets to 10000 solve the problem. Not sure why, since maxSocket defaults to infinity.

<S_CODE_TOKEN>
",antouhou,2016-01-13 10:24:39
614,2015-11-27 16:54:13,"Perhaps this will help those for whom the `keepAlive` / `maxSockets` settings don't make a difference: it may very well be down to DNS lookups. I noticed that even when proxying locally, to a virtual machine, if the target is a hostname rather than IP, the response is 100 to 150 ms slower
",manueltimita,2016-01-13 10:24:39
614,2015-12-09 07:57:05,":+1: getting this when using a host on /etc/hosts, Node v5 if that helps
",alexw23,2016-01-13 10:24:39
614,2016-01-13 10:13:51,"Is there any other fix for this? I am seeing the same issue.
",Kulikowski,2016-01-13 10:24:39
614,2016-01-13 10:24:39,"The solution to this issue is to use a custom agent or to up the sockets on the default agent, which by default in many older vesions of node is set very low (5 sockets). If you are running on node@4, however, the default number of sockets is high. 
",indexzero,2016-01-13 10:24:39
613,2014-04-02 20:16:15,"I'm trying to just setup a simple endpoint /api/proxy/?to=... Where ... is the target to call.

When I try something like:

<S_CODE_TOKEN>

and then use it with: http://localhost/api/proxy/?to=http://google.com/

I get a response back from google saying: ""The requested URL /api/proxy/?to=http://google.com/ was not found on this server. That‚Äôs all we know.""

I take that to mean that google is actually getting a request for http://google.com/api/proxy/?to=http://google.com/

How do I make http-proxy just call http://google.com/ (or whatever is in the to argument) and return the result?
",jdarling,2014-04-02 20:47:28
613,2014-04-02 20:47:24,"I'll answer my own question, you have to override the URL before handing to proxy.web:

<S_CODE_TOKEN>
",jdarling,2014-04-02 20:47:28
612,2014-04-01 15:33:00,"I am using http-proxy to proxy all socket.io requests to another port on the same domain (node/express):

I define the proxy:

<S_CODE_TOKEN>

I catch the request:

<S_CODE_TOKEN>

As well as the upgrade:

<S_CODE_TOKEN>

The server now complains: KeyError: 'wsgi.websocket'

FYI: The server is written using python and Flask-SocketIO

This has always worked, but does no longer since the update from 1.0.2 to 1.0.3. I specifically and with a lot of pain checked all my stack and could narrow it down to this update.

Please tell me if you need more information. Unfortunately I can not publish the whole code.
",olingerc,2014-04-04 10:40:51
612,2014-04-01 19:48:30,"@olingerc are you positive that is the only thing that has changed? No other dependencies could have updated their version? The ONLY possible relevant change is [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L49-L56) but I cannot see how that would effect websockets.

Can you take your example and turn it into a minimal failing test case? It should be reproducible by a simple node server using `socket.io` as well.
",jcrugzz,2014-04-04 10:40:51
612,2014-04-02 10:10:47,"@jcrugzz 
Thanks for the reply. I have tested some more. If I stay in a complete node environment as you  suggested, v1.0.3 works fine [(here)](https://github.com/olingerc/http-proxy-testcase) . So thats already a good thing, except I need a python backend :-/

As soon as I switch to the python socket.io backend, keeping the frontend the same, v1.0.3 gives the errors. The server switches to polling over socket.io after a few seconds, but the websocket itself is not setup. Reverting to v1.0.2 on the frontend, without changing anything on the backend, makes everything work again with the python backend. I simply use `npm install http-proxy@1.0.3` and `npm install http-proxy@1.0.2` to switch between versions. All other dependencies are fixed.

So I conclude:
- The frontend setup is ok
- Since all dependency versions except http-proxy do not change, it sort of has to be http-proxy, sorry
- The python backend works correctly with http-proxy v1.0.2
- The python backend can not setup a websocket with v1.0.3, but successfully switches to polling. Maybe incomplete headers somewhere?

I can not exclude an error in the python backend which maybe became apparent due to v1.0.3 being more strict? I'll investigate more and post some minimal python code. FYI, the backend is based on Flask and  [(Flask-SocketIO)](https://github.com/miguelgrinberg/Flask-SocketIO).
",olingerc,2014-04-04 10:40:51
612,2014-04-02 10:16:44,"@jcrugzz 
I can confirm that [this line](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L55) is the culprit. Commenting it out makes v1.0.3 work fine.
",olingerc,2014-04-04 10:40:51
612,2014-04-02 10:51:35,"@olingerc super weird, there shouldnt be any reason the python backend just doesn't accept a request with `connection: close`. The problem with reverting this change is that it can cause sockets to leak since in the default case we do not use an [`agent`](http://nodejs.org/api/http.html#http_class_http_agent) and node core http is broken in this regard.

So we have two possible solutions here. The first one is that I want you to see if a change on line 54-55 to the following makes a difference.

<S_CODE_TOKEN>

If it does not, I would try using an [`agent`](http://nodejs.org/api/http.html#http_class_http_agent) with your proxy so that it properly keeps the socket alive and is managed by node versus the OS. I would just recommend increasing the `maxSockets` value to a good sized number so you don't get throttled by socket pooling.

Let me know what you come up with.
",jcrugzz,2014-04-04 10:40:51
612,2014-04-02 10:53:16,"Sorry for the multiple comments.
Here's the python code (python 2.7) Use pip to install Flask-socketio then run python server.py

<S_CODE_TOKEN>

You see, there's not much to it. Very minimal. Everything's handled by flask-socketio which itself is a mall wrapper (200 lines of code) around gevent-socketio and gevent-websocket. I have absolutely no clue how to proceed with debugging now.

Traceback from python:

<S_CODE_TOKEN>
",olingerc,2014-04-04 10:40:51
612,2014-04-02 11:03:01,"Replaceing lines 53-56 with the below, did not change anytthing :-(

<S_CODE_TOKEN>

I'll try to see with the agent (who's this agent ?). It's a bit above my head but i'll try to figure it out.
",olingerc,2014-04-04 10:40:51
612,2014-04-02 11:44:57,"Ok, the follwing two lines indeed make v1.0.3 work unmodified with my python backend:

<S_CODE_TOKEN>

<S_CODE_TOKEN>

Which is better and what's the drawback of increasing maxSockets?
From my side we can close the issue but I'm afraid future python backend users might run into the same issue again.
",olingerc,2014-04-04 10:40:51
612,2014-04-02 16:35:22,"@olingerc the reason this ""fix"" is in place is due to node core not properly closing sockets in some cases when there was no agent. Hopefully there will be no others with python backends as it was necessary for others.

To answer your above question, the second one is better and there is no downside to increasing the # of sockets. It prevents you from limiting the # of sockets you rotate through and potentially block the ability to proxy depending on your traffic. (it will block pretty quickly with only 5 which is the default on the global agent)
",jcrugzz,2014-04-04 10:40:51
611,2014-04-01 11:54:34,"Hey everyone.

I have a strange problem that i couldn't find in issues.
Im trying to use node-http-proxy with socket.io.
This is route for websocket server proxy:

<S_CODE_TOKEN>

'app' is express and 'server' is actual node http server.

Upgrade seems to be sent, but socket.io logs 'debug: destroying non-socket.io upgrade'.
Timeout is hit in a moment and socket.io starts working with xhr-polling, which works, but i dont really need that one :)
I tried to set 'destroy upgrade' to false, but that doesn't help, still no response on upgrade, and client never gets 'connection' event.

Thanks in advance.
",RavisMsk,2014-04-01 17:44:21
611,2014-04-01 17:45:48,"Sorry for disturbing, problem was in these prefixes.
I didn't remove '/chat' prefix from 'upgrade' event, so proxied to another end-point.
",RavisMsk,2014-04-01 17:44:21
610,2014-03-31 15:08:22,"How to get the proxy-target for one proxy-request inside the ""proxyRes"" event?

proxy.on('proxyRes', function (res) {
  // target of this sucessfull proxy-request?
});
",zlaoz,
609,2014-03-31 08:44:47,"I'm building a proxy to be run on my local machine that will log all domains accessed. Kind of the same way Fiddler works, but my program is more simple, I don't need to look at the data or decrypt anything.

I got this working fine for HTTP but for HTTPS it resigns the traffic with the self-signed certificate provided. This results in that the browser displays a warning. The same thing doesn't happen in fiddler unless you choose to decrypt HTTPS traffic.

So my question is: How do I proxy HTTPS traffic so that it is completely transparent for the web browser user?
",Kantaris,
609,2014-03-31 08:50:11,"HTTPS traffic will look like garbage to any monitoring application so you won't be able to distinguish domains without decrypting the traffic (requested domain is sent in HTTP headers). Your options:
- Proxy HTTPS to HTTPS (provide a valid certificate in the proxy, wastes resources)
- Proxy HTTPS to HTTP (faster, still needs valid certificate in the proxy and disable HTTPS in the application)
",Rush,
609,2014-03-31 09:35:20,"Proxy HTTPS to HTTPS seems like the way to go. I want everything to work exactly like if the proxy wasn't there
",Kantaris,
608,2014-03-27 15:18:25,"<S_CODE_TOKEN>

This example doesn't work, but gives the following error

<S_CODE_TOKEN>

Would be great with a working proxy table example as this is probably one the most sought after functions of http-proxy? 
",jonaslund,
608,2014-04-02 13:39:07,"I've got the same problem.  It would be really nice with working examples for the most common usage cases.
",SmallRoomLabs,
608,2014-04-03 16:06:38,"You must add a error handling like this:

<S_CODE_TOKEN>

maybe can you help my!

How can i use a proxy server with pathname routing like this

<S_CODE_TOKEN>

I don't understand the new ProxyTable API

pleas help my

Thanks
",norbusol,
607,2014-03-26 20:59:52,"I am using the proxy but my code keeps getting ECONNRESET and crashing.  

I looked at https://github.com/nodejitsu/node-http-proxy/pull/488.  It seems to be saying to modify the headers of the request.  Forgive me if I'm being stupid, but I don't seem to be able to modify the request headers.

How can I stop getting the error or at least catch it?  Should I be creating new proxies on every request?  (I presently just have one proxy for each site and I reuse them).
",JoeIsCool,2014-03-27 05:20:04
607,2014-03-27 05:20:04,"@JoeIsCool should be fixed in 1.0.3

Feel free to ping me here if this is not the case and give me a gist :)
",jcrugzz,2014-03-27 05:20:04
606,2014-03-25 00:18:43,"@yawnt pretty simple fix here. We lost backwards compatibility hard.

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L11-L16
",indexzero,2014-04-09 17:38:21
606,2014-03-25 12:05:20,"they are not the same thing, a ProxyServer is expected to be used as a server, while Proxy just provides the two function for proxying..

that said, if you think it's better to change it, i can do that ... what do you need exactly? just createProxy to behave like createProxyServer?
",yawnt,2014-04-09 17:38:21
605,2014-03-23 16:11:38,"Pushing element in array must to be 
  addresses.push(target.target);

http.createServer(function (req, res) {
  //
  // On each request, get the first location from the list...
  //
  var target = { target: addresses.shift() };

  //
  // ...then proxy to the server whose 'turn' it is...
  //
  console.log('balancing request to: ', target);
  proxy.web(req, res, target);

  //
  // ...and then the server you just used becomes the last item in the list.
  //
  addresses.push(target);
}).listen(8021);

// Rinse; repeat; enjoy.
",rinobilla,
605,2014-03-23 19:20:56,"@rinobilla why not submit a PR? ;)
",jcrugzz,
605,2014-05-23 02:24:28,"I think that is the bug.
addresses.push(target); -> addresses.push(target.target);
",ShockUtility,
604,2014-03-21 23:48:43,"I want to do something like:

var http = require('http'),  
    httpProxy = require('http-proxy');

//
// Just set up your options...
//
var options = {  
  hostnameOnly: true,
  router: {
    'domainone.com': '127.0.0.1:9000',
    'domaintwo.net': '127.0.0.1:9001',
    'domainthree.org': '127.0.0.1:9002'
  }
}

//
// ...and then pass them in when you create your proxy.
//
var proxyServer = httpProxy.createServer(options).listen(80); 

However, I get an error when I do that. I think it's the older version of http-proxy. Can you do that now with the new api?
",Jonovono,2014-03-21 23:58:54
604,2014-03-21 23:50:42,"Please read #600 
",Rush,2014-03-21 23:58:54
604,2014-03-21 23:58:54,"Looks good, thanks. 
",Jonovono,2014-03-21 23:58:54
603,2014-03-21 11:36:29,"Hello,
My use-case is this: I have a proxy server running in Nodejs (created using httpProxy.createProxyServer. call it server#1). There is another proxy-server (squid-based. call it server#2) to which server#1 should proxy requests to.
So basically, clients will use my server#1 as proxy for their website calls. server#1 will in turn proxy request to server#2. server#2 will actually call the requested domain and send response back to client via server#1.

I could do this in node-http-proxy v0.x by:
var httpProxy = require('http-proxy')
var proxy = new httpProxy.RoutingProxy();
httpProxy.createServer( function (request, response, proxy) {
// blah blah
proxy.proxyRequest( request, response, { host : server#2_host, port: ... } );
});

How to achieve this in node-http-proxy 1.x is the question?
I expected this to work, but it doesn't:
var proxy = httpProxy.createProxyServer({target: {
    host: server#2_host,
    port: ...
}});
proxy.web(req, res);

Any pointers on how I can do this?
",2w1x2elz,2014-03-27 02:07:53
603,2014-03-25 12:53:02,"i figured out the problem. looks like a bug in v1.x.
https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/common.js#L47 line should be:
outgoing.path = req.url
instead of:
outgoing.path = url.parse(req.url).path

this is similar to what was there in v0.10.x
",2w1x2elz,2014-03-27 02:07:53
603,2014-03-25 14:20:05,"@KetanSpeaketh could you give me a gist that I can run that fails? in the specific case you listed with the new api there is no server running that would be able to receive requests in order to proxy appropriately. 

<S_CODE_TOKEN>

Both of these should work as expected, otherwise please elaborate on the issue you have.
",jcrugzz,2014-03-27 02:07:53
603,2014-03-26 18:43:54,"@jcrugzz - hey, thanks for responding.
please refer to https://gist.github.com/KetanSpeaketh/9790240 while i explain the situation. also, to run these snippets, start the node scripts, connect your browser to the internet via proxy (localhost:3010) and navigate to, say, www.amazon.com

gist#1: simple proxy. works as expected.
gist#2: i first connect to proxy on port 3010, which then routes my request to amazon via another proxy on port 9010. this should work, but doesn't. things work if i make the change suggested in my previous comment.
",2w1x2elz,2014-03-27 02:07:53
603,2014-03-26 23:59:10,"So this is actually interesting as it made me go back and read why this is in place. @KetanSpeaketh I recommend giving #529 a read. it seems that this is ONLY the case when you proxy to ANOTHER proxy. For this specific use case, I can add an option (something like `toProxy`) that when `truthy`, keeps the absolute URI instead of making it relative. How does that sound as a solution to this?
",jcrugzz,2014-03-27 02:07:53
603,2014-09-11 13:06:59,"Hi @jcrugzz,
I can't seem to get this right. I want to proxy all request made to `localhost:3000` to an api server `someserver.com:port`and this works fine from home. At my office, we have a corporate proxy which makes everything harder. I figure the toProxy attribute is what I want, but I cannot get it to work. This had happened for the ¬¥mikeal/request`library where the fix was to use

<S_CODE_TOKEN>

How would I configure your lib to do the same? The following gists show how this works from outside the corporate proxy and also how routing to local addresses works fine behind the proxy.
https://gist.github.com/avilaton/3b72861a75eb31fa6dd3
Any clues?
",avilaton,2014-03-27 02:07:53
603,2014-09-23 07:38:51,"@avilaton it looks like the `toProxy` option is broken in latest http-proxy. I've raised #703
",samcday,2014-03-27 02:07:53
602,2014-03-20 06:48:24,"Not sure why the CLI was removed, it may have been moved? Anyhow, I've published this fork as `j-http-proxy` as I just needed a simple CLI HTTP proxy
",jpillora,2014-09-27 15:09:13
602,2014-03-21 02:32:13,"Check this: https://github.com/cha0s/kiss-proxy
",cha0s,2014-09-27 15:09:13
602,2014-09-27 15:09:13,"I made a simple CLI called [`proxy-server`](https://github.com/jcrugzz/proxy-server)
",jcrugzz,2014-09-27 15:09:13
601,2014-03-20 02:39:38,,jpillora,2014-03-20 06:48:41
601,2014-03-20 06:48:41,"Opened PR #602
",jpillora,2014-03-20 06:48:41
600,2014-03-16 15:23:25,"Hi folks,
first of all, great job! I have migrated to the latest version (1.0.2) due to some issues with the old version and the web socket support. I have been search half of the day and finally have a functioning configuration: proxy with web socket support. It would really be helpful to find that somewhere in the documentation, as I believe that this is a pretty standard use case. Could you please have a look and check if this looks like what you have thought of when designing the API?

<S_CODE_TOKEN>

I do not know if/why I have to put the error callback to the proxy.ws method, but it does not work without. Any comments and feedback would be very much appreciated.
",deradam,2014-03-21 09:31:51
600,2014-03-21 02:31:51,"Check this: https://github.com/cha0s/kiss-proxy
",cha0s,2014-03-21 09:31:51
600,2014-03-21 08:56:26,"@cha0s looks quite interesting. Do you also support websockets? This is very crucial to me.
",deradam,2014-03-21 09:31:51
600,2014-03-21 09:31:51,"@cha0s okay I see it can handle websockets. I switched our configuration from the script above to kiss-proxy and it works like a charm! Thanks for the hint and the good work :+1: 
",deradam,2014-03-21 09:31:51
600,2014-03-21 11:41:47,"`kiss-proxy` is very nice but if you need more features like SSL (with SNI), listening on multiple ports, redirects etc. you may want to look up https://github.com/CodeCharmLtd/http-master
",Rush,2014-03-21 09:31:51
600,2014-03-21 19:11:54,"@RushPL thanks for the hint. I had a quick look and it really looks very powerful and feature rich. I really would like to see an overview of all these solutions with pros and cons. Currently I don't need SSL and the richer features, so kiss-proxy is just perfect for me. But I already recommended http-master to a colleague who will give it a try in the next days.
",deradam,2014-03-21 09:31:51
599,2014-03-13 11:48:43,"I have the following setup - a proxy and a server that provides a few websocket connections on different ports. When connecting to a websocket through the proxy the connection is much more unstable compared to connecting directly to the port in question (without proxying). 
Sample code:

<S_CODE_TOKEN>

Also I cannot find any reason for the websocket connection to close - it appears to me that it is closed at random - anywhere between 3 minutes to ~10 minutes. And again - when connecting to the websocket directly (no proxy) the connection lasts for much longer (waited about ~35 minutes before stopping the test)

EDIT: I am using pure websockets and not a library like socket.io
EDIT 2: The websocket is closed with status code 1006 (CLOSE_ABNORMAL)
",dininski,
598,2014-03-13 02:50:22,"Does this work with node _0.10.x_, I have the following code, but the server doesn't behave as expected.  It doesn't forward traffic to the IP/URL that I've specified.

<S_CODE_TOKEN>

I even tried changing the target to `google.com`, but it **still** didn't work.
",amagura,2014-03-24 02:59:56
598,2014-03-13 19:35:06,"Nevermind, go ahead and close this.  It was a false alarm.  Upon connecting to the server via `https://<URL>` it worked just fine, it just wasn't responding to HTTP requests.
",amagura,2014-03-24 02:59:56
597,2014-03-11 03:26:32,"Hi, 
After reading up on
   https://github.com/nodejitsu/node-http-proxy/issues/264
   https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/custom-proxy-error.js
currently the way i handle the proxyError event is as follows: 

<S_CODE_TOKEN>

Is there anything blatantly wrong with the above?   i am asking this because my program ran into the following error during a load test:

<S_CODE_TOKEN>

i believe the culprit is the following line:

<S_CODE_TOKEN>

The skeleton of my application is:

<S_CODE_TOKEN>

What is a good way to handle the proxyError event?

Thanks for reading.
",hseuming,
596,2014-03-04 10:08:05,"I have used your repo for a standard HTTP reverse proxy, and it works brilliantly (except a small issue with status codes), and I have been working on a HTTPS version.

I had to get code form another repo for SNI, and I have that successfully set up.

I can go to https://domain1.com:444 and https://domain2.com:444 and both will show the correct certificates, and the default certificates are set as domain1.com

This works brilliantly, and the correct certificate is always shown for the domain, but I cannot get the HTTPS script to use the new version of your API to proxy a request (proxy.web(req,res, {});)

Here is the server that currently proxies to a single target:

<S_CODE_TOKEN>

As said above, this server works halfway, but can only proxy to a single target, After googling, i have noticed you removed the router: {} options

I have tried setting up like this: (but with ssl settings) https://github.com/nodejitsu/node-http-proxy/issues/594

If I set it up like the example in the above issue, then the server wont even listen for connections, although no errors are thrown.

What would be the correct syntax to change to multiple targets from the code above ?
It looked so easy with the router options, I there any way of me botching some old code back in, to get the router options working again?

If not, is there a way I can pick the internal ip to proxy to, depending on the hostname used to access the proxy ?

Node.js has proved very very powerful, and it looks faster than a dedicated nginx reverse proxy !!

Thanks!
",djpimp2010,2015-02-17 17:47:58
596,2015-02-17 17:31:07,"Did you ever have any luck setting this up? I am trying to figure how to do SNI with node-http-proxy as well.
",lsvx,2015-02-17 17:47:58
596,2015-02-17 17:47:58,"@lsvx i believe this issue is around the old API usage. My recommendation here is to create a standard HTTPS server (which uses SNI callback) and create a separate `http-proxy` instance to proxy the requests within the handler.

<S_CODE_TOKEN>

 Please create a new issue if this does not work out for you as this issue itself is dated. Thanks!
",jcrugzz,2015-02-17 17:47:58
596,2015-02-18 00:47:53,"@jcrugzz,

Thanks for your example! I was able to get SNI working perfectly.
",lsvx,2015-02-17 17:47:58
596,2015-02-18 07:21:44,"@jcrugzz Minor and clever solution!
",lekojson,2015-02-17 17:47:58
595,2014-03-03 20:52:28,"I was noticing some unusual behavior on my proxy.

Lets say we have a line along the lines of:

<S_CODE_TOKEN>

And we have a simple http server that just outputs the request.url to console.log.

I've noticed this same string can have different effects on the server depending on the url requested of the proxy.

Here's an easy table
| user request | third argument | server sees |
| ---------------- | ------------------- | --------------- |
| /fb9e71fd7d2264699e50 | http://127.0.0.1:8085/belew/fb9e71fd7d2264699e50 | / /fb9e71fd7d2264699e50 |
| /belew /fb9e71fd7d2264699e50 | http://127.0.0.1:8085/belew/fb9e71fd7d2264699e50 | /belew /fb9e71fd7d2264699e50 |

As you can see we have the same value for the third argument but different effects on the server.  Is this the intended result?

The reason why this is relevant to the quality of the project is it's making it a little hard for me to create a mapping from belew.mysite.com -> 127.0.0.1:8085/belew because 127.0.0.1:8085 just keeps getting / instead of /belew
",jvonmitchell,
595,2014-08-17 21:45:42,"It seems to me as the path is actually ignored. So the question is, how can we proxy to a given path?
",manast,
595,2014-08-17 21:54:30,"Here there is a workaround: https://github.com/nodejitsu/node-http-proxy/pull/645
",manast,
594,2014-03-01 00:14:30,"I have installed your proxy from your git repo 2014-02-28.

I have set up some custom actions, but when I get the status code of the response, it is always 200, even when my backend apache/nginx servers return a 502/404/301 etc.

<S_CODE_TOKEN>

I also cannot get a valid referrer header, but thats not as important, and shouldnt really take over this issue.
",djpimp2010,
594,2014-03-01 02:50:14,"@djpimp2010 I have not seen this at all, could you please provide reproducible test case for this so we can get to the bottom of why this could be happening? Thanks! :)
",jcrugzz,
594,2014-03-01 14:29:05,"@jcrugzz 

Yes, of course... I have a basic node-js install, default locations...

Here is my code, I have the extra libraries 'node-mysql' , 'fs' and 'util' installed for custom actions:

<S_CODE_TOKEN>

This works perfectly, for HTTP connections (except status codes always being 200), although I cannot get it working for HTTPS (name based with SNI) - Thats a different problem!
",djpimp2010,
594,2014-03-01 14:38:27,"And just to save hassle, here is a cut down version that always proxies default IP, and a 404 on that request still logs 200...

<S_CODE_TOKEN>
",djpimp2010,
594,2014-08-28 19:29:58,"@jcrugzz 

We are running into this same issue. All requests return a 200 status code. 

Included an example below, we can print out the correct status code, however, writeHead doesn't appear to be actually sending the header.

<S_CODE_TOKEN>
",derekschultz,
594,2015-04-10 23:12:47,"We're seeing this problem using the `proxy` option of [Webpack Dev Server](http://webpack.github.io/docs/webpack-dev-server.html)
",mars,
594,2015-11-15 14:37:30,"Hello,
Have this issue been addressed? I am getting exactly the same problem which is totally blocking since actions or custom logic related to actual status codes cannot be implemented in the proxy.
",hatembr,
594,2015-11-25 11:45:13,"check the proxy response status code instead of res.statusCode;

`proxy.on('proxyRes', function(proxyRes, req, res) { 
console.log('status:' + proxyRes.statusCode); 
        res.status(proxyRes.status); 
});`
",PhilCorcoran,
594,2015-12-20 17:09:42,"That worked.
Thanks for your help.
",hatembr,
594,2016-06-17 14:06:38,"@mars - Did you figure out how to resolve this for the webpack dev server case? If so, can you provide your solution.
",nikhilbaradwaj,
594,2016-06-17 14:18:51,"This still looks like its a bug if it is still happening. Would definitely take a PR to fix this! 
",jcrugzz,
594,2016-06-17 14:27:25,"if anyone wants to tackle this, we should ensure that this function is getting called. https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L100-L102
",jcrugzz,
594,2016-06-17 19:29:52,"@jcrugzz - On further investigation, it does work as expected for me. The response status was set incorrectly on my server code, the proxy was just returning that incorrect status of 200. Sorry for the false alarm.
",nikhilbaradwaj,
593,2014-02-28 21:40:34,"I'm using http-proxy to implement a proxy/load balancer.
Each client-request is forwarded by node to a different (remote) server using the _.web_ method of the _http-proxy.createProxyServer()_ object.

It works properly, that is, I can forward the request to the remote servers and their response to the clients, **unless** one of these remote servers happens to reply a page with a status code _HTTP-301 (Moved permanently)_.

Pages having such status are passed to the _.on('error')_ event in _http-proxy_ (instead of the normal _.on('proxyRes')_) so they won't be forwarded to the client.

I'm tapping the _.on('error')_ handler to see if I can somehow forward the 301 page anyway, but I'm failling to find the original response sent by the remote server.
",pabalvar,
593,2014-05-16 17:12:27,"@pabalvar can you provide me with a reproducible test case so we can work from there? Thanks!
",jcrugzz,
592,2014-02-26 13:12:53,"Fix for proxy crash if `HOST` header is not defined bug https://github.com/nodejitsu/node-http-proxy/issues/591.
",SkeLLLa,2014-03-11 22:03:12
592,2014-03-11 21:58:28,"@SkeLLLa thanks for the contribution! 
",jcrugzz,2014-03-11 22:03:12
591,2014-02-26 12:04:07,"<S_CODE_TOKEN>
",SkeLLLa,
591,2014-03-11 14:22:15,"I'm experiencing the same thing
",CarsonF,
590,2014-02-22 23:03:16,"For my application I need fine-grained control over the ciphers used when establishing the TLS sockets underlying the outgoing HTTPS connection. This functionality is supported by the HTTPS client using the `ciphers` parameter:
http://nodejs.org/api/https.html#https_https_request_options_callback
However, I couldn't find a way to use the parameter in the backend of a proxy, hence this pull request.

While I was in there I thought I'd add all of the other optional HTTPS parameters, so this pull request also passes `pfx`, `key`, `passphrase`, `cert`, `ca` and `secureProtocol`.
",apcj,2014-12-17 17:12:07
590,2014-12-17 17:12:07,"@apcj cherry-picked, sorry this took so long
",jcrugzz,2014-12-17 17:12:07
589,2014-02-20 21:24:31,"I don't think this is really an issue, more of like... a how do I? I am trying to come up with a proxy by url solution so we can only have 1 external facing port open. Essentially I want the following to happen:

proxy:8000/dtolley-wsl proxies to an app running on dtolley-wsl.internal.com:1234
proxy:8000/someguys-wsl proxies to an app running on someguys-wsl.internal.com:1234

The problem I am having is when the initial proxy happens when I go to proxy:8000/dtolley-wsl in my browser, the page may load, but the links and all actions have the wrong host associated with them. The links and such go to proxy:8000 and NOT proxy:8000/dtolley-wsl like I need them to.

below is the code I have so far that isn't working 100% like I would like it to:

require('http').createServer(function(req, res) {
  req.url = '/';
  req.headers.host = 'proxy.com:8000/dtolley-wsl';
  var urlObj = url.parse(req.url);
  proxyServer.web(req, res, {
    target: {
      host: 'dtolley-wsl.internal.com',
      port: 1234,
      secure: false
    }
  },fail);
}).listen(8000);

any ideas?
",DavidTolley,
589,2014-03-12 06:14:58,"I am running into this same issue.
",stanleygu,
589,2014-03-12 17:21:45,"`node-http-proxy` does not control website's content so obviously you need to redo your website to have proper links
",Rush,
589,2014-03-12 21:41:58,"So what would one do in the situation where it wouldn't be feasible to change all the links of the proxied app/website?

For example, if there can be many routes that direct to multiple instances of an internal web app that is listening to different ports that are not open to the public:
foo.com/proxy/8000 -> localhost:8000
foo.com/proxy/8001 -> localhost:8001

Or, simply if we want to proxy to an external site that we don't have any control over, so we definitely can't rewrite any of the links:
foo.com/proxy/google -> http://google.com

Currently, I can't seem to get `node-http-proxy` to work in either case because all the links in the proxied pages will point relative to `foo.com` as the base URL, rather than foo.com/proxy/google. So for the google proxy example, none of the assets on the page will load correctly.

EDIT: Adding some sample code
Example 1

<S_CODE_TOKEN>

Example 2

<S_CODE_TOKEN>
",stanleygu,
588,2014-02-20 16:02:49,"Hello!
If I proxying some request from express, cookie values not encoded when sends further

<S_CODE_TOKEN>

So if cookie values contains, for example, russian characters, backend, for example jetty, gives such error:
`WARN  HttpParser - badMessage: 400 Illegal character for HttpChannelOverHttp@14a86899{r=0,a=IDLE,uri=-}`
",klimashkin,
587,2014-02-19 18:49:51,"every http event out there passes the req and response as arguments. Not having them as part of the proxyRes event cripples out chances of doing additional processing in an asynchronous environment.

Ref: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L120

Proposed enhancement:

<S_CODE_TOKEN>
",simoami,
587,2014-04-02 14:32:09,"We need this as well. We want to check the upstream server's response headers to see if it gzipped the response, then decode it before attempting to process the contents.
",scriby,
587,2014-04-11 18:34:32,":+1: 
",sandinmyjoints,
586,2014-02-19 12:07:22,"Apparenty, there is no (easy) way to set the read timeout for the outgoing leg when proxying http; access to the request object should be needed, but there is none

After some experimenting, I can see this request has the default 120 sec read timeout set by node.js

Is there any plan on that direction? I understand this is needed to implement proper support for HTTP 504 responses 
",pepmartinez,
586,2014-07-08 00:07:11,":+1: 
",samlecuyer,
586,2014-07-08 16:13:01,"@pepmartinez [`proxyTimeout`](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L112-L118) is an option that exists it is just very poorly documented. Would happily take a pull request :).
",jcrugzz,
586,2014-07-08 16:15:25,"@jcrugzz Just to clarify, the last commit message is ""Change name targetTimeout to proxyTimeout"", so the property is `proxyTimeout` right?
",samlecuyer,
586,2014-07-08 16:22:51,"@samlecuyer yes you are correct, editing that comment xD. Brain must not be in optimal form yet ;)
",jcrugzz,
585,2014-02-19 07:05:05,"I'm testing a proxy on a separate java app. The app has about 280 static resources (js, css and images) in non-production mode.

After a number of requests on a single page load, I start getting the EMFILE error, which typically indicates a resource leak, more precisely ""Too many open file descriptors"". 

Attached my code below.
1. Would provide any pointers on what could be the problem?
2. Do you have any recommendations on handling request and response objects to avoid  leaks?
3. Not sure if this is related, but can you explain why [proxyReq.end()](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L128) is commented out? Is it intentional? 

code contains only the relevant parts:

<S_CODE_TOKEN>

Thanks,
",simoami,2014-02-19 07:16:26
585,2014-02-19 07:16:26,"Sorry, just realized this is the same as #570. Using http.globalAgent as default agent solves the problem. Closing this issue as duplicate.
",simoami,2014-02-19 07:16:26
584,2014-02-19 06:21:05,"From the examples it is implied that the callback passed to proxy.web() may or may not have an error, meaning it will be called regardless.

The current behavior is that the CB will only be invoked in case of errors.

See ref. code: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L110
",simoami,
583,2014-02-11 21:02:06,"When we make outgoing requests, we may want to bind to a specific local
address. This change allows the localAddress property to be specified
via the options object.
",sberan,2014-03-27 02:33:00
582,2014-02-11 18:53:26,"This also required adjusting web-incoming to pass the options object to the web-outgoing passes.  One thing I noticed is that web-outgoing doesn't appear to be exposed to anyone that wants mutate it externally.

I think extensions of this nature would be better done via some well-defined API that allows me to mutate the passes on the proxy object.  But, as it stands that doesn't exist and is too much for me to just guess at what would be acceptable and try to fix.
",cheddar,
582,2014-04-14 13:10:34,"Why aren't web-outgoing passes exposed the way incoming passes are exposed, for before and after hooks?
",sandinmyjoints,
582,2014-12-19 16:09:01,"@cheddar could you rebase the PR and rename to outgoingHeaders? This seems reasonable, sorry it took so long
",jcrugzz,
582,2015-04-01 16:17:30,"Also as a note, headers can be modified in the `proxyRes` event
",jcrugzz,
581,2014-02-11 10:38:39,"<S_CODE_TOKEN>

when I print res.statusCode its always 200 , though the target don't exist. Why?

Please follow the thread on http://stackoverflow.com/questions/21725038/how-to-catch-404-errors-using-connect-framework
",NandishAndDev,
580,2014-02-11 08:53:36,"Hi,

Please answer the query on SO on http-proxy
http://stackoverflow.com/questions/21697051/how-to-get-response-object-in-a-nodejs-proxy-request
",NandishAndDev,2014-02-11 10:49:09
579,2014-02-09 22:41:57,"Hi,
I have a proxy (in http and https. both with web sockets) that is working but if the target application (also in node) is stopped, the proxy receives the following error and stops running:

events.js:72
        throw er; // Unhandled 'error' event
              ^
Error: read ECONNRESET
    at errnoException (net.js:901:11)
    at TCP.onread (net.js:556:19)

Can anyone please tell me how to overcome this?
I've added a handler to listen to 'error' events but the proxy is still terminated in the event of the target application is stopped.

Thanks!
Best regards,
Hugo
",HugoMag,
579,2014-02-09 22:45:37,"@HugoMag could you please gist a reproducible example of this behavior? If you are listening on the `error` handler, this should not happen. 
",jcrugzz,
579,2014-02-10 11:26:54,"Hi, 
I've created the  https://gist.github.com/HugoMag/8914225 with the behavior.
I've tried using the callback API or the Event Emitter API.

From what I've gathered this error happens only in Windows. In OS X is working fine.

Thanks!
Best regards,
Hugo
",HugoMag,
579,2014-02-25 02:42:12,"+1 too have such an issue on Windows, I'm listening to error it still happens.
maybe this related https://github.com/nodejitsu/node-http-proxy/pull/488
",whitecolor,
579,2014-02-25 04:36:54,"it seems that https://github.com/nodejitsu/node-http-proxy/pull/488 fixes the issue
",whitecolor,
579,2014-02-26 04:45:20,"+1 I can't get my app to stay up since upgrading to 1.x.x and I'm not able to catch it with the proxy error handler.

<S_CODE_TOKEN>
",baer,
579,2014-02-26 05:22:09,"@baer try to apply this fix https://github.com/nodejitsu/node-http-proxy/pull/488
",whitecolor,
579,2014-02-26 05:37:50,"That PR does appear to fix the issue. I have two environments exhibiting this problem just to throw some context into the conversation:

**Environment 1**
node: 0.10.24
node-http-proxy: 1.0.2
OSX

**Environment 2**
node: 0.10.24
node-http-proxy: 1.0.2
Windows with IIS-Node (Azure Deployment)

They are both proxying to a hitting an IIS (Windows) deployment 
",baer,
578,2014-02-07 21:51:23,"Seeing ""npm WARN package.json http-proxy@1.0.2 No repository field."" makes me anxious :anguished: 
This PR adds a repo field to the package.json, for others who feel the same.
",pivotal-topher-bullock,2014-02-11 04:47:47
578,2014-02-07 22:16:00,"@xtreme-topher-bullock thanks for the contribution! Would you mind changing it to look like...

<S_CODE_TOKEN>

After that I'll merge it right in :). It makes it display correctly on npmjs.org
",jcrugzz,2014-02-11 04:47:47
578,2014-02-10 15:08:24,"Updated! Also fixed the formatting to match the style of the rest of the file. :smile: 
",pivotal-topher-bullock,2014-02-11 04:47:47
578,2014-02-11 04:47:45,"@xtreme-topher-bullock thanks :)
",jcrugzz,2014-02-11 04:47:47
577,2014-02-07 16:43:06,"Hello,

I am using node-http-proxy to route websocket from port 80 to port 8080. I have a http server (port 80). I would like to create a websocket connection between the client and the server through the nodejs server. I use the following source code : 

<S_CODE_TOKEN>

But, the server only receives the handshake message and the connection closes (eof). I tested with apache and proxy_mod, the server works fine.

Any idea ?

Thank you very much.
",rere16,
577,2014-02-07 18:20:43,"@rere16 you also have to proxy the web requests in the `proxyServer` as websockets is initialized by a couple POST requests iirc
",jcrugzz,
577,2014-02-08 09:14:38,"Thank you very much for your answer. But, I have no idea how to do this. Please, could you give me a short example ?

Thanks
",rere16,
577,2014-02-09 21:01:40,"@rere16 well lets start with why do you want to proxy the websocket connection to another server when you already have an http server that you can then attach the websocket server to as well?
",jcrugzz,
577,2014-02-09 21:40:35,"Because I developed an application using websocket (port 8080) and I would like that this application communicates with the client through the webserver (port 80). By proxing, only the port 80 is open. The port 8080 is local. (The webserver and the application is on the same machine)
",rere16,
577,2014-02-09 22:43:03,"@rere16 ahh ok, I guess my argument is why are they two separate applications? The tricky part here is that you will have to custom proxy based on the particular requests that initialize the websocket connection. 
",jcrugzz,
577,2014-02-12 19:45:51,"There are two applications because one is an application written in C++ using websocket and the other is the webserver (nodejs). I just want to redirect the websocket stream between the client and the application (no cache). It's a routing proxy feature.

For example with apache (port 80)

Location /ws
ProxyPass ws://127.0.0.1:8080
ProxyPassReverse ws://127.0.0.1:8080
Location

The request ws://127.0.0.1:80/ws will be redirect to ws://127.0.0.1:8080/ws.

Thx
",rere16,
577,2014-07-29 14:42:17,"@rere16 I am also in this situation. I have websocket server written in c++ and generating some data and I want to use node-http-proxy.
 I am wondering whether you are able to find the solution for this or not. 

Please let me know if you did this already
Thanks
",gara-MI,
577,2014-07-29 14:44:33,"Did some one find the solution for this problem?
",gara-MI,
577,2015-01-30 20:31:30,"+1
",glortho,
577,2015-02-11 17:18:48,"The javascript source code in my first message works. I had an issue in my C++ program.
",rere16,
576,2014-02-07 15:38:05,"I have an application that uses websockets via socket.io. For my application I would like to use a separate HTTP server for serving the static content and JavaScript for my application. Therefore, I need to put a proxy in place.

I am using node-http-proxy As a starting point I have my websockets app running on port 8081. I am using the following code to re-direct socket.io communications to this standalone server, while using express to serve the static content:

<S_CODE_TOKEN>

The above application works just fine, however, I can see that socket.io is no longer using websockets, it is instead falling back to XHR polling.

I can confirm that by looking at the logs from the proxy code:

<S_CODE_TOKEN>

Does anyone know how to proxy the web sockets communication? All the examples from `node-http-proxy` assume that you want to proxy all traffic, rather than proxying some and serving others.
",ColinEberhardt,2014-02-22 02:55:21
576,2014-02-07 18:23:04,"@ColinEberhardt try forcing a websocket connection in the `socket.io` config. If the `upgrade` event is not being called, that has to do with the library not initializing the handshake. 
",jcrugzz,2014-02-22 02:55:21
576,2014-02-13 11:50:36,"@jcrugzz thanks for your comment, although I can see that the upgrade event is being sent from the browser. Without the proxy in place, the upgrade event occurs and the protocol switches to websockets:

![websocketssuccess](https://f.cloud.github.com/assets/1098110/2159398/7c02613e-94a4-11e3-8312-da13d24ca05c.PNG)

With the proxy code above, the upgrade request is sent, but there is no response, so after ~5 seconds socket.io falls back to XHR polling:

![image](https://f.cloud.github.com/assets/1098110/2159397/6ec64a08-94a4-11e3-8725-c935c642f333.png)

I have tried forcing socket.io to just use websockets:

<S_CODE_TOKEN>

But as you can probably guess, it just hangs on the upgrade request
",ColinEberhardt,2014-02-22 02:55:21
576,2014-02-19 04:22:16,"Instead of using express, you should try listening for the upgrade event with a regular HTTP server. You might find the gist I made that covers routing and websockets helpful. https://gist.github.com/richardkazuomiller/9085758
",richardkazuomiller,2014-02-22 02:55:21
576,2014-02-19 04:33:39,"@ColinEberhardt yes what @richardkazuomiller said. I totally missed that previously. You should be using a regular `var server = http.createServer(app); server.listen(8080);` where the `app` is your same express `app` but you now have a proper server to listen for an upgrade request. Everything else should be able to stay the same.
",jcrugzz,2014-02-22 02:55:21
576,2014-02-19 05:28:22,"@jcrugzz It might be helpful to include something about the upgrade event in the documentation. I, like a lot of people, use Express for my web stuff and Socket.io or SockJS for my websocket stuff so I'm not very used to working directly with the HTTP servers and I had to do a bit of digging to figure it out. I just found that you include that in UPGRADING.md but I missed that because I says in the readme ""Looking to Upgrade from 0.8.x?"" and I was upgrading from 0.1.1 or something like that. People who are using it for the first time are probably going to miss that too.
",richardkazuomiller,2014-02-22 02:55:21
576,2014-02-19 06:53:36,"... I just stupidly deleted the Gist by accident so I recreated it here https://gist.github.com/richardkazuomiller/9087254 so sorry lol.
",richardkazuomiller,2014-02-22 02:55:21
576,2014-02-20 10:01:18,"@richardkazuomiller thank you **very** much, that works just perfectly. 
",ColinEberhardt,2014-02-22 02:55:21
576,2014-02-22 02:55:21,"@richardkazuomiller this sounds like an awesome idea, would definitely take a pull request :)
",jcrugzz,2014-02-22 02:55:21
575,2014-02-05 14:04:08,"Update option lines
",ozh,2014-02-05 14:42:51
575,2014-02-05 14:42:55,"Thanks!
",jcrugzz,2014-02-05 14:42:51
574,2014-02-05 10:35:45,"Hi, I have been trying to use the [ProxyTable API](https://blog.nodejitsu.com/node-http-proxy-1dot0/) example on one of my servers (Node v0.10.25). I have added some error handling to the example.

<S_CODE_TOKEN>

If I go to foo.com or www.foo.com, I'll get the following error:

<S_CODE_TOKEN>

Also noticed that if I go to a host name that isn't in my options list, the app crashes, and I get this error:

<S_CODE_TOKEN>

I've noticed some previous discussion on adding `target: {protocol: 'http'}` to options, but this doesn't work for me. Not sure if these are bugs, or just a lack of understanding on my part. Any help grately appreciated?

Also wondered if you can use Wild cards (*) to catch hostnames in the new API?
",noducks,2014-02-05 11:39:10
574,2014-02-05 11:37:15,"Changing the options to include `http://` fixes my first error. 

<S_CODE_TOKEN>
",noducks,2014-02-05 11:39:10
574,2014-08-14 14:45:36,"Thanks for this post, I'm having the same problem, the routing crashes when it gets a request for any other address (subdomain for example). :(
",EskelCz,2014-02-05 11:39:10
574,2014-08-14 15:24:03,"@EskelCz post the example in a new issue if it is not solved by using a FULL url as a proxy target. If its crashing the host header is probably not what you expect it to be.
",jcrugzz,2014-02-05 11:39:10
574,2014-08-14 15:44:09,"@jcrugzz Thanks for a quick reply! Here: https://github.com/nodejitsu/node-http-proxy/issues/678
",EskelCz,2014-02-05 11:39:10
573,2014-02-03 20:22:38,"This is an alternative fix for #570 (see my other pr #572).

The idea here is that if no agent is specified, we explicitly set keepAlive to false.

If keepAlive is true, then every time we proxy a request we will create a new connection (because there is no agent managing a pool of connections), but with keepAlive set, node.js will not kill the connection after we make a request.  The connection will stay open (potentially for several minutes) eating up a file descriptor.

With keepAlive set false, node.js will close the connection for us after the request is made, cleaning up the resources immediately.  Under heavy load, this will result in far more connections than in PR #572, but may or may not result in better performance overall.  When heavy load clears, however, the connection count will drop back down immediately.

Note that, with or without this fix, connections are not being reused - all this does is clean up connections after we're done with them.  Also not that in node v0.11.11, this option is [implicitly set for us](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/_http_agent.js#L293) when node [assigns us an agent](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/_http_agent.js#L297).
",jwalton,2014-03-27 02:09:23
573,2014-02-03 20:24:10,"You would also need extremely high load to actually run out of FDs.  I can hold down CTRL-R in my browser and constantly load a 404 page, and it climbs up into the ~170 range on my mac, but this is a far cry from the 10K range it will get to without this fix.
",jwalton,2014-03-27 02:09:23
573,2014-02-07 22:27:55,"@jwalton This is something I can jive with. We haven't seen issues with this currently but it does make sense as we need to tell the operating system in SOME WAY to close the FD. Have you been able to test that this still works appropriately with `0.11.x`? I cannot see why not, I'd just like to be sure :). Thanks for the contributions!
",jcrugzz,2014-03-27 02:09:23
573,2014-02-07 23:13:00,"I can't say for sure that I did try it, so I'll try it again to be extra
sure.  :)

-Jason
On Feb 7, 2014 5:28 PM, ""Jarrett Cruger"" notifications@github.com wrote:

> @jwalton https://github.com/jwalton This is something I can jive with.
> We haven't seen issues with this currently but it does make sense as we
> need to tell the operating system in SOME WAY to close the FD. Have you
> been able to test that this still works appropriately with 0.11.x? I
> cannot see why not, I'd just like to be sure :). Thanks for the
> contributions!
> 
> ## 
> 
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/pull/573#issuecomment-34514464
> .
",jwalton,2014-03-27 02:09:23
573,2014-02-08 00:31:43,"Arg.  Tonight I'm seeing this problem happen in node 0.10 and node 0.11,
both with and without my fix.  :(  This'll have to wait until Monday I'm
afraid.

On Fri, Feb 7, 2014 at 6:12 PM, Jason Walton jason@thedreaming.org wrote:

> I can't say for sure that I did try it, so I'll try it again to be extra
> sure.  :)
> 
> -Jason
> On Feb 7, 2014 5:28 PM, ""Jarrett Cruger"" notifications@github.com wrote:
> 
> > @jwalton https://github.com/jwalton This is something I can jive with.
> > We haven't seen issues with this currently but it does make sense as we
> > need to tell the operating system in SOME WAY to close the FD. Have you
> > been able to test that this still works appropriately with 0.11.x? I
> > cannot see why not, I'd just like to be sure :). Thanks for the
> > contributions!
> > 
> > ## 
> > 
> > Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/pull/573#issuecomment-34514464
> > .
",jwalton,2014-03-27 02:09:23
573,2014-02-11 04:54:03,"@jwalton Looks like we should be fine in [`0.10.25`](https://github.com/joyent/node/blob/v0.10.25-release/lib/http.js#L1404-L1433). 
",jcrugzz,2014-03-27 02:09:23
573,2014-03-27 02:09:23,"fixes in 89a22bc00396f069eeb054ce30891a204077d16d
",jcrugzz,2014-03-27 02:09:23
572,2014-02-03 17:04:40,"Make it so we default to [`http.globalAgent`](http://nodejs.org/api/http.html#http_http_globalagent) as the agent if no agent is explicitly specified.  This is the agent that HTTP requests use by default when no agent is specified, so this is more in keeping with the http module, and it also fixes #570.  :)

`globalAgent` was introduced way back in [node 0.5.3](http://nodejs.org/docs/v0.5.3/api/http.html#http.globalAgent), so this should be a reasonably safe change as far as compatibility goes.
",jwalton,2014-02-03 20:05:18
572,2014-02-03 17:07:26,"I think it is not safe at all. Using agent may severely degrade performance. And no agent works well on Node 0.11.x.
",Rush,2014-02-03 20:05:18
572,2014-02-03 17:16:03,"As things stand, in node 0.10.x, using no agent will cause you to run out of file handles under heavy load, which will absolutely degrade performance.  :P

If node 0.11 isn't recycling connections, it's performance is likely going to be worse than not using an Agent.  If they are recycling connections, they're probably using http.globalAgent anyways.
",jwalton,2014-02-03 20:05:18
572,2014-02-03 18:17:14,"node-http-proxy is [calling `http.request()`](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L95) to proxy connections.  In node 0.10.25, this [creates a new ClientRequest](https://github.com/joyent/node/blob/b7fd6bc899ccb629d790c47aee06aba87e535c41/lib/http.js#L1834).  In node 0.11.11, [http.request](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/http.js#L51) calls into [`globalAgent.request()`](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/http.js#L51).  If you pass in `false` as the agent, then `globalAgent.request()` will [modify your options and assign you a new agent](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/_http_agent.js#L297) for each request, however the new agent will [turn off keep-alive](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/_http_agent.js#L293).  That's why it works in 0.11.
",jwalton,2014-02-03 20:05:18
572,2014-02-03 20:05:18,"@jwalton if you plan to receive heavy load, you should be specifying an agent with a large amount of sockets (enough where you wont run into the case where you run out of file handles). Regardless, if you get to this point, it is an indicator you should probably scale to multiple servers. At nodejitsu we use an agent for our load balancers and specify around `320,000` for `maxSockets` in the agent. 

One thing we cannot assume here is that it will be an `http` agent and the reason the default is set to false is because we do not want people just getting started to hit the caveat of having a default socket pool of 5. The `agent: false` covers the widest range of use cases and we will be in the proper situation when `node 0.12.x` hits.
",jcrugzz,2014-02-03 20:05:18
572,2014-02-03 20:39:00,"@jcrugzz Well, allow me to define ""heavy load"".  On OS/X Mavericks, http-proxy will currently stop processing new requests after two minutes if you exceed a sustained 2 requests/second, assuming you haven't bumped up your max file handle count.  :P
",jwalton,2014-02-03 20:05:18
572,2014-02-03 20:43:07,"On a Linux machine, assuming you have no user-level limits imposed by your host, assuming your system-wide file handle limit is 75K (this is distro dependent), and assuming the service you are proxying to is not on the same machine, then http-proxy can sustain ~625 connections/second for two minutes.  At this point, the Kernel will be unable to open new files.  You won't be able to SSH into the machine.  If you are SSHed in, you won't be able to run commands like ""ls"" because the shell won't be able to stat ls, ls won't be able to stat any of the libraries it needs to load to run, and even if it could it wouldn't be able to read the directory you're currently in.
",jwalton,2014-02-03 20:05:18
571,2014-02-02 07:21:06,"Where has the documentation on using a table gone?

e.g. where you set up an `options` variable that contains a `router` property listing all the domains and where they route to, then call `httpProxy.createServer(options)`? 
",trusktr,
571,2014-02-02 17:40:37,"Proxy table has been removed and the authors of node-http-proxy encourage developing third party solutions. One third party solution is for example https://github.com/CodeCharmLtd/http-master

If the above is too much, you may roll out a custom solution really quickly as shown in the below blog post.
https://blog.nodejitsu.com/node-http-proxy-1dot0/
",Rush,
571,2014-02-08 05:09:48,"Cool. It'll be easy to rewrite mine like the example in the link you posted (https://blog.nodejitsu.com/node-http-proxy-1dot0/). Thanks!
",trusktr,
571,2014-02-08 05:11:24,"I'd suggest adding the example at https://blog.nodejitsu.com/node-http-proxy-1dot0/ to the documentation here on github. It'd be super convenient to have it there for others.
",trusktr,
571,2014-02-08 05:13:55,"@yawnt Could you add the example from https://blog.nodejitsu.com/node-http-proxy-1dot0/ to the documentation to help users who will miss the ProxyTable API?
",trusktr,
571,2014-02-08 05:15:12,"@trusktr pull requests accepted :)
",jcrugzz,
571,2014-02-08 09:36:46,"@jcrugzz mmmmm. good opportunity... will try to make one.
",trusktr,
571,2014-03-10 18:28:44,"I am running into the issue here where the old proxy table functionality can't be reproduced.

Say I want to mount two services on different paths on the same domain:

<S_CODE_TOKEN>

When I run the proxy:

<S_CODE_TOKEN>

The request gets through, but all the relative links on the proxied page will point to `/lib.js` instead of `/bar1/lib.js`. Am I missing something here?
",stanleygu,
571,2014-03-21 02:33:27,"I made a very simple CLI reminiscent of the old one: https://github.com/cha0s/kiss-proxy
",cha0s,
571,2014-05-14 21:38:13,"I'm still using http-proxy 0.10.2 as I don't see any advantage in upgrading only to lose my router table, and I haven't had time to consider trying http-master like originally suggested.

Do you guys know if there are any security issues that would warrant an upgrade?
",trusktr,
571,2014-05-15 02:54:19,"@trusktr ive been meaning to write an external routing table module but havent had the time. And the advantage is being able to take advantage of node `0.10.x` and above where there is built in buffering to streams so they are easier to deal with. But if you are comfortable with `0.8.x` that is your choice.
",jcrugzz,
570,2014-01-31 20:58:16,"Run this:

<S_CODE_TOKEN>
- `ps -ef | grep node` to figure out the PID that's running it.
- `watch 'lsof -p 5966 | wc -l'` (replace 5966 with your pid)
- Point a browser at http://localhost:9000 (you'll get a 404 from example.com).  I was using Chrome and FF.
- Hit CTRL-R over and over.
- Watch your open file count climb.

Sockets don't seem to close for 2 minutes.  On OS/X, heavy traffic will run out of file descriptors very quickly (my product's Selenium test case kills node-http-proxy about 1/10th of the way through.)

Using node v0.10.25 and node-http-proxy 1.0.2.
",jwalton,2014-03-27 05:45:53
570,2014-01-31 21:10:16,"Note this doesn't seem to happen in 1.0.1.
",jwalton,2014-03-27 05:45:53
570,2014-01-31 21:18:16,"@jwalton wow really? the changes between `1.0.1` and `1.0.2` don't touch the web proxy implementation. Are you positive this doesn't happen with `1.0.1`? Ill do some testing myself
",jcrugzz,2014-03-27 05:45:53
570,2014-01-31 21:18:20,"Er... This exact scenario doesn't happen in 1.0.1.  But, in my non-trivial version of this, where I also use webservice proxying, I see this number climb.  My Selenium test suite still fails going through 1.0.1.  :P
",jwalton,2014-03-27 05:45:53
570,2014-01-31 21:19:09,"Yeah, I'm just looking at the 1.0.1 vs 1.0.2 compare view, and there's nothing that could account for this.  :/
",jwalton,2014-03-27 05:45:53
570,2014-01-31 21:27:34,"My coworker @goffrie discovered that this seems to fix things:

<S_CODE_TOKEN>

Setting `connection = 'Close'` means the back-end server is going to close the connection right after we make a request, which suggests this problem has to do with not reusing backend connections.
",jwalton,2014-03-27 05:45:53
570,2014-01-31 21:31:56,"Yeah - so it looks like the proxy server ends up making a ton of keep-alive connections to the backend server, each of which is used for only one request (and then kept alive for 2 minutes). 
",goffrie,2014-03-27 05:45:53
570,2014-01-31 21:37:33,"Does it happen with node 0.11.10 as well?
",Rush,2014-03-27 05:45:53
570,2014-01-31 21:48:13,"Isn't this #488?

Last I checked, if you don't set an `agent:` explicitly when using http-proxy 1.x, it will default to `agent: false` and leak.

I apologize for not having found the time to improve my original PR.  We worked around this in my project by always using an explicit agent (which made sense for us for other reasons), but this leaves the default behavior as broken.
",glasser,2014-03-27 05:45:53
570,2014-01-31 22:23:10,"I honestly think this is `http` being broken in `0.10.x` without using an agent. This is one of the reasons `http` was a big focus for `0.12.x`. I would either use an agent with a larger amount of sockets (since default is 5 and thats why this defaults to `false`) or use that workaround until it is fixed in `0.12.x`. I believe in #488 this was confirmed to be a bug in node core that was fixed in `0.11.x`. Closing the connection when we do not have an agent would not be the correct default behavior either so we just can't win in this situation currently.
",jcrugzz,2014-03-27 05:45:53
570,2014-02-03 16:59:25,"You are correct, sir.  This does seem to work on 0.11.x, and this:

<S_CODE_TOKEN>

fixes the example above.
",jwalton,2014-03-27 05:45:53
570,2014-02-03 18:18:03,"Copying this here from PR #572: node-http-proxy is [calling `http.request()`](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L95) to proxy connections.  In node 0.10.25, this [creates a new ClientRequest](https://github.com/joyent/node/blob/b7fd6bc899ccb629d790c47aee06aba87e535c41/lib/http.js#L1834).  In node 0.11.11, [http.request](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/http.js#L51) calls into [`globalAgent.request()`](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/http.js#L51).  If you pass in `false` as the agent, then `globalAgent.request()` will [modify your options and assign you a new agent](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/_http_agent.js#L297) for each request, however the new agent will [turn off keep-alive](https://github.com/joyent/node/blob/b46e77421581ea358e221a8a843d057c747f7e90/lib/_http_agent.js#L293).  That's why it works in 0.11.
",jwalton,2014-03-27 05:45:53
570,2014-02-10 09:19:15,"I've fun into this issue myself, using node 0.10.25 and http-proxy 1.0.2. I'm using the workaround in which one sets request.headers.connection to ""Close"", rather than setting an agent for the proxy. Is that the best workaround for now?
",sebjameswml,2014-03-27 05:45:53
570,2014-02-13 10:17:12,"Running into same issue here. And fix/workaround confirmed: setting the agent makes the issue disappear! Thanks.
",Reggino,2014-03-27 05:45:53
570,2014-02-19 07:20:09,"Just wanted to confirm that the globalAgent fix works here as well.

In my  case I used:

<S_CODE_TOKEN>
",simoami,2014-03-27 05:45:53
570,2014-03-27 05:45:53,"fixed in `1.0.3`
",jcrugzz,2014-03-27 05:45:53
569,2014-01-31 02:34:53,"This may not be an issue, save for the fact that I couldn't find anything about this in the documentation.

I'm attempting to use the Ghost blogging platform (v0.4) in a subdirectory with another Node/Express app.  I was able to get it working by using node-http-proxy as described here: http://stackoverflow.com/questions/20431697/node-http-proxy-and-express

However, when I go to the ghost/signin/ page and try to login, it returns the a 404.

If I go directly to port 2368, then I can login just fine, just not over the proxy.  I believe this may have to do with the fact that it's a POST request instead of a GET request, but I'm not sure.  Is there something special that needs to be done to proxy POST requests?

Thanks!
",lobo78,
569,2014-04-03 09:42:33,"This might help you https://github.com/nodejitsu/node-http-proxy/issues/180#issuecomment-12244852
",zigomir,
569,2014-04-03 18:35:28,"@lobo78 that api is no longer valid. Please check the new docs and let me know if you have any questions :).
",jcrugzz,
568,2014-01-30 16:55:04,"How would I go about setting up a reverse proxy such that the node-http-proxy is the only process that can connect to the server that is being proxied to?

For example:
If I have the proxy running on 8080 and my server running on 8081
I want to ban people from connecting to 8081 directly. If have an insecure network and I can not modify the firewall rules, is it possible to do this with SSL or any other configuration?
",srossross,2014-01-30 17:44:16
568,2014-01-30 17:00:27,"If your reverse proxy runs on the same server you should bind to the local IP only on your application: http://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback
`server.listen(3000, '127.0.0.1')`
Otherwise your application may detect if the request was done by a proxy via header `x-forwarder-for` and cross-checking that with origin ip would allow you to be relative sure where the request comes from.
",Rush,2014-01-30 17:44:16
568,2014-01-30 17:44:16,"@RushPL thanks that works for now.  If anyone else has an encrypted solution that would be great, thanks. Perhaps there is a way to do this with a self signed cert?
",srossross,2014-01-30 17:44:16
568,2014-01-30 17:46:45,"Glad it helped. Frankly, I do not see a point in using encryption here. You are connecting on local sockets so nobody (except admin) could be listening in. 
",Rush,2014-01-30 17:44:16
568,2014-01-30 17:50:25,"I have a situation where users could login to the network via ssh.  They are typically trusted users, but I would prefer to secure the connection.
",srossross,2014-01-30 17:44:16
568,2014-01-30 23:46:18,"@srossross You should be able to proxy https -> https if there is a need. if this is not exposed or documented well I'll look into clarifying that
",jcrugzz,2014-01-30 17:44:16
568,2014-01-31 00:26:33,"@srossross to clarify, please checkout my answer in #563 
",jcrugzz,2014-01-30 17:44:16
567,2014-01-29 14:33:00,"I'm trying to reverse proxy three localhost ports to a single localhost port. I keep getting the error:

`{ [Error: connect EMFILE] code: 'EMFILE', errno: 'EMFILE', syscall: 'connect' }`

After about ~100 serves. I can connect directly to the servers without issue for thousands of serves and nginx works well using the same reverse proxy.

Here is my code:

<S_CODE_TOKEN>

I have also asked about the same issue in this [Stackoverflow question](http://stackoverflow.com/questions/21409199/error-connect-emfile-and-node-http-proxy). EMFILE issues seem to be around issues with maxfiles, but it given that I can run everything without the proxy with no issues, it seems like node-http-proxy not closing something?
",stockholmux,2014-01-30 23:49:55
567,2014-01-29 14:39:17,"I would suggest running node 0.11.10, there have been some fixes in the unstable branch regarding such problems.  See also #488 and discussion regarding http agent. Personally I do not want the agent and I am running node 0.11 with good results.
",Rush,2014-01-30 23:49:55
567,2014-01-29 15:15:57,"Interesting. I'm not sure unstable is an option for me at the moment. I'm running Node v0.10.25 (latest stable) and definitely has the issue described (as did the earlier version v0.10 that I upgraded from). 
",stockholmux,2014-01-30 23:49:55
567,2014-01-30 23:49:14,"@stockholmux this probably has to do with your machine's `ulimit` which handles the number of file descriptors your computer will allow you to open. Make that `infinity` or a larger number and you should be fine. you can see how we set this for most of our production machines [here](https://github.com/opsmezzo/composer-systems/blob/master/base/smartos-base/files/limits)
",jcrugzz,2014-01-30 23:49:55
567,2014-01-30 23:49:55,"Closing as this is not an issue with `http-proxy` :).
",jcrugzz,2014-01-30 23:49:55
567,2014-02-05 15:38:22,"Am I wrong in thinking there is a leak here? ""-n   The maximum number of open file descriptors. "" implies to me that this is a limit on the amount of open handlers at one time. The fact that this limit can be breached with light usage makes me think http-proxy fails to close (some of) its handles correctly, and thus has an ever increasing number of open file descriptors. So while raising the limit will almost certainly solve the problem (at least temporarily) it seems like an ugly hack to me. What happens if traffic increases significantly, will the new limit be reached after a few months?
",martijnve,2014-01-30 23:49:55
566,2014-01-28 13:52:05,"Syntax error correction
",septs,2014-01-28 13:54:27
565,2014-01-24 22:18:18,"This error messaging is a bit confusing. You don't know where in your application it originated and it dumps the whole error object instead of the string message and backtrace. Since this event is exposed the user can subscribe herself to it.
",geigerzaehler,2014-01-28 17:33:18
565,2014-01-28 17:33:18,"Yea we should replicate the behavior of node core and throw an error if there are no error listeners since `EventEmitter3` does not do this natively. Forces correct behavior :).

This is fixed in daad4703f3a80014936c89f4d67affdc3246f478
",jcrugzz,2014-01-28 17:33:18
564,2014-01-24 00:57:10,"How do i covert this 0.10 API code

<S_CODE_TOKEN>

to the new 1.0 API

UPDATE:
Also if possible how do i force redirect from www.example.com to example.com ... and is this the right place to do it?
",purepear,2014-01-28 16:58:23
564,2014-01-24 14:52:18,"+1, wondering where the router options have gone
",valette,2014-01-28 16:58:23
564,2014-01-27 19:15:27,"+1, the wiki said to use httpProxy.RoutingProxy, but that is undefined now.
",prashn64,2014-01-28 16:58:23
564,2014-01-28 16:58:23,"Hey guys, checkout the ProxyTable API example in our [blogpost](https://blog.nodejitsu.com/node-http-proxy-1dot0/). This should be what you are looking for :). The api is much simpler now but that makes it way more powerful!
",jcrugzz,2014-01-28 16:58:23
564,2014-01-28 23:44:06,"Thanks @jcrugzz 
The post answers my questions perfectly
:)
",purepear,2014-01-28 16:58:23
563,2014-01-24 00:21:24,"The `ssl` option is used (in `listen`) to mean ""create an HTTPS server, using this as its constructor arguments"".  OK, that makes sense.

But... it also is used in the argument to `common.setupOutgoing` the three times it is called?  Which is constructing a request to use as a client?  What are the expected options that are valid _both_ as constructor options to `https.Server` _and_ as options to `https.request`?  (Or for that matter to `http.request`, which could also be called there...)
",glasser,
563,2014-01-31 00:23:37,"@glasser see [here](http://nodejs.org/api/https.html#https_https_request_options_callback) and scroll to the options that are passed in. A request can take the same options as the server but thats assuming the same cert is used for making the request (when as i think about it may be a false assumption but IMO whoever is creating an `https` server and `https` proxy should be doing them separately).

I think the main use case is not using the `options.ssl` in for the listen function (which is not called when you are just using it as a proxy), but exactly where you noticed it in `common.setupOutgoing`. This allows us to correctly make `https` requests using those same options. This also works with self signed certs if we pass in a custom agent. In this case you just need to set maxSockets to a reasonably high number so you aren't blocked by socket pooling 5 sockets as per default. 

I hope this covers everything, let me know if you have any questions!
",jcrugzz,
563,2014-01-31 16:41:53,"Well, at the very least, the README should probably say something more than ""object to be passed to https.createServer()"" especially if you're not considering that as the main use case?
",glasser,
563,2014-01-31 18:27:55,"@glasser agreed, it should clarify that this is used for client proxying as well, IF you define an agent.
",jcrugzz,
562,2014-01-23 09:52:13,"if we have some targets:
{ target: 'ws://localhost:3001', ws: true },
{ target: 'ws://localhost:3002', ws: true },
{ target: 'ws://localhost:3003', ws: true },

On server error: (for example if some target servers not exist)

TypeError: Object  has no method 'emit'
    at ClientRequest.onError (./node_modules/http-proxy/lib/http-proxy/passes/ws-incoming.js:115:16)
    at ClientRequest.EventEmitter.emit (events.js:95:17)
    at Socket.socketErrorListener (http.js:1547:9)
    at Socket.EventEmitter.emit (events.js:95:17)
    at net.js:441:14
    at process._tickCallback (node.js:415:13)

on line 115 - 'server' argument is a Buffer object, and they have not method emit...
I'm fix this problem somthing like this:

server.emit('error', err, req, socket);

modify to:

socket.server.emit('error', err, req, socket);

---

But it's a some bug.. Why the Buffer is named 'server'?)
",llevkin,2014-01-28 19:26:26
562,2014-01-23 13:23:37,"Hi, can you provide an example code that reproduces the issue?
",yawnt,2014-01-28 19:26:26
562,2014-01-23 13:29:33,"var proxyServer = require('http').createServer();
var proxy       = require('http-proxy').createServer();
var targets     = [
    { target: 'ws://localhost:3001', ws: true },
    { target: 'ws://localhost:3002', ws: true },
    { target: 'ws://localhost:3003', ws: true },
];
var target;
proxyServer.on('upgrade', function (req, socket, head) {
    target = targets.shift();
    proxy.ws(req, socket, head, target);
    targets.push(target);
});
proxyServer.on('error', function(error) { console.error(error); arguments[1].socket.destroy(); });
proxyServer.listen(3000);

run server instance only on 'ws://localhost:3001'..
",llevkin,2014-01-28 19:26:26
562,2014-01-28 19:26:26,"fixed in 0b223abb65286e0844627c2791e98dc884dadf10
",jcrugzz,2014-01-28 19:26:26
561,2014-01-22 23:43:05,"Note that this includes #560.
",glasser,2014-01-28 19:23:17
561,2014-01-23 18:16:07,"@glasser besides my comment, LGTM. Good find!
",jcrugzz,2014-01-28 19:23:17
561,2014-01-23 18:21:41,"Ok, in that case it probably shouldn't be called onOutgoingError. What should the event's args be? Right now the error event always gets the incoming socket as an arg even though the error is on the outgoing one. Should there be some way for the event to indicate which socket had the error?
",glasser,2014-01-28 19:23:17
561,2014-01-23 18:39:23,"@glasser Well lets think of what we can do in these failure cases. Correct me if I'm wrong here, but in the case where the `socket` errors, we cannot re-proxy with that same socket. So it would make sense to have a different error function in that case that just returns the request if thats even useful? Cause it seems the connection is just FUBAR if we hit that case and we just need to kill the things and let someone know. So I'm thinking we may even want to destroy the socket when the socket errors as well if my assumption here is correct

thoughts @yawnt?
",jcrugzz,2014-01-28 19:23:17
561,2014-01-23 18:56:41,"I don't think it is necessary to `destroy` a socket that has emitted `error`, from my limited understanding of how `Socket` works.  Look in Node's `net.js` for instances of emitting `error` on a `Socket`. In `v0.10` there are 3 (ignore the ones that are on `Server` instead).  One is inside `_destroy`, one is immediately before a call to `_destroy`, and one is in a callback that is only placed on the `Socket` immediately before a call to `destroySoon`. So by the time you get this error it should already be on the path to destruction.

As to how to differentiate, seems like a design choice for the module maintainers... should there be lots of different error events with different names (which is what caronte seemed to originally have when it was using EventEmitter2) or a single error event with different parameters?
",glasser,2014-01-28 19:23:17
561,2014-01-28 18:52:49,"@glasser I'm going to cherry pick part of this since the other PR was merged. And until I have a better idea of how the errors should be handled from messing around with the fail cases, I think we'll just emit the `error` event without a socket in the case that it errors since it will of course be dead in that case.
",jcrugzz,2014-01-28 19:23:17
561,2014-01-28 19:23:17,"Hmm actually I recant this, I don't believe we can really do anything if the client's socket errors so we just have to wait for them to reconnect. Emitting an error is actually not useful so your solution seems like the best course. The only reason I see for emitting _some_ kind of event is for logging purposes. It should not be under `error`. Cherry picked your commit 4c3ba74c4e99f03eed84f4d34844870845d96790
",jcrugzz,2014-01-28 19:23:17
560,2014-01-22 23:29:16,"head and error handling was broken before this commit.
",glasser,2014-01-28 07:04:09
560,2014-01-27 17:50:55,"Just to be clear: while #561 might require some extra thought to figure out How Things Should Be, this fix is a two-token fix to a clear bug in the current release, with a test.
",glasser,2014-01-28 07:04:09
559,2014-01-22 06:09:10,"The ws pass does not have any logic to say ""if an error occurs on `socket`, clean up `proxySocket` somehow"".  And there's no way for you to add that at the application level, because `proxySocket` is never passed to application code.  This means that in practice, our proxies leak `proxySocket`s.

Yes, if `socket` is cleanly _closed_, the `pipe` will close `proxySocket` as well. But that doesn't occur if `socket` errors; for example, if the client disappears from the network (without closing its TCP sockets), `socket` will emit `error`, and `proxySocket` will never be cleaned up.

See https://github.com/glasser/proxy-error-handling for a reproduction of this issue; it is trivially reproduced if you have a second machine (such as a recent Android/iPhone) that can load a web page served from your workstation and then disconnect itself from the network.

I've found a hacky way to close `proxySocket`: calling `socket.unshift(null)` causes `socket` to emit `end`, which triggers `proxySocket.end()` through the pipe.  But this is an undocumented use of `unshift`. Surprisingly, `socket.destroy()` does not seem to cause `socket` to emit `end` and has no effect on `proxySocket`.

Node 0.10.22, but I don't believe there are any net or streams changes in 0.10.23 or 0.10.24.

See also meteor/meteor#1769.
",glasser,2014-01-28 19:23:13
559,2014-01-22 20:44:10,"@glasser thanks for your thorough report. This definitely seems fixable and I will try and give it a look later today. If you are able to dig deeper into a possible solution please post here :)

cc @yawnt
",jcrugzz,2014-01-28 19:23:13
559,2014-01-22 21:49:02,"@jcrugzz @yawnt 

Here's my thought.  There are two ways we could go.  Either http-proxy should itself take care of this, by reacting to 'error' on `socket` by ending `proxySocket`... or http-proxy should give the end user access to `proxySocket` and let it do its own error handling.

I think the former is probably the way to go. First of all, it's more or less necessary to do this error handling, and we shouldn't make it easy for users to accidentally cause a leak.  Secondly, it's already the case that the ws `stream` phase doesn't give much control over the way that `socket` and `proxySocket` are connected (eg, it doesn't let you interpose some sort of transformation).  If we add an API for that later (or the user overrides the `stream` phase entirely) then sure, it would make sense to also give the user control over the error handling semantics. But because http-proxy doesn't offer that control, then it makes sense to do the automatic right thing.

Working on a PR now.  One thing that confuses me: it looks like there's a straight-up bug in the stream pass: it takes its server and head arguments in a different order from how they are passed in!  Is there a test suite that should be catching this?  (Our current production use of http-proxy/caronte is based on an old commit from back when caronte used EventEmitter2 which doesn't have this issue.)
",glasser,2014-01-28 19:23:13
559,2014-01-22 23:29:41,"OK, see #560 for the ""one thing that confuses me"". I'm going to build a PR on top of that PR to fix this issue.
",glasser,2014-01-28 19:23:13
559,2014-01-22 23:46:27,"#561 is the PR for this issue.

Note that even _with_ this PR, it's most likely the case that most users will also want to run

<S_CODE_TOKEN>

which we've had in our code forever. That cleans up the other direction: errors in outgoing should close incoming.  You might want to add that to the ws stream pass too.  The main difference is that users actually _can_ write the above code with the current module, whereas they _can't_ write the code that's being added in this commit.  (Also, you could imagine wanting to have different error handling behavior for this case: for example, maybe the proxy should instead to try reconnect to another backend server while keeping the client's socket alive.)
",glasser,2014-01-28 19:23:13
558,2014-01-21 19:42:27,"No one is assigned
http-proxy cannot listen on ipv6 ports.

IMO it should be enough to add an additional parameter 'hostname' to listen (/lib/http-proxy/index.js) and pass it to _server.listen.

See http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback.
",pl31,2014-01-21 19:49:46
558,2014-01-21 19:49:37,"LGTM
",jcrugzz,2014-01-21 19:49:46
557,2014-01-21 18:12:54,"http-proxy cannot listen on ipv6 ports.

IMO it should be enough to add an additional parameter 'hostname' to listen (/lib/http-proxy/index.js) and pass it to _server.listen.

See http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback.
",pl31,2014-01-21 19:45:20
557,2014-01-21 19:23:36,"a pull request would be appreciated :)
",yawnt,2014-01-21 19:45:20
557,2014-01-21 19:45:20,"Created pull request.
",pl31,2014-01-21 19:45:20
556,2014-01-20 16:29:43,"There was previously no way to get past these checks.
",alevicki,2014-01-20 17:55:28
556,2014-01-20 17:55:32,"thanks!
",yawnt,2014-01-20 17:55:28
556,2014-01-20 18:09:18,"Needs a test.
",3rd-Eden,2014-01-20 17:55:28
555,2014-01-19 06:09:02,"See: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L110-L114

Otherwise it is impossible to send the correct responses back to the `res` or make decisions based of the `req` on errors.
",indexzero,2014-01-19 10:49:43
554,2014-01-17 21:54:33,"Not sure if the `README.md` needs to be updated or not, but it appears as though you have to set callbacks when you proxy via .web/ .ws to allow it to work.  

This works:

<S_CODE_TOKEN>

Doing the same without the callback however, will error out:

<S_CODE_TOKEN>
",droppedoncaprica,2014-01-17 22:49:38
554,2014-01-17 22:49:38,"@droppedonjapan the instance of `proxy` is does not require a callback when it is an `EventEmitter`, but you need to listen on the `error` event ;). It is only an `EventEmitter` in the following cases... see the code [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L6-L54)

<S_CODE_TOKEN>

The `var proxy = HttpProxy.createProxy()` api requires the callback as it is the simpler implementation. 

Regardless the proxy has the chance of error so how you choose to handle that is up to you!
",jcrugzz,2014-01-17 22:49:38
553,2014-01-17 18:56:37,"From your examples on the Nodejitsu blog, the following code should redirect correctly:

<S_CODE_TOKEN>

When you hit http://localhost:8000, the proxy process dies with this error:

<S_CODE_TOKEN>

Node v0.10.24, http-proxy v1.0.0
",droppedoncaprica,2014-01-17 21:19:11
553,2014-01-17 18:59:26,"To clarify, the createProxyServer() method works as expected.

<S_CODE_TOKEN>

Unfortunately this method doesn't allow you to filter by host.
",droppedoncaprica,2014-01-17 21:19:11
553,2014-01-17 21:20:30,"thanks for reporting, fixed in `http-proxy@1.0.1`
",yawnt,2014-01-17 21:19:11
553,2014-01-17 21:23:58,"Not a problem. 
",droppedoncaprica,2014-01-17 21:19:11
553,2014-01-17 21:32:26,"(for the record, you can use the same methods on .createProxyServer().. it will work in the same way `.web` and `ws` .. there's a `.createProxy()` alone because it's more clean semantically :P)
",yawnt,2014-01-17 21:19:11
553,2014-01-17 21:52:11,"Right on.  I was trying to proxy to different ports depending on the `req.headers.host`, so from what I understand you have to use the `.createProxy` over `.createProxyServer`  For example, this will error out:

<S_CODE_TOKEN>

However this works:

<S_CODE_TOKEN>
",droppedoncaprica,2014-01-17 21:19:11
552,2014-01-16 15:26:21,"Here it is
",yawnt,2014-01-16 15:34:37
551,2014-01-16 15:25:09,,yawnt,2014-01-16 15:25:15
550,2014-01-15 10:38:00,"I have a usecase where I wanted a request uri to be routed as is to a different port
With the following configuration, I wanted to route i.e.
- http://localhost/invoke/test to http://127.0.0.1:15010/test
- http://localhost/dummy to http://127.0.0.1:15000/dummy
- http://localhost/dummy2 to http://127.0.0.1:15000/dummy2

<S_CODE_TOKEN>

What was happening was http://localhost/invoke/ was properly redirected
but http://localhost/dummy and http://localhost/dummy2 were both mapped to http://127.0.0.1:15000, because of `req.url = url.format(target.replace(route.source.regexp, ''));`

This is the change I've made in `proxy-table.js line 226` to have it working

<S_CODE_TOKEN>
",imaguiraga,
550,2014-01-31 00:13:56,"I am unsure whether my answer is legit but I am the author of `http-master` which utilizes `node-http-proxy` (latest versions) and you can do the above with this code - however if you wish to use this solution then post any feedback to https://github.com/CodeCharmLtd/http-master

`npm install http-master`

<S_CODE_TOKEN>
",Rush,
550,2014-01-31 07:24:22,"@RushPL completely legit.  `http-proxy` encourages these kind of modules ;)
",yawnt,
549,2014-01-14 07:48:31,"When a callback is passed into .web() such as:

<S_CODE_TOKEN>

the `server` var is set to false and therefor can't emit the `proxyRes`.
",mmoulton,2014-01-14 09:23:28
549,2014-01-14 09:23:32,"+1.. thanks
",yawnt,2014-01-14 09:23:28
548,2014-01-13 20:47:39,"On branch caronte, if you attach a callback to your proxy request, then web-incoming's `stream()` method gets called with `false` as the value of the `server` object.  This causes it to fail to actually emit the ""proxyRes"" event, which results in everything breaking.

This is an example stack trace:

<S_CODE_TOKEN>
",cheddar,2014-01-14 09:25:07
548,2014-01-14 09:25:07,"fixed in https://github.com/nodejitsu/node-http-proxy/pull/549, thanks for reporting
",yawnt,2014-01-14 09:25:07
547,2014-01-11 12:43:43,"@yawnt found a few minor things when I was using this extensively:
- **EventEmitter3 will not throw on an unhandled `error`:** but without any default handler it's very confusing to debug when your proxy logic is just plain wrong. _We should have a default logger if there are no `error` handlers._ cc/ @3rd-Eden 
- **We should have a simple(r) `.createProxy()` method:** which is basically just exposing `createRightProxy`. A lot of our users don't even bother with `httpProxy.createServer`, they just use `new httpProxy.RoutingProxy()`. Forcing them to create a server that they will never use feels very awkward. 
- **Remove all (soon to be old) caronte links:** The README.md and a few other doc links still have hrefs to the `caronte` branch
",indexzero,2014-01-16 15:34:38
547,2014-01-11 18:53:33,"@indexzero running `httpProxy.createServer()` actually just creates a proxy. The only thing that makes it a ""server"" is by calling the `.listen()` method. This is one of the reasons I exposed the ""server"" on the main `module.exports` so you can just do..

<S_CODE_TOKEN>

This allowed my OCD to calm down because it is now semantically correct in what you are creating. 
",jcrugzz,2014-01-16 15:34:38
547,2014-01-16 13:58:36,"@jcrugzz Thanks, but still want this.

@yawnt ping?
",indexzero,2014-01-16 15:34:38
547,2014-01-16 14:07:31,"done, the onlyu references i've found to caronte are the images for test coverage and travis, and i think it's saner to change those post-merge
",yawnt,2014-01-16 15:34:38
547,2014-01-16 14:20:27,"@yawnt Sold. Lets do the damn thing :-D
",indexzero,2014-01-16 15:34:38
546,2014-01-10 10:28:21,"The code i'm using

<S_CODE_TOKEN>

The error comes in randomly but its:

<S_CODE_TOKEN>

I can't really ascertain what causes it but running it again it does tend to work.
",Tarang,2014-01-28 19:28:25
546,2014-01-10 10:38:10,"i think i know what's up .  i'll look into it this soon
",yawnt,2014-01-28 19:28:25
546,2014-01-28 19:28:25,"should be fixed in 0b223abb65286e0844627c2791e98dc884dadf10
",jcrugzz,2014-01-28 19:28:25
545,2014-01-07 07:52:22,,marmor,2014-01-08 05:38:20
544,2014-01-07 00:31:20,"The ""Host"" header field that was created and sent by the proxy to the backends, was wrong, because it had been copied from the original headers that were received by the proxy.

This caused many problems; for example, when the backend web server served several websites on the same IP/port (""name-based virtual-host""), which is very common, a wrong Host header caused the request to fail or to bring the wrong site.

The patch overwrites the Host field by the real host/port of the backend.
",marmor,2014-12-18 18:40:25
544,2014-01-07 00:51:45,"The fix was done to the caronte branch, of course.
",marmor,2014-12-18 18:40:25
544,2014-01-07 02:30:52,"@marmor can you provide a test case for this? I do not believe your implementation is correct in the general case as it breaks 8 of the tests.
",jcrugzz,2014-12-18 18:40:25
544,2014-01-07 06:01:07,"Did you mean examples?
Try to access elmar.co.il from your browser, you'll reach one site.
Now access it through Caronte (as a reverse proxy, with ""http://elmar.co.il"" as the target), you'll reach another site (netmask.it).
The reason: both hold the same IP.
These domains are mine, but there are millions of sites that share their IPs, especially in hosting services.

Are you sure that these 2 lines (of my patch) broke the tests?!
I'll try to look at the tests, but either something else broke it, or something is not correct with these tests.
Thanks in any case!
",marmor,2014-12-18 18:40:25
544,2014-01-07 06:05:57,"@marmor look at the travis-ci [build](https://travis-ci.org/nodejitsu/node-http-proxy/builds/16499169). Also an actual failing test case would be best that can be easily used to prove your point but a gist of a runnable example of this is second best :). 
",jcrugzz,2014-12-18 18:40:25
544,2014-01-07 07:57:05,"Thank you.
Sorry for the newbie question, but it requests me to allow write access to sensitive data of me;
Should I allow it?
",marmor,2014-12-18 18:40:25
544,2014-01-07 16:19:44,"The errors are not caused by my patch;
I edited the original file, before my patch, and added one empty line, and got the same errors.
Regarding a runnable test:
It will either require to run under a machine with several domains (or sub-domains) sharing the same IP, or will dependent on external backend.
If there is a static IP that all the tests run under, I can cheat it by adding this IP to one of my domains, and create several entries with different sub-domains and the same IP.
",marmor,2014-12-18 18:40:25
544,2014-01-07 18:42:08,"@marmor I'll try this week to replicate but without code to try is difficult to understand what is really the problem, if I found some trouble I'll make a test the reproduce the issue.
",cronopio,2014-12-18 18:40:25
544,2014-01-07 21:34:20,"OK, I wrote something.
But it can't be automatic, because it requires you to add the following lines to your /etc/hosts:

127.0.0.1   host8001
127.0.0.1   host8002

Then npm install simples, and the following script will re-produce the bug:

# 

var httpProxy = require('http-proxy'), server = require('simples')(8000);

server                 .get('/', function(con) { con.end('Host8001\r\n'); });
server.host('host8002').get('/', function(con) { con.end('Host8002\r\n'); });

httpProxy.createProxyServer({target:'http://host8001:8000'}).listen(8001);
httpProxy.createProxyServer({target:'http://host8002:8000'}).listen(8002);

# 

Requesting http://host8001:8000 will give you ""Host8001"".
Requesting http://host8002:8000 will give you ""Host8002"".
Requesting http://127.0.0.1:8001 will give you ""Host8001"".
However,
requesting http://127.0.0.1:8002 will give you ""Host8001"" too!
(instead of ""Host8002"" as required by the RFC and as done by all the reverse-proxies).

Most of the HOSTED websites work this way and share their IP with others (contrary to not-hosted sites which have their own IP), and without my 2-lines patch, it isn't possible to access them through the proxy.
",marmor,2014-12-18 18:40:25
544,2014-01-29 21:14:10,"@marmor Having just patched this on top of master, this is definitely having some unintended behavior as it consistently breaks the tests locally as well. I'll try and give it a look later this week.
",jcrugzz,2014-12-18 18:40:25
544,2014-01-30 15:18:00,"Obviously this is wrong for reverse http proxying. In reverse proxy case the host header needs to be exactly copied. I think there should be a totally separate option to enable the behavior requested in here. An option to `proxy.web` perhaps.

I would see this working exactly as `http.request` is working. There one may do:

<S_CODE_TOKEN>
",Rush,2014-12-18 18:40:25
544,2014-06-29 23:34:37,"@marmor any update on this? Your fix works for me too.
",ndreckshage,2014-12-18 18:40:25
544,2014-07-02 06:35:13,"I would love to apply it.

However, I was disappointed to find out how hard it is to check-in anything
in this project (maybe it's true for all the other projects, I don't know).
I have a list of dozens of fixes and improvements, and this is only the
first of them, and the easiest and most self evident.

It's great that there is a proxy module for Node, and it was very kind and
generous of its developers to develop it for us.
But based on my own experience with other proxies (especially Apache's
mod_proxy, which I'm familiar with its source code very well), the current
status is very preliminary, it still has to pass light-years to become even
just close to mod_proxy, and it's despaired that even the easiest and clear
fix is so hard to apply.

And even now, after convincing the maintainers that this specific patch is
OK, I'm still puzzled what exactly I should do (from the technical point).
People said ""what's the problem? do this and that, and that's all"", but for
a Git newbie I'm afraid, especially when it's not my own project and I
don't want to do things that I wasn't suppose to do, and when my name will
be put on it forever in GitHub archives. I'm not even sure that this
specific message is personal to you or it shows to anybody else...

I don't want anybody else to apply it for me, so I just asked a friend,
living near me, to sit with me 10 minutes and do it with me (so the next
time I'll have the confidence to do it alone), but I must apologize that it
will take several days till we meet. He is a GitHub guru, maintaining many
projects there.

Regarding a fork: no, I don't want to do it. I have my honor and
appreciation to the developers of this project, and I want this project to
succeed, together with them. I was involved in many other Open-Source
projects in the past (but not in GitHub), and have never forked.

Thanks a lot for your trust!

On Mon, Jun 30, 2014 at 2:34 AM, ndreckshage notifications@github.com
wrote:

> @marmor https://github.com/marmor any update on this? Your fix works
> for me too.
> 
> ‚Äî
> Reply to this email directly or view it on GitHub
> https://github.com/nodejitsu/node-http-proxy/pull/544#issuecomment-47483274
> .
",marmor,2014-12-18 18:40:25
544,2014-07-02 13:39:50,"@marmor the issue is that it breaks a bunch of the [tests](https://travis-ci.org/nodejitsu/node-http-proxy/jobs/16499170) on `0.10.x` (`0.11.x` tests are broken due to ssl changes). If you can fix these to confirm it does not cause any regressions with other use cases, I would be happy to accept it :). I just haven't had the time to dig into them personally so any help here is definitely appreciated. 
",jcrugzz,2014-12-18 18:40:25
544,2014-12-18 18:40:25,"This is properly set when using the `changeOrigin` options
",jcrugzz,2014-12-18 18:40:25
543,2014-01-07 00:03:56,"Many of the websites use ""name-based virtual hosting"", i.e. several websites which share the same IP. Their web servers use the ""Host"" header field of each incoming request to know what to serve.

Unfortunately, while Caronte sends the HTTP request to the right target, the ""Host"" header field is copied from the original request (which the browser sent to the proxy), so the wrong web site is served by the target.
",marmor,
543,2014-01-07 00:21:40,"Caronte works properly (as is expected for reverse HTTP proxying) but you can of course change the request's host field manually to whatever the target server has to receive. When you're done, do `proxy.web()` manually.
",Rush,
543,2014-01-07 00:42:43,"I just sent a pull request of 2 lines (common.js) that fixes the bug.
The original behavior, not only caused a bug with name-based virtual hosts, but was broken and against the RFCs.
All the other proxies put the real address of the backend in the ""Host"" field.
Some proxies let you overwrite this behavior, but it is not the default, and against the RFCs.
For example, in Apache you can add a ProxyPreserveHost directive.
Otherwise, the address of the proxy is copied only to the X-Forwarded-Host and X-Forwarded-Server header fields.
",marmor,
543,2014-01-13 03:14:25,"same problem.
",TooBug,
542,2014-01-05 15:08:03,"Some sites don't work if get ""Proxy-connection"" header. They believe that the proxy - is always bad and block requests.

How to replace""Proxy-connection"" header to ""Connection"" ?

For example, run this code:

<S_CODE_TOKEN>

set proxy in browser to 127.0.0.1:8080 , and try go to drakensang-online.ru
",MichaelMonashev,2014-01-31 00:27:01
542,2014-01-05 16:11:03,"hi!

we have rewritten http-proxy from scratch in the branch `caronte` in this repo. Would you mind testing with that (since it's the new and supported version) and report if the issue is still present?

Thanks
",yawnt,2014-01-31 00:27:01
542,2014-01-05 16:33:40,"Thank you!
Caronte branch send ""Connection"" header and doesn't send ""Proxy-connection"".

I am waiting for realese.
",MichaelMonashev,2014-01-31 00:27:01
542,2014-01-05 16:39:16,"shouldn't take long, it should be a matter of days :)
",yawnt,2014-01-31 00:27:01
542,2014-01-31 00:14:50,"this should be resolved I believe
",Rush,2014-01-31 00:27:01
542,2014-01-31 00:27:01,"@RushPL thanks :)
",jcrugzz,2014-01-31 00:27:01
541,2014-01-01 19:04:18,"I am using express behind enterprise corporate proxy/firewall. 
I am struggling because because I just don't know where to set proxy for node.js

I usually export http_proxy=""http://<username>:<password>@myproxy.com:8080 at prompt. This is just sufficient. 

But this setting is not working for node.js. 
Please help.
Should I use node-http-proxy if yes then please give a simple code sample for my code request. 
Else just give a sample node.js to do this. 

Thanks in advance. 
",wabmca,
540,2013-12-30 05:27:25,"I want to create a man in the middle proxy. The client should be able to connect to my proxy server which would make the request to the url requested by the client, get the response, modify it and send it back to the client. This should work for https sites as well. 
I would like to know if this is possible with node-http-proxy. I was not able to get this to work with the examples given.
Thanks for your help!
",inian,2013-12-30 10:42:33
540,2013-12-30 10:42:33,"yes, it's possible.. you need to create an object which mimics `http.response` and is a stream2 .. you can then override stream2 methods to include your own modification logic and pipe into `res` :)

it'll look something like this

<S_CODE_TOKEN>
",yawnt,2013-12-30 10:42:33
539,2013-12-29 21:01:57,"@cronopio we could probably use some tests for adding functions before/after any of the passes. 

cc @yawnt
",jcrugzz,2013-12-29 22:20:46
538,2013-12-28 23:48:30,"How would one go about modifying the routing table after startup?  I'd suspect it'd be as simple as changing some object properties -- specifically, being able to use a REPL to modify the table:

**expected behavior:**

<S_CODE_TOKEN>
",martindale,2013-12-29 08:06:44
538,2013-12-29 08:06:44,"We're dropping the router from `node-http-proxy@1.0.0` which will be released soon.
",indexzero,2013-12-29 08:06:44
538,2014-01-14 23:25:09,"That's fine, but then how would one accomplish this same objective of changing handlers without a restart in `node-http-proxy@1.0.0`?
",martindale,2013-12-29 08:06:44
537,2013-12-28 17:02:43,"@yawnt there is no way to currently splice in before or after functions currently as there is no general [`this.passes`](https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/http-proxy/index.js#L120-L139). We have passes for either web or ws which needs to be specified in some manner. 

What do you think is the cleanest way to do so? We could pass a `type` parameter to the `before` and `after` functions as the first argument but that seems suboptimal.

Thoughts?
",jcrugzz,2014-01-08 05:37:32
537,2014-01-08 05:37:31,"fixed in c47adac391ca2f80ac1adad52e4fd652d85ac2a4. @cronopio this could definitely use some tests though!
",jcrugzz,2014-01-08 05:37:32
537,2014-01-08 13:06:55,"@jcrugzz yeah sure I'll take care asap
",cronopio,2014-01-08 05:37:32
536,2013-12-28 00:07:20,"@yawnt thoughts? I think it adds a nice semantic when you aren't actually creating the proxy as a server. It also eases elements of my OCD.
",jcrugzz,2013-12-28 18:58:29
535,2013-12-26 02:06:27,"`An error has occurred: {}` when route http to https website.

I catch the proxy error, the err message is: `UNABLE_TO_VERIFY_LEAF_SIGNATURE`

and then i try to set `rejectUnauthorized` option, but it doesn't work:

<S_CODE_TOKEN>

then I set `process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';` to resolve this problem.

I want to know , why `rejectUnauthorized` option doesn't work. Thanks~!
",switer,2014-01-28 19:27:12
535,2013-12-26 12:54:30,"hi, are you using the master branch or the `caronte` branch? if you're using master, i encourage you to try out caronte.

if that is still failing, please post here a working example so that i can reproduce the bug and fix it!

thanks!
",yawnt,2014-01-28 19:27:12
535,2013-12-27 05:49:44,"@yawnt I use `http-proxy` npm module, version `0.10.3`.
In my use case:

<S_CODE_TOKEN>

run the proxy server, and then visit `localhost:9001` in browser, it will be response `An error has occurred: {}`.
and you remove the comment of `process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';`,
you can visit the website success.
",switer,2014-01-28 19:27:12
535,2013-12-27 09:21:10,"that version of http-proxy is no longer maintained (because it is only 0.10.x compatible).. i encourage you to try the `caronte` branch in this repo.. you can install it by doing

<S_CODE_TOKEN>
",yawnt,2014-01-28 19:27:12
535,2013-12-27 09:28:32,"Ok, thanks @yawnt, but why don't you publish `caronte` to npm ?
",switer,2014-01-28 19:27:12
535,2013-12-27 11:20:20,"it's gonna be published in the next few days
",yawnt,2014-01-28 19:27:12
535,2014-01-28 19:27:12,"@switer it is currently published. Open a new issue if you have the same problem
",jcrugzz,2014-01-28 19:27:12
534,2013-12-25 08:13:37,"Hi,
i've been running a node server application which crashes probably once a week due to an uncaught ""Can't render headers ..."" exception.   The skeleton of the code is like:

<S_CODE_TOKEN>

In the log file, i can see the message ""!!!!!  ProxyError received"" being printed.   With ""node debug ..."" to step into the calls, i realized the culprit is DNS resolution failure.

For proper error handling, if the constructor call (HttpProxy) at [1] fails, the following statement should be skipped completely:

<S_CODE_TOKEN>

What is a good pattern in this case for error handling?   Do i need to resort to the Step or Async module for serial execution?

My earlier posting (before i realized DNS resolution is to be blamed) with stack trace for this problem can be found at:
   https://groups.google.com/forum/?hl=en#!topic/nodejs/QuxzukAHqPw

Thanks.
",hseuming,
534,2014-01-03 17:04:15,"This is not the right answer -- But I run a local dns to reduce likelyhood
of dns failures.  + I hacked HttpProxy to check for headersSent before
responding.  -- had to change in two places.

On Wed, Dec 25, 2013 at 2:13 AM, hseuming notifications@github.com wrote:

> Hi,
> i've been running a node server application which crashes probably once a
> week due to an uncaught ""Can't render headers ..."" exception. The skeleton
> of the code is like:
> 
> var
>   httpProxy   = require('http-proxy'),
>   spdy        = require('spdy'),
>   ...
> 
> spdy.createServer
> (
>   options,
>   function(req,res)
>   {
>     if (...)
>     {
>       ...
>       var proxy = new httpProxy.HttpProxy({target: {host: ..., port: ...}});   //  [1]
> 
> <S_CODE_TOKEN>
> 
>   }
> )
> 
> In the log file, i can see the message ""!!!!! ProxyError received"" being
> printed. With ""node debug ..."" to step into the calls, i realized the
> culprit is DNS resolution failure.
> 
> For proper error handling, if the constructor call (HttpProxy) at [1]
> fails, the following statement should be skipped completely:
> 
>    proxy.proxyRequest(req,res);    //  [2]
> 
> What is a good pattern in this case for error handling? Do i need to
> resort to the Step or Async module for serial execution?
> 
> My earlier posting (before i realized DNS resolution is to be blamed) with
> stack trace for this problem can be found at:
> https://groups.google.com/forum/?hl=en#!topic/nodejs/QuxzukAHqPw
> 
> Thanks.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/534
> .

## 

Bryan Waters
SolutionsbyWaters.com
IT and Web Solutions to Business Problems

Cell: 512-825-2032
",bwaters,
534,2014-01-03 18:26:39,"Thanks for the input

> But I run a local dns to reduce likelyhood of dns failures.

Unfortunately i'm not allowed to do that in this case, :-(

> - I hacked HttpProxy to check for headersSent before responding.

Sadly we're using Node 0.8.22 and i believe headersSent was added to core
http.js in version 0.9.3, :-(

> --  had to change in two places.

You were referring to both

<S_CODE_TOKEN>

right?

On Fri, Jan 3, 2014 at 12:04 PM, bwaters notifications@github.com wrote:

> This is not the right answer -- But I run a local dns to reduce likelyhood
> of dns failures. + I hacked HttpProxy to check for headersSent before
> responding. -- had to change in two places.
> 
> On Wed, Dec 25, 2013 at 2:13 AM, hseuming notifications@github.com
> wrote:
> 
> > Hi,
> > i've been running a node server application which crashes probably once
> > a
> > week due to an uncaught ""Can't render headers ..."" exception. The
> > skeleton
> > of the code is like:
> > 
> > var
> > httpProxy = require('http-proxy'),
> > spdy = require('spdy'),
> > ...
> > 
> > spdy.createServer
> > (
> > options,
> > function(req,res)
> > {
> > if (...)
> > {
> > ...
> > var proxy = new httpProxy.HttpProxy({target: {host: ..., port: ...}});
> > // [1]
> > 
> > proxy.on
> > (
> > 'proxyError',
> > function(err,req,res)
> > {
> > res.writeHead(500, {'Content-Type': 'text/plain'});
> > res.end('Something went wrong and we are reporting a custom error
> > message.');
> > util.log('!!!!! ProxyError received');
> > }
> > );
> > 
> > proxy.proxyRequest(req,res); // [2]
> > ...
> > }
> > }
> > )
> > 
> > In the log file, i can see the message ""!!!!! ProxyError received"" being
> > printed. With ""node debug ..."" to step into the calls, i realized the
> > culprit is DNS resolution failure.
> > 
> > For proper error handling, if the constructor call (HttpProxy) at [1]
> > fails, the following statement should be skipped completely:
> > 
> > proxy.proxyRequest(req,res); // [2]
> > 
> > What is a good pattern in this case for error handling? Do i need to
> > resort to the Step or Async module for serial execution?
> > 
> > My earlier posting (before i realized DNS resolution is to be blamed)
> > with
> > stack trace for this problem can be found at:
> > https://groups.google.com/forum/?hl=en#!topic/nodejs/QuxzukAHqPw
> > 
> > Thanks.
> > 
> > ‚Äî
> > Reply to this email directly or view it on GitHub<
> > https://github.com/nodejitsu/node-http-proxy/issues/534>
> > .
> 
> ## 
> 
> Bryan Waters
> SolutionsbyWaters.com
> IT and Web Solutions to Business Problems
> 
> Cell: 512-825-2032
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/534#issuecomment-31536367
> .
",hseuming,
534,2014-01-13 20:42:25,"Now that we are talking hacks just use an undocumented node call for the
later .0.8.xx versions  res._headerSent

On Fri, Jan 3, 2014 at 12:26 PM, hseuming notifications@github.com wrote:

> Thanks for the input
> 
> > But I run a local dns to reduce likelyhood of dns failures.
> 
> Unfortunately i'm not allowed to do that in this case, :-(
> 
> > - I hacked HttpProxy to check for headersSent before responding.
> 
> Sadly we're using Node 0.8.22 and i believe headersSent was added to core
> http.js in version 0.9.3, :-(
> 
> > -- had to change in two places.
> 
> You were referring to both
> 
> res.writeHead
> 
> right?
> 
> On Fri, Jan 3, 2014 at 12:04 PM, bwaters notifications@github.com
> wrote:
> 
> > This is not the right answer -- But I run a local dns to reduce
> > likelyhood
> > of dns failures. + I hacked HttpProxy to check for headersSent before
> > responding. -- had to change in two places.
> > 
> > On Wed, Dec 25, 2013 at 2:13 AM, hseuming notifications@github.com
> > wrote:
> > 
> > > Hi,
> > > i've been running a node server application which crashes probably
> > > once
> > > a
> > > week due to an uncaught ""Can't render headers ..."" exception. The
> > > skeleton
> > > of the code is like:
> > > 
> > > var
> > > httpProxy = require('http-proxy'),
> > > spdy = require('spdy'),
> > > ...
> > > 
> > > spdy.createServer
> > > (
> > > options,
> > > function(req,res)
> > > {
> > > if (...)
> > > {
> > > ...
> > > var proxy = new httpProxy.HttpProxy({target: {host: ..., port: ...}});
> > > // [1]
> > > 
> > > proxy.on
> > > (
> > > 'proxyError',
> > > function(err,req,res)
> > > {
> > > res.writeHead(500, {'Content-Type': 'text/plain'});
> > > res.end('Something went wrong and we are reporting a custom error
> > > message.');
> > > util.log('!!!!! ProxyError received');
> > > }
> > > );
> > > 
> > > proxy.proxyRequest(req,res); // [2]
> > > ...
> > > }
> > > }
> > > )
> > > 
> > > In the log file, i can see the message ""!!!!! ProxyError received""
> > > being
> > > printed. With ""node debug ..."" to step into the calls, i realized the
> > > culprit is DNS resolution failure.
> > > 
> > > For proper error handling, if the constructor call (HttpProxy) at [1]
> > > fails, the following statement should be skipped completely:
> > > 
> > > proxy.proxyRequest(req,res); // [2]
> > > 
> > > What is a good pattern in this case for error handling? Do i need to
> > > resort to the Step or Async module for serial execution?
> > > 
> > > My earlier posting (before i realized DNS resolution is to be blamed)
> > > with
> > > stack trace for this problem can be found at:
> > > https://groups.google.com/forum/?hl=en#!topic/nodejs/QuxzukAHqPw
> > > 
> > > Thanks.
> > > 
> > > ‚Äî
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/nodejitsu/node-http-proxy/issues/534>
> > > .
> > 
> > ## 
> > 
> > Bryan Waters
> > SolutionsbyWaters.com
> > IT and Web Solutions to Business Problems
> > 
> > Cell: 512-825-2032
> > 
> > ‚Äî
> > Reply to this email directly or view it on GitHub<
> > https://github.com/nodejitsu/node-http-proxy/issues/534#issuecomment-31536367>
> > 
> > .
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/534#issuecomment-31542529
> .

## 

Bryan Waters
SolutionsbyWaters.com
IT and Web Solutions to Business Problems

Cell: 512-825-2032
",bwaters,
533,2013-12-22 01:37:06,"The casual example shows proxying web sockets when target was provided to the `createProxyServer` function, however when dispatching http requests I want only a single proxyServer instance per port.

I wrote a simple test and a WebSocket enabled website running at port 4000:

<S_CODE_TOKEN>

However, this does not work and errors out with:

<S_CODE_TOKEN>

Adding a simple workaround by bassing `{target: {protocol: 'http'}}' yields:

<S_CODE_TOKEN>

How can we fix it?
",Rush,2013-12-26 18:39:33
533,2013-12-22 14:04:36," target should be a string, not an object.. you also need to configure `ws: true` if you want websockets.. last but not least you also need to tell proxy.ws where to proxy to

<S_CODE_TOKEN>
",yawnt,2013-12-26 18:39:33
533,2013-12-22 14:17:59,"According to code `{ws: true}` is only used by `listen()` inside proxyServer. When I am listening outside of that, it is not necessary if I catch `upgrade` event manually.

About the target of proxy.ws, I thought that it already had that knowledge? Does it make sense to proxy to a different location than proxy.web? Isn't the connection already estabilished to the target (Keep-Alive?) ? Shouldn't the target be the same as the first proxy.web?
",Rush,2013-12-26 18:39:33
533,2013-12-22 14:44:26,"if you want to proxy to a single location you should set it up in the constructor

<S_CODE_TOKEN>

in which case both ws and web will have knowledge and you don't need to pass manually 
",yawnt,2013-12-26 18:39:33
533,2013-12-22 14:47:59,"That's what I am doing at the moment but I am concerned that creating hundreds of createProxyServer for each of my routes. Do you think there is any downside of that? Furthermore the only way to get that proxyServer instance when getting my upgrade event is kind of hackish:

<S_CODE_TOKEN>

I am not even sure what `_idleNext` is.... but I found that instance there and it works. :)
",Rush,2013-12-26 18:39:33
533,2013-12-22 15:06:50,"<S_CODE_TOKEN>

this is how it should be done, you're only creating ONE server, proxy.web and proxy.ws are just methods of the instance
",yawnt,2013-12-26 18:39:33
533,2013-12-22 15:21:13,"Well, that is the simplest use case, my use case is proxying to many targets based on the host/url and whatever different condition, like current moon phase. That's why optimally I would like to dispatch by:
`proxy.web(req, res, {target: dynamicallyResolveTarget(req) });`
my problem is that I need to ""save"" this decision for any arbitrary 'upgrade' event I later get and reproduce it with `proxy.ws`. My original thinking was that `proxy.ws` would do that automatically.

Currently I resolve each of my targets at run time and create a proxyServer for each of them and then `proxy.ws` is run through `socket._idleNext.proxy`. It appears that `_idleNext` is internal `connection`, because the proxy reference comes from `req.connection.proxy = proxy;` done at the request time.

If you think there is nothing that can be improved (or you are willing to improve) in node-http-proxy related to my use case, or nothing you could advice me on accessing the proxy object from last `proxy.web` then I guess this issue could be closed.
",Rush,2013-12-26 18:39:33
533,2013-12-22 19:34:49,"@RushPL can you gist the full example you are using to test this? I'm not sure where you are running into issues as we have our staging balancers running this code and we proxy to multiple targets. Could help us see if we missed something with in our testing! 
",jcrugzz,2013-12-26 18:39:33
533,2013-12-26 18:39:33,"It was my confusion that web sockets are somehow not an ordinary request, but are bound to a previous HTTP request. I am now applying target to `ws` same as to `web` and it seems to work all right. Thank you for all your hard work.

My example is a full-fledged routing/redirect proxy-solution ( https://github.com/CodeCharmLtd/rush-http-proxy/tree/caronte ) Update to caronte branch required me to write my own dispatching logic but it is already done and works quite well.
",Rush,2013-12-26 18:39:33
532,2013-12-17 14:35:03,"Can you add a bit more detail around this one? What does the buffering, and how does it affect latency?
",cosjef,2013-12-18 12:31:28
532,2013-12-18 12:31:28,"sorry, it was just a reminescence from old versions. it referred to the buffering which http-proxy used to handle. the new branch `caronte` doesn't have that as it uses streams2 :)
",yawnt,2013-12-18 12:31:28
532,2013-12-18 12:40:17,"@cosjef I am guessing that your inquiry has pertains to this within `README.md` on master:

> - Uses event buffering to support application latency in proxied requests

The question of ""What is buffering in node.js?"" is a big one. Within `http-proxy` the above statement referred [to this](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L204-L257) implementation to work-around lack of buffering in node.js core before `0.10.x`

In `http-proxy@1.x.x` the statement is no longer in `README.md` because we assume `node@0.10.x` by default and thus all buffering is handled there.
",indexzero,2013-12-18 12:31:28
531,2013-12-13 07:05:19,"When I use `httpProxy.createServer`, I Can't listen the 'data' & 'end' event on response. 

Here is my code:

<S_CODE_TOKEN>
",swain,2013-12-18 11:36:30
531,2013-12-18 11:36:30,"hi!

the master branch is in the process of being deprecated in favour of [caronte](https://github.com/nodejitsu/node-http-proxy/tree/caronte) which is a 0.10.x compatible rewrite.
Please check that out and if you have issues feel free to report them :)

Cheers!
",yawnt,2013-12-18 11:36:30
530,2013-12-04 03:04:44,"Example app http-proxy-post-test.js:

<S_CODE_TOKEN>

Run this with node and try with CURL

node http-proxy-post-test.js

Get to non-proxied URL is ok

<S_CODE_TOKEN>

Get to proxied URL is ok (request goes to google.com)

<S_CODE_TOKEN>

Post with no body is ok

<S_CODE_TOKEN>

Post with body hangs and proxyRequest never sends response or tries to connect to google.com

<S_CODE_TOKEN>
",tikonen,2013-12-09 04:37:19
530,2013-12-09 04:37:19,"Seems to be duplicate of this #180 and caused by express bodyParser
",tikonen,2013-12-09 04:37:19
529,2013-12-02 23:04:35,"According to the [HTTP standard](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2), a request's URI (the second field in the first line of an HTTP request, after the verb, and which gets into req.url) may be relative or absolute.

A request to a proxy must always have an absolute URI, and indeed when we receive a request, req.url is always absolute. We just forward the request in proxyRequest and copy the URI into the new request.

The receiving end of our new request will in turn get an absolute URI. This behaviour, however standard, is breaking some sites which naively expect the path to be relative to the hostname (starting with a ""/""). They are wrong, but still node-http-proxy could be ""fixed"" so as to not break this assumption of theirs.

By placing ""req.url = req.url.replace(/._?:\/\/._?\//, '/')"" (an ugly regexp, granted) before calling proxyRequest I was able to conform to the naivet√© of Wordpress and other stuff which is out there being used and does not implement the standard.

Thanks for building this nice, flexible proxy.
## 
",fabiosantoscode,2013-12-18 11:49:52
529,2013-12-03 15:33:30,"Here is my changeset to my front-end dev tool using node-http-proxy which fixes this assumption.

https://github.com/fabiosantoscode/magicProxy/commit/d8118e37532bc479e71a806b8f1e2fcc9d8763db
",fabiosantoscode,2013-12-18 11:49:52
529,2013-12-10 01:12:30,"This is also the cause of incompatibility with socket.io.
",boutell,2013-12-18 11:49:52
529,2013-12-10 01:39:38,"Add ""all express sites using the express.sessions middleware,"" also known as ""all sites using the connect sessions middleware.""

if (0 != req.originalUrl.indexOf(cookie.path || '/')) return next();

That is trying to detect a leading / in the default configuration. It'll never happen with an absolute URL.

There are just too many commonly used frameworks, and therefore sites, that don't work with this behavior.
",boutell,2013-12-18 11:49:52
529,2013-12-10 01:44:18,"@fabiosantoscode Thanks for that simple solution, it should have occurred to me since I'm doing custom proxying with proxy.web too.

Here's a better regexp that should not experience false positives:

req.url = req.url.replace(/^\w+:\/\/.*?\//, '/');
",boutell,2013-12-18 11:49:52
529,2013-12-10 05:36:32,"@boutell and @fabiosantoscode if you haven't already, check out the [`caronte`](https://github.com/nodejitsu/node-http-proxy/tree/caronte) branch as that will be `node-http-proxy` 1.0 in the near future.
",jcrugzz,2013-12-18 11:49:52
529,2013-12-10 11:37:08,"Jarrett, I'm experiencing this with the caronte branch. It is a serious
enough bug (and easy enough to fix) to be worth holding 1.0 just a minute
longer I think.

On Tue, Dec 10, 2013 at 12:36 AM, Jarrett Cruger
notifications@github.comwrote:

> @boutell https://github.com/boutell and @fabiosantoscodehttps://github.com/fabiosantoscodeif you haven't already, check out the
> caronte https://github.com/nodejitsu/node-http-proxy/tree/carontebranch as that will be
> node-http-proxy 1.0 in the near future.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/529#issuecomment-30201042
> .

## 

Tom Boutell
P'unk Avenue
215 755 1330
punkave.com
window.punkave.com
",boutell,2013-12-18 11:49:52
529,2013-12-10 12:28:50,"Although it is indeed serious, I don't think it is trivial to fix. After
all, this proxy can forward the request to another proxy (and in that case
should send the absolute URL) or to a server (and in that case not send the
absolute URL, to fix their assumptions).

I will try out the caronte branch.
",fabiosantoscode,2013-12-18 11:49:52
529,2013-12-10 12:56:21,"That is true, there needs to be appropriate behavior based on whether this
is a forward to another proxy or not, and that means proxy.web has to be
told that, and right now there's no provision to tell it so. So it's an API
change.

Trivial or not though, I don't think it makes sense to ship a ""1.0"" version
of a proxy that demonstrably will fail with Express sessions, socket.io and
lots of non-node technologies in frequently encountered combinations.
Better to hold up and address it.

On Tue, Dec 10, 2013 at 7:28 AM, F√°bio Santos notifications@github.comwrote:

> Although it is indeed serious, I don't think it is trivial to fix. After
> all, this proxy can forward the request to another proxy (and in that case
> should send the absolute URL) or to a server (and in that case not send the
> absolute URL, to fix their assumptions).
> 
> I will try out the caronte branch.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/529#issuecomment-30221465
> .

## 

Tom Boutell
P'unk Avenue
215 755 1330
punkave.com
window.punkave.com
",boutell,2013-12-18 11:49:52
529,2013-12-10 13:28:42,"@boutell that was not my implication, I just wanted to make sure you guys were trying the newest code :). Im sure @yawnt will be on it. If you can post a gist of the smallest reproducible case, this will be extremely helpful in developing a test and figuring out a solution!
",jcrugzz,2013-12-18 11:49:52
529,2013-12-10 15:37:42,"Smallest reproducible case:

https://gist.github.com/fabiosantoscode/349a8d29d3bdf109c78c

It's unfortunate that the API will be one option more complicated just because there's too much stuff not implementing this correctly.

We should report this problem when we see it in the real world.
",fabiosantoscode,2013-12-18 11:49:52
529,2013-12-10 15:50:37,"Real world cases cited here so far:

Wordpress
Express/Connect session middleware (many node-powered sites)
socket.io's built-in asset server

This is a duplicate of #416 which cites pages on dailymotion.

Re: the spec, that bit says in full:

""To allow for transition to absoluteURIs in all requests in future versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies.""

Emphasis on that last bit. The servers that don't like the absolute URI are most in the wrong here, but we're not doing all that hot either because we're generating absolute URIs when not talking to (another) proxy.
",boutell,2013-12-18 11:49:52
529,2013-12-18 11:49:52,"apologies for the delay, should be fixed in 9e74a63

@fabiosantoscode i used the test case you provided and now it's correctly sending ""/"" instead of the full path :)
",yawnt,2013-12-18 11:49:52
529,2013-12-18 14:14:11,"With this closed, do we need to open a new issue on support for being downstream from another proxy? That has the opposite issue: an absolute URL is required.
",boutell,2013-12-18 11:49:52
529,2013-12-18 15:54:04,"i would be happy to accept a pull request regarding that, or a test case which outlines the issue :)
",yawnt,2013-12-18 11:49:52
529,2013-12-18 16:10:49,"It doesn't affect me at all personally, but it seemed only honest to point
it out (:

On Wed, Dec 18, 2013 at 10:54 AM, yawnt notifications@github.com wrote:

> i would be happy to accept a pull request regarding that, or a test case
> which outlines the issue :)
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/529#issuecomment-30852747
> .

## 

Tom Boutell
P'unk Avenue
215 755 1330
punkave.com
window.punkave.com
",boutell,2013-12-18 11:49:52
528,2013-12-02 16:44:53,"Could someone advise how to implement the following case using node-http-proxy?
Use case: 
A server is master server, B server is slave server.
if B server is up and running, A server will forward all request to B server.
if B server is down, A server will handle the request by itself ?
",TonyLuo,2013-12-03 10:20:47
528,2013-12-03 10:20:47,"you can do something like this

<S_CODE_TOKEN>
",yawnt,2013-12-03 10:20:47
528,2013-12-03 16:53:45,"Thanks so much for yawnt's comment. 
Seems node-http-proxy doesn't have the proxy.web function, do you have any sample code for this? I am so new to this... 
",TonyLuo,2013-12-03 10:20:47
528,2013-12-03 18:13:05,"hi! i was referring to ""proxy"" as in ""your proxy instance"" .. the code i used is from the ""caronte"" branch which is the refactoring of node-http-proxy :)
",yawnt,2013-12-03 10:20:47
527,2013-11-30 05:04:28,"I'm getting errors that look like this happening every hour or two, causing systemd to restart my nodeProxyServer.js script:

<S_CODE_TOKEN>

May it be related to node-http-proxy, or something else?
",trusktr,2014-12-01 15:20:42
527,2013-11-30 12:04:06,"can you paste me an issue that demonstrates the problem? also are you using `caronte` or the `master` branch?
",yawnt,2014-12-01 15:20:42
527,2014-09-24 09:19:20,"I also encounter the issue.

I'm using sample code from the README:

<S_CODE_TOKEN>

One way to reproduce is to refresh the page many times really quickly (hold down refresh keys). The 'socket hang up' error kills the process if not handled correctly.

**EDIT** The issue appears to be caused by this line: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-incoming.js#L127 - It looks like Node.js always throws an error when you call req.abort().
I think ideally Node.js shouldn't raise an error there because the abort() in this case is fully intentional - Errors should only be raised when an unexpected condition occurs.
",jondubois,2014-12-01 15:20:42
527,2014-09-24 17:36:44,"@jondubois You should listen on the error event for the proxy so that you can handle the errors and return proper responses when hitting this case. It is most likely triggered because there are not anymore sockets to be used and there is no socket pooling by default.
",jcrugzz,2014-12-01 15:20:42
527,2014-09-30 16:25:36,"I noticed that when I revert back to the 0.10.x version I don't encounter this problem.  It looks like 1.x.x was a fairly significant rewrite, so it's tough to say what may have changed that could be causing this issue.  Perhaps someone more familiar with codebase could comment?
",seglo,2014-12-01 15:20:42
527,2014-09-30 16:56:19,"@seglo in `0.10.x` there was a `proxyError` event that was emit when something happened with the conenction so there could be a response sent to the client. This is now an `error` event. For example usage, see [here](https://github.com/jcrugzz/proxy-server/blob/master/index.js#L53-L65). The error event should not go unhandled, its the default behavior of the EventEmitter to throw when it has no listeners.
",jcrugzz,2014-12-01 15:20:42
527,2014-09-30 18:56:20,"@jcrugzz I see, OK I'll start handling that.  Are you saying that with `0.10.x` a proxyError event would be raised, but is internally handled?
",seglo,2014-12-01 15:20:42
527,2014-09-30 19:25:50,"@seglo in `0.10.x` a `proxyError` event would be raised but it wouldn't crash the server if it wasn't handled. You just wouldn't properly respond to clients who disconnect if you didn't handle the event
",jcrugzz,2014-12-01 15:20:42
527,2014-09-30 22:10:17,"I feel that this error isn't very useful at all for the following reasons:
- It happens predictably every time a connection is intentionally aborted by the client (can be quite often)
- There is no way to 'properly respond to clients' since the connection is now closed so when this error happens, there is no way to inform the client anyways (all we can do is log it).

Also using an agent for socket pooling doesn't fix the issue.

In my particular project (which makes use of http-proxy internally), for a while, I was just logging the error (not doing anything else) but it seemed to cause confusion among some developers who thought that it was an actual error that they needed to handle.

Unlike other Node.js errors, this error appears to be completely harmless - It doesn't cause any side effects if you ignore it (I've tested this for a while) - No memory leaks. I feel that exceptions are not exceptions if they happen predictably during a common use case of the system (in this case, aborting the connection). I think it's more of a Node.js issue than an http-proxy issue - I was able to reproduce this issue in Node by creating a client request and then aborting the connection (it would throw an error whenever I called req.abort()).
",jondubois,2014-12-01 15:20:42
527,2014-10-01 00:37:16,"@jcrugzz Thanks for the example.  I've made the appropriate updates to my project.
",seglo,2014-12-01 15:20:42
527,2014-10-01 00:42:33,"@jondubois my explanation was how the `error` event in general should be handled. In node the semantics in various libraries are never consistent. Socket hangups don't only happen with that particular edge case you ran into. Do you have a gist of that consistent reproducible case? Im curious how its hitting the code paths in node core. 
",jcrugzz,2014-12-01 15:20:42
527,2014-11-29 11:01:29,"Hi I just upgraded to version 1.7.0 of http-proxy and getting following error at random occasions. 

Error: socket hang up at createHangUpError (http.js:1472:15) at Socket.socketCloseListener (http.js:1522:23) at Socket.EventEmitter.emit (events.js:95:17) at TCP.close (net.js:465:12)

Node.js : 0.10.28
Express : 4.4.2

I want to avoid these failed calls.
",ashu-daffodil,2014-12-01 15:20:42
527,2014-11-30 09:55:32,"Same here.

<S_CODE_TOKEN>

Node.js: 0.10.26
Express: 4.10.4 and 4.8.5
",WooDzu,2014-12-01 15:20:42
527,2014-12-01 03:39:00,"@ashu-daffodil can you specify what your code is doing? There was nothing in the latest release that affects how errors are handled. To me, both you and @WooDzu seem to not be handling errors when the destination you are proxying to kills the socket for whatever reason. I cannot really reason about this without a small reproducible code sample.

I general, the expectation should be to get these types of errors when there are legitimate network failures or the server you are proxying to goes down. Errors need to be handled in these cases. Please see my example [`proxy-server`](https://github.com/jcrugzz/proxy-server/blob/master/index.js#L53-L65) to see how errors are handled. This ensures clients are responded to when the destination is having issues.
",jcrugzz,2014-12-01 15:20:42
527,2014-12-01 05:28:34,"@jcrugzz 
I'm even getting hangups while loading images and css besides queries and other services.

REQUESTS :
req >> /images/user.png
req >> /js/lib/text-angular.min.js

ERROR :
Error: socket hang up at createHangUpError (http.js:1472:15) at Socket.socketCloseListener (http.js:1522:23) at Socket.EventEmitter.emit (events.js:95:17) at TCP.close (net.js:465:12)

Error handling CODE :

var proxy = httpProxy.createProxyServer({});
proxy.on('error', function (err, req, res) {
    maintainErrorLogs(err, req, res);
});
process.on('uncaughtException', function (err) {
    maintainErrorLogs(err);
});
function maintainErrorLogs(error, req, resp) {
    var reqInfo = """";
    if(req){
        reqInfo = ""req >> ""+req.url+"">>>host>>>""+req.headers.host;
    }
    getCollection(Config.LOGTABLE, Config.LOG_DB, function (err, logCollection) {
        if (err) {
            printError(error, err, reqInfo,req, resp);
        } else {
            logCollection.insert({""errorTime"": new Date(),reqInfo:reqInfo, error: error.stack || error.message || error}, function (err) {
                printError(error, err, reqInfo,req, resp);
            })
        }
    })
}
function printError(mainError, dbError, reqInfo,req, resp) {
    if(reqInfo && req){
        console.error(reqInfo);
    }
    if (mainError) {
        console.error(""Error in ProxyServer : "" + mainError.stack || mainError.message || mainError);
    }
    if (dbError) {
        console.error(""Error in ProxyServer (DB): "" + dbError.stack || dbError.message || dbError);
    }
    if(resp){
        resp.writeHead(500, {
            'Content-Type': 'text/plain'
        });
        resp.end('Something went wrong during redirection. We are reporting an error message.');
    }
}
",ashu-daffodil,2014-12-01 15:20:42
527,2014-12-01 15:20:42,"@ashu-daffodil this is most likely a path issue, you should log the path that is trying to be requested through the proxy and debug backwards from there. This is not a bug with `http-proxy` itself. Closing this issue as there is no bug related, errors just need to be handled.
",jcrugzz,2014-12-01 15:20:42
527,2015-07-10 11:07:12,"Same problem here: `Error { [Error: socket hang up] code: 'ECONNRESET' }`.

The cose is: 

<S_CODE_TOKEN>
",bitliner,2014-12-01 15:20:42
527,2017-03-01 11:28:37,"`
const targetUrl = config.apiHost + config.apiPort;
const proxy = httpProxy.createProxyServer({
  target: targetUrl
});
// Proxy to API server
app.use('/api', (req, res) => {
  console.log(req.originalUrl);
  console.log(targetUrl);
  proxy.web(req, res, {target: targetUrl});
});`

Why http proxy send a request to the right address, and receives 404, and if you open the same address through brouser gets json.
checked through console.log the issue the required address",NightFury2,2014-12-01 15:20:42
526,2013-11-30 04:26:53,"How do you turn on logging? I'm not running from command line, I'm require()ing it.
",trusktr,2013-11-30 05:02:57
526,2013-11-30 05:02:57,"Wait, nevermind, I think I found it. I'm running node-http-proxy as a systemd service, so using the command `journalctl --unit=nodeProxyServer` (where nodeProxyServer is the name I've given to the unit) shows relevant error output.
",trusktr,2013-11-30 05:02:57
525,2013-11-29 05:05:08,"Hello, sorry if this isn't the right place to ask this, but, how can I actually measure how much bytes are being sent/received for a specific domain? 

For example: 

I've set 3 servers on the route table.

website1.com -> localhost:3001
website2.com -> localhost:3002
website3.com -> localhost:3003

I want to calculate how much bandwidth is taken for each host per-request (I'll sum them later)

Request 1 to website1.com:
-> Request = 384 bytes (header + body)
-> Response = 658 bytes (header + body)

Request 2 to website1.com
-> Request = 460 bytes (header + body)
-> Response = 1560 bytes (header + body)

Basically I need to calculate how much bandwidth is being takes for each host, and since I'm using node-http-proxy to actually serve them from the same server/port (80), I find it easier to calculate this inside the proxy application. How can I accomplish this? 
",WoLfulus,
524,2013-11-27 22:08:40,"I am using caronte, node 0.10.22, and proxying sockjs connections to another host. These requests are xhr_streaming, not actual web sockets, because we cannot use real web sockets in production.

Using the older http-proxy, when I close a browser window, I see the sockjs close event fire. With the new caronte branch, the socket seems to stay open forever.

I added some debug code and the socket stays in readyState=1.

I tried disabling the agent, creating a new agent, and no matter what it is still the same result. Any ideas as to what I should check next?
",niahmiah,
524,2013-11-27 23:37:32,"can you give me a snippet that reproduces the issue? thanks
",yawnt,
524,2013-11-28 00:37:49,"https://gist.github.com/niahmiah/7685529

If you connect to the unproxied port in the browser (9000), and close the tab, you will see the node console state that the connection has been closed.

If you connect to the proxied port (8000), close the tab, the socket does not fire the close event.
",niahmiah,
523,2013-11-27 15:34:08,"I'm having some troubles getting the websocket proxy to work with 0.10.x (.22 currently).

With the main branch, things do not work at all. This is expected, as you mention in your readme that it only works with 0.8.x

So I switched to the `caronte` branch. Connection is forwarded to the endpoint and kept open as long as the client is connected, but NO data is being transmitted in either direction. Are there some API changes anywhere that I might have overlooked?

Using it like this:

<S_CODE_TOKEN>
",Tharit,2013-11-28 12:30:28
523,2013-11-27 23:40:24,"hey,

the api for caronte is `proxy.ws` so i'm not exactly sure what you're using :D
",yawnt,2013-11-28 12:30:28
523,2013-11-28 12:30:02,"Doh.. my bad. Seems like I somehow managed to repeatedly end up cloning the wrong branch without me noticing.
Thanks ;-)
",Tharit,2013-11-28 12:30:28
522,2013-11-22 09:56:51,"in my project, my backend server give me a 302, but proxy show me a 200.
i find it didnot work just call res.writeHead(response.statusCode);
 and need set res.statusCode.
",xudejian,2013-12-08 07:30:32
522,2013-12-08 07:30:32,"This feels wrong. Can you please provide a failing test illustrating why this is correct?
",indexzero,2013-12-08 07:30:32
522,2013-12-10 10:19:09,"it my fault, actually i use it with connect-livereload in my Gruntfile.js, it the connect-livereload's bug, the api  res.writeHead has been stub in connect-livereload.
",xudejian,2013-12-08 07:30:32
521,2013-11-21 17:34:21,"I struggled to get the section about using https to http with two certificates to work, because I didn't understand where the myCert etc. came from. Once I realised they had to be created by the user I could get it working. I want to save someone else the time it took me.
",derekdreery,2013-12-27 07:10:25
520,2013-11-19 17:34:25,"I just rewrite the examples, just using as base the old examples, so I updated all this examples according to the new improvements and the new api of node-http-proxy.

Review and merge

CC: @yawnt 
",cronopio,2013-12-18 18:03:46
520,2013-11-19 17:37:33,"[![Coverage Status](https://coveralls.io/builds/327909/badge)](https://coveralls.io/builds/327909)

Coverage remained the same when pulling **db11bb41c6841c6645b7a47aef24bff54023cfe9 on better-examples** into **83367e7e91c88cfce7adbd2bb7935bdd9f1ba3e7 on caronte**.
",coveralls,2013-12-18 18:03:46
520,2013-11-19 17:41:01,"[![Coverage Status](https://coveralls.io/builds/327917/badge)](https://coveralls.io/builds/327917)

Coverage remained the same when pulling **a3ed7558ad98a9ceeb9df376b6421702573ca2a7 on better-examples** into **83367e7e91c88cfce7adbd2bb7935bdd9f1ba3e7 on caronte**.
",coveralls,2013-12-18 18:03:46
520,2013-11-27 15:35:50,"[![Coverage Status](https://coveralls.io/builds/345021/badge)](https://coveralls.io/builds/345021)

Coverage decreased (-0.2%) when pulling **bac210f5635b36fcb60ec05a50169a305590251d on better-examples** into **83367e7e91c88cfce7adbd2bb7935bdd9f1ba3e7 on caronte**.
",coveralls,2013-12-18 18:03:46
520,2013-11-27 22:05:18,"[![Coverage Status](https://coveralls.io/builds/345869/badge)](https://coveralls.io/builds/345869)

Coverage decreased (-0.2%) when pulling **db952d16fc8d7b004c0dd8abea7a3d365aece0e5 on better-examples** into **83367e7e91c88cfce7adbd2bb7935bdd9f1ba3e7 on caronte**.
",coveralls,2013-12-18 18:03:46
520,2013-11-27 23:37:55,"Ok there is a very weird trouble in `test/examples-test.js`, if I run it alone all the tests pass, but running all the suite using `npm test` give a trouble trying to require socket.io

**TypeError: Cannot set property 'XHR' of undefined**

The last part of the stack trace show this:

<S_CODE_TOKEN>
",cronopio,2013-12-18 18:03:46
520,2013-12-09 17:35:41,"[![Coverage Status](https://coveralls.io/builds/369629/badge)](https://coveralls.io/builds/369629)

Coverage decreased (-0.2%) when pulling **89a00c0e30c98701e9dc67a557182c36ce70294c on better-examples** into **83367e7e91c88cfce7adbd2bb7935bdd9f1ba3e7 on caronte**.
",coveralls,2013-12-18 18:03:46
520,2013-12-09 19:59:59,"Ready for review and merge

cc: @yawnt @indexzero 
",cronopio,2013-12-18 18:03:46
520,2013-12-18 11:06:22,"@cronopio looks good but i the travis CI build is failing, if you fix that we can merge :)
",yawnt,2013-12-18 18:03:46
520,2013-12-18 14:30:46,"@yawnt Thank you. Seems that there is a trouble running the coveralls script. Can I drop it from the `.travis.yml` and just set the `npm test` script?
",cronopio,2013-12-18 18:03:46
520,2013-12-18 14:57:12,"Actually I think there is the same trouble in `caronte` branch. Seems there is a trouble running the coveralls script using node `0.10` and break very bad using `0.11`
",cronopio,2013-12-18 18:03:46
520,2013-12-18 15:52:50,"damn,sucks.. okay drop it T_T
",yawnt,2013-12-18 18:03:46
520,2013-12-18 16:35:15,"Oh. Seems that this commit 9e74a633a75d466cf266b1c57c68edd20a883f69 break the tests. I'll investigate and fix it before the merge. I'll let you know when is ready to merge
",cronopio,2013-12-18 18:03:46
520,2013-12-18 17:09:12,"okay, but i don't think it's related.. it's such an insignificant addition to the codebase :\
",yawnt,2013-12-18 18:03:46
520,2013-12-18 17:34:56,"Ok, I fixed the stuff and rebase it.

Now travis is failing due another stuff. This is ready to merge
",cronopio,2013-12-18 18:03:46
520,2014-01-07 16:49:54,"For what it's worth, I have gotten caronte to work for my use case.  See https://gist.github.com/risacher/8302220
",risacher,2013-12-18 18:03:46
520,2014-01-07 18:36:35,"@risacher Oh thanks! that is helpful, I'll take a deep look in a few hours, maybe you can format it like the examples I made and then open a pull request :wink: 
",cronopio,2013-12-18 18:03:46
519,2013-11-19 07:08:42,"This PR is based on https://github.com/nodejitsu/node-http-proxy/pull/376, with the following changes:
- Rebased off of latest master
- Added support for reverse-proxying HTTP 303 and 307 responses
",provegard,2013-12-27 07:17:29
519,2013-12-27 07:17:29,"The `reverse-proxy-helper` is pointless. Just use the `url` module. It ships with node.js core.
",indexzero,2013-12-27 07:17:29
518,2013-11-18 23:07:22,"Websockets have sockets, not responses.
",bfirsh,2013-11-18 23:27:23
518,2013-11-18 23:08:37,"[![Coverage Status](https://coveralls.io/builds/326184/badge)](https://coveralls.io/builds/326184)

Changes Unknown when pulling **cb7af4f4d76744cd3348297ce8284e97d17c9304 on bfirsh:fix-ws-error-handling** into *\* on nodejitsu:caronte**.
",coveralls,2013-11-18 23:27:23
518,2013-11-18 23:27:27,"thanks!
",yawnt,2013-11-18 23:27:23
517,2013-11-15 00:58:05,"I have a use case where I accept a https connection, and need to stitch on a client certificate for the endpoint. I tried doing something like:

<S_CODE_TOKEN>

But after some research it appears after digging through the code that you guys expect that be ONLY a bool. Is there anyway to do what I am trying to achieve? If not if I get some spare cycles and make a patch would it be accepted?
",cstockton,2014-01-31 00:24:43
517,2014-01-31 00:24:43,"@cstockton this is available in the new master branch. See my response in #563 
",jcrugzz,2014-01-31 00:24:43
516,2013-11-12 22:43:57,"As instructed by @jcrugzz I tried this against the caronte branch. Same code, same result.

Using the proxy as a straight HTTP proxy works fine for most URLs but I find I'm getting 400 Bad Request from one particular server.

This pattern of using the proxy, a standard client proxy, isn't that easy to work out from the examples. I don't want to proxy an internal server, I want to proxy requests going to outbound servers, look at the requests and either log them or potentially change them on the way through. Though I'm not doing any of this in the test stub below.

Is there something I'm doing wrong with the proxy setup? It's strange that it works everywhere else except this one server.

Test stub I'm using:

<S_CODE_TOKEN>

Using curl I get a 500 server error:

<S_CODE_TOKEN>

Oddly, with Firefox I get a 400 Bad Request error:

<S_CODE_TOKEN>
",shermozle,
516,2013-11-12 22:55:09,"@shermozle you must be using the wrong branch or not the right code. You can install it with `npm install ""git://github.com/nodejitsu/node-http-proxy#caronte""`. The api is not the same so the code you have posted will not work. See the new [readme](https://github.com/nodejitsu/node-http-proxy/tree/caronte#core-concept)
",jcrugzz,
516,2013-11-12 23:18:18,"Okay done that. Now trying to make some sense of the examples. I don't see
how I can specify the destination server depending on the request. i.e.,
how to create a standard HTTP proxy, not an application reverse proxy.

On 13 November 2013 09:55, Jarrett Cruger notifications@github.com wrote:

> @shermozle https://github.com/shermozle you must be using the wrong
> branch or not the right code. You can install it with npm install ""git://
> github.com/nodejitsu/node-http-proxy#caronte"". The api is not the same so
> the code you have posted will not work. See the new readmehttps://github.com/nodejitsu/node-http-proxy/tree/caronte#core-concept
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/516#issuecomment-28342350
> .

## 

Simon Rumble simon@simonrumble.com
www.simonrumble.com
",shermozle,
516,2014-01-22 20:27:19,"@shermozle sorry for the late response. Check out the ProxyTable API example in our [blog post](https://blog.nodejitsu.com/node-http-proxy-1dot0/). Let me know if you have anymore questions!
",jcrugzz,
515,2013-11-12 01:41:32,"Using the proxy as a straight HTTP proxy works fine for most URLs but I find I'm getting 400 Bad Request from one particular server.

This pattern of using the proxy, a standard client proxy, isn't that easy to work out from the examples. I don't want to proxy an internal server, I want to proxy requests going to outbound servers, look at the requests and either log them or potentially change them on the way through. Though I'm not doing any of this in the test stub below.

Is there something I'm doing wrong with the proxy setup? It's strange that it works everywhere else except this one server.

Test stub I'm using:

<S_CODE_TOKEN>

Using curl I get a 500 server error:

<S_CODE_TOKEN>

Oddly, with Firefox I get a 400 Bad Request error:

<S_CODE_TOKEN>
",shermozle,2013-11-12 06:57:07
515,2013-11-12 06:57:07,"@shermozle hey, the current master of `node-http-proxy` does not work with `node 0.10.x`. We recommend checking out the [`caronte`](https://github.com/nodejitsu/node-http-proxy/tree/caronte) branch which will be `node-http-proxy 1.0` very soon :). Please open another issue if you run into any troubles!
",jcrugzz,2013-11-12 06:57:07
515,2013-11-12 21:49:49,"Hey Jarrett. Same problem with that branch. Want me to open a brand new issue?
",shermozle,2013-11-12 06:57:07
515,2013-11-12 22:38:30,"@shermozle yea open a new issue with the new code snippets, ill tag it appopriately :)
",jcrugzz,2013-11-12 06:57:07
514,2013-11-11 19:30:41,"(informational/possible-feature-request)

Is there any mechanism available to retry a proxy request based on the proxy response? 

Example 1: Suppose I want to do some authN negotiation in the proxy; the internal server sends a 401, upon which I would like to inject some appropriate additional info into the headers, etc. and retry the proxy request.

Example 2: Suppose I'm creating a load-balancer, and I have some custom criteria to determine whether a given internal server is 'down'; when a server is down, I want to mark it and retry the request against a different internal server.

Are these cases possible? 
",matt-deboer,2013-11-11 20:09:46
514,2013-11-11 20:09:46,"Hi!

The `caronte` branch (which is a 0.10.x refactoring of node-http-proxy) in this repo provides a callback API

<S_CODE_TOKEN>
",yawnt,2013-11-11 20:09:46
513,2013-11-08 20:16:42,"`node-http-proxy@1.0.0` is has a number of features removed and a (few) breaking changes. It makes the library leaner and more ""node-like"" but we _have to make sure to ensure the same high quality examples and documentation._
## Examples

We either need a working example file or a reason why we're dropping this example for all of these files:
- [x] examples/balancer/simple-balancer-with-websockets.js
- [x] examples/balancer/simple-balancer.js
- [x] examples/http/basic-proxy.js
- [x] examples/http/concurrent-proxy.js
- [x] examples/http/custom-proxy-error.js
- [x] examples/http/forward-proxy.js
- [x] examples/http/latent-proxy.js
- [x] examples/http/proxy-https-to-http.js
- [x] examples/http/proxy-https-to-https.js
- [ ] examples/http/proxy-table.js
- [x] examples/http/standalone-proxy.js
- [x] examples/middleware/bodyDecoder-middleware.js
- [x] examples/middleware/gzip-middleware-proxytable.js **_(wont fix)_**
- [x] examples/middleware/gzip-middleware.js
- [x] examples/middleware/jsonp-middleware.js **_(wont fix)_**
- [x] examples/middleware/modifyResponse-middleware.js
- [x] examples/middleware/url-middleware.js **_(wont fix)_**
- [x] examples/middleware/url-middleware2.js **_(wont fix)_**
- [x] examples/websocket/latent-websocket-proxy.js
- [x] examples/websocket/standalone-websocket-proxy.js
- [x] examples/websocket/websocket-proxy.js
## Documentation
- [x] Setup a basic stand-alone proxy server
- [x] Setup a stand-alone proxy server with custom server logic
- [x] Setup a stand-alone proxy server with latency (e.g. IO, etc)
- [x] Proxy requests within another http server
- [x] Listening for proxy events
- [x] Using HTTPS
- [x] Proxying to HTTP from HTTPS
- [x] Using two certificates
- [x] Proxying to HTTPS from HTTPS
- [x] Proxying WebSockets
- [x] with custom server logic
- [x] Configuring your Socket limits
- [x] POST requests and buffering
- [x] Double check API & method documentation in code
#### Dropped
- Proxy requests using a ProxyTable
- Proxy requests using a 'Hostname Only' ProxyTable
- Proxy requests using a 'Pathname Only' ProxyTable
- Middleware
## Upgrade Guide
- [x] No more `ProxyTable`
- [x] No more middleware

cc/ @cronopio @yawnt
",indexzero,2014-01-11 12:39:50
513,2014-01-11 12:39:50,"This is done. Good work @yawnt @cronopio 
",indexzero,2014-01-11 12:39:50
512,2013-11-06 10:50:39,"Hi, guys!

I have been struggling with http-proxy for a couple of days already and I'd appreciate it much if one of you could help me to configure it properly.

What I am doing is I am trying to create an open-source framework for UI testing based on Karma+Jasmine+FuncUnit. To make JavaScript able to make interactions on pages (e.g., driving elements) I need to proxy these pages to localhost first (due to Same Origin Policy restrictions).

I tried to do that using included in Karma proxying, but then found out that it doesn't work fine for many https pages (e.g., for https://www.ozon.ru/context/cart/). When I open this page via proxy (e.g., as localhost:9001/context/cart/), browser gets redirected to a real url (https://www.ozon.ru/context/cart/).

I hope, http-proxy will help me to avoid this problem, but now (after carefull reading of documentation) I am still running into difficulties with http-proxy configuration. I'd like to run my proxy from the command line, or, better, using a config file. The problem is I can't figure out the correct arguments to proxy (forward) pages and subpages from https://www.ozon.ru to, for example, localhost:9001. Would you, please, help me to create a configuration file? Will http-proxy help me to avoid ""redirecting proxied https urls to the original"" issue described above?

Looking forward to your reply
",andrei-khveras,
512,2013-11-22 10:55:44,"+1 I was having the same problem. Ended by writing this small proxy server in Node.js that makes use of requests's followRedirect option. Sharing the code in this gist if it could come in handy for you:
https://gist.github.com/olafurnielsen/8527c17237eeb3c6f785
",olafurnielsen,
511,2013-11-05 21:34:21,"@cronopio Running `npm test` gives me the following failures.. Let me know if Im doing something wrong.

<S_CODE_TOKEN>
",jcrugzz,2013-11-07 20:31:38
511,2013-11-07 20:10:44,"I fixed the tests, please be sure to use the dependencies in correct versions and run again the suite.
",cronopio,2013-11-07 20:31:38
510,2013-11-05 21:06:09,"All of this options parsing that is found [here](https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/http-proxy/index.js#L43-L64) is not being utilized. We are extending the global `this.options` but not passing them into any of the `passes`. I will see if the fix is as trivial as it seems otherwise I'll let you handle it @yawnt.
",jcrugzz,2013-11-05 21:33:30
510,2014-02-01 18:52:49,"This issue is still present ( I am using node v0.10.25 and http-proxy v1.0.2 ). 

Why it has been closed ?
",pmalek,2013-11-05 21:33:30
510,2014-02-01 19:04:12,"@pmalek can you show me a `gist` of a reproducing test case?
",jcrugzz,2013-11-05 21:33:30
510,2014-02-01 19:08:28,"@jcrugzz something like this https://gist.github.com/pmalek/8756997 although I have tried many more options to pass in there but all the time I get the same issue

<S_CODE_TOKEN>
",pmalek,2013-11-05 21:33:30
510,2014-02-01 19:25:36,"@pmalek look at the [`httpProxy.createServer(options)`](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy.js#L33-L55) function. It only takes an options argument and expects a full URL to proxy to. See the examples in the readme to see that a `target` is always a string to be parsed with the `url` module.
",jcrugzz,2013-11-05 21:33:30
510,2014-02-01 19:42:26,"@jcrugzz I have changed my options to look like this : 

<S_CODE_TOKEN>

and my `createServer` to 

<S_CODE_TOKEN>

( I have tried to remove the `ws`, `secure` and `xfwd` options) and now I do not get the aforementioned error but the page on `localhost:80` keeps loading as in an infinite loop ( I have my server listening on port `443` and I can see the http-proxy being created on port `80`)
",pmalek,2013-11-05 21:33:30
510,2014-02-01 20:01:33,"@pmalek Got it so there is a slight caveat here because of how the `ssl` options are used. See my response in #563. They are used as the server cert information in this case AND used as a client cert when trying to proxy. This is obviously not what you want as you are just running it as an `https` server that you want to proxy via http. This is not how it behaves. You may also want `secure` set to false as I'm assuming this is a self signed cert (but I'm not positive in how it behaves in regards to localhost so it may not throw an error).

Since I have not figured out a clean way to make this more clear without making `sslServer` and `sslClient` options. I would just create a standard `https` server and use `httpProxy` as just a proxy (so you dont call the listen function).
",jcrugzz,2013-11-05 21:33:30
510,2014-02-01 20:32:04,"@jcrugzz Can you provide a `gist` how should I use it as I do not really understand what would be there for me if I throw away `.listen(80);` from it ?

BTW: I already have an https server, that's what I need this proxy to redirect all of the clients to go from `localhost:80` to `localhost:443`.
",pmalek,2013-11-05 21:33:30
510,2014-02-01 21:24:25,"@pmalek ok lets back up a second, I misunderstood the use case. I thought you were proxying the other way around for whatever reason. What is the exact purpose of your proxy in this case? Until then I'll take a stab at what you MIGHT want.

<S_CODE_TOKEN>
",jcrugzz,2013-11-05 21:33:30
510,2014-02-01 21:53:48,"@jcrugzz My exact intentions are as follows: 

I have a working sails web server on port `443` using https. I would like to make a proxy (redirect clients coming on port `80`) to force usage of https at port `443`. 

So I thought using a `node-httpp-proxy` which would redirect all traffic from port `80` to `443` is a good idea. 

I have tried your solution and I have the following error : 

<S_CODE_TOKEN>

After that I have tried to change `secure: true` to `secure: false` and now it works but! on `http`. So I can access my server on both `http` (port `80`) and `https` (port `443`).

Yet still I would like to redirect clients to `https` while connecting to port `80`.

I have found this connected case https://github.com/mikeal/request/issues/418 and SO question https://stackoverflow.com/questions/14088787/hostname-ip-doesnt-match-certificates-altname which suggest to use 

<S_CODE_TOKEN>

or 

<S_CODE_TOKEN>

while passing arguments to tls server but those didn't work for me (still the error).
",pmalek,2013-11-05 21:33:30
510,2014-02-01 22:09:06,"@pmalek the problem is what I outlined in #563 regarding self signed certs. Since you were supplying the ssl credentials I thought this wouldn't be an issue but I was wrong ;). You need an agent in order for `secure: false` to work (as it uses `rejectUnauthorized: false` under the hood).

<S_CODE_TOKEN>
",jcrugzz,2013-11-05 21:33:30
510,2014-02-01 22:19:41,"@jcrugzz I get this ""loop"" (no response/timeout) again on port `80`.

So let's summarize: 
- with `secure: false` I can access the website both on port `80` (using `http`) and `443` (using `https`),
- using `secure: true` I get `Error: DEPTH_ZERO_SELF_SIGNED_CERT` on port `80` but can access website through `https` on port `443` without any problems
- with `agent: new Agent({ maxSockets: Infinity })` and no matter what `secure` is set to I get loop on port `80` and service ok on `443`
",pmalek,2013-11-05 21:33:30
510,2014-02-01 22:59:05,"@pmalek hmm ok, my mistake here is that this agent should be an `require('https').Agent` not an `http.Agent in this case. Give that a try but you should be at a point where this is debuggable.
",jcrugzz,2013-11-05 21:33:30
510,2014-02-02 00:29:34,"@jcrugzz This still gave me the same result (or `DEPTH_ZERO_SELF_SIGNED_CERT`) and I have decided to use https://npmjs.org/package/express-force-ssl for this purpose but still I would like to  get that running (for different ports etc.)

Maybe some other time.
",pmalek,2013-11-05 21:33:30
510,2014-02-02 01:33:50,"@pmalek Ensure you still have `secure: false`. There is some odd behavior in this area which is why `0.12.x` will have a refactored `http`. Unless Im misunderstanding something about the behavior of HTTP -> HTTPS proxying, this should work. That module looks like your best bet for now. 
",jcrugzz,2013-11-05 21:33:30
510,2014-02-10 07:13:24,"I'm still getting the same error from the simplest of examples.

<S_CODE_TOKEN>

is coming from

<S_CODE_TOKEN>
",blairn,2013-11-05 21:33:30
510,2014-02-10 07:23:15,"@blairn you are using an old api. And please create a new issue if you are having a problem using the new api :).
",jcrugzz,2013-11-05 21:33:30
510,2014-02-10 07:38:38,"Thanks! 
Is there an example of a plain proxy? Just forwards the traffic onwards (not to a particular place)?
I can't find one in the example set.
",blairn,2013-11-05 21:33:30
509,2013-11-04 21:22:43,"This is in regards to the code found at https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/gzip-middleware-proxytable.js

I've found that it causes some requested resources to come back empty.

This can be seen by comparing http://vimque.com/tag/new which has no compression and the bad router at http://vimque.com:8080/tag/new.

As you can see several of the resources don't load including the css.

I can't find any pattern to what fails but it does seem to be deterministic rather than random and content type doesn't seem to be a factor.

I sort of regret pointing to one of my dumb sites as if I expect help on it but it was the easiest way to illustrate content with the issue.

The code for both are as follows:

<S_CODE_TOKEN>

<S_CODE_TOKEN>

Where options is a valid router table.
",jvonmitchell,2013-11-07 18:24:27
509,2013-11-07 18:17:46,"hi @jvonmitchell ,
you should check out the `caronte` branch in this repo, it's the refactoring of `http-proxy`. 
in the soon-to-be http-proxy@1.0 we dropped  support for `proxy-table` but it's really easy to create a tiny module on the top that works the same way :) !

feel free to reopen the issue if you have problems with that branch :)
",yawnt,2013-11-07 18:24:27
508,2013-11-02 20:54:51,"I need to be able to pass custom HTTP headers to the HTTP server behind this proxy.

For example, look at this guy:
http://blog.nikmartin.com/2013/07/secure-sessions-in-nodejs-with-nginx.html

He adds a few headers to indicate to the receiving server that it is a passthrough, with the real IP address.

How can I do the same with node-http-proxy?

I would assume the proxy should create a X-Forwarded-For header automaticaly (does it).. but additionally add other headers I specify.

What is the best way of doing this?
",Analogreality,
508,2013-11-02 21:47:29,"I am looking at the main beef of the code here:
https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js

There are some juicy parts where I can hook up event listeners.. but I would like to know the BEST usage for them.. I am trying to find explicit documentation on them.
",Analogreality,
508,2013-11-04 19:14:34,"Hi @Analogreality We're working in a total refactor to support node v0.10.x at the [caronte branch](https://github.com/nodejitsu/node-http-proxy/tree/caronte) please take a look of the new way of hook up your own logic, we called ""passes"", by now there is a `xfwd` option that you can set to true to set the x-forward-\* headers [here](https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/http-proxy/passes/web-incoming.js#L63-L78), also you can set your own ""pass"" and make what you want before pipe the request/response.

Hope this help, I'll keep this open until you resolve your doubt
",cronopio,
508,2014-02-11 18:30:40,"@cronopio I'm trying to do something similar (specifically, I want to be able to add CORS headers on the outgoing responses) and I see the passes, but I'm not seeing the proper method to use to add things to the passes?

I'd like to add it after `web-outgoing.writeHeaders` and before `web-outgoing.writeStatusCode`.  Is there any example available somewhere that shows how to do that?
",cheddar,
508,2014-02-11 18:53:58,"Fwiw, I just did a pull request to try to enable this.

https://github.com/nodejitsu/node-http-proxy/pull/582
",cheddar,
508,2015-07-01 10:06:21,"How about ""x-forwarded-host"" ?
",ericfong,
507,2013-11-01 20:02:49,"https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L275

I'm running into an issue where my proxy is not running on default port. So `req.headers.host` is set to `localhost:7070`. This causes the host match to fail at line 275.

For example, I'm running the proxy on `localhost` on port `7070`, forwarding the request to `remotehost` on port `443`. Remote host issues a 301 redirect, setting location header to `https://remotehost/...`. The proxy should rewrite the location header to `http://localhost:7070/...` on the redirect, but it is not because the host does not match (`localhost:7070` vs `localhost`)
",ming-codes,2013-11-07 18:23:36
507,2013-11-07 18:23:36,"hi!
we are in the process of refactoring node-http-proxy to make it compatible with 0.10.x. you should check out [caronte](https://github.com/nodejitsu/node-http-proxy/tree/caronte) and give it a go with that!

feel free to reopen the issue should you face the same problem :)
thanks!
",yawnt,2013-11-07 18:23:36
506,2013-10-28 19:37:03,"I'm at a loss and have tried practically every example in the README.

All I'm trying to do is proxy requests to localhost:9000 to anotherserver.com:80 and return the result. For some reason, the proxy goes to anotherserver.com:80, but the response clearly has an error message saying it's hitting port 9000 on the target server.  What am I doing wrong?

<S_CODE_TOKEN>
",probablyup,2013-10-28 20:24:18
506,2013-10-28 20:24:18,"Hi @Evster88 I just ran your example and works fine. I changed the destiny to something testable to me like `www.nodejs.org` and worked fine.

<S_CODE_TOKEN>

If you experiment some additional issue feel free to reopen this.
",cronopio,2013-10-28 20:24:18
506,2015-02-04 01:37:15,"Don't know if this is related, but I am getting

<S_CODE_TOKEN>

when using this with local addresses, but not with external addresses.
",jtremback,2013-10-28 20:24:18
506,2015-02-04 01:49:19,"@jtremback open a new issue with some code and a more descriptive depiction of what you are doing
",jcrugzz,2013-10-28 20:24:18
505,2013-10-24 18:50:02,"I am using some custom and complex proxy logic on the caronte branch. For http requests, among other things, I add a header `X-Proxy-Rejected: reason` if for some reason I can not find a suitable endpoint to the users request.

I have found this very useful to debug small issues and gain a quick understanding of what is going on for a user. 

Is it possible to do something like this for web sockets since we do not have a response object? Also, on an error I end up calling just `socket.end()` otherwise the websocket on the client side just hangs, is that a correct way to handle this?
",srossross,
504,2013-10-23 07:00:54,"right now we pass just a single agent... but we actually need two.. one for http and one for https 

@cronopio 
",yawnt,2013-12-09 15:40:42
504,2013-10-23 19:28:01,"Ok, I'll investigate that.
",cronopio,2013-12-09 15:40:42
504,2013-12-09 15:40:42,"I just tested using HTTP and HTTPS agents and so far seems working fine, if there is a specific test case I'll take care
",cronopio,2013-12-09 15:40:42
503,2013-10-21 17:08:54,"The web/ws handlers allow a callback to be passed in that will be invoked on error. This callback was never being fired. This change fixes this by invoking the callback if present, otherwise emitting the 'error' event.

Included some new test cases to evaluate this state where the web/ws handlers are being used by an existing server. (ie: `listen` is never called on the proxy)
",mmoulton,2013-10-22 03:48:15
503,2013-10-21 17:10:48,"[![Coverage Status](https://coveralls.io/builds/272290/badge)](https://coveralls.io/builds/272290)

Coverage increased (+2.0%) when pulling **37e390d470e9c39ed51fd9f002bb71c0df810313 on mmoulton:caronte** into **f23bbbaf0ddd41e357504ce9902ddddd556089c4 on nodejitsu:caronte**.
",coveralls,2013-10-22 03:48:15
503,2013-10-21 17:23:41,"lookin good! would you mind moving the tests from the file you created to https://github.com/nodejitsu/node-http-proxy/blob/caronte/test/lib-http-proxy-passes-web-incoming-test.js ? we're trying to keep a 1-1 test-file js-file ratio :)
",yawnt,2013-10-22 03:48:15
503,2013-10-21 19:02:50,"I was working on fixing this some hours ago, thank you so much. I did a test case with an error event handler but I miss the callback test, thanks for add it, follow the patter that @yawnt suggest and we'll merge this asap
",cronopio,2013-10-22 03:48:15
503,2013-10-21 20:56:45,"@yawnt @cronopio I have moved the tests into a single file. Let me know if there is anything else you would like to see. Thanks!
",mmoulton,2013-10-22 03:48:15
503,2013-10-21 21:04:34,"[![Coverage Status](https://coveralls.io/builds/272833/badge)](https://coveralls.io/builds/272833)

Coverage remained the same when pulling **fc1a6dd6e9363ab67a5a3ec2ac86a3529e9ed6cb on mmoulton:caronte** into **5d66ce11bb7eef7e704a2de2c0ef3b5f754843e9 on nodejitsu:caronte**.
",coveralls,2013-10-22 03:48:15
503,2013-10-21 21:54:23,"Got ya. I was assuming that since I was testing from the `createProxyServer` method down and not just the changes I made to web-incoming that you would want them in that file. I can move them if you would like.

On Oct 21, 2013, at 2:48 PM, yawnt notifications@github.com wrote:

> hey @mmoulton, thanks for doing this, although you got the wrong file xD.. i need them to be in https://github.com/nodejitsu/node-http-proxy/blob/caronte/test/lib-http-proxy-passes-web-incoming-test.js since it's where you modified the code :)
> 
> ‚Äî
> Reply to this email directly or view it on GitHub.
",mmoulton,2013-10-22 03:48:15
503,2013-10-21 21:58:34,"it's ok, we'll cherry-picked.. thanks!
",yawnt,2013-10-22 03:48:15
503,2013-10-22 03:48:15,"Cherry-picked. Tests pass, Thanks!
",cronopio,2013-10-22 03:48:15
502,2013-10-20 03:46:47,"Current link for 'valid properties are available here' goes to url:

https://github.com/nodejitsu/node-http-proxy/blob/caronte/tree/master/lib/http-proxy.js#L26-L39

The url works fine if 'tree/master/' is removed, so this is trying to remove that part of the relative path.

The same removal of 'tree/master/' is being made for the 'available here' link that is preceded by ""When a request is proxied it follows two different pipelines"" since it suffers the same issue.

The edited README.md has both links working in my fork with this edit applied.
",jamesmanning,2013-10-20 09:19:58
502,2013-10-20 03:47:52,"[![Coverage Status](https://coveralls.io/builds/269856/badge)](https://coveralls.io/builds/269856)

Coverage remained the same when pulling **bbe2b2788a7ee3c74fd44fe88b6dcf213264436f on jamesmanning:patch-1** into **86750c7e594c419dfae957aaf7e44e61e1d480e8 on nodejitsu:caronte**.
",coveralls,2013-10-20 09:19:58
502,2013-10-20 09:19:55,"Good catch, thanks!
",jcrugzz,2013-10-20 09:19:58
501,2013-10-18 06:50:11,,vishr,2013-10-18 07:34:26
501,2013-10-18 07:34:26,"@vishr `npm install ""git://github.com/nodejitsu/node-http-proxy#caronte""`
",jcrugzz,2013-10-18 07:34:26
500,2013-10-15 15:12:17,,StyMaar,2013-10-15 15:20:41
499,2013-10-14 10:56:16,"README has this example for custom application logic (for caronte tree):

<S_CODE_TOKEN>

I'm getting these errors:

<S_CODE_TOKEN>

I am running node v0.10.20.
",jheusala,2013-10-28 20:35:36
499,2013-10-15 18:26:01,":+1: same issue. Probably solve it by passing an object to http.createProyx...

pass this:

<S_CODE_TOKEN>
",matejkramny,2013-10-28 20:35:36
499,2013-10-15 18:35:28,"I don't think it fixes the actual problem. 

In my case I must change the `proxy.options` each request and the code seems not to support that at the moment. 

The problem is here at [lib/http-proxy/index.js line 76](https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/http-proxy/index.js#L76), there is `cbl ? false : this`, where -- AFAIK -- `this` is the instance of HTTP proxy object `proxy`, which has `proxy.options` but it's not the `options` which is created at [lib/http-proxy/index.js line 48](https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/http-proxy/index.js#L48).

I think it might be fixed by changing that code on line 76 to:

<S_CODE_TOKEN>

...but that feels like a bad kind of workaround.
",jheusala,2013-10-28 20:35:36
499,2013-10-15 18:49:16,"Actually I don't see how that `proxy.options` would be url parsed since it is done at [line 63](https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/http-proxy/index.js#L63) for different `options` which seems not to be in use at all. 

Although it's hard to understand how that could be possible -- nobody is using the code as it is documented?
",jheusala,2013-10-28 20:35:36
499,2013-10-15 20:27:02,"I've tested this workaround and it actually does fix the issue I'm having.

However I don't know which would be best way to fix it in real life. Currently the passes implementation for web does not use anything else but `.options` and `.emit`, so this workaround works at least for it.
",jheusala,2013-10-28 20:35:36
499,2013-10-15 23:53:13,"Now that I rechecked the code for missing `options.xfwd` support I see that all other passes are using `options` -- not instance of `proxy` -- as the third option. Isn't this wrong behavior to be different?
",jheusala,2013-10-28 20:35:36
499,2013-10-16 06:52:08,"sorry for the late answer, i have been refactoring some code and might have inadvertedly broken something.. i'll look into it this afternoon
",yawnt,2013-10-28 20:35:36
499,2013-10-16 11:51:55,"Another issue I noticed was that the code is changing `req.headers` directly which is documented as read only in Node.js 0.10.20 -- although I haven't tested if Node still lets you change them.
",jheusala,2013-10-28 20:35:36
499,2013-10-28 20:35:36,"Using the last commit (f720e36b4208be5a7b55c79f264d19aefb58b65d) from the `caronte` branch show that this is no more an issue. If you saw it again please reopen this.
",cronopio,2013-10-28 20:35:36
499,2013-10-31 03:55:15,"Hi. 

I'm seeing this issue and it seems to revolve around the following code in lib/http-proxy/index.js - line 77. All of the above code uses options, but the very last part references this.options, which is just an empty object. 

<S_CODE_TOKEN>

If I change this.options to just options, it works on my end. 
",wookets,2013-10-28 20:35:36
499,2013-11-02 20:48:19,"The `this.options` is a reference to the options passed to the construction, See https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/http-proxy/index.js#L90 So, if at some point that reference is an empty object so is a bug. Please open a new issue with further information and examples code to reflect the bug.
",cronopio,2013-10-28 20:35:36
499,2013-11-05 21:15:00,"Yes this is a bug, currently filed in #510 
",jcrugzz,2013-10-28 20:35:36
499,2014-06-08 11:04:32,"Why is it closed? The workaround works, but the problem (simply running basic example code from main github page) remains unsolved (Node 0.11.13) 
",q2dg,2013-10-28 20:35:36
499,2014-07-07 20:32:44,"I too am still having this problem
",ksnyde,2013-10-28 20:35:36
499,2014-07-16 04:06:02,"Seeing this issue currently as well
",theak,2013-10-28 20:35:36
499,2014-07-16 16:51:35,"@theak can you post a new issue and give an example of the code you are using? This shouldn't be happening
",jcrugzz,2013-10-28 20:35:36
499,2014-07-16 20:34:07,"Ah, actually turned out to be an issue with how I was calling the code. Everything seems to be working fine now- false alarm :+1: 
",theak,2013-10-28 20:35:36
499,2014-07-27 15:26:09,"Hello. I'm having exactly the same issue; I've cloned this repo & npm installed it. I've copy-pasted the sample from http://blog.nodejitsu.com/node-http-proxy-1dot0/ which looks like this:

<S_CODE_TOKEN>

When I visit http://localhost:8000 the following error occurs:

<S_CODE_TOKEN>

Perhaps I'm just having a bad day, but am I missing something?

Thanks.
",qmacro,2013-10-28 20:35:36
499,2014-07-29 01:45:55,"@qmacro hey there was a typo in the blog post unfortunately that I just fixed. It should be a full URL prefixed with `http://` or `https://` if it will be a string passed in as target. We should have a check for this though.
",jcrugzz,2013-10-28 20:35:36
499,2014-08-07 21:13:05,"@qmacro Hi I was playing with the similar issue you came across.  In my case when I entered my IP address the proxy generated the very same error.  Than I included the my IPaddress in target options and redirected the request to some error server. 

<S_CODE_TOKEN>
",webduvet,2013-10-28 20:35:36
499,2014-11-10 09:34:55,"@webduvet That IP address issue took me some time to figure out. That was as tough one.
",rjsteinert,2013-10-28 20:35:36
498,2013-10-12 06:53:40,"Hi,

I am struggling with getting chunked requests through the proxy. It would be nice if you could help.

What I have: I create a http server that should serve static files under one path (which works) and proxy another:

<S_CODE_TOKEN>

It seems to work file with the headers, but the chunks don't seem to be copied over to the response. I've inserted an `console.log(chunk)` [in the ondata method](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L335), which outputs

<S_CODE_TOKEN>

This [is written to the original response](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L340), but nothing comes through.

Any hints on how to handle chunked requests or how to debug this further are very welcome!
",rweng,2013-10-15 09:09:04
498,2013-10-15 09:09:04,"The problem seems to have been with the backend, which was down, ... It works now, even without using a buffer.
",rweng,2013-10-15 09:09:04
497,2013-10-11 16:44:43,"Towards the end of putting this together and testing it works, I found a solution combining regex entries in the proxy table to achieve a default to similar effect. But, this certainly makes for a tidier solution so I'll put it forward.

Have included an example in this pull request to demonstrate what I'm trying to do.

The ProxyTable will now support a `'default'` entry (unless `hostnameOnly:true` is flagged).

<S_CODE_TOKEN>
",yanneves,2013-12-27 07:43:19
497,2013-12-27 07:43:19,"We're dropping the `ProxyTable` in `node-http-proxy@1.0.0`. If you want to take ownership of it `proxy-table` is available on `npm`! :-D
",indexzero,2013-12-27 07:43:19
496,2013-10-11 16:13:47,"We have written a proxy to authenticate http requests to several servers, following the recommended design pattern:
https://github.com/nodejitsu/node-http-proxy#proxy-requests-within-another-http-server

We are using `connect middleware` within this proxy to process cookie authentication and relay this internally to the servers via queryString parameters. The middleware in use is:

<S_CODE_TOKEN>

Everything works ok for GET requests.

I'm having trouble with POST requests. Originally the requests were just hanging but I was able to resolve that using the `httpProxy.buffer(req)`.

During a POST response the request is forwarded to the backend, the backend responds and then the proxy throws `{ [Error: socket hang up] code: 'ECONNRESET' }`.

I've done some digging around.
1. This does not happen with node 0.10.x (but we're proxying websockets as well so [need 0.8](https://github.com/nodejitsu/node-http-proxy/pull/402))
2. This doesn't happen when we proxy without connect middleware processing the request

Can anyone offer any advice?

connect :       ~2.9.0
http-proxy :   ~0.8.7
node : 0.8.24

Many thanks
",robsquires,2015-03-05 22:49:41
496,2013-10-11 17:04:21,"The `connect.session` appears to  be the culprit...not sure why :(
",robsquires,2015-03-05 22:49:41
496,2013-10-11 17:29:09,"This is being caused by `utils.pause(req);` within `connect.session`.

https://github.com/senchalabs/connect/blob/master/lib/middleware/session.js#L306

Any ideas why this might be messing up the response when handled by the proxy?
",robsquires,2015-03-05 22:49:41
496,2013-10-14 14:26:12,"I think I've got to the bottom of this. I was buffering the request object further up the middleware chain than the connect session. The session calls `pause.resume` after the rest of the middleware, including the proxy, leading to further data events being emitted.  I discovered this by logging inside the `data` listener in the proxy.

By re-ordering my middleware, buffering after the session everything seems to work OK.

Does anyone have any advice on this solution?

thanks
",robsquires,2015-03-05 22:49:41
496,2014-01-26 22:41:32,"FWIW, I'm having the same symptom (POSTs fail when proxied, everything else works fine), but I'm not buffering.
",matt2000,2015-03-05 22:49:41
496,2014-07-24 15:46:10,"This looks like it is related to issue #180 and #326 though those use an older version of http-proxy.  It certainly would be nice if http-proxy was changed to work without having to reorder the middleware.  :-)
",fidian,2015-03-05 22:49:41
496,2015-03-05 20:16:14,"I'm also having this issue.
",djmccormick,2015-03-05 22:49:41
496,2015-03-05 22:49:41,"@djmccormick I will be closing this as it is an old issue but the answer has to do with having any middleware that buffers the request data when attempting to proxy. The solution is to create a separate a proxy middleware to handle the intended routes before hitting that middlware OR create a separate router altogether that has its own middleware chain that does not parse the request.

Hope this helps. If you cannot figure it out, open a new issue with a complete reproducible code sample
",jcrugzz,2015-03-05 22:49:41
495,2013-10-08 23:26:26,"The Node http client (at least in 0.10.x) removes the socket error handler
(which forwards errors from socket to request) before invoking 'upgrade'. So we
need to put our error handler back on it if we don't want errors (eg
ECONNRESET/EPIPE) talking to the server to throw.

See https://gist.github.com/glasser/6893545 for an example script showing why this is necessary.
",glasser,2013-11-07 18:13:24
495,2013-10-09 07:43:38,"i am in the process of refactoring how errors are handled (dropping wildcards among other things), but i'll make sure to include this... thanks! :D
",yawnt,2013-11-07 18:13:24
495,2013-11-07 18:13:24,"added, sorry for the late fix 
",yawnt,2013-11-07 18:13:24
494,2013-10-07 17:44:06,"I don't believe this scenario is handled.

I am using the node-http-proxy as the public facing server.  Using the routing feature, I use this to talk to multiple backend servers.  To force the communications to be over SSL, the proxy only accepts HTTPS connections.  The proxy then talks to the back-end servers over HTTP or some sort of websocket.

Is there a way to force any connecting client to utilize HTTPS?  Currently, the HTTP request doesn't receive a response, which makes sense, since options.https is being set.

If the functionality doesn't exist, my feature request would be for a flag that forces node-http-proxy to listen on two ports, and redirect all HTTP requests to HTTPS.

Here's the summary of the code that I'm running:

<S_CODE_TOKEN>
",jonni83,2013-10-07 18:57:10
494,2013-10-07 18:57:10,"You don't need a proxy for that. See [FAQ](https://www.nodejitsu.com/documentation/faq/#how-do-i-force-my-clients-to-use-https-with-my-application), it has exactly the code you need (setting up an HTTP server redirecting everything to HTTPS).
",mmalecki,2013-10-07 18:57:10
493,2013-09-30 21:16:33,"I'm trying to create a service that receives a request, proxies it to another service while also forwarding to a third server.

This was possible in the older version of http-proxy, but it doesn't seem to work in caronte. I only see the request coming to the ""forward"" server and not the ""target"" server.  I've tried using both objects and strings for the options and they both are the same.

https://github.com/nodejitsu/node-http-proxy#proxy-requests-with-an-additional-forward-proxy

<S_CODE_TOKEN>
",grantkl,2013-11-07 17:58:20
493,2013-11-07 17:58:20,"hi @grantkl,

`target` and `forward` reciprocally exclude one another.. that is because if one request comes in, one has to come out.. not many (**imho**)

the way you could solve this is by creating an http server and a proxy server and dynamically proxy

<S_CODE_TOKEN>
",yawnt,2013-11-07 17:58:20
493,2013-11-08 19:43:01,"This is quite the change from the previous version of http-proxy. 

https://github.com/nodejitsu/node-http-proxy#proxy-requests-with-an-additional-forward-proxy

In your example, which response would be returned upstream?
",grantkl,2013-11-07 17:58:20
493,2013-11-08 20:03:00,"i just pushed a commit ( https://github.com/nodejitsu/node-http-proxy/commit/961d2f9400b4cfd236c3c8ccbf401d37f8e871b8 ) which should help.. if you set two options `≈ßarget` and `forward` in options, then target will be the one piped and forward will receive a ""fire and forget"" request (aka it doesn't care about the response)
",yawnt,2013-11-07 17:58:20
493,2013-11-12 21:44:45,"That helps gets the request to the forward server (in addition to the proxy), but now it seems as though http-proxy closes the connection to the forward server prematurely. 

The 2 services I have sitting under http-proxy are Java based (Tomcat) and I see the following error on the ""forward"" server:

Nov 12, 2013 12:38:13 PM com.sun.jersey.server.impl.application.WebApplicationImpl _handleRequest
SEVERE: The response of the WebApplicationException cannot be utilized as the response is already committed. Re-throwing to the HTTP container
javax.ws.rs.WebApplicationException: javax.xml.bind.MarshalException - with linked exception:
[javax.xml.stream.XMLStreamException: ClientAbortException:  java.net.SocketException: Connection reset by peer: socket write error]
",grantkl,2013-11-07 17:58:20
493,2013-11-14 01:12:07,"I seem to have fixed this by adding a couple of lines to handle errors and disregard the response.  I'm still testing but it seems promising.

<S_CODE_TOKEN>
",grantkl,2013-11-07 17:58:20
493,2013-11-14 09:50:41,"Hi,

could you send a PR + a test for this? It would be super useful

Thanks!
",yawnt,2013-11-07 17:58:20
493,2013-11-14 19:44:17,"I'll definitely do that once I've ironed out all the issues. I'm still having an issue where I get somewhere around 1 second added latency if the 'forward' server goes down. Ideally, http-proxy shouldn't attempt to pipe() the request to the 'forward' server if the 'forward' server isn't available.

Any ideas?
",grantkl,2013-11-07 17:58:20
492,2013-09-26 09:04:30,"...ropriate.
",yawnt,2013-09-26 09:05:02
491,2013-09-26 07:56:56,"@yawnt I added some baseline benchmark scripts that we can use in the `1.0.0-dev` branch (they are also in the `caronte` branch, but that's behind now). **These benchmarks exposed what appear to be (at first glance) serious performance issues in the 1.0.0-dev branch.**
## node: v0.8.25 | http-proxy: v0.10.3

I am using the [benchmark branch](https://github.com/nodejitsu/node-http-proxy/compare/benchmark). The documentation on how to run these benchmarks is in [benchmark/README.md](https://github.com/nodejitsu/node-http-proxy/tree/benchmark/benchmark). **On average I am seeing just under 3000 request / second.** 

**$ wrk -c 20 -r 2000 -t 4 http://127.0.0.1:8000**

<S_CODE_TOKEN>

**$ wrk -c 20 -r 10000 -t 4 http://127.0.0.1:8000**

<S_CODE_TOKEN>

The highest I pushed it was _100k total requests across 8 threads with a concurrency of 20 per thread:_

$ wrk -c 20 -r 100k -t 8 http://127.0.0.1:8000

<S_CODE_TOKEN>
## node: v0.10.19 | http-proxy: v1.0.0-dev

I am using the [1.0.0-dev branch](https://github.com/nodejitsu/node-http-proxy/compare/caronte...1.0.0-dev). Again, the documentation on how to run these benchmarks is in [benchmark/README.md](https://github.com/nodejitsu/node-http-proxy/tree/1.0.0-dev/benchmark). There are two main problems here:
#### 1. **A 50% performance degradation**

This could be a number of things (such as changes to node core itself), but right now I'm seeing _**a 50% performance hit.**_

<S_CODE_TOKEN>
#### 2. **Proxies fall over with ETIMEOUT**

Increasing the number of total requests beyond ~6k _without raising the concurrency or threads of the wrk process_ causes `node benchmark/scripts/proxy.js` to fall over with `ETIMEOUT`.

**$ wrk -c 20 -r 10000 -t 4 http://127.0.0.1:8000**

<S_CODE_TOKEN>

This happens consistently and in a reproducible fashion. _**This is a show stopping bug and needs to be fixed:**_

<S_CODE_TOKEN>
",indexzero,
491,2013-09-27 12:47:35,"I keep trying to benchmark `caronte` branch (@indexzero: branch `v1.0.0-dev` does not exist), yet I keep getting:

<S_CODE_TOKEN>

Target server stays up all the time, `ulimit` is set to reasonable values. @yawnt any idea?
",mmalecki,
491,2013-09-27 19:08:27,"@mmalecki error handling needs to be refactored as there is no easy way to handle the errors with how they are namespaced. See #462 
",jcrugzz,
491,2013-10-18 05:06:41,"After some improve from @yawnt I ran again the benchmark and this what I got in my humble laptop.

Node: v0.10.20
Last commit at caronte branch: 86750c7e594c419dfae957aaf7e44e61e1d480e8
wrk: wrk 3.0.1 [epoll] Copyright (C) 2012 Will Glozer

<S_CODE_TOKEN>

I would love to see what numbers show at @indexzero's laptop because my humble laptop show some improve.
",cronopio,
491,2013-10-18 05:11:42,"And a 3 minutes benchmark show this:

<S_CODE_TOKEN>
",cronopio,
490,2013-09-24 08:44:21,"hi, 
after reading the code, I see that the `middleware` feature wasn't on the source code anymore.

So I have few questions :
- how can we do some asynchronous verification/modification on the request ? It was easy with the middleware but I don't see how to do it now. I see that some events are emitted but it's not possible to perform a async job on an event.
- I would like to be able to modify the response going to the client. I don't know where I can add a stream that transform the response (See http://nodejs.org/docs/v0.10.0/api/stream.html#stream_class_stream_transform). Is there any hook that I missed?

If we agree on the best way to extend the proxy, I would be glad to contribute with a pull request.
",abarre,
490,2013-12-05 10:46:50,"Hi all, struggling with exactly the same thing - async modifications on the request / response. I can see the 'passes' logic but that all just runs in a synchronous loop (plus I couldn't actually get the 'before' or 'after' modifier methods to work since `this.passes` is undefined).
",makeusabrew,
490,2013-12-18 11:01:56,"hi!

you can just proxy manually and modify there

eg

<S_CODE_TOKEN>
",yawnt,
490,2013-12-28 12:08:16,"I would like to achieve something like this (let's say this would be async modification of response coming to the client)

<S_CODE_TOKEN>

This is because of Chrome bug preventing node-spdy usage. The workaround is to delay response sending until request ends ... any ideas if this is achievable using current API? I think not. Maybe patching the response object could be other solution.
",Rush,
490,2013-12-28 19:05:21,"i'd rather not patch request.. caronte uses streams2 api.. perhaps you could try to play around with .pause() and .resume()
",yawnt,
490,2014-01-05 11:08:41,"My question still stands, I do not see how `.pause()` and `.resume()` may help me. However, I have a different question.
How would I go on implementing changing of `proxyResponse` data? For example - appending some content to the proxied HTML.
",Rush,
490,2014-01-05 12:45:55,"write a stream that implements `res` semantics with custom logic on `write` and `end` :)
then do something like 

<S_CODE_TOKEN>

where wrapStream returns an instance of your stream
",yawnt,
490,2014-02-11 18:55:25,"I agree that the current implementation makes it really difficult to do this sort of thing.  I created

https://github.com/nodejitsu/node-http-proxy/pull/582

To make it easier to just attach some headers.  But, there should be some sort of API to allow me to add place passes into their correct location.
",cheddar,
490,2014-04-03 21:32:43,"Here are some middleware examples: 
https://github.com/nodejitsu/node-http-proxy/tree/caronte/examples/middleware
",gdw2,
490,2015-11-16 11:45:18,"https://github.com/nodejitsu/node-http-proxy/tree/caronte/examples/middleware

This link seems to be broken......

I think I have a similar problem... See my code:

 var http = require('http'),
    httpProxy = require('http-proxy'),
    proxy = httpProxy.createProxyServer({});  
    var miTarget='web:CountryName';
    var inicio = '<'+miTarget+'>';
    var fin = '</'+miTarget+'>';

<S_CODE_TOKEN>

});
",macscripter,
489,2013-09-24 07:32:17,"I¬¥ve been trying for two days to develop a proxy balancer that:
1. Receives a requesting HTTP/S URL.
2. Selects a Proxy from a list.
3. Dispatches the requested HTTP/S URL to that target proxy.

My first attemp with HTTP URL Request was fantastic, and everything was OK, but doing the same with HTTPs URLS doesn¬¥t work. The code is simple, and I¬¥ve read http-proxy documentation plus some question answers here, but still doesn¬¥t work.

Here is the code:

var https = require('https'),
http = require('http'),
httpProxy = require('http-proxy');

var fs = require('fs');

var addresses = [
  {
    host: 'localhost',
    port: 3128
  },
  {
    host: 'otherIP',
    port: 3128
  }
];

var httpsOptions = {
  https: {
      key: fs.readFileSync('./ssl/key.pem', 'utf8').toString(),
      cert: fs.readFileSync('./ssl/key-cert.pem', 'utf8').toString()
    }
};

var proxy = new httpProxy.RoutingProxy({
  target: {
      https: true
  }
});

var counter = 0;

https.createServer(httpsOptions.https, function (req, res) {  
  console.log(""URL=""+req.url);  
  var target = addresses.shift();  
  addresses.push(target);  
  proxy.proxyRequest(req, res, target);

  proxy.on('end', function() {
    console.log('Proxied ('+counter+'). URL='+req.url);
  });

  proxy.on('proxyError', function (err, req, res, counter) {
    res.writeHead(500, {
      'Content-Type': 'text/plain'
    });  
    res.end('Something went wrong. And we are reporting a custom error message.');

  });

}).listen(443);

The code is pretty simple: it creates a HTTPS server listening to 443 port using a self-signed certificate. There is also a RoutingProxy that dispatches the HTTPs URL to the proxy selected from the list. Optional parameters such as https=true are setted.

However, when launching the Node.Js code and configuring Firefox pointing to localhost 443 proxy and then loading, for example, https://www.google.com or https://www.facebook.com doesn¬¥t work: page waits loading and loading and never load and the request never 'enters' into https Server and prints the console.log message.

Can anyone help me, please?

Thank you very much in advance,

Best regards,

Luis Cappa
",luiscappabanda,
488,2013-09-24 06:51:53,"Avoids unhandleable ECONNRESETs.

I think this is arguably a Node http bug (in 0.10.18 at least), but: if you run

<S_CODE_TOKEN>

During the `ClientRequest` constructor, `self.shouldKeepAlive` is set to false because there is no agent. But then it calls (indirectly) the `storeHeader` function (in `http.js`, which sets `self.shouldKeepAlive` to true because you specified the keep-alive header.

Then once the request is over `responseOnEnd` (in `http.js`) runs.  Because `shouldKeepAlive` is true, we do NOT destroy the underlying socket. But we do remove its error listener.  However, because we do NOT have an agent, nobody cares that we emit `free`, and the socket is essentially leaked.

That is, we continue to have an open socket to the target server, which has no `error` listener and which will never be cleaned up.

It's bad enough that this is a resource leak. But to make matters worse: let's say that the target server dies.  This socket will emit an ECONNRESET error... and since there is no `error` listener on the socket (there's a listener on the `ClientRequest`! but not on the socket), bam, time for an incredibly confusing error to be thrown from the top level, probably crashing your process or triggering `uncaughtException`.

I think the best workaround here is to ensure that if we have no agent, then we don't send connection: keep-alive. This PR is one implementation of this.

(I'll work around this a different way in Meteor for now: by providing an explicit Agent.)
",glasser,2014-03-27 02:09:09
488,2013-09-24 06:53:05,"[![Coverage Status](https://coveralls.io/builds/225268/badge)](https://coveralls.io/builds/225268)

Coverage increased (+0.17%) when pulling **5007bd301b81fba4239eb1f4f4caac897ae4f229 on glasser:keep-alive-requires-agent** into **94ec6fa5ce6826ca1e8974f7e99b31541aaad76a on nodejitsu:caronte**.
",coveralls,2014-03-27 02:09:09
488,2013-09-24 07:21:50,"Hmm. I can pretty easily make a test which shows that without this PR, sockets are leaked. Just something as basic as

<S_CODE_TOKEN>

<S_CODE_TOKEN>

pointing a web browser at localhost:4010, and running `lsof -p pidofproxyserver`.... you'll see that sockets remain open from the proxy server to the target server, but since agent is false they will never be reused.

Unfortunately I have not been able to make a simple reproduction of the ECONNRESET error without the full complexity of Meteor.

Also, my PR ends up (unless you specify an Agent) turning all connections into connection: close, which probably is a little too strong. I mean, without an Agent the proxy-target communication should be connection: close, but there's no reason that the client-proxy communication should be too (but my PR makes it be that way).
",glasser,2014-03-27 02:09:09
488,2013-09-24 10:30:16,"The problem with using an agent is that they are impossibly slow. Only disabling the agent gives you any sort of performance. In my opinion disabling client to proxy keep-alive is totally unacceptable, especially when paired with HTTPS. The handshake can take up to 150ms during my tests so basically any REST service would be impossibly slow .
",Rush,2014-03-27 02:09:09
488,2013-09-24 17:06:57,"Do we have an understanding of what aspect of using an agent is slow? Am I confused if I think that without an agent, the proxy to server connection is just going to be leaked and never reused?
",glasser,2014-03-27 02:09:09
488,2013-09-24 21:53:06,"hey @glasser,
i think your solution is a bit too brutal as a workaround to be implemented without significant sacrifices.. we should, imho,  post this on [joyent/node](https://github.com/joyent/node/issues) and see what they say there about it

could you do it since you uncovered this bug and know more about it? if not, i can handle this

thanks for submitting the PR anyway :)

regarding @RushPL 's comment i think he's referring to the performance that `ab` shows when tested against caronte.. there are a couple of things that make `ab` behave weirdly (most noticeably the fact that it's `HTTP1/0` and node allows only `HTTP1/1` requests, thus preventing me from sending a content length which `ab` requires).. using other `HTTP/1.1` perf suites hasn't shown, so far, significant penalties in using agents except the usual slow-down due to pooling
",yawnt,2014-03-27 02:09:09
488,2013-09-24 21:56:36,"I am actually referring to a situation where many outgoing connections need
to be made and a pool (by its nature) is limited. Hence the problem.

2013/9/24 yawnt notifications@github.com

> hey @glasser https://github.com/glasser,
> i think your solution is a bit too brutal as a workaround to be
> implemented without significant sacrifices.. we should, imho, post this on
> joyent/node https://github.com/joyent/node/issues and see what they say
> there about it
> 
> could you do it since you uncovered this bug and know more about it? if
> not, i can handle this
> 
> thanks for submitting the PR anyway :)
> 
> regarding @RushPL https://github.com/RushPL 's comment i think he's
> referring to the performance that ab shows when tested against caronte..
> there are a couple of things that make ab behave weirdly (most noticeably
> the fact that it's HTTP1/0 and node allows only HTTP1/1 requests, thus
> preventing me from sending a content length which ab requires).. using
> other HTTP/1.1 perf suites hasn't shown, so far, significant penalties in
> using agents except the usual slow-down due to pooling
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/pull/488#issuecomment-25045764
> .
",Rush,2014-03-27 02:09:09
488,2013-09-24 21:57:43,"oh yes, in that case you can just increase the pool size to an absurd number :P
",yawnt,2014-03-27 02:09:09
488,2013-09-24 21:58:43,"And hence no need for pool. :-)

2013/9/24 yawnt notifications@github.com

> oh yes, in that case you can just increase the pool size to an absurd
> number :P
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/pull/488#issuecomment-25046066
> .
",Rush,2014-03-27 02:09:09
488,2013-09-24 22:03:13,"not really, if you leave without pools at one point you're gonna finish up file descriptors and the node process will crash.. with a pool you can have mostly the same perf, but without the horrible crash when you're done with FDs
",yawnt,2014-03-27 02:09:09
488,2013-09-24 22:42:21,"I agree that this is sort of brutal.  But right now, the most obvious way to create a proxy without any options defaults to no agent.  So in the commonish case where the client is sending Connection:keep-alive, bam, your proxy leaks sockets forever, which will certainly crash eventually. (And in my app will probably lead to ECONNRESETs eventually, though I can't reproduce this in a small example.)

Maybe caronte should default to using an agent (perhaps a large one)?

I'm not sure exactly what bug to report to joyent/node. Basically, the issue is this: if, when using `http.request`, you go out of your way to specify two somewhat-conflicting non-default options (`{headers: {connection: 'keep-alive'}, agent: false}`) then you get bad behavior (a leaked open socket).
",glasser,2014-03-27 02:09:09
488,2013-09-24 22:44:36,"Oops, hit send too soon.

... but then there's the valid argument of ""ok, well, don't specify two conflicting options"".  The problem is that `agent: false` is the _default_ for caronte, and that when proxying you probably aren't controlling the headers.

So what should I suggest node does?  Maybe it shouldn't set `shouldKeepAlive` when you specify connection: keep-alive with agent: false. But then the keep-alive is getting ignored!

Or maybe specifying both of those options should throw an error. That's reasonable, except then caronte has to still make a change, either the one from this PR, or to stop supporting `agent: false`.
",glasser,2014-03-27 02:09:09
488,2013-09-24 22:46:45,"Another potential caronte-side fix: if you're doing `agent: false` (whether or not that's the case), then the proxy->server code should use `connection: keep-alive` just as in this PR.  _but_, if we're making that change, then the web-outgoing connection header pass should NOT copy the proxy response's connection header back to the client; it should keep the connection open if the original client's request said keep-alive, and not otherwise.
",glasser,2014-03-27 02:09:09
488,2013-09-25 12:34:19,"ok so i had a talk with a node core contrib about this.. keep alive connections should only be used, as you said, when there's an agent.. so i think the best way is to make sure that
- if there's an agent, all is well
- if there's no agent, the connection between client and proxy should be kept keep-alive but the connection between proxy and server should be defaulted to close (this also means restoring keep-alive on the response)

can you add the ""restore keep-alive"" part? when that's done (with tests :D) i'm willing to merge this 

thanks!
",yawnt,2014-03-27 02:09:09
488,2013-09-25 12:35:21,"[![Coverage Status](https://coveralls.io/builds/227824/badge)](https://coveralls.io/builds/227824)

Coverage increased (+0.17%) when pulling **5007bd301b81fba4239eb1f4f4caac897ae4f229 on glasser:keep-alive-requires-agent** into **94ec6fa5ce6826ca1e8974f7e99b31541aaad76a on nodejitsu:caronte**.
",coveralls,2014-03-27 02:09:09
488,2013-09-25 21:59:20,"I can look into this, but due to some travel it definitely won't be this week. Already stayed up until 3am on this issue once this week :)
",glasser,2014-03-27 02:09:09
488,2013-09-25 22:02:50,"no prob, i'll look into it myself ASAP (aka when i'm done with the other issue)
",yawnt,2014-03-27 02:09:09
488,2013-12-08 02:42:19,"I'm noticing this behavior too. It can DOS a backend server pretty quick actually; lsof shows my backend hanging up immediately on new connections once there are 216 outstanding keepalive connections from the proxy server, because of course I've hit the default limit of 256 file descriptors on my Mac. Naturally that can be raised but eventually there's a limit in whatever context.

Eventually these connections time out and the back end is usable again.

I'm curious why node's core http module doesn't have a tuneable parameter for breaking connections based on how long it's been since the last request. That would at least keep well intentioned goofs like leftover keepalive connections from DOSing the server. Without doing something hamfisted like breaking an incomplete HTTP upload or other long-lived single request, which is a completely different decision.

I think one could write a watchdog in a few lines in userspace: when you see a new req.connection, add a close event handler, and also watch for additional requests with the same connection. If it hasn't been closed or had a new request come in for a few seconds, just close it...

But is that necessary or am I missing a piece of existing functionality?

Apologies for getting a little off the beam of the original issue with node-http-proxy. It's a bug for sure, bad enough behavior that a lot of servers would probably just firewall the responsible IP (:
",boutell,2014-03-27 02:09:09
488,2013-12-08 02:49:45,"The problem seems entirely resolved by adding the default agent:

var proxy = httpProxy.createProxyServer({ agent: http.globalAgent });

I did see @RushPL's comment that the use of any agent at all is a performance-killer. I haven't attempted any measurements of my that, but leaking sockets and not really leveraging keepalive as a result can't be good either.
",boutell,2014-03-27 02:09:09
488,2013-12-08 22:37:49,"@boutell Yes, it would be great if Node's http server had a way to flip the socket timeout value between one value for ""during a request"" and one for ""between requests"".  Or a more usable event for ""socket is now awaiting another request"".

We did something in Meteor recently to try to simulate this but it's hacky: https://github.com/meteor/meteor/blob/devel/packages/webapp/webapp_server.js#L209  https://github.com/meteor/meteor/blob/devel/packages/webapp/webapp_server.js#L448
",glasser,2014-03-27 02:09:09
488,2013-12-08 23:51:12,"Nice, this is what I was suggesting... I think you could build that as a
generic npm module, though it no doubt belongs in core.

On Sun, Dec 8, 2013 at 5:37 PM, David Glasser notifications@github.comwrote:

> @boutell https://github.com/boutell Yes, it would be great if Node's
> http server had a way to flip the socket timeout value between one value
> for ""during a request"" and one for ""between requests"". Or a more usable
> event for ""socket is now awaiting another request"".
> 
> We did something in Meteor recently to try to simulate this but it's
> hacky:
> https://github.com/meteor/meteor/blob/devel/packages/webapp/webapp_server.js#L209
> https://github.com/meteor/meteor/blob/devel/packages/webapp/webapp_server.js#L448
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/pull/488#issuecomment-30095063
> .

## 

Tom Boutell
P'unk Avenue
215 755 1330
punkave.com
window.punkave.com
",boutell,2014-03-27 02:09:09
488,2013-12-18 12:01:50,"hey, 
i've been going back on this one and using 0.11 (latest master) it doesn't look like it's leaking for me
can you confirm?
",yawnt,2014-03-27 02:09:09
488,2013-12-21 01:13:09,"So it is possible with 0.11 to run without agent and do keep alive to the target? How would I go about testing it?
",Rush,2014-03-27 02:09:09
488,2013-12-21 01:28:02,"I ran a test with:

<S_CODE_TOKEN>

and proxying with:

<S_CODE_TOKEN>

Seems that it works and does not leak (checked with lsof).. unless `agent: null` is ignored, I am not sure.
",Rush,2014-03-27 02:09:09
488,2013-12-21 11:42:47,"i also tried completely without specifying an agent and it didn't leak as well.. waiting to hear from @glasser 
",yawnt,2014-03-27 02:09:09
488,2014-02-25 04:37:57,"It seems that this fixes https://github.com/nodejitsu/node-http-proxy/issues/579
",whitecolor,2014-03-27 02:09:09
488,2014-03-27 02:09:09,"behavior is inconsistent, i accept this as a patch until `http` is finally fixed in `0.12.x`.

Fixed in 89a22bc00396f069eeb054ce30891a204077d16d
",jcrugzz,2014-03-27 02:09:09
488,2014-05-09 23:00:37,"This seems to be breaking Upgrades (#638). It forces the Connection header to 'close', but on a Socket Upgrade, we don't have an agent, yet. Perhaps, instead it should check if there is no agent AND the connection is not set to 'upgrade'.
",jayharris,2014-03-27 02:09:09
488,2014-05-09 23:14:23,"@jayharris id buy that. It seems that in that case it shouldnt leak sockets as it will only be making one request of that nature. I haven't run into this problem personally since we use an agent in our proxy that is handling sockets. I'd accept that patch.
",jcrugzz,2014-03-27 02:09:09
488,2014-05-09 23:23:05,"Awesome. I'll get it submitted in a few hours.
",jayharris,2014-03-27 02:09:09
487,2013-09-24 01:06:38,"The error message in caronte.createProxyServer says:

<S_CODE_TOKEN>

but I think that's not really true: you do need to pass one of `target` or `forward` to _either_ createProxyServer or the `proxy.web` call, but not necessarily to createProxyServer.
",glasser,2013-11-07 18:06:14
486,2013-09-23 16:19:45,"- [x] Make the `proxy` object returned from `httpProxy.createServer()` behave more like an `EventEmitter`. 
- [ ] Fix outstanding performance issues from benchmarks (https://github.com/nodejitsu/node-http-proxy/issues/491)
- [x] In code: `s/caronte/httpProxy`
- [x] Files: `s/caronte.js/node-http-proxy.js`
- [x] JSHint (See: https://gist.github.com/indexzero/f9a92bc727ec15573798)
- [ ] Update CHANGELOG.md
- [ ] Add section in README.md for _""Upgrading to node-http-proxy@1.0""._ This needs to be really thorough.
- [ ] Expand on the examples **way** more. _We need 1-1 parity with all examples in `master`_
- [ ] Blog post about the update.
- [ ] Merge in `caronte` branch _preserving history._ (i.e. bankruptcy then merge)
- [ ] Update Copyright headers
- [ ] Decide what to do with outstanding pull-requests for a maintenance release.
",yawnt,
485,2013-09-23 16:17:04,"https://gist.github.com/indexzero/f9a92bc727ec15573798
",yawnt,2013-09-23 16:21:31
485,2013-09-23 16:21:30,"Duplicate of 486
",indexzero,2013-09-23 16:21:31
484,2013-09-21 20:24:06,"@yawnt @jcrugzz, the reason that your wildcard error handler `ee.on('*:error', function (err) {}` does not get picked up is because it does not match the event emitted. you could use `ee.on('*:*:*:error', function (err) {}`

I do agree that the number of namespaces does seem a bit much. perhaps `ws:error` and `web:error` would be sufficient. 

Issues #462 #470 
",srossross,2013-09-22 11:22:40
484,2013-09-21 20:25:17,"[![Coverage Status](https://coveralls.io/builds/222209/badge)](https://coveralls.io/builds/222209)

Coverage remained the same when pulling **32a40889cedfd6b0d92224aa921700a7b7271c68 on srossross:error_handling** into **32dcb0449cef7b6723893e36ff03043549bca347 on nodejitsu:caronte**.
",coveralls,2013-09-22 11:22:40
484,2013-09-22 11:22:42,":+1: we totally need to refactor error events ..
",yawnt,2013-09-22 11:22:40
483,2013-09-21 00:44:06,"Badges should link to the web service they build on not the direct image file ;). 

cc @yawnt 
",jcrugzz,2013-09-21 08:49:35
482,2013-09-17 19:01:09,"- Pushed the options logic for targets and agents to from `caronte.createProxyServer` to `common.setupOutgoing`
- Added `headers` to options. Can now overwrite headers (see https.js example 2)
- Added https example. please review the example as I am not sure if this is the intended usage

Also you will notice that the third option raises an error and exits the node interpreter. I am not sure where this error is coming from or where it can be caught.
",srossross,2013-09-21 08:49:00
482,2013-09-17 19:03:28,"[![Coverage Status](https://coveralls.io/builds/215555/badge)](https://coveralls.io/builds/215555)

Coverage decreased (-0.62%) when pulling **4ee96ddd664f795ad35e703a009d1fa674937bb1 on srossross:caronte** into **69f126b34cbd190be8541a854d21f13bfb5a61bf on nodejitsu:caronte**.
",coveralls,2013-09-21 08:49:00
482,2013-09-17 19:40:14,"hey, thanks for the PR

i'm okay with the idea of allowing overridable headers, not so much about the agent.. 

as you might have noticed [we disabled it by default](https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/caronte.js#L49) and i don't see why would someone want to specify a different agent for each connection (if you can bring a valid usecase i'd be happy to reconsider my position :D )

the philosophy behind caronte is to keep everything as lean and simple as possible.. overloading `common.setupOutgoing` with features means, ultimately, slowing down `proxy.web` and `proxy.ws` .. that's why i don't want to introduce anything new unless critical.. it would also be really good that every modification to `caronte`'s behaviour was coupled with a test case

last thing.. i don't want to sound too picky but i think that keeping a consistent style is important.. please use `/* */` for multiline comments and no comma-first.. (i'm in the process of writing a CONTRIBUTING.md, should be available in the next few days)
",yawnt,2013-09-21 08:49:00
482,2013-09-17 20:28:11,"@yawnt thanks for the review.  I opened this PR as a discussion. I am happy to follow your `CONTRIBUTING.md` guidelines and add tests. 

As for the use case, my goal was to make the options object consistent between the global `caronte.createProxyServer` and the per request `proxyServer.web|ws` calls. What do you think? 

Let me know if you think this it is the right direction and I will modify and add tests. 
",srossross,2013-09-21 08:49:00
482,2013-09-17 20:40:31,"i see what you mean.. i think the global options should be used for things that are not subject to changes often.. 

how about we settle for removing `agent` from `options.target/options.forward`.. then we can set the agent in `common.setupOutgoing` using `outgoing.agent = options.agent || false` (it should default to false if none is specified).. we should remove the default agent `new Agent...` and leave that to the user.. that means also taking out `maxSock` and adjusting documentation/`lib/caronte.js`

if we do this you can then specify a global `Agent` and override it locally for free (since `extend` is used)

about the tests please look at the way `lib-common-test.js` is setup and follow the same path.. if you have questions, ask ahead
",yawnt,2013-09-21 08:49:00
482,2013-09-17 22:02:22,"[![Coverage Status](https://coveralls.io/builds/215908/badge)](https://coveralls.io/builds/215908)

Coverage decreased (-0.1%) when pulling **1b5fb1d8fc21421b8383919d93e4149b586b211b on srossross:caronte** into **69f126b34cbd190be8541a854d21f13bfb5a61bf on nodejitsu:caronte**.
",coveralls,2013-09-21 08:49:00
482,2013-09-17 22:07:48,"[![Coverage Status](https://coveralls.io/builds/215919/badge)](https://coveralls.io/builds/215919)

Coverage decreased (-0.1%) when pulling **a350fadea6bace293131581487f8c66948009449 on srossross:caronte** into **69f126b34cbd190be8541a854d21f13bfb5a61bf on nodejitsu:caronte**.
",coveralls,2013-09-21 08:49:00
482,2013-09-18 01:22:36,"[![Coverage Status](https://coveralls.io/builds/216130/badge)](https://coveralls.io/builds/216130)

Coverage remained the same when pulling **39b0c46a6967fda5329760ad93a8ec01bc4a6f14 on srossross:caronte** into **69f126b34cbd190be8541a854d21f13bfb5a61bf on nodejitsu:caronte**.
",coveralls,2013-09-21 08:49:00
482,2013-09-18 13:59:50,"when you feel like it's done give me a shout and i will review :) .. lookin good so far.. only thing i'd change is.. in README.md instead of [0] and [1] write the actual links `[ my text ]( my link )`
",yawnt,2013-09-21 08:49:00
482,2013-09-18 16:12:10,"[![Coverage Status](https://coveralls.io/builds/217151/badge)](https://coveralls.io/builds/217151)

Coverage increased (+0.64%) when pulling **7ad5c0f993294c9e2e7650e15fbc62d11a2cb062 on srossross:caronte** into **69f126b34cbd190be8541a854d21f13bfb5a61bf on nodejitsu:caronte**.
",coveralls,2013-09-21 08:49:00
482,2013-09-21 00:25:21,"@yawnt let me know what you need to pull this in.
",srossross,2013-09-21 08:49:00
482,2013-09-21 08:49:07,":+1: perfect :)
",yawnt,2013-09-21 08:49:00
482,2013-09-21 08:57:21,"argh, i just saw you mentioned me in a commit about this being done.. i don't remember seeing it.. i apologize for the late response :(
",yawnt,2013-09-21 08:49:00
481,2013-09-17 16:51:19,"Hey,

I'm looking to use node-http-proxy as a reverse proxy between Nginx and Django.

E.g., I wanted to forward all requests for '/account*' to Django and other requests to an express app. I setup my proxyTable like so:

<S_CODE_TOKEN>

Is there a way to do this without having a matched pattern such as `/account/foo` become translated into `/foo`? If not, would it be helpful to introduce a flag that determines whether or not the matched pattern is removed? The default behavior makes sense but it isn't the only use case.
",muffs,2013-09-17 19:54:01
481,2013-09-17 17:36:26,"@muffs I would encourage you to look at the `caronte` branch and see if it can be used to meet your needs. It is a complete refactor done by @yawnt and takes a much simpler approach. Let us know what you think!
",jcrugzz,2013-09-17 19:54:01
481,2013-09-17 18:45:00,"@jcrugzz thanks for the quick response ;)

I'm assuming `caronte` can proxy to multiple targets right? I'll have to mess around with it. Thanks for the recommendation.
",muffs,2013-09-17 19:54:01
481,2013-09-17 19:54:23,"closed since you'll be looking at caronte.. feel free to reopen should you have further doubts :)
",yawnt,2013-09-17 19:54:01
480,2013-09-17 14:14:56,"I am running the same test as with previous issues, now I have switched to `siege`.  :-)

<S_CODE_TOKEN>

Make sure siege is running in keep-alive mode, set in `.siegerc` or `/etc/siege/siegerc`.

`> siege -c 1000 -b -t 10S http://localhost:8000`
The test may be a bit over the top but nevertheless it shouldn't throw exceptions.

on the other hand, the original http server works:
`> siege -c 1000 -b -t 10S http://localhost:9000`
",Rush,2013-09-17 14:28:57
480,2013-09-17 14:23:46,"EMFILE means too many open files.. aka too many sockets... try using an agent for the request

an example on how to do that

<S_CODE_TOKEN>
",yawnt,2013-09-17 14:28:57
480,2013-09-17 14:25:23,"Well, that might work but is it desired behavior for the proxy server to throw exceptions? It should report errors with some 'error' event instead.
",Rush,2013-09-17 14:28:57
480,2013-09-17 14:26:20,"you can listen on errors through 

<S_CODE_TOKEN>
",yawnt,2013-09-17 14:28:57
480,2013-09-17 14:28:57,"I didn't see that it throws the error only if there are no listeners:

<S_CODE_TOKEN>

Closing.
",Rush,2013-09-17 14:28:57
479,2013-09-17 12:45:01,"I think the naming should be changed as I was trying to understand the code and it struck me that ""web-outgoing"" is actually the pass that processes the incoming requests from the remote server and not outgoing requests to the remote server.
",Rush,2013-11-07 17:47:05
479,2013-09-17 14:30:52,"mmm, kinda makes sense.. @jcrugzz opinion about this one?
",yawnt,2013-11-07 17:47:05
479,2013-09-17 17:31:02,"Yea its hard to be _exactly_ clear with this as it is all a matter of perspective. `web-outgoing` does make sense to me as the requests are being modified as they come in from the issuer with `web-incoming` (which is then proxied to the remote server) and when you send the response back to the issuer with `web-outgoing`, completing the reverse proxy. @yawnt maybe have it as `web-reverse` if that would make it more clear? What do you think @RushPL?
",jcrugzz,2013-11-07 17:47:05
479,2013-09-17 18:13:32,"`web-request` vs `web-response` (or reply)?
",glasser,2013-11-07 17:47:05
479,2013-09-17 18:13:38,"how about `to-client` and `from-client`
",srossross,2013-11-07 17:47:05
479,2013-09-17 18:15:32,"I would personally go for something along: client2proxy, proxy2client, proxy2target, target2proxy
Most explicit ...
",Rush,2013-11-07 17:47:05
479,2013-09-17 18:22:31,"none of the names here strucks me honestly.. the only thing i might want to do is invert is to follow the node convention about IncomingMessage and ServerResponse.. if anyone has a better name i'd be glad to take that into consideration.. it has to be short and make sense (so no client2proxy.. sorry @RushPL :P)
",yawnt,2013-11-07 17:47:05
479,2013-11-07 17:47:05,"closing this since it has been inactive for quite a while.. feel free to comment if you come up with better names and i'll take into consideration :)
",yawnt,2013-11-07 17:47:05
478,2013-09-17 09:37:54,"see https://github.com/nodejitsu/node-http-proxy/issues/477#issuecomment-24574204
",yawnt,2013-09-17 13:42:11
478,2013-09-17 09:40:26,"and some failing (probably due to the same issue)
",Rush,2013-09-17 13:42:11
478,2013-09-17 09:41:33,"i'm not sure if it's related to setting maxSock (so that the global agent can create more connections)
",yawnt,2013-09-17 13:42:11
478,2013-09-17 09:45:36,"yeah it's a problem related to connection pooling.. if i disable the agent completely i get 530 req/sec which is definitely more acceptable..

i'll have to look into the way agents are setup'd.. maybe there's a bug there..

thanks for reporting!
",yawnt,2013-09-17 13:42:11
478,2013-09-17 10:20:32,"i've pushed a fix that removes the connection pool .. i'm using `wrk` to do benchmarking (i trust very little ab) and here's what i got

with the default agent it's real slow

<S_CODE_TOKEN>

after the patch (please note that v8's JIT still has to warm up, subsequent requests perform around 800+ req/sec)

<S_CODE_TOKEN>

ab performs very strangely.. it measures 500 req/sec one time, when i run it again it hangs (at random).. i checked and the connection isn't even received by the node server (if you have any clue about this, please do share :D )
",yawnt,2013-09-17 13:42:11
478,2013-09-17 10:39:16,"I think you should first test with -t1 and -c1 which is single connection and one thread ... in which wrk is strangely terribly slow. No idea why ... I think ab2 shows good numbers with single thread single connection testing. Furthermore wrk does not show if it got valid responses ...
",Rush,2013-09-17 13:42:11
478,2013-09-17 10:42:58,"As a proof that ab2 is not in the wrong, please try the following:
`# ab2 -c 1 -k -n 10000 http://127.0.0.1:9000/`
Which tests keep alive without proxying. You should see a huge number of req/s. For me it is 4600/sec
",Rush,2013-09-17 13:42:11
478,2013-09-17 10:56:31,"mm it doesn't look slow to me.. what is weird is that `ab` hangs in the sense that the node server stops receiving requests .. and that happens randomly

<S_CODE_TOKEN>
",yawnt,2013-09-17 13:42:11
478,2013-09-17 11:05:49,"Well, as I pointed out it does not hang if it connects directly to the http server. With wrk (-r option does not work for me) and latest commit ""[fix] pooled connections"" afc4d0931fa1bc73ef797e2b59570e2f8145d447 I get only about 25req/s - I have triple checked that I have the right source and I see your latest commit ...

<S_CODE_TOKEN>

Compared to connecting directly to the http server:

<S_CODE_TOKEN>

Maybe the pooling is still on?
",Rush,2013-09-17 13:42:11
478,2013-09-17 11:10:27,"I wonder if this is connected: https://github.com/joyent/node/issues/4769 - It says closed only 2 months ago, so perhaps 0.10 still has problems with keep-alive.
",Rush,2013-09-17 13:42:11
478,2013-09-17 11:14:56,"i'm gonna look into that.. but i tested with both siege

<S_CODE_TOKEN>

and weighttp

<S_CODE_TOKEN>
",yawnt,2013-09-17 13:42:11
478,2013-09-17 11:17:03,"I have just tried with node 0.11, I installed it with Node Version Manager. The behaviour is different in `ab2`, as in  much worse. With wrk still 25req/s.
",Rush,2013-09-17 13:42:11
478,2013-09-17 11:26:21,"Also, in wrk headers there is no keep-alive.
",Rush,2013-09-17 13:42:11
478,2013-09-17 13:03:54,"i'm making progress.. slowly.. it seems to be a bug related to how CLRF is sent (something that should be node's responsability).. more likely is ab being nasty

http://stackoverflow.com/questions/4345602/problem-with-apachebench-ab-and-transfer-encoding-chunked

it thinks the content length is a header apparently

<S_CODE_TOKEN>
",yawnt,2013-09-17 13:42:11
478,2013-09-17 13:26:22,"Either ab is nasty or simply more strict to the HTTP standard. I on the other hand forced the `proxy -> server` requests to be ""connection: close"" and keep `client -> proxy` to be `connection: keep-alive` but it did not help which means you are on the right track. What strucks me as odd is that shouldn't this issue occur as well when connecting directly to the HTTP server without the proxy? It leads me to believe that it has to be a bug in the proxy.
",Rush,2013-09-17 13:42:11
478,2013-09-17 13:29:03,"no, because when you query a node.js server with `ab` it sends a `HTTP 1.0` request (that defaults to `connection: close` and doesn't use `chunked`) .. on the other hand when i create the request through `http.request()` it uses `connection: keep-alive` with `HTTP 1.1`.. please see https://github.com/joyent/node/issues/940
",yawnt,2013-09-17 13:42:11
478,2013-09-17 13:31:16,"both `siege` and `weighttp` use `keep-alive` and `HTTP 1.1` and they seem to work just fine
",yawnt,2013-09-17 13:42:11
478,2013-09-17 13:40:46,"A workaround - just to get it working - would be to always set:
`proxyRes.headers.connection = 'close':` in `web-outgoing.js`.
",Rush,2013-09-17 13:42:11
478,2013-09-17 13:42:11,"i can't do that.. i would kill every keep-alive connection ever.. just use `HTTP/1.1`  (which means `siege` or `weighttp` to test perfs)

thanks for reporting this tho :)
",yawnt,2013-09-17 13:42:11
478,2013-09-17 13:48:46,"I see, so simply not worth fixing the use case solely for ab.
",Rush,2013-09-17 13:42:11
478,2013-09-17 13:51:58,"i'm willing to implement that if you can find a way to send http/1.0 requests via http.request() .. if i do that manually (removing transfer-encoding chunked and setting content-length.. and i tried).. it's a huge performance hit
",yawnt,2013-09-17 13:42:11
477,2013-09-17 08:54:09,"Please run the example from README:

<S_CODE_TOKEN>

Please use the tool from `apache2-utils` package:

<S_CODE_TOKEN>

With `-k` option in `ab2` you may see it properly (well, almost - but this would be another issue) working as it sets keep alive in the initial header:

<S_CODE_TOKEN>
",Rush,2013-09-17 09:37:15
477,2013-09-17 09:03:20,"yep, sounds about right.. that's what i was thinking as well.. the commit i just pushed (https://github.com/nodejitsu/node-http-proxy/commit/2c10f256b658bc0e906c20f29d94ab7eaf653055) should fix it

i apologize for the late fix... with the tests rewriting going on, i kinda miscalculated the time i had
",yawnt,2013-09-17 09:37:15
477,2013-09-17 09:16:09,"You are very kind and no need to apologize. I am happy it is moving forward. Thank you for your support! Now let's do some testing - I will paste only some noteworthy lines:

Without keep-alive (spoiler: very good!!)

<S_CODE_TOKEN>

Just for the sake of benchmarking (it IS an utterly useless benchmark I know):

<S_CODE_TOKEN>

Now the real problem, testing with Keep-Alive:

<S_CODE_TOKEN>

48% of failed requests and very slow response. I hope this helps ...
",Rush,2013-09-17 09:37:15
477,2013-09-17 09:37:15,"oh wow, that's not good .. i'll look into this.. if you can figure out what's wrong please let me know..
i'm closing this one and opening another issue related to keepalive
",yawnt,2013-09-17 09:37:15
476,2013-09-17 02:56:14,"I fixed all the test suite according to the last refactor.

Accordign to the `cov/coverage.html` file created with `npm run-script test-cov` we got a 92% of the code covered.

Run the test suite and tell me any error/comment/feedback you got

Cheers!

cc: @yawnt 
",cronopio,2013-09-17 08:23:55
476,2013-09-17 08:23:59,"awesome work man.. thank you!
",yawnt,2013-09-17 08:23:55
475,2013-09-16 23:46:25,"@yawnt, I just found this bug in my code right after you merged #470
",srossross,2013-09-17 00:04:38
475,2013-09-17 00:04:27,"@srossross good looks, thanks!
",jcrugzz,2013-09-17 00:04:38
474,2013-09-16 19:00:07,"I see, eg, that the `ws-incoming` `stream` pass calls `unshift` on a socket, which I believe is a new method as of streams2. Since the `package.json` doesn't use the backwards-compatibility `readable-stream` package, that makes me think that caronte is not intended to support Node 0.8.

That's probably a reasonable decision to make, but could it be documented explicitly, in the README.md and/or the `engines` field of `package.json`?
",glasser,2013-09-16 19:38:09
474,2013-09-16 19:38:52,"i added that to package.json .. thanks for reporting the issue!
",yawnt,2013-09-16 19:38:09
473,2013-09-16 18:49:26,"I'm skimming the source of the caronte branch before rewriting my project (Meteor) to use its new API. (I've definitely been looking forward to this for a while since this is the main thing keeping Meteor stuck on Node 0.8!)  caronte is much easier to understand than the old code!

I notice that the `stream` pass in `ws-incoming` ignores the `head` argument.  ie, if there is any socket body data in the initial buffer sent to the http parser where the upgrade header it is detected, this `head` is the only access you get to those initial bytes, and they won't show up in a later stream from the socket.  You properly unshift the equivalent argument from the connection between the proxy and the proxy target, but the `head` (the data sent from the client) seems to be ignored.

As I said I have not actually tested caronte in practice yet; this issue is based just on reading the code. But the improper handling of this argument is related to the reason that the current http-proxy release is broken on 0.10 so I suspect that this is a bug.
",glasser,2013-09-17 08:34:18
473,2013-09-17 03:08:07,"Hi @glasser thanks for take some time in reading the `caronte` branch.

I just fixed the test suite in the `caronte-tests` according to the new changes, so, if you can propose a test case where we can reflect the behaivor that you said, would be very useful.

More info on https://github.com/nodejitsu/node-http-proxy/pull/476

Thanks!!
",cronopio,2013-09-17 08:34:18
473,2013-09-17 08:34:17,"sounds about right.. fixed.. thanks
also what @cronopio said.. it would be real useful :)
",yawnt,2013-09-17 08:34:18
472,2013-09-16 18:34:14,,glasser,2013-09-16 19:01:27
472,2013-09-16 19:04:06,"Merged, thanks!
",mmalecki,2013-09-16 19:01:27
471,2013-09-16 15:30:34,"I tried all your examples of using Node HTTP Proxy for WebSockets, cannot get it working.

I am also getting the following error on any request - `destroying non-socket.io upgrade`, locally before pushing to nodejitsu
",OmShiv,2013-09-16 15:57:15
471,2013-09-16 15:57:15,"Duplicate of #444, there are known issues with `node-http-proxy` running on `node v0.10.x`. @OmShiv Please test out the `caronte` branch and try to break it :). cc @yawnt 
",jcrugzz,2013-09-16 15:57:15
470,2013-09-16 15:14:11,"Let me know if you are accepting pull requests. I can also add some examples
",srossross,2013-09-16 20:02:59
470,2013-09-16 16:19:13,"@yawnt forgot to tag you
",srossross,2013-09-16 20:02:59
470,2013-09-16 16:42:51,"hey, yeah we definitely accept PRs.. thanks! 

if you could add some examples in the README (under Core Concept) it'd be awesome :)
",yawnt,2013-09-16 20:02:59
470,2013-09-16 20:04:33,"thanks :+1: 
",yawnt,2013-09-16 20:02:59
469,2013-09-15 20:01:25,"Again, I am trying the simplest use case:

<S_CODE_TOKEN>

Testing `ab2 -v 2 -c 1 -n 20 http://127.0.0.1:8081/`

<S_CODE_TOKEN>

Thanks for your support!
",Rush,2013-09-17 08:41:06
469,2013-09-15 20:08:13,"fixed
",yawnt,2013-09-17 08:41:06
469,2013-09-15 20:12:13,"I am afraid it is not completely fixed because the request does not finish.
Considering my test:

<S_CODE_TOKEN>

After that it simply hangs, and sometimes it ends at print `4` and sometimes it prints out `TEST` as well. The `4`  which is content-length should not be there, you write it to socket by accident I think.
",Rush,2013-09-17 08:41:06
469,2013-09-15 20:14:31,"ok i'll give it better look tomorrow morning.. thanks for taking the time to report this :)
",yawnt,2013-09-17 08:41:06
469,2013-09-16 22:00:45,"Still cannot get it work and it seems like the simplest use case. Could you provide any working single file test that would work as a reverse proxy?
",Rush,2013-09-17 08:41:06
469,2013-09-17 08:41:06,"I will open a different issue cause I seem to have identified the problem and will specify it there.
",Rush,2013-09-17 08:41:06
468,2013-09-15 19:04:09,"Hey, I just playing around with caronte and I have a question about dynamic proxying. From the README it seems this is the general flow:

<S_CODE_TOKEN>
",srossross,2013-09-16 20:09:55
468,2013-09-15 19:59:44,"yeah that's pretty how it should be done.. i want to remove the part where specifying an object in `createProxyServer` is mandatory, but i still haven't thought of a nice way.. some_url should be something like `require('url').parse('http://myurl.com:3000')`
",yawnt,2013-09-16 20:09:55
468,2013-09-15 20:04:34,"I don't want to create a new issue to ask this question - would caronte work with Keep-Alive connections properly? I mean, keeping Keep-Alive at `client -> caronte` and also from `caronte -> server` while utilizing it as a reverse proxy of course.
",Rush,2013-09-16 20:09:55
468,2013-09-15 20:12:18,"@RushPL i think so? honestly, i'm not sure.. i don't see why not since headers are copied.. 

if i were you and i needed such feature, i'd test it out and if it breaks open an issue :)
",yawnt,2013-09-16 20:09:55
468,2013-09-16 20:09:55,"@srossross hey, i saw you added to the PR auto-url parsing, so i'm closing this.. feel free to reopen should you have any more doubts :) 
",yawnt,2013-09-16 20:09:55
467,2013-09-15 15:33:13,"<S_CODE_TOKEN>

Run with `ab2 -v 2 -c 1 -n 20 http://127.0.0.1:8081/`

Will yield:

<S_CODE_TOKEN>

Now uncomment the:

<S_CODE_TOKEN>

The test will work but without headers being sent, please advice.
",Rush,2013-09-15 15:56:28
467,2013-09-15 15:35:14,"i didn't realize you were calling proxy.web directly, my bad.. in that case you do have to provide an object (not a string) .. this is also kinda lame.. i'll come up with something

about the headers.. i'm writing the outgoing pipeline described in the README.md which will implement res.writeHeader 
",yawnt,2013-09-15 15:56:28
467,2013-09-15 15:57:23,"works for me.. as a temporary workaround you can pass { target: require('url').parse(""MYURL"") }
",yawnt,2013-09-15 15:56:28
466,2013-09-15 15:01:37,"<S_CODE_TOKEN>
",Rush,2013-09-15 15:21:53
466,2013-09-15 15:09:27,"i need a gist to reproduce this
",yawnt,2013-09-15 15:21:53
466,2013-09-15 15:09:44,"please mark issues with the tag `caronte`, so i can look them up.. thank you!
",yawnt,2013-09-15 15:21:53
466,2013-09-15 15:16:54,"Unfortunately only repository contributors can add labels and I am not one of them.

Actually the error I pasted should trigger at any use of that function, since the `opts` is undefined. There is `var` declaration for it and it is an optional arguments enclosed in comments.

I was trying to put a quick test, first by using the README guidelines and next by following errors, and I have managed to run the below test (sorry it's not a gist) by jury rigging the mentioned bug.

<S_CODE_TOKEN>

I am not sure if above is the right usage, but the above test does not forward any headers from the target server, the client only gets:

<S_CODE_TOKEN>

Otherwise the performance seems very good! Perhaps my testing is premature but I am very curious.
",Rush,2013-09-15 15:21:53
466,2013-09-15 15:20:59,"i fixed opts [being undefined](https://github.com/nodejitsu/node-http-proxy/commit/adc5be020c7fff09a1c05ac771d5c5ab61002c23).. it should work now.. if you have trouble with headers please open another issue!

thanks
",yawnt,2013-09-15 15:21:53
465,2013-09-15 14:32:43,"`npm test`

<S_CODE_TOKEN>
",Rush,2013-09-17 09:38:23
465,2013-09-15 14:41:25,"you're right, tests are broken, i changed some structure.. so we're gonna have to update those
",yawnt,2013-09-17 09:38:23
465,2013-09-17 09:38:23,"fix'd
",yawnt,2013-09-17 09:38:23
464,2013-09-15 13:46:38,"- [x] engine.io
- [x] websockets
- [x] socket.io
- [ ] browserchannel
- [ ] sockjs
",yawnt,
463,2013-09-15 13:46:16,"https://github.com/yawnt/caronte/issues/10
",yawnt,2013-11-07 18:08:56
463,2013-09-17 11:50:37,"this should be fixed since error handling is now implemented.. @jcrugzz feel free to reopen if it's not the case
",yawnt,2013-11-07 18:08:56
463,2013-09-19 14:51:52,"The following [example](https://gist.github.com/jcrugzz/6624625) results in...

<S_CODE_TOKEN>

For one the error should be handled if the `EventEmitter2` wildcards are working properly so I have not yet determined if the client will receive the `end` event (which it should) upon the server being destroyed due to the proxy crashing the process. 

cc @yawnt
",jcrugzz,2013-11-07 18:08:56
463,2013-09-19 15:31:31,"@cronopio also we should have tests for cases like this for all the various transports as I believe we will hit some edge cases with various disconnects being triggered. 
",jcrugzz,2013-11-07 18:08:56
463,2013-09-20 23:33:15,"Ok, @jcrugzz by now there are tests for `ws` and `socket.io` and not for `primus`, I'll try to write it
",cronopio,2013-11-07 18:08:56
463,2013-09-20 23:54:10,"@cronopio thanks! and make sure the test cases handle when the server closes and the proxy errors. Keep up the good work :)
",jcrugzz,2013-11-07 18:08:56
462,2013-09-15 13:45:50,,yawnt,2013-11-07 17:45:46
462,2013-09-17 09:38:36,"fixed in #470 
",yawnt,2013-11-07 17:45:46
462,2013-09-19 14:52:26,"This should be documented somewhere. related to #463 
",jcrugzz,2013-11-07 17:45:46
462,2013-09-21 07:01:24,"The root of the problem is that listening on a wildcard error listener (`ee.on('*:error', function (err) {}`) does not get picked up with this [check](https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/caronte/passes/web-incoming.js#L111-L113) so we will always throw an error in this use case. We should hae 

@yawnt you think we could simplify the error listener in some manner (maybe to a simple `ee.on('error', function (err) {}`)? I feel like most use cases will only need this.
",jcrugzz,2013-11-07 17:45:46
462,2013-09-23 00:23:38,"As @srossross confirmed, we cannot use a single wildcard to cover multiple delimited sections. So if we are to continue to namespace the error handling in some way, we should choose something simpler. 

So we should think about what distinctions are important when handling errors. The `web:error` and `ws:error` idea seems reasonable as we may want to handle those cases differently for cleaning up connections. @yawnt what are your thoughts?
",jcrugzz,2013-11-07 17:45:46
462,2013-09-23 09:43:33,"yeah i've been trying to find a better way without losing the 'incoming/outgoing' differentiation.. since i have no idea yet i'll refactor like you suggested
",yawnt,2013-11-07 17:45:46
462,2013-09-27 19:22:22,"Why not drop whole silly namespacing completely and just ""tag"" the error instances with a type so people and we can filter based on that? For example:

<S_CODE_TOKEN>
",3rd-Eden,2013-11-07 17:45:46
462,2013-09-27 19:30:17,"not bad at all actually.. how close is EE3 to completion @3rd-Eden ? if i have to refactor i'd like to use that
",yawnt,2013-11-07 17:45:46
462,2013-09-27 19:33:57,"@yawnt EE3 works as intended, differences between normal EE and EE3 are explained in the README: https://github.com/3rd-Eden/EventEmitter3 ( also, it doesn't have namespaces ;-), never found them useful enough to implement )
",3rd-Eden,2013-11-07 17:45:46
462,2013-09-27 19:49:34,"@yawnt @3rd-Eden this sounds like a win. \o\
",jcrugzz,2013-11-07 17:45:46
462,2013-11-07 17:45:46,"`server.on('error'` was implemented.. namespaces were also dropped
",yawnt,2013-11-07 17:45:46
462,2014-02-04 16:23:47,"I just upgraded to the latests http-proxy in npm (1.0.2), I am using express JS and I get this error:

`TypeError: Object #<Socket> has no method \'status\'`

from my `server.on('error', function(err, req, res) {` error function because this is a websocket error, how do I distinguish  between the two types of errors?
",srossross,2013-11-07 17:45:46
462,2014-02-04 17:30:28,"@srossross yea i have been thinking how these should be separated. `wsError` is the best I've come up with for segmenting the two but still subideal. For now just do a check for `res.statusCode` or something of the sort. Messy I know but I'd love your thoughts on what you think works :)
",jcrugzz,2013-11-07 17:45:46
461,2013-09-15 13:45:38,"@cronopio status?
",yawnt,2013-09-17 09:38:46
461,2013-09-15 16:02:52,"related #465 
",yawnt,2013-09-17 09:38:46
461,2013-09-17 03:08:51,"I just open the PR related #476 
",cronopio,2013-09-17 09:38:46
461,2013-09-17 09:38:46,"fix'd
",yawnt,2013-09-17 09:38:46
460,2013-09-15 09:39:45,"[RFC 2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) Section 14.23 specifies that the port argument in the Host header is optional if connecting to default port (80 on HTTP f.e.). At the moment we always add the port, but I've encountered a website (10 mio pageviews a day) running IIS 7 that doesn't accept this host header and wants one without the port specified. See http://www.funda.nl. At the moment node-http-proxy doesn't work with this site if changeOrigin is enabled. Chrome f.e. doesn't add the port if doing a request for HTTP on port 80.

I saw only integration tests, no unit tests who cover this code, that's why there aren't any attached.

/cc @nathan7 
",janjongboom,2013-12-27 07:36:55
460,2013-12-27 07:36:55,"cherry-picked. Thanks.
",indexzero,2013-12-27 07:36:55
459,2013-09-12 15:54:18,"I spent quite a lot of time trying to getting a websocket proxy working on 0.10 before digging through the issues and realising 0.10 isn't supported. Maybe it would be worth adding a note to the readme that node-http-proxy is only compatible with 0.8?
",bfirsh,2013-09-17 08:38:26
459,2013-09-15 09:42:58,"+1 This is a pretty major feature break with no notes at all until digging around in the issues list.
",robertjpayne,2013-09-17 08:38:26
458,2013-09-12 14:50:53,"[RFC 2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) Section 14.23 specifies that the port argument in the Host header is optional if connecting to default port (80 on HTTP f.e.). At the moment we always add the port, but I've encountered a website (10 mio pageviews a day) running IIS 7 that doesn't accept this host header and wants one without the port specified. See http://www.funda.nl. At the moment node-http-proxy doesn't work with this site if changeOrigin is enabled. Chrome f.e. doesn't add the port if doing a request for HTTP on port 80.

I'd suggest changing the codez to:

<S_CODE_TOKEN>

Let me know if this is OK, then I'll open a PR.
",janjongboom,
458,2013-09-13 23:39:56,"Hey Jan - pullreq certainly welcome! (we have an incomplete pullreq for this already)
",edef1c,
458,2014-10-28 03:40:33,"When you going to fix this?
",whitecolor,
457,2013-09-10 14:27:38,"A couple of patches (one updating the README) which allow a user to handle middleware errors in much the same way they might in express. For example, within the middleware calling:

<S_CODE_TOKEN>

Now emits `middlewareError` and can be handled later like this:

<S_CODE_TOKEN>

This change is backwardly compatible and the old behaviour persists if nothing heard the `middlewareError` event.
",philjackson,2013-12-27 07:39:56
457,2013-12-27 07:38:41,"I like it.
",indexzero,2013-12-27 07:39:56
457,2013-12-27 07:39:56,"cherry-picked. Thanks.
",indexzero,2013-12-27 07:39:56
456,2013-09-06 16:19:42,"I am proxying an API which returns headers that need to be transformed.
",aaronshaf,2013-12-09 17:18:20
456,2013-12-09 17:18:20,"Hi @aaronshaf 
We're doing a rewrite of the proxy to work with node `0.10.x`, also Im working on improve the examples for the new proxy.

I got [an example](https://github.com/nodejitsu/node-http-proxy/blob/better-examples/examples/middleware/modifyResponse-middleware.js) for what you need here https://github.com/nodejitsu/node-http-proxy/blob/better-examples/examples/middleware/modifyResponse-middleware.js

If you got troubles or questions about that example, the [discuss is here](https://github.com/nodejitsu/node-http-proxy/pull/520) #520 

I'm goona close this, if you got further doubts please open a new issue
",cronopio,2013-12-09 17:18:20
455,2013-08-26 12:30:13,"Hi there. Please excuse my n00b status but I was wondering how I might be able to proxy a service at the end of a remote domain name to somewhere in my localhost domain.  When I use the usual method of proxying, the host doesn't know what I'm talking about because I think the hostname ""localhost"" is being passed as the hostname to the target server as opposed to the domain name I defined.  

<S_CODE_TOKEN>

If this dev server had a dedicated IP address I bet it would work but that's not the case as it shares an IP address with other servers.  I looked at the [Forward Proxy example](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/forward-proxy.js) which involves a remote domain name but I don't quite get why there are three services involved to connect two.
",rjsteinert,2013-11-07 18:21:48
455,2013-11-07 18:21:48,"if you only need to proxy that particular domain you can alias it in `/etc/hosts`, without using http-proxy!
",yawnt,2013-11-07 18:21:48
454,2013-08-23 12:02:35,"I am trying to log http and https traffic going through the proxy. After a little fiddling around I came up with the following code. Unfortunately it does not work for https and I am not sure why not.

<S_CODE_TOKEN>

Testing with `curl`

<S_CODE_TOKEN>

For `https` it just sits there and nothing happens. But I am not even getting a callback in the server.

Bug? Wrong expectations? What am I missing?
",tcurdt,
454,2013-10-03 21:51:18,"I am trying to achieve the same thing and apparently ended up writing my own proxy for https. From the http-proxy code I see there is no callback registered for ""CONNECT"" event.  

The following blog helped. 
http://newspaint.wordpress.com/2012/11/05/node-js-http-and-https-proxy/ 
",gisripa,
454,2013-10-15 16:47:14,"Same error here..
",cranic,
454,2013-11-19 23:30:54,"I believe that this is a similar error to the one happening for me and mentioned in issue https://github.com/nodejitsu/node-http-proxy/issues/453
",kalebdf,
453,2013-08-22 00:58:33,"Is it possible to use the module in https forward mode? I've tried different examples, though without any luck. It works fine for me in reverse proxy mode.

Basically when I try to do:

<S_CODE_TOKEN>

the proxy doesn't respond anything.

---

Further, is it possible to intercept data in https proxy mode? Like web debugging proxies do, eg. Charles. 
",runk,2013-12-19 04:14:40
453,2013-11-19 23:17:24,"I'd be interested in a solution to this: `HTTP` localhost --> `HTTPS` remote service.

On a possibly related note, I couldn't get the `vows` tests in `npm test` to pass on my Mac (npm `1.2.18` and node `0.10.5`)
",kalebdf,2013-12-19 04:14:40
453,2013-12-09 17:22:06,"There is [an example](https://github.com/nodejitsu/node-http-proxy/blob/better-examples/examples/middleware/modifyResponse-middleware.js) right now in the `better-examples` branch feel free to check it out and close this issue. Also if you got further questions the [discuss is here](https://github.com/nodejitsu/node-http-proxy/pull/520) #520 
",cronopio,2013-12-19 04:14:40
453,2013-12-18 11:04:49,"@kalebdf please check out the branch `caronte` in this repo, master is not compatible with 0.10.x
",yawnt,2013-12-19 04:14:40
453,2013-12-24 16:36:42,"better-examples is not accessible anymore. 
I'm looking to setup an HTTPS forward proxy as well, like the example: curl -x localhost:8080 https://github.com can you please send me an updated link or demo? also, for production, should I use caronte or the regular version?

Any step by step on how to generate the certificate and install it on the client browser (enterprise use case) so that the clients will not get the typical SSL warning? 
",damiga,2013-12-19 04:14:40
453,2014-01-06 06:10:48,"@damiga looks like examples now live here https://github.com/nodejitsu/node-http-proxy/tree/caronte/examples/http
",runk,2013-12-19 04:14:40
453,2014-01-06 09:20:34,"Have you been able to make it work in SSL man in the middle mode? (forward https to https)?
",damiga,2013-12-19 04:14:40
453,2014-01-06 22:08:25,"Nope. I needed this functionality to create a caching proxy for npm registry, but was unable to get it working. Eventually I did everything myself :) You can get a look at repo https://github.com/runk/npm-proxy-cache and particularly https://github.com/runk/npm-proxy-cache/blob/master/lib/proxy.js file. You can get an idea of how it's working there.
",runk,2013-12-19 04:14:40
453,2016-05-12 18:20:28,"hi @runk. Looked at your code but quick question: do I understand correctly that I need an external proxy server running (as identified by `mitmSocketPath`) ? I hoped this was a self-containing https forward proxy. Any help much appreciated
",gebrits,2013-12-19 04:14:40
453,2016-05-13 04:29:28,"@gebrits nope, it's just an option to set a path where internal https server keeps its spocket.
",runk,2013-12-19 04:14:40
452,2013-08-20 14:30:20,"I have been trying to use the nodeJS module to create a web proxy, but I have been unable to. Is this project really usable for creating web proxies (such as those we use to access the web anonymously) or can it only be used for reverse proxies for load balancing and whatnot?

What I am trying to do is a proxy server which you can configure in your browser's internet options, which will proxy all requests but intercept and respond to some with custom data.

I intend to implement a proxy server for easily swapping remote code with local files, which I intend to use in order to ease front-end JS development. Instead of reproducing whole environments from a remote site in my own machine, I intend to simply access the remote website and have this software swap ""main.js"" with a file on my machine.

Is this possible to do with this module?

Thanks ;)
",fabiosantoscode,2013-08-21 18:19:32
452,2013-08-21 18:19:24,"I spent some more time tinkering and was able to do what I wanted. Now I can change the frontend scripts without access to my colleagues' full setup, which is great.

Thanks for the wonderful library :)
",fabiosantoscode,2013-08-21 18:19:32
452,2015-07-17 17:14:23,"Hey @fabiosantoscode! How did you handle the static resources? For me only the main html file gets loaded. Here's a quick example of my code:

<S_CODE_TOKEN>
",tarkeshwars,2013-08-21 18:19:32
452,2015-07-25 21:10:13,"I didn't pass so many options. The ignorePath one is catching my eye, could the proxy be resolving `/static/*` to `/`?
",fabiosantoscode,2013-08-21 18:19:32
452,2015-07-25 21:10:57,"While debugging this you might find it useful to look at your server's access log and see if the proxy is requesting the right stuff.
",fabiosantoscode,2013-08-21 18:19:32
451,2013-08-18 04:54:53,"I cannot seem to get einaros/ws websockets proxied.  The example code I am using is here:

https://gist.github.com/verma/6259211

I have posted a question regarding this on stackoverflow as well.  

http://stackoverflow.com/questions/18294586/proxying-websockets-through-node-http-proxy-doesnt-work

In this example when I connect directly to the websocket server, things seem to work fine (port 19000 instead of 9090).
",verma,
451,2013-09-11 16:56:27,"I think I am having the same problem. 

Did you try sending a message from **ws** as soon a new client is connected? In my case **ws** is registering a new client, but the browser (**ws** client) is not receiving the connection event. If I send a message from **ws** when a new client is detected the browser gets the event.

I am using node v0.10. It was working on v0.8 AFAIK.
",rc1,
451,2013-09-11 17:03:03,"Seems to be related #444 
",rc1,
451,2013-11-07 18:19:52,"hi!
we are in the process of refactoring node-http-proxy to make it compatible with 0.10.x. you should check out [caronte](https://github.com/nodejitsu/node-http-proxy/tree/caronte) and give it a go with that!
thanks!
",yawnt,
450,2013-08-16 02:03:56,"It'd be nice to be able to set a custom error message in a property of the options object that get passed in to `httpProxy.createServer(options);`

The property could be called `errorMessage` and to make it work you'd only have to add a conditional test around line 303 of /lib/node-http-proxy.js and line 211 of /lib/node-http-proxy/http-proxy.js.

<S_CODE_TOKEN>

Then we could do things like

<S_CODE_TOKEN>

Personally, I'd take it further and also allow options.errorMessage to be a function that returns a string. This would allow the most imaginative people to do things like display error messages at random.
",trusktr,
449,2013-08-06 03:34:14,"Use case:

URL looks like:  host:port/a/b/c

Want to map ""a"" to a host, ie host2:port2, and rewrite to host2:port2/b/c.

There doesn't seem to be a mechanism in place to do such a thing.

Thanks.
",robertjchristian,
449,2013-08-07 08:52:25,"+1
",MrSwitch,
449,2013-08-20 11:45:55,"+1
",foxbunny,
449,2013-08-27 13:09:45,"+1
",michaellopez,
449,2013-09-15 10:01:57,"It requires adding a middleware for this that would do such redirects. I have added such feature to https://github.com/RushPL/rush-http-proxy (which is based on node-http-proxy). You may see how it is implemented there (in case you use http-proxy as a module) or otherwise just use my CLI tool.
",Rush,
449,2013-09-17 05:15:02,"I determined this is actually brain-dead simple, and perhaps why it's not a specific request.  

Consider:

// proxy requests to target
proxy.proxyRequest(req, res, TARGET_SERVER);

To rewrite the URL prior to proxy, simple do:

req.url = ""/foo"";

Of course you can add any logic necessary to the rewrite.  Didn't realize it was that simple.

I no longer think there is a need for this as a middleware or a ""feature""
",robertjchristian,
448,2013-08-05 23:44:28,"I am having an issue where i get a 3 - 5 second delay handling the websocket protocol upgrade.  I have found this to be the case using node v0.8.25 as well as node v0.10.15.  I also tried http-proxy@0.8.0 and 0.10.  Here is the code I am using https://gist.github.com/joshontheweb/6160503.

You can see the difference by looking at these 2 urls:
direct to application server: http://192.241.227.80/
via http-proxy load balancer: http://192.241.227.86/
",joshontheweb,2013-10-01 05:15:25
448,2013-10-01 04:45:55,"@joshontheweb did you solve this ? or find something ?
",matthiasg,2013-10-01 05:15:25
448,2013-10-01 05:12:03,"@joshontheweb @matthiasg I would encourage both of you to test out the `caronte` branch of `node-http-proxy` as that will be the replacement for `0.10.x` and beyond. Please open any issues if you find anything!
",jcrugzz,2013-10-01 05:15:25
448,2013-10-01 05:15:25,"I would encourage both of you guys to checkout the [`caronte`](https://github.com/nodejitsu/node-http-proxy/tree/caronte) branch and let us know if you run into the same issue!
",jcrugzz,2013-10-01 05:15:25
448,2013-10-03 20:12:15,"@mattiasg sorry, no I never found a solution so i ripped out the load balancer.  I haven't tried the caronte branch though.
",joshontheweb,2013-10-01 05:15:25
448,2013-10-10 10:24:43,"will try it again then

On Thu, Oct 3, 2013 at 10:12 PM, Josh Nielsen notifications@github.comwrote:

> @mattiasg https://github.com/mattiasg sorry, no I never found a
> solution so i ripped out the load balancer. I haven't tried the caronte
> branch though.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/448#issuecomment-25653870
> .
",matthiasg,2013-10-01 05:15:25
447,2013-08-03 04:41:46,"The proxyWebSocketRequest() function for handling upgrades does not appear to work with engine.io.
",jondubois,2014-02-20 09:28:50
447,2014-02-19 19:37:02,"We experienced this with v0.8.6. Updated to v1.0.2 and everything is peachy.
",danmactough,2014-02-20 09:28:50
447,2014-02-20 09:28:50,"Thanks for the update!
",indexzero,2014-02-20 09:28:50
446,2013-07-29 20:55:09,"http://tools.ietf.org/html/rfc2616#section-14.10

<S_CODE_TOKEN>

It looks to me like http-proxy currently passes along the Connection header value without parsing it. That might be OK assuming that the value will only ever be keep-alive or close, but it seems like it'd be better to follow the spec.

Currently, if the browser asks for keepalive, then the request to the target server will also use keepalive. This doesn't seem like very sensible default behavior to me; instead the browser-to-proxy keepalive policy should be totally independent from the proxy-to-target keepalive policy. In my project the browser might be connecting to the proxy via HTTPS over TCP, so we certainly want to use keepalive; but the proxy connects to the target servers using HTTP over domain sockets, so we don't want to use keepalive. Right now I can accomplish this by parsing and modifying the Connection header myself, but it seems more in the spirit of HTTP for the proxy to treat connection persistence as a hop-by-hop concept.

(Additionally, http://tools.ietf.org/html/rfc2616#section-13.5.1 indicates a number of headers that shouldn't be automatically forwarded by proxies: Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, TE, Trailers, Transfer-Encoding, and Upgrade.)
",jcheng5,
446,2013-07-29 20:56:15,"Should this be filed as multiple issues? Let me know if I should refactor.

Thanks!
",jcheng5,
445,2013-07-28 20:04:45,"I am trying to write a header on the response object from within the proxy:

<pre>
// dependencies
var httpProxy = require('./lib/node-http-proxy'),
    http = require('http');

// 
// Setup proxy server on 8000
//

var server = httpProxy.createServer(function (req, res, proxy) {

  // fetch cookies
  var cookies = {};
  req.headers.cookie && req.headers.cookie.split(';').forEach(function( cookie ) {
    var parts = cookie.split('=');
    cookies[ parts[ 0 ].trim() ] = ( parts[ 1 ] || '' ).trim();
  });
  
  console.log(cookies);

  // write session cookie
  res.writeHead(200, {
    'Set-Cookie': 'token=12345678'    
  });

  // proxy requests to localhost:9000
  proxy.proxyRequest(req, res, {
    host: 'localhost',
    port: 9000,
  });

});
server.listen(8000);



//
// Dummy target server on port 9000 (echo request)
//
http.createServer(function (req, res) {
 
 res.write('Echo service: ' + req.url + '\n' + JSON.stringify(req.headers, true, 2));
  
  res.end();
  
}).listen(9000);
</pre>


And http fails with ""Cannot write header/s after they have been written.""  Reverse proxy documentation says nothing about setting cookies.  What am I doing wrong?
",robertjchristian,
445,2013-07-29 01:03:29,"This isn't going to work because `proxy.proxyRequest` calls `res.writeHead` too (and `res.writeHead` flushes headers). I don't think there's a way to walk this around so I'm going to leave this open as a feature request.
",mmalecki,
445,2013-08-03 19:47:46,"I suggest to close this issue since we can quite easily achieve replacing of headers by ""emulating"" express middlewere and replacing setHeader.

<S_CODE_TOKEN>
",aiboy,
445,2016-04-24 09:14:58,"@aiboy, I tried your solution on a recent boilerplate (since that was written in 2013) and while I'm able to modify/override any header property, I can't get a cookie to save under resources, jessionid in particular.
",adi518,
445,2016-06-09 14:37:40,"Is there any solution with cookies received from a proxied subdomain, which also contain the **""domain""** attribute?

We cannot authenticate from localhost (we are using webpack-dev-server) because of this problem. The 'domain' attribute for the received cookie is different from 'localhost' (obviously) and this causes the authentication to not work on the next call.

Is there any solution or trick to this problem? (i.e. automatically changing the ""domain"" attribute value through a proxy rule or code?)

Thanks!
",afilp,
445,2016-06-09 14:40:56,"Actually... is this PR what I am really looking for?

https://github.com/nodejitsu/node-http-proxy/pull/1009

If yes, can you **please** add it to the library?

Thanks!
",afilp,
445,2016-07-13 12:42:52,"What status is this feature ? is this still going on?
",qbaty,
444,2013-07-25 21:14:48,"I am using http-proxy to proxy to the socket.io driven app [tty.js](https://github.com/chjj/tty.js/)

The socket does not seem to be connecting most of the time. 1 of 5 times I refresh the page it connects, otherwise I see `Text Status: Pending` for the websocket, in chrome developer tools: 

I am using:
- Amazon EC2 linux: `$uname -a
  Linux ip-10-236-133-58 3.4.37-40.44.amzn1.x86_64 #1 SMP Thu Mar 21 01:17:08 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux
  `
- Either `node v0.10.13` and `node v0.6.21`
- `http-proxy@0.10.3`
",srossross,2013-12-18 11:05:05
444,2013-07-25 21:16:24,"The commands I am using are:
- `node ./bin/tty.js --port=4003`
- `node ./bin/node-http-proxy --target localhost:4003  --host 0.0.0.0 --port 2228`
",srossross,2013-12-18 11:05:05
444,2013-07-25 21:20:27,"Websocket proxying is broken in Node 0.10, see #387 (which is incorrectly closed). It is obviously broken in http-proxy 0.10.1 and subtly broken in http-proxy 0.10.2.

I'm keeping all my work (eg, meteor) on 0.8 (and keeping http-proxy at 0.10.1) until this is fixed. There is some work being done on the `0.10.x` branch to fix this, which is great.
",glasser,2013-12-18 11:05:05
444,2013-07-26 04:36:07,"> Websocket proxying is broken in Node 0.10, see #387 (which is incorrectly closed). It is obviously broken in http-proxy 0.10.1 and subtly broken in http-proxy 0.10.2.

Ok, thank you, this does not solve my problem, but it does occur less frequently.

> I'm keeping all my work (eg, meteor) on 0.8 (and keeping http-proxy at 0.10.1) until this is fixed. There is some work being done on the 0.10.x branch to fix this, which is great.

Is there anyone who knows what the underlying issue is? Where can I track this? Both for `nodejs` and `node-http-proxy`. 
",srossross,2013-12-18 11:05:05
444,2013-08-09 09:18:36,"I'm also very interested about this. Where can I check the current work on the 0.10.x support?
",jokesterfr,2013-12-18 11:05:05
444,2013-08-14 00:15:03,"Is there anyone who knows what the underlying issue is? 
Where can I track this?
",srossross,2013-12-18 11:05:05
444,2013-08-21 05:43:10,"@yawnt Is working on the updates for `node@0.10.x`. We are aware of this issue and are working on a solution, but the implementation around `streams2` is non-trivial as `node-http-proxy` is one of the oldest node libraries.
",indexzero,2013-12-18 11:05:05
444,2013-08-21 15:42:22,"@indexzero, @yawnt, thanks for the response.  One issue that I noticed is that `node-http-proxy` does not proxy websockets (at all) to tornado servers as of `node>=v0.8`

To test this - Try proxying to an `IPython notebook`
Use `*nix` OS (works on mac osx) download and install the anaconda Python Distribution http://continuum.io/downloads
Run:

<S_CODE_TOKEN>

Click `create notebook` to get to a page with a web-socket.
",srossross,2013-12-18 11:05:05
444,2013-08-22 13:15:56,"@srossross simpler than that, the `http-proxy` test-case for websocket just does the trick (ie: fails with node 0.10.x) : https://github.com/nodejitsu/node-http-proxy/tree/master/test/ws
",jokesterfr,2013-12-18 11:05:05
444,2013-09-09 16:39:15,"@yawnt I noticed that you have not committed to the 10.x branch for a month.  I am sorry for being persistent, but this is very important to me.  I am also trying to evaluate whether I should just jump in and start finding my own solution or wait for the 10.x branch to be completed.
May I ask what your timeline is? What is blocking you from completing it?  Are you waiting on improvements in stream2? 

Sorry and thank you for your patience
",srossross,2013-12-18 11:05:05
444,2013-09-09 16:49:32,"@srossross i'm working on another repo that is going to be eventually merged into node-http-proxy
",yawnt,2013-12-18 11:05:05
444,2013-09-09 20:13:06,"@yawnt: Is there a way to help? Is it your branch 10.x specifically?
",Rush,2013-12-18 11:05:05
444,2013-09-15 10:19:43,"@RushPL @srossross I believe Yawnt is working on https://github.com/yawnt/caronte.git
",robertjpayne,2013-12-18 11:05:05
444,2013-09-15 10:23:49,"Cool, so I gather node-http-proxy will move to internally use that module and in itself being simply a configuration parser, router?
",Rush,2013-12-18 11:05:05
444,2013-09-15 10:41:06,"@RushPL No idea how they plan to merry them up and integrate, I simply was just pointing towards the other repository incase you wanted to have a look. I have no idea how stable or ready it may be, only testing could show.
",robertjpayne,2013-12-18 11:05:05
444,2013-09-15 18:52:09,"@RushPL Thanks, I'm looking at caronte. 
",srossross,2013-12-18 11:05:05
444,2013-12-09 17:27:59,"Hi guys, thanks a lot to all of you for the discuss and the patience. Please check it out the `caronte` branch, we are so excited about your feedback using that branch, also I been working improving the examples, so check also this PR #520, the issues commented here should be resolved there.
",cronopio,2013-12-18 11:05:05
444,2013-12-18 11:05:05,"i'm going to close this as it focuses on the old version which is replaced by `caronte`. feel free to open issues regarding that branch if you bump into any :)
",yawnt,2013-12-18 11:05:05
444,2013-12-18 17:49:25,"Well, it's not my project...  
Personally, I would not close an issue until it is fixed in master.  It is not obvious to the casual user that they should be using some specific branch, particularly a branch with a cryptic name like 'caronte'.

I spent a little time trying to switch to caronte, but since I used the ProxyTable feature which is not in caronte, it was non-trivial to switch. 
",risacher,2013-12-18 11:05:05
444,2013-12-18 18:04:51,"@risacher caronte is the new master, the current `master` branch is deprecated and is just there until the migration is complete (since it's a complete refactor and not a bugfix) :)
",yawnt,2013-12-18 11:05:05
443,2013-07-11 14:02:02,"I've got recurrent errors using http-proxy@0.10.3 with the following message. How to avoid it ?

http.js:687
    throw new Error('Can\'t render headers after they are sent to the client.'
          ^
Error: Can't render headers after they are sent to the client.
    at ServerResponse.OutgoingMessage._renderHeaders (http.js:687:11)
    at ServerResponse.writeHead (http.js:951:20)
    at ClientRequest.proxyError (/home/nodejs/node_modules/http-proxy/lib/node-http-proxy/http-proxy.js:203:9)
    at ClientRequest.g (events.js:192:14)
    at ClientRequest.EventEmitter.emit (events.js:96:17)
    at Socket.socketErrorListener (http.js:1331:9)
    at Socket.EventEmitter.emit (events.js:96:17)
    at Socket._destroy.self.errorEmitted (net.js:329:14)
    at process.startup.processNextTick.process._tickCallback (node.js:244:9)
",nfroidure,
443,2013-07-16 08:10:27,"Here is the code i use:

<S_CODE_TOKEN>
",nfroidure,
443,2013-07-16 08:14:34,"Seems to be a duplicate of https://github.com/nodejitsu/node-http-proxy/pull/388
",nfroidure,
443,2013-07-16 08:18:00,"Maybe usefull:

<S_CODE_TOKEN>
",nfroidure,
443,2014-01-05 08:46:55,"I am getting this error when trying to proxy http://www.amazon.de/ website. Can someone reproduce the bug for this website?
",inian,
442,2013-07-10 22:21:18,"Hi, 
I need to modify a request body before proxying to another server.
So far, I managed to make it almost work perfectly using the bodyParser and connect-restreamer modules, but the **changes made to the req.body are lost on proxying** as in the example below. 

Basically the req coming from A has the attributes x, y & z. I need to remove z, change the value of y and and add w so that the end server B to which I am proxying will have x, y*, w.

I added a middleware that does the job of modifying the body and req.url. However when the request is proxied through, it seems like the modifications to the body are always lost as if it posts the original body, not the final one (or is the req.body read-only?). The changes to other properties such as req.url are being proxied correctly.

Is there another way to accomplish this? What am I doing wrong? If req.body is read-only in node-http-proxy, how would you accomplish this?

Thanks for the help

... my current code

<S_CODE_TOKEN>
",micheltem,
441,2013-07-05 05:02:54,"i'd like to use nodejitsu.com to host an app that does rendezvous between two processes, cf., the ""HTTP-specific protocol"" implemented here:

<S_CODE_TOKEN>

the problem is that ithe appt needs to be able to ""park"" an incoming HTTP connection from one client while waiting for a connection from a second client. 

i believe that the easiest way to implement this is for node-http-proxy to implement connect transparently, e.g., node-http-proxy receives

  CONNECT ... HTTP/1.1
  Host: example.nodejitsu.com

establishes a connection to port 8080 on the application, sends the CONNECT verbatim and then transparently copies octets over the connection until it closes, e.g.,

<S_CODE_TOKEN>

what's your thinking?

thanks!

/mtr
",mrose17,2016-01-20 23:39:06
441,2016-01-20 23:39:06,"This question was relevant to nodejitsu as a service before we shut down. Closing due to irrelevance to the library in question as its possible to tap into the `connect` event. Open a new issue if you have a problem.
",jcrugzz,2016-01-20 23:39:06
440,2013-07-04 01:18:53,"This resolves issue #401.
",Rush,2013-12-27 07:16:02
440,2013-09-09 20:14:27,"I wonder, is anything in particular stopping this pull request? These are merely improvements to the node-http-proxy command line tool.
",Rush,2013-12-27 07:16:02
440,2013-09-09 21:25:28,"+1 for merging this. CA bundles are required for some SSL providers, e.g. certum.pl.
",Nowaker,2013-12-27 07:16:02
440,2013-12-27 07:16:01,"No tests. Fails JSHint.
",indexzero,2013-12-27 07:16:02
440,2013-12-27 15:47:21,"Is there any will to have this? As I understand you are stripping down node-http-proxy to bare proxying library. (which is good!!) Since this pull request I have made a more high level proxy with above feature at https://github.com/CodeCharmLtd/rush-http-proxy currently being improved to use caronte and have its own http-dispatch-table with host-based / wildcard and regexp.
",Rush,2013-12-27 07:16:02
440,2013-12-27 16:36:46,"No, the caronte branch is going to be a library only. But thanks for asking :)
",yawnt,2013-12-27 07:16:02
439,2013-07-01 23:50:06,"Calling http-proxy.buffer(stream) will do stream.on('data). This puts the stream into  old mode (http://nodejs.org/api/stream.html#stream_event_data). If I then try and use the new stream interface with that stream, it won't work properly. I'll get 'readable' events, but all calls to read() will return null.

EDIT:
Nevermind, I think this was my error.
",dkillebrew,2013-10-22 06:55:57
438,2013-06-28 08:29:54,"I tried to use http-proxy today using a global install, but the module could not be found. A local install worked fine. FYI I was running a simplified node script without any packages, just a web-server.js file.

DOES NOT WORK
npm install -g http-proxy
-> Error: Cannot find module 'http-proxy' 

WORKS
npm install http-proxy

Thanks for a great module!
",kretz,2013-07-02 15:22:48
438,2013-07-01 10:05:52,"Is the installation failing? The error message you're posting looks like it comes from trying to require() a module that you don't have. You probably want to install it locally.
From the npm documentation:
- Install it locally if you¬¥re going to require() it.
- Install it globally if you¬¥re going to run it on the command line.
- If you need both, then install it in both places, or use npm link.
",ruquay,2013-07-02 15:22:48
438,2013-07-02 15:22:48,"This is how `node` module works. @ruquay is right here.
",mmalecki,2013-07-02 15:22:48
437,2013-06-26 22:27:31,"I have a question on how I can get node-http-proxy to handle requests sent to external IP addresses. An example:

I have node-http-proxy listening on port 1.1.1.1:80
I have all of my traffic being forwarded untouched to 1.1.1.1:80
However, since the packet was untouched. The proxy is ignoring the request due slashdot.org resolving as 123.123.123 as its destination IP.

I also tried to DNAT requests to my proxy, however, I would loose the source IP of the client which would break my internal logic of the proxy.

Is there a guide on how to setup a transparent proxy with node-http-proxy?

Thanks!
",fostahgix,2013-12-27 08:02:08
437,2013-07-01 10:01:10,"If you post some code, it might be clearer what you are trying to do. Are the IP addresses your are using examples, or are they actual values? Because for me slashdot.org doesn't resolve to 123.123.123 (which isn't even a full IP address) or anything like it.
",ruquay,2013-12-27 08:02:08
436,2013-06-22 05:59:24,"I've been using this package to route connections to dozens of apps all over my server. Recently, I've been trying to add HTTPS to some of them. I managed to work out the following, which works: https://gist.github.com/DanH42/5836006

In that example, domain1.com is only available over plain HTTP, domain2.com and domain3.com use HTTPS with a custom certificate, and domain4.com uses a self-signed one. If SNI fails, the self-signed cert is served (I think; the documentation was somewhat unclear on that part).

I need to add another domain that will have to use WebSockets over SSL, and my application seems to be unhappy unless SSL is used end-to-end, meaning I need to add an HTTPS-to-HTTPS route in the proxy. However, the majority of my apps that use HTTPS on the outside still just use plain HTTP on localhost, and I'd like to keep it that way.

This means I need to be able to proxy HTTP, HTTPS-to-HTTP, _and_ HTTPS-to-HTTPS, while using multiple certificates. I got as far as https://gist.github.com/DanH42/5836026 and am now stuck.

In that case, the new domain is domain5.com, which needs to use HTTPS-to-HTTPS. My main problem is that the `target` option seems to have to be provided directly to `httpProxy.createServer` rather than per-site.

Is what I'm trying to do even possible? Is there a better way? Any help would be greatly appreciated.
",DanH42,2016-01-20 23:36:33
436,2016-01-20 23:36:33,"This is possible and will require multiple instances of `http-proxy` that you use within a single node process. Your code is based on the old version of `http-proxy` so if you still have an issue with the new version, please open an issue. Thanks!
",jcrugzz,2016-01-20 23:36:33
435,2013-06-21 16:00:53,"More of a question than an issue..

The Issue: When manually changing the req.headers.host to a remote host ('example.com'(and some other custom logic)), the url in the the browser is not changing.

Note: I thought this was working, however when using google.com as my example, it turned out google was detecting the proxy and changing the host.

Question: Is there a way to change the url in the browser to a remote host (ie. example.com), everytime? Thanks!

Example: myproxy.com:8004/?url=example.com -> would change url in the browser to example.com.

The code I am using to do this currently:
var util = require('util'),
    colors = require('colors'),
    http = require('http'),
    httpProxy = require('../../lib/node-http-proxy');

//
// Http Server with proxyRequest Handler and Latency
//
var proxy = new httpProxy.RoutingProxy();
http.createServer(function (req, res) {
  req.headers.host = 'example.com'; // manually setting example.com
  // and some other custom logic before proxying...
  var buffer = httpProxy.buffer(req);
  setTimeout(function () {
    proxy.proxyRequest(req, res, {
      port: 80,
      host: 'example.com',
      buffer: buffer
    });
  }, 200);
}).listen(8004);

Any help is greatly appreciated!
",fostahgix,2013-06-23 13:16:18
435,2013-06-23 13:16:18,"You're not looking for a proxy at all. You're looking for a way to redirect requests. 

<S_CODE_TOKEN>
",mmalecki,2013-06-23 13:16:18
435,2013-06-24 16:21:36,"Thanks for the followup. The requirement was to evaluate the clients IP and user-agent evaluate` on some logic, either pass the request through to its original endpoint, or change the endpoint to a splash page.

So the flow on our system would be.
-User connects to our system.
-User navigates to example.com
-That request(and all port 80 requests) is redirected to our proxy via iptables (ie. proxyserver:8004/?url=http://example.com)
-The proxy determines if the request should continue to example.com or be redirected to splashpageexample.com.

So if we just do a 301, I think we will get into an endless loop of redirects. Is there anyway to just change the endpoint of the request while changing url in the browser so it is transparent to the user that their request being evaluated before being passed through?  Thanks for any advice on this!
",fostahgix,2013-06-23 13:16:18
434,2013-06-20 14:58:53,"What is the current way to modify headers, say, to inject Basic Authentication into a proxied request?

I am having trouble, and tried _two_ different ways. Am I missing something?

http://stackoverflow.com/questions/17174862/modify-headers-of-proxied-request
",ghost,2013-09-07 23:02:37
434,2013-07-01 10:45:47,"I answered your question on StackOverflow, but here's the code below as well:

<S_CODE_TOKEN>
",ruquay,2013-09-07 23:02:37
434,2013-10-17 04:12:35,"Thanks @ruquay, that fixed my problem too.
",aexmachina,2013-09-07 23:02:37
434,2014-01-24 02:51:31,"thanks it solved my problem
",karthikbalu,2013-09-07 23:02:37
433,2013-06-19 07:45:55,"- [WebSocket] header Sec-Websocket-Origin missing  (IE9 with flashsockets)

After upgrading from 0.8.7 to 0.10. Worked fine before that. \* XHR works but is unstable. 

Here is my code. even tried to manually add it:

<pre>
 server.on ""upgrade"", (req, socket, head) ->
     req.headers[""sec-websocket-origin""] = req.headers[""origin""]
     for e of req.headers
       console.log e + "": "" + req.headers[e]
     console.log ""Websocket: #{req.url}"", head
     backends.express.proxyWebSocketRequest req, socket, head
</pre>


The header now looks like this: 

connection: Upgrade
host: {website.com}
origin: http://{website.com}
cookie: __utma=232169373.1461931670.1369898552.1371626296.1371629001.25; __utmz=232169373.1369898552.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmb=232169373.16.10.1371629001; __utmc=232169373; __atuvc=3%7C17; session=7e2v8ij15hevksve63jjref7g0
sec-websocket-key1: 24  V   #   3 1 8849 5s0
sec-websocket-key2: f+41> I`08f;$51  5 1  6S  -    sO8
Sec-Websocket-Origin: http://{website.com}
",samsonradu,2016-01-20 23:34:28
433,2016-01-20 23:34:28,"This is referring to an old version of http-proxy. Please try versions `1.x.x` and open an issue if you have a problem, Thanks!
",jcrugzz,2016-01-20 23:34:28
432,2013-06-15 00:51:57,"Hi,

Was wondering your thoughts on allowing the proxy to act as a full superset of the http or https APIs (Server, ServerResponse) whereby the ""proxy"" could be a transparent go-between for existing server code and middleware?

My interests are:
1. To avoid setting up listeners on different ports (and adding the code to do so) while still getting the benefits of middleware.
2. To make the addition of middleware even easier by simply swapping the requiring of ""http"" or ""https"" with either:
   - a generic proxy module (in which case one would also need to change one's existing code by adding middleware callbacks at the end of `createServer`) OR
   - a reusable module already baking in some specific middleware (thereby avoiding the need to modify existing code at all--excluding changing `require(""http"")` to require one's module)

Maybe this doesn't fit into your scope, so if not, it appears one could at least do this while supporting your middleware module API...

Thanks,
Brett
",brettz9,2013-06-15 02:18:53
432,2013-06-15 02:18:53,"You are right, this is not in our scope.
",indexzero,2013-06-15 02:18:53
432,2013-06-15 06:31:56,"K, thanks, I implemented my own version at https://github.com/brettz9/htteepee
",brettz9,2013-06-15 02:18:53
431,2013-06-10 15:36:58,"Refers to this issue:
https://github.com/nodejitsu/node-http-proxy/issues/386
",Giuliano84,2013-12-27 07:31:03
431,2013-12-27 07:31:03,"We're dropping the `ProxyTable` in `node-http-proxy@1.0.0`. If you want to take ownership of it `proxy-table` is available on `npm`! :-D
",indexzero,2013-12-27 07:31:03
430,2013-06-09 19:35:56,"Includes socketPath support for routing table, and hack to ensure 'socket' event is done after 'upgrade' event
",openhoat,2013-12-27 07:13:06
430,2013-08-09 09:32:55,"I've just tested your patch... it seems it's still not working with the ./example/websocket/websocket-proxy.js yet :/
",jokesterfr,2013-12-27 07:13:06
430,2013-12-27 07:13:06,"If you want websockets on `node >= 0.10.0` use `node-http-proxy@1.0.0`. This is currently on the `caronte` branch but will be released soon.
",indexzero,2013-12-27 07:13:06
429,2013-06-04 12:25:47,"This change enables proxying (for hostnameOnly tables) based on wildcard domains of the type *.foo.com, which is something I need for a project. I've included tests and docs.
",darobin,2013-12-27 07:30:55
429,2013-08-11 17:17:26,"+1
",ungoldman,2013-12-27 07:30:55
429,2013-12-27 07:30:55,"We're dropping the `ProxyTable` in `node-http-proxy@1.0.0`. If you want to take ownership of it `proxy-table` is available on `npm`! :-D
",indexzero,2013-12-27 07:30:55
428,2013-05-31 01:37:19,"reverseProxy can have many subscribers to the 'drain' event when large
uploads occur. This can be avoided by setting the maxlistener to a value / unlimited. 

added a new option for the same. 
",vinodsr,2013-12-27 08:01:30
428,2013-12-27 08:01:30,"Cherry-picked. Thanks!
",indexzero,2013-12-27 08:01:30
427,2013-05-23 19:30:11,"windows xp ie8 page wont load
every other browsers seems to be fine even ie8 on vista or win7 works but on xp the page times out. 
",pellepelle3,2013-05-23 23:46:58
427,2013-05-23 23:39:04,"More details please. Code, what errors are you seeing, etc.
",mmalecki,2013-05-23 23:46:58
427,2013-05-23 23:44:22,"Yeah sorry about that I'm actually unsure atm I thought it was the proxy but it seems to a more obscure problem i did a http 301 redirect with a header change to make the http responses be pushed to https but it works fine in one set of code on all browsers and another app run on a different ip same code essential and works on all but windows xp ie8
",pellepelle3,2013-05-23 23:46:58
427,2013-05-23 23:46:58,"Okay, I'm going to close this one until you can provide more details then.
",mmalecki,2013-05-23 23:46:58
426,2013-05-23 18:28:15,"I'd like to send the request again when the server being proxied exhibit certain behaviors. Is this possible? I've tried doing this:

<S_CODE_TOKEN>

But, this doesn't appear to send the request to the server again, and no response is ever given to the client.
",TrevorBurnham,2013-05-23 18:47:07
426,2013-05-23 18:47:06,"@TrevorBurnham Try removing the `process.nextTick`. You want to ensure that the socket of the response has not already closed in order to be able to retry the proxy. I believe you can check `res.connection.destroyed`. 

I am guessing that the wait time of `process.nextTick` is too long so the underlying TCP socket is already closed. Reopen the issue if you can't get it to work :).
",jcrugzz,2013-05-23 18:47:07
426,2013-05-23 19:06:29,"Thanks for the quick response. Unfortunately, removing `process.nextTick` doesn't seem to have any effect. The scenario I'm testing is:
1. I shut down the server,
2. I start the proxy, 
3. The client sends a request via the proxy, and
4. Then I start the server

Logging the `err` argument, I'm seeing a bunch of `ECONNREFUSED`s alternating with a bunch of `ETIMEDOUT`s‚Äîwhether I ever start the server or not. The server never receives a request, and the client never receives a response.
",TrevorBurnham,2013-05-23 18:47:07
425,2013-05-21 08:11:31,"I want to catch event when reverseProxy is on timeout 

maybe ...
in http-proxy.js

<S_CODE_TOKEN>
",sanggyun,2016-01-20 23:33:08
425,2013-07-12 22:20:40,"+1 this would be super nice. Just automatically sending a 504 on timeout would be great.
",alum,2016-01-20 23:33:08
425,2013-09-09 13:44:40,"This would be really nice, but you'd have to work out who is responsible for calling res.end() somehow.
",philjackson,2016-01-20 23:33:08
425,2016-01-20 23:33:08,"This is from the old version of http-proxy, please open up a new issue if you run into an issue with the new version! Thanks.
",jcrugzz,2016-01-20 23:33:08
424,2013-05-15 16:44:31,"The _getKey method of the RoutingProxy would throw an error if a host/port pair wasn't provided in the options of the proxyRequest call.  It will now check to see if the socketPath option was provided as well.

Additionally the _getAgent method would error if a host wasn't provided, this now checks for socketPath as well.
",stanger,2013-12-27 07:41:39
424,2013-12-27 07:41:39,"Need tests. 
",indexzero,2013-12-27 07:41:39
423,2013-05-14 07:11:56,"`req.remotePort` returns the ephemeral port, which is not useful.
node v0.10.0 added `req.localPort` which returns what we want, but
we want to maintain backwards compatibility. Fixes #341 & #227
",blahed,2013-12-27 07:59:59
423,2013-12-27 07:59:59,"Some minor bugs, but fixed and cherry-picked.
",indexzero,2013-12-27 07:59:59
422,2013-05-13 02:51:27,"Could anyone explain the differences (performance, etc) between plug-in a RoutingProxy instance into a http server and simply a standalone proxy server. Here are links as reference:

https://github.com/nodejitsu/node-http-proxy#proxy-requests-within-another-http-server

vs.

https://github.com/nodejitsu/node-http-proxy#setup-a-stand-alone-proxy-server-with-custom-server-logic

I need a proxy to add additional headers to incoming requests before sending them to a 3rd party API server.
",mpl0916,2016-01-20 23:26:18
422,2016-01-20 23:26:18,"Closing old issue, we have a new version of `http-proxy` please open a new issue if you have any issues with it
",jcrugzz,2016-01-20 23:26:18
421,2013-05-12 01:58:32,"I'm not sure if this is a bug or not but websockets wont work with a proxy table e.g

<S_CODE_TOKEN>

It works fine proxying web requests. But websockets don't work. If I access the site directly it does work (with websockets)

I also unsuccessfully tried adding in

<S_CODE_TOKEN>

It also looks like `server.on('upgrade` doesn't fire. In addition, even without the above event. If there are attempts to use websockets (after a while). The below error will appear:

<S_CODE_TOKEN>

After a while it will run out of memory and crash.
",Tarang,2013-12-18 11:13:02
421,2013-05-13 06:50:43,"See https://github.com/nodejitsu/node-http-proxy/pull/402#issuecomment-16539748
",glasser,2013-12-18 11:13:02
421,2013-06-04 17:20:58,"I just tried to update from 0.8.5 to 0.10.2 and I see the same issue... :-(

0.8.5 ok
0.10.2 nok
",adrai,2013-12-18 11:13:02
421,2013-08-22 11:40:55,"DId you guys figure out a solution somehow? Still having troubles proxying ws
",christian-fei,2013-12-18 11:13:02
421,2013-09-03 09:54:01,"I would love to know the solution as well ...
",Rush,2013-12-18 11:13:02
421,2013-09-03 10:01:43,"Hey @RushPL I found that the only solution **atm** is to use nginx to proxy stuff.
WebSockets work just fine.
If you need further help just ask
",christian-fei,2013-12-18 11:13:02
421,2013-09-03 10:44:23,"Thanks a lot. Actually I found out about **nvm** which stands for Node Version Manager. I was able to run the node-http-proxy binary on the older node version and still have the newest node for rest of my stuff. I have also tried the 0.10.x branch but it didn't work at all.
",Rush,2013-12-18 11:13:02
421,2013-09-03 11:08:25,"Yep, same here. tried the http-proxy of nodejitsu, but no luck with node 0.10.x, so I just switched to nginx, where 0.10.x work just fine
",christian-fei,2013-12-18 11:13:02
421,2013-12-10 23:30:54,"+1 please.

In the meantime, say I did want to use http-proxy for routing with WS. That seems impossible right now so will have to resort to nginx or not bother with WS.

Can anyone comment on the memory footprint of nginx versus a routing http-proxy script? Nginx would be setup to route and not cache or do anything else fancy.
",raintonr,2013-12-18 11:13:02
421,2013-12-11 22:24:01,"You can use old node-http-proxy with Node.JS 0.8 - it works fine with web sockets. I have observed only negligible memory usage on the proxy's part but I am not running thousands of web sockets so your mileage may vary.

You can get Node 0.8 very easily with Node Version Manager.
",Rush,2013-12-18 11:13:02
421,2013-12-18 11:13:02,"hi!
@RushPL 
if you're having other issues with the `caronte` branch and websockets, you can open up an issue and i'll have a look!
please provide a test case as well :)

closing this issue since it refers to a dropped component (router) and the 0.8.x branch
",yawnt,2013-12-18 11:13:02
421,2013-12-18 20:04:07,"router has been dropped? I assume that is because there is another node module that can be integrated with http-proxy to give the same function?

If someone could put a quick link/note here to explain how that can/should be done that would be great.

Sorry - I'm no expert in any of this or would try to do that.
",raintonr,2013-12-18 11:13:02
420,2013-05-11 19:24:28,"Hello. At now I use nginx as load balancer like the following:

<S_CODE_TOKEN>

   }

Can use use whole replace nginx by using node-http-proxy?
",skotchio,2013-05-11 22:48:42
420,2013-05-11 22:48:42,"@vovan22 `node-http-proxy` is not a load balancer replacement itself but it can be used to create your own load balancer. (this is what we do @nodejitsu).
",jcrugzz,2013-05-11 22:48:42
420,2013-05-12 07:18:22,"How can I create ow load balancer by using hide-htto-proxy?, answer please
",skotchio,2013-05-11 22:48:42
420,2013-05-12 14:34:14,"Here are some examples: https://github.com/nodejitsu/node-http-proxy/tree/master/examples/balancer
",mmalecki,2013-05-11 22:48:42
419,2013-05-10 23:55:09,"Using only SNICallback to create a HTTPS / TLS server is bad. It means all non SNI clients can't do anything because there are no certs.

in v0.10 of node TLS server was updated to throw if you forgot to supply certs.

Which means that every HTTPS server needs to supply certs as a fallback for when SNI is not available.
- closes #399
",Raynos,2013-06-15 02:20:25
418,2013-05-10 19:04:45,"I've only tested this with Chrome 26, which uses the latest hybi spec, and node v0.87. It seems to work well for me.

This isn't tested enough to be taken, no hixie testing was done whatsoever, and I don't have the time to do that testing but I'm posting this in case it helps someone else.
",aalness,2013-05-10 19:12:16
417,2013-05-10 17:32:22,,geek,2013-12-04 05:02:33
417,2013-05-10 18:07:35,"It should be `""0.10""`
",3rd-Eden,2013-12-04 05:02:33
417,2013-12-04 02:54:56,"Do you know that your latest build fails on Travis? Kind of frustrating to use it.
",kadishmal,2013-12-04 05:02:33
417,2013-12-18 11:07:30,"@kadishmal the `master` branch isn't 0.10 compatible, for a compatible version check out the branch `caronte` which is a new refactor :)
",yawnt,2013-12-04 05:02:33
417,2013-12-19 00:56:36,"Ok, got it. Any plan to have it become compatible?
",kadishmal,2013-12-04 05:02:33
417,2013-12-19 01:07:43,"caronte is going to become the new master branch :)
",yawnt,2013-12-04 05:02:33
416,2013-05-04 20:58:45,"According to http://nodejs.org/api/http.html#http_http_request_options_callback and http://nodejs.org/api/https.html#https_https_request_options_callback

Instead of pass the full url as path, the url is parsed and the path extracted.

Without this change, it's not possible to access to several pages on dailymotion.
",MiLk,2013-12-18 11:49:59
416,2013-09-27 12:59:03,"I've hit the same issue, and just passing the path seems to fix it -- if this could be merged, it would be much appreciated.
",mwilliamson,2013-12-18 11:49:59
416,2013-09-27 13:51:06,"Do you have an example of full URL being passed as a path?
It's been referenced a couple of times in http-proxy issues already, never with a test or a code example.
",mmalecki,2013-12-18 11:49:59
416,2013-09-27 14:23:44,"<S_CODE_TOKEN>

<S_CODE_TOKEN>

On master:

<S_CODE_TOKEN>

With the fix:

<S_CODE_TOKEN>
",MiLk,2013-12-18 11:49:59
416,2013-09-27 14:30:02,"Similarly:

<S_CODE_TOKEN>

<S_CODE_TOKEN>

On master, wrong location header:

<S_CODE_TOKEN>

With the fix:

<S_CODE_TOKEN>
",mwilliamson,2013-12-18 11:49:59
416,2013-09-27 14:47:29,"As a piece of wild speculation, I'd assume this happens since the first line of HTTP requests include an absolute URL when sending requests to a proxy.

http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2

> The absoluteURI form is REQUIRED when the request is being made to a proxy.
",mwilliamson,2013-12-18 11:49:59
416,2013-10-30 12:06:05,"@mmalecki Do you want more informations ?
",MiLk,2013-12-18 11:49:59
416,2013-10-30 15:41:09,"@MiLk We are in the process of a complete rewrite of `node-http-proxy`. Can you try out the `caronte` branch and see if this resolves your problem?
",indexzero,2013-12-18 11:49:59
416,2013-10-30 16:03:13,"I still get the same issue. Source file:

<S_CODE_TOKEN>

Output:

<S_CODE_TOKEN>

Presumably this is because [`common.js`](https://github.com/nodejitsu/node-http-proxy/blob/caronte/lib/http-proxy/common.js#L42) still has the same (incorrect) logic as before:

<S_CODE_TOKEN>
",mwilliamson,2013-12-18 11:49:59
416,2013-10-30 16:13:36,"@mwilliamson the fix should be

outgoing.path       = req.url.match(/^(https?:)/gi)? url.parse(req.url).path : req.url;
",sequoiar,2013-12-18 11:49:59
416,2013-10-30 16:16:53,"@sequoiar: I think the fix originally given by @MiLk suffices, and has the benefit of being slightly simpler.
",mwilliamson,2013-12-18 11:49:59
416,2013-12-08 05:43:48,"This bug also breaks socket.io's built-in server which delivers its custom builds of browser side javascript, making socket.io effectively incompatible with node-http-proxy at this time. The symptom is the dreaded ""Welcome to socket.io"" message appearing instead of the expected javascript source code.

The source code of socket.io parses the URL on the assumption that it begins with a / and does not have a protocol, host and port.

This should probably be fixed in socket.io for long-term compatibility with a future in which URIs will supposedly someday always be fully absolute in requests, however there are too many other sites and servers out there with the same issue for it to be sensible not to also address it in node-http-proxy.

The spec does say this is a bug in socket.io, but only the weakest sense that it's not a great example of being ready for HTTP 1.2; it also says that HTTP 1.1 clients will never present an absolute URL except in a request to a proxy. (A request _from_ a proxy is not the same thing (: )

 To allow for transition to absoluteURIs in all requests in future
 versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
 form in requests, even though HTTP/1.1 clients will only generate
 them in requests to proxies.
",boutell,2013-12-18 11:49:59
415,2013-05-02 16:10:41,"It's possible to crash the proxy server using certain URLs in the HTTP request.  If the URL causes **require(""url"").parse** to return a result with null pathname, such as the one below, the proxy server will crash due to a null reference.

<S_CODE_TOKEN>
",ruquay,2016-01-20 23:16:01
415,2016-01-20 23:16:01,"This is based on an older version of `http-proxy` please use the latest version and open a new issue if you have a problem. Thanks!
",jcrugzz,2016-01-20 23:16:01
414,2013-05-02 01:17:16,"<S_CODE_TOKEN>

ex :

Node(node-http-proxy)  ---- (jetty1, jetty2, jett3)
       If jetty1 server is down, the requests are still sent to that server. 
",firemonk9,2013-05-02 07:40:02
414,2013-05-02 07:40:02,"This is a higher level feature that isn't aligned with the lower-level focus of node-http-proxy. In other words, node-http-proxy is a raw reverse proxy, not a load balancer.
",indexzero,2013-05-02 07:40:02
413,2013-05-01 06:50:16,"Used and played around with http-proxy,good for use.

We've a requirement in our project, where we need to scale/add node servers depending on load/traffic.Is there a way to add an entry to list of servers in http-proxy dynamically ?
",chiragsanghvi,2016-01-20 23:01:54
413,2013-09-20 04:02:18,"@chiragsanghvi If you are talking about updating the routes dynamically after starting the proxy server, it can be achieved by adding routes as a json file. http-proxy listens to the file changes and updates the routes.  

<S_CODE_TOKEN>

Contents of routes.json will be   

<S_CODE_TOKEN>
",gisripa,2016-01-20 23:01:54
413,2014-01-09 17:14:29,"Actually, the contents of routes.json will be:

<S_CODE_TOKEN>
",fonini,2016-01-20 23:01:54
413,2016-01-20 23:01:54,"This is referencing an old version of `http-proxy` but if you come across this issue we have a new module that handles routing and this sounds like a feature that could be requested if needed. [`http-proxy-rules`](https://github.com/donasaur/http-proxy-rules)
",jcrugzz,2016-01-20 23:01:54
412,2013-04-28 16:26:00,"For versions > 0.8.7, reponse.writeHead in the httpProxy.createServer call back does not receive the headers parameter.  Only the statusCode is passed.
",ghost,2016-01-20 23:00:05
412,2013-05-09 15:58:19,"I ran into this the other day too, as the older version I was using was passing the headers into the `writeHead()` function. Looks like this commit is what changed the previous behavior, in that setHeader is now used to add all the headers. https://github.com/nodejitsu/node-http-proxy/commit/ffe74ed299f81206b898147dbcc985519b2921f8#L0L284

After reading the node docs it appears the headers parameter for `writeHead` is optional and it sounds like `setHeader()` does a better job of handling normalizing/duplicates, I am guessing that is the reason for the switch??

Anyways, what I ended up doing when I override `writeHead` is use the `this._headers` object within my new writeHead function to retrieve/modify the headers instead of relying on the headers parameter being filled in. Not sure if that is the absolute best way but seems to be working. Hope that helps...
",cengebretson,2016-01-20 23:00:05
412,2013-06-19 15:19:47,"I don't see any examples of how to modify headers. I'm having a bit of trouble with the above methods.  Anybody have any insight? http://stackoverflow.com/questions/17174862/modify-headers-of-proxied-request
",ghost,2016-01-20 23:00:05
412,2016-01-20 23:00:05,"We have proper headers support in the latest version of `http-proxy` please open a new issue if this is still a problem
",jcrugzz,2016-01-20 23:00:05
411,2013-04-26 04:01:39,"I have a network where I want to be able to chain two node-http-proxy applications together and use web-sockets. 

I have a system setup like this:

<S_CODE_TOKEN>

I have tested that `host1:80 ->  host2:4000` works and  `host2:4000 -> host2:4001` also works. With the chained proxy, the web-socket will connect, however no data seems to be transmitted. 

Is there anything I can do to enable this functionality?
",srossross,2013-04-26 16:44:52
411,2013-04-26 04:09:19,"What version of Node are you using? websocket proxying is flaky in Node 0.10.
",glasser,2013-04-26 16:44:52
411,2013-04-26 15:10:25,"I am using this combination of versions.  And I am using the RoutingProxy object. 

<S_CODE_TOKEN>

I am going to try node v0.9.9 next.
- Do you have a preferred version? 
- Are there any debug flags I can set to trace where the data is getting dropped?
",srossross,2013-04-26 16:44:52
411,2013-04-26 16:44:51,"I no longer believe this is an issue with node-http-proxy. I think it is the 3rd party (Python Tornado) server running on my endpoint `host2:4001`

I tested the same setup with `tty.js` and it works fine.
",srossross,2013-04-26 16:44:52
411,2013-04-27 17:27:42,"I have posted this as a [question on stackoverflow](http://stackoverflow.com/questions/16254957/tornado-does-not-handle-node-http-proxy-websockes-on-linux)

I would be grateful for any debugging tips or tricks. 
~Thanks
",srossross,2013-04-26 16:44:52
411,2013-07-04 16:22:09,"I have solved this issue by using node 0.6.13. Anything greater and node-http-proxy will not proxy web-sockets to a tornado server.

Many people commented that web-sockets in later versions of node have something wrong with the headers. I was wondering if you guys are tracking that and where can I watch for this issue to be solved?
",srossross,2013-04-26 16:44:52
410,2013-04-24 01:00:39,"The routing-proxy provides support for unix sockets via the socketPath option.
This implements this feature for the proxy-table as well. This is done by
interpreting an imaginary socket:// protocol. This enables router
configurations like the following:

<S_CODE_TOKEN>
",domachine,2013-12-27 07:31:21
410,2013-12-27 07:31:21,"We're dropping the `ProxyTable` in `node-http-proxy@1.0.0`. If you want to take ownership of it `proxy-table` is available on `npm`! :-D
",indexzero,2013-12-27 07:31:21
409,2013-04-19 04:32:44,"I had a simple proxy working in node v0.8.x (written in Coffeescript):

<S_CODE_TOKEN>

When I moved to node v0.10.x every request returned:

<S_CODE_TOKEN>

I did not find a way to configure my proxy to make it work.

I had to change **http-proxy/lib/node-http-proxy.js**

and insert : **options.rejectUnauthorized = false;**

<S_CODE_TOKEN>
",jclevy,2016-01-20 22:58:41
409,2013-06-23 07:40:46,"I'm also experiencing this problem. On node 0.10.10 and 0.10.11, I'm unable to get even the ""Proxying to HTTPS from HTTPS"" example to work, without modifications (other than inserting my certificate and key). When I run that example, I get an HTTP 500 with `An error has occurred: {}` and no errors in the console.

HTTP->HTTP and HTTPS->HTTP work fine.
",DanH42,2016-01-20 22:58:41
409,2013-07-19 19:52:47,"You shouldn't need to change anything. You can pass rejectUnauthorized when you create a new HttpProxy instance:

<S_CODE_TOKEN>
",RGBboy,2016-01-20 22:58:41
409,2016-01-20 22:58:41,"New `http-proxy` uses a separate module for routing [`http-proxy-rules`](https://github.com/donasaur/http-proxy-rules)
",jcrugzz,2016-01-20 22:58:41
408,2013-04-19 01:08:23,"How about proxy to 'CONNECT' request?

In case chrome browser:
1. chrome send SPDY 'CONNECT' request first
2. then http-proxy create a tcp/ssl connection to origin server
3. then chrome send 'HTTP CONNECT' request
4. then chrome  fetch HTTPS request over proxy tunnel. 

this way can implements a end-to-end secure forward proxy.
",sequoiar,2016-01-20 22:55:37
408,2013-05-26 18:47:53,"I would also like to see this feature implemented in the module.

Here is my current implementation for the problem (maybe something ca be reused):
https://gist.github.com/tom-muhm/5653643
",tommuhm,2016-01-20 22:55:37
408,2015-07-09 12:00:36,"Bump
",steelbrain,2016-01-20 22:55:37
408,2015-07-09 14:51:48,"if you want to tunnel the proxy request through a tunnel (which uses connect), you want to use something like [`tunnel-agent`](https://github.com/mikeal/tunnel-agent) and pass it in as the agent. If there is another use case please be more clear and give a code example that does not work.
",jcrugzz,2016-01-20 22:55:37
408,2015-07-09 14:53:53,"@jcrugzz I am unable to get https to work in `node-http-proxy`, here's the code example https://gist.github.com/steelbrain/b24f795fe92ec229ddb9#comment-1489331
",steelbrain,2016-01-20 22:55:37
408,2016-01-20 22:55:37,"Closing old issue. Please open a new issue if this is a problem as there should be better docs around this
",jcrugzz,2016-01-20 22:55:37
407,2013-04-18 23:36:10,"This issue stems from #59

Since the proxy requests comes from NodeJS's HTTP 1.1 request client, a
backend server may default to setting Connection: keep-alive in its
response. However, the real HTTP 1.0 client may not be able to
handle that.

Force HTTP 1.0 client's to Connection: close, unless the client
explicitly supports keep-alive.

Here's a demonstration of the existing problem with a default nginx install running on port 8082 and the proxy running on port 9999:

<S_CODE_TOKEN>

Straight to nginx with default HTTP 1.0:

<S_CODE_TOKEN>

Straight to nginx with HTTP 1.0 and keep-alive header:

<S_CODE_TOKEN>

Default HTTP 1.0 request through the proxy:

<S_CODE_TOKEN>

This patch restores nginx's default behavior of only returning `Connection: keep-alive` for HTTP 1.0 clients if the client explicitly supports it. Otherwise, it will default to `Connection: close`.

I'm not sure if all backend servers behave this way, but this seems like the correct way to handle it given the fact that the node proxy forces the request to HTTP 1.1 but an HTTP 1.0 client won't support keep-alive by default.
",GUI,2013-04-21 20:25:36
407,2013-04-21 20:25:30,"@GUI If all PRs were this good the world would be a better place. You sir, are a hero.
",indexzero,2013-04-21 20:25:36
406,2013-04-18 02:06:03,"I recently upgraded my backend to node 0.10.4 and node-http-proxy 0.10.1 and some of my services stopped serving static files correctly. After a while poking around, I `curl`ed the file locally using http and it was serving it correctly, but then I noticed this when `curl`ing behind the proxy:

<S_CODE_TOKEN>

This is how I'm using http-proxy:

<S_CODE_TOKEN>

Any ideas why this stopped working all of a sudden? Let me know if you need any more details.
Thanks in advance.
",NachoSoto,2016-01-20 22:54:29
406,2013-07-05 18:16:20,"I'm having the same issue. I investigated further and found that any content over 10901 bytes in length has it's connection closed.

Any ideas?

Node 10.6
http-proxy 0.10.3
",RGBboy,2016-01-20 22:54:29
406,2013-07-05 20:33:12,"Ok so I figured out a solution to my problem. I was using a HTTPS to HTTPS proxy with an Apache server. The Apache server had Keep Alive turned off. Turning it on seems to have solved the issue.
",RGBboy,2016-01-20 22:54:29
406,2013-08-21 09:25:39,"I have the same issue. I have a backend Apache server (http) and a frontend https node-http-proxy. The problem happens on about 20 % of the requests. I'm trying to fetch a document of 243543 bytes, but sometimes the (frontend) connection is closed when 14431 bytes are remaining.

This doesn't happen if I change the frontend to http.

Turning on keep-alive in the backend _seems_ to fix it, but only for certain clients. If you run curl in HTTP 1.0 mode (`curl -0 ...`), it will fail again.

Maybe there's a timing problem somewhere in the http-proxy code, a one that' sonly triggered in a certain keepalive config, and for some reason only when serving https.

How to fix? Any workarounds?
",tuomassalo,2016-01-20 22:54:29
406,2013-08-21 11:38:11,"I tried to write a test case on this. It was difficult, since the problem seems to only appear when there's some latency between the client and the proxy server. I didn't have time to find a tool to simulate the latency, so the test doesn't show the problem when executed on one machine.

However, the problem should appear when `server.js` is started on one host and `curl-test.sh` on another, maybe in another network.

How to test:
- Clone my fork: https://github.com/tuomassalo/node-http-proxy.git
- Go to test/keepalive/
- run `node server.js`
- **On another machine**, modify `curl-test.sh` and run it. It should print a bunch of `OK` lines, and then an occasional error with something like `* transfer closed with 6568 bytes remaining to read`. That's the bug.

**UPDATE:** I first thought that the problem only appeared with some specific keepalive settings. Now I'm able to reproduce it without curl's `-0` and without sending `Connection: close` in the backend server. Odd, but I don't have more time to look at this now.

**UPDATE 2:** It seems that the bug only happens on specific versions of eg. `curl`. This seems like a very hard one. I was able to reproduce on Ubuntu 10.04 and 12.04, but not OSX 10.8.4.

But there seems to be more to it. I created a simple HTTPS server that only sends data (see https://gist.github.com/tuomassalo/6296041), and most versions of `curl` seem to fail with even that. No `http-proxy` in that example. I'm running that server at https://212.246.29.149:11443, so you can try eg. this:

`while true; do curl -s -k -0 https://212.246.29.149:11443 2>&1 | wc -c; sleep .5; done`

My `curl` prints mostly 243543, but sometimes 229251. 

I'm quite confused about this whole thing. Is there a node.js problem? A `http-proxy` problem?

Oh, btw, I'm running node v0.10.15 on all servers.
",tuomassalo,2016-01-20 22:54:29
406,2013-08-22 14:56:09,"@NachoSoto this bug is probably fixed in v0.11.x. See https://github.com/joyent/node/issues/6107. Can you test by running http-proxy on v0.11.x?
",tuomassalo,2016-01-20 22:54:29
406,2013-10-14 12:30:09,"This turned out to be a node.js problem, and will be fixed in node.js v0.10.21. See https://github.com/joyent/node/issues/6107.
",tuomassalo,2016-01-20 22:54:29
405,2013-04-17 10:45:25,"http-proxy@0.10.1 (even with 0.10.0) nodejs@0.10.4 (even with 0.10.3)
Ubuntu 12.10 64bit

<S_CODE_TOKEN>

<S_CODE_TOKEN>

There's a tomcat server on localhost:8080 and a nodejs ""grunt server"" on localhost:9000.
The exception is thrown VERY frequently (it's a 99% ALWAYS) after involving authentication on the tomcat server.
The autentication is obtained with a quite standard session cookie with the following workflow:
- api.test.it/auth/login --> redirect to an OAuth provider
- OAuth provider --> redirect to api.test.it/auth/result (this page validate the user and return a session)

The app itself on tomcat allow CORS calls exchange.
Any idea? Tnx in advance
",bfx81,2015-10-30 21:28:58
405,2013-04-30 17:33:00,"I am getting this same error with http-proxy@0.10.2 on node 0.8.24 my dump looks like the following. Not sure what types of requests are triggering it.

http.js:673
    throw new Error('Can\'t set headers after they are sent.');
          ^
Error: Can't set headers after they are sent.
    at ServerResponse.OutgoingMessage.setHeader (http.js:673:11)
    at HttpProxy.proxyRequest (/usr/local/share/adproxy/node_modules/http-proxy/lib/node-http-proxy/http-proxy.js:330:11)
    at Array.forEach (native)
    at ClientRequest.<anonymous> (/usr/local/share/adproxy/node_modules/http-proxy/lib/node-http-proxy/http-proxy.js:329:35)
    at ClientRequest.g (events.js:192:14)
    at ClientRequest.EventEmitter.emit (events.js:96:17)
    at HTTPParser.parserOnIncomingClient [as onIncoming](http.js:1582:7)
    at HTTPParser.parserOnHeadersComplete [as onHeadersComplete](http.js:111:23)
    at Socket.socketOnData [as ondata](http.js:1485:20)
    at TCP.onread (net.js:404:27)
",bwaters,2015-10-30 21:28:58
405,2013-04-30 17:38:05,"Looks like same as #388 Also has a code fix waiting for a pull request
",bwaters,2015-10-30 21:28:58
405,2015-07-03 00:16:17,"Ran into this situation where I was bouncing back the Origin header as Access-Control-Allow-Origin to address CORS behavior. There's some circumstances where the Origin header isn't set and it was causing undefined to be passed as the header value, causing this error. Making sure we at least passed an empty string worked around this issue.
",LoganBarnett,2015-10-30 21:28:58
405,2015-10-30 21:28:58,"This is an old issue that is no longer relevant to the current version of `http-proxy`
",jcrugzz,2015-10-30 21:28:58
404,2013-04-15 22:02:32,"Hi,

So we encountered an interesting problem today, less so a bug with node-http-proxy but more of a incongruent behavior from when compared against other browsers and client's we've tested. 

When working with cloudfoundry.com we found that their proxy did not consider a request to port 80 the same if the port was explicitly specified in the 'Host' header field.

So a request to http://foo.cloudfoundry.com:80/ and http://foo.cloudfoundry.com/ behaved differently. We narrowed it down to the difference in the Host field. The changeOrign logic  included the port when crafting the 'Host' header regardless of the port number. 
- http://foo.cloudfoundry.com:80/ has a Host header of ""Host: foo.cloudfoundry.com:80""
- http://foo.cloudfoundry.com/ has a Host header of ""Host: foo.cloudfoundry.com""

No big deal right? Well so everyone else strips port 80 because it is the default :(
- Curl strips port 80 from the Host header
- wget strips port 80 from the Host header
- Safari strips port 80 from the Host header
- Firefox strips port 80 from the Host header
- Chrome strips port 80 from the Host header

You can test the behavior using ""http://helloworld-ng.cloudify.com:80/"" and ""http://helloworld-ng.cloudify.com/"" - notice that both URLs work the same in all of the above listed browsers

In curl we can see the failure case

<S_CODE_TOKEN>

(We've asked cloudfoundry to fix this issue, but to be clear the behavior in node-http-proxy is incongruent with every other client and browser we've tested) 

So then the question becomes - should node-http-proxy do the same? Sadly it seems like this shouldn't be an issue but it is an unexpected behavior and no one else does it - hence why I think node-http-proxy should strip port 80 from the Host field if it is specified. 
",celer,2013-12-27 07:29:17
404,2013-04-16 14:53:52,"Please see 

https://github.com/mikeal/request/issues/515

For details about how each client handles a URL with port 80 specified. 
",celer,2013-12-27 07:29:17
404,2013-04-16 22:33:19,"this assumes 80 is default, what about https?
",mikeal,2013-12-27 07:29:17
404,2013-04-17 14:37:31,"So the behavior appears to be he same with all the clients - although a bit harder to test.  But they all strip 443 from the host field when using https. 

So I used a simple nodejs server and the various development tools with the browsers to verify the behavior. 

<S_CODE_TOKEN>
",celer,2013-12-27 07:29:17
404,2013-12-27 07:29:17,"No updates from @celer. Closing.
",indexzero,2013-12-27 07:29:17
403,2013-04-10 23:41:09,"I'm using restify for several service URI's but I would like one particular service URI to be forwarded to a different host allowing my service to act as a proxy for the results from that host.

e.g.,

http://myservice/solr-suggest?q=lou&bunchOfQueryParams=more --> http://realservice/solr-suggest?q=lou&bunchOfQueryParams=more

Here's the code I have tried to do this:

<S_CODE_TOKEN>

Is it possible to do this within an existing service like this?
",occasl,2013-04-11 16:33:54
403,2013-04-11 16:33:54,"Chalk it up to a late night, but all that was required is to remove the create server since I already did that before.  The result was this:

<S_CODE_TOKEN>
",occasl,2013-04-11 16:33:54
402,2013-04-08 16:15:08,"The headers in the 'handshake' event were not written to the socket, the client received data but not the headers.

https://github.com/nodejitsu/node-http-proxy/issues/387
",pkarc,2013-04-21 21:03:23
402,2013-04-10 04:38:35,"thank you @pkarc! just lost 5 hours on this one. works for us.

+1 
",breck7,2013-04-21 21:03:23
402,2013-04-10 05:37:14,"@pkarc Thanks for this. Can you confirm the fix is backwards compatible with node@0.8.x? 
",indexzero,2013-04-21 21:03:23
402,2013-04-13 16:18:08,"Tested on v0.7.0, v0.8.0, v0.8.2 and v0.8.6, and it works!
",pkarc,2013-04-21 21:03:23
402,2013-04-17 21:45:57,"This helps a bit (the headers aren't dropped like they are without this patch) but I'm still seeing weird results where the first data in the websocket gets written twice across the proxy.
",glasser,2013-04-21 21:03:23
402,2013-04-17 22:01:48,"Specifically, it looks like the `listeners.onIncoming` is set too early. This is an `on('data')` on the same socket as the `handshake` `on('data')`, and it looks like the same bit of data can get sent to both and doubly-proxied to the client.
",glasser,2013-04-21 21:03:23
402,2013-04-17 22:28:09,"Yeah. Trace through the logic.

In `http.js` `ClientRequest.prorotype.onSocket`, we set `socket.ondata = socketOnData` and immediately emit a socket event. This triggers the `reverseProxy.once('socket')` which sets the `handshake` `on('data')`.  This also switches the socket's stream into 0.8 emulation mode.

Then we actually read the headers over the network. By my reading of `onread` in `net.js`, this calls `socket.ondata` directly rather than invoking the stream API (that's the `self.push` there).  This is the `socketOnData` in `http.js`, which parses the headers and decides it's an upgrade. First it clears `socket.ondata` (switching the socket into ""use the normal stream API"" mode) and then it invokes the 'upgrade' handler on `reverseProxy`.

This in turn (with this patch) saves the headers into `reverseProxy.handshake` and calls our `onUpgrade` function, which among other things sets the `listeners.onIncoming` listener on the socket. Now we have two separate data listeners on the socket... and we still haven't invoked either!

(BTW, if the initial block of data sent to socketOnData contained some bytes past the headers, this will be lost! This is the `bodyHead` in `socketOnData`, which is the ignored `head` argument in the `reverseProxy.on('upgrade')` handler. But this isn't the issue I'm seeing...)

Finally, the proxied server sends the beginning of its body. This goes BOTH to `handshake` and to `listeners.onIncoming`, and the first part of the body gets double-printed!

Seems to me that the contents of `handshake` should be done as a first-time-only step inside `listeners.onIncoming` instead of settings up two separate listeners that may overlap.
",glasser,2013-04-21 21:03:23
402,2013-04-17 22:30:20,"This also is helping us a bit, but not quite a full fix--still getting weird behavior. Haven't quite dived down into the details as much as @glasser, but I can second that this is not quite a full fix.
",breck7,2013-04-21 21:03:23
402,2013-04-17 22:45:05,"(Or, well, this whole thing probably should be rewritten to use Node 0.10-style `readable` events, but...)
",glasser,2013-04-21 21:03:23
402,2013-04-18 17:30:46,"Because of streams2, `node-http-proxy` could use a pretty serious rewrite internally for many reasons. This patch will be merged as a stop-gap, and the next work will go into a 0.10+ only version.
",indexzero,2013-04-21 21:03:23
402,2013-05-10 00:25:05,"A third on this being insufficient:

This doesn't seem to work on node v0.8.7 w/SSL (not sure if SSL is significant to the problem.) Also in my application the server end (proxy target) begins sending data first, again, not sure if that matters.

I see the 'ondata' event for the socket fire first and call the 'handshake' function but meanwhile the 'upgrade' event hasn't fired yet to populate the status code and the 101 response headers so they are null and still don't find their way back to the browser to complete the handshake.

I should add my browser is Chrome 26.
",aalness,2013-04-21 21:03:23
402,2013-07-19 14:13:45,"Anyone looking at this? Seems node 0.10.13V isn't compatible with node-http-proxy - websockets when proxied are dropped.
",danhowitt,2013-04-21 21:03:23
402,2013-07-19 15:34:34,"+1

Any way we can help short of leading a rewrite (I don't know the code well enough).

Works so great on 0.8.x and would love to be able to use node-http-proxy with 10.
",breck7,2013-04-21 21:03:23
402,2013-07-19 17:12:12,"This diff looks terrible but it seems to work well for the current version of the WebSocket protocol. I haven't tested it with the older drafts. It probably doesn't work for them.

I don't have time to test it for older implementations but I'm using it in my project without issue.

Diff: http://www.onegrandcircle.com/~andy/ws.diff
",aalness,2013-04-21 21:03:23
402,2013-07-19 18:36:05,"We are working on a complete rewrite for `streams2`. See the work from @cronopio on the [0.10.x](https://github.com/nodejitsu/node-http-proxy/tree/0.10.x) branch.
",indexzero,2013-04-21 21:03:23
402,2013-07-20 16:39:44,"Awesome, thanks @indexzero , @cronopio !
",breck7,2013-04-21 21:03:23
401,2013-04-04 10:00:37,"I am using the stock `node-http-proxy` script. It would be nice if it was extended to handle the SNI protocol and per domain certificates. 
",Rush,2014-01-31 00:34:07
401,2013-04-17 01:10:54,"+1
",antoinerg,2014-01-31 00:34:07
401,2013-04-21 21:04:40,"+1

pr?
",indexzero,2014-01-31 00:34:07
401,2014-01-31 00:34:07,"Anybody interested in SNI please use or rip the code from https://github.com/CodeCharmLtd/http-master. Closing.
",Rush,2014-01-31 00:34:07
400,2013-04-03 03:44:00,"reverseProxy can have many subscribers to the 'drain' event when large
uploads occur. Without this fix I get the following warning printed in the log:

<S_CODE_TOKEN>
",jcheng5,2013-12-27 07:19:49
400,2013-04-21 21:03:45,"This needs to be an option.
",indexzero,2013-12-27 07:19:49
400,2013-04-22 00:37:07,"Could you elaborate on why? I didn't see a way for users to add their own listeners to reverseProxy; unless I missed something, there's no way the maxListeners warning on this particular object would help users catch a bug in their own code.
",jcheng5,2013-12-27 07:19:49
400,2013-07-02 13:06:42,"I have the same problem when uploading files with HTTP multipart/form-data. (about 2MB total) The patch is worked, thanks. 

This problem should be solved by decreasing the event listeners,  not free the limitation (even it's fastest solution..).
",welkineins,2013-12-27 07:19:49
400,2013-12-27 07:19:49,"Needs to be broken out into several smaller pull-requests.
",indexzero,2013-12-27 07:19:49
399,2013-04-02 10:12:10,"Hey guys,

I've been trying to make work ""Proxying http from https using two certificates"" with the last version of Nodejs currently available (v0.10.2) but I've not been able to do it. However, I had tried it before with the version 0.6.12 of Nodejs and it worked perfectly.

I've seen that the problem is due to this:

---

tls.js:1028
    throw new Error('Missing PFX or certificate + private key.');
          ^
Error: Missing PFX or certificate + private key.
    at Server (tls.js:1028:11)
    at new Server (https.js:35:14)
    at Object.exports.createServer (https.js:54:10)
    at Object.exports.createServer (/home/afuentes/node_modules/http-proxy/lib/node-http-proxy.js:178:13)
    at Object.<anonymous> (/home/afuentes/nodejs_test/node4_https_2cert.js:53:11)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Function.Module.runMain (module.js:497:10)

---

The reason of this is that in this file (tls.js) was added (compared with the version that worked) the following line  

---

 if (!self.pfx && (!self.cert || !self.key)) {
    throw new Error('Missing PFX or certificate + private key.');
 }

---

Therefore, it requieres the "".pfx"" certificate. I have tried to solve it creating it, but It does not work yet.

Could anyone help me? Has anyone tried the same?

Thanks in advance.
",fuentecilla86,2013-06-15 02:20:25
399,2013-04-02 19:44:24,"No idea. Haven't played with `v0.10.x` yet much. @isaacs or @indutny?
",indexzero,2013-06-15 02:20:25
399,2013-04-02 21:16:59,"I believe you either forgot to put `key` or `cert` property in your options. Because this check is essentially the same as: `!(self.pfx || self.cert && self.key)`
",indutny,2013-06-15 02:20:25
399,2013-04-03 09:47:41,"Hey guys,

First of all, thanks for you quickly replies!

I have tried the same scenary with two different syntax to show you better what's my problem. One of them fails and the other runs perfectly:

The one that runs perfectly (one certificate syntax):

---

var https = require(""https""),
    path = require(""path""),
    http = require(""http""),
    fs = require(""fs""),
    httpProxy = require(""http-proxy""),
    crypto = require(""crypto"");

//
// Proxy options
//
var options = {
  https: {
     key:  fs.readFileSync('ryans-key.pem'),
     cert: fs.readFileSync('ryans-cert.pem')
  },
  hostnameOnly: true,
  router: {
    'foobar.com':  '127.0.0.1:8005',
  }
};

//
// Create a standalone HTTPS proxy server
//
httpProxy.createServer(options).listen(8002);

//
// Create the target HTTPS server
//
http.createServer(function (req, res) {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.write('hello https\n');
  res.end();
}).listen(8005);

---

Testing:

> curl -k https://foobar.com:8002
> hello https
> 
> ---

The one that fails (two certificates syntax):

---

var https = require(""https""),
    path = require(""path""),
    http = require(""http""),
    httpProxy = require(""http-proxy""),
    fs = require(""fs""),
    crypto = require(""crypto"");

//
// generic function to load the credentials context from disk
//
function getCredentialsContext () {
  return crypto.createCredentials({
    key:  fs.readFileSync('ryans-key.pem'),
    cert: fs.readFileSync('ryans-cert.pem')
  }).context;
}

//
// A certificate per domain hash
//
var certs = {
  ""foobar.com"":  getCredentialsContext(),
};

//
// Proxy options
//
var options = {
  https: {
    SNICallback: function (hostname) {
      return certs[hostname];
    }
  },
  hostnameOnly: true,
  router: {
    'foobar.com':  '127.0.0.1:8005',
  }
};

//
// Create a standalone HTTPS proxy server
//
httpProxy.createServer(options).listen(8002);

//
// Create the target HTTPS server
//
http.createServer(function (req, res) {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.write('hello https\n');
  res.end();
}).listen(8005);

---

Logs:

---

tls.js:1046
    throw new Error('Missing PFX or certificate + private key.');
          ^
Error: Missing PFX or certificate + private key.
    at Server (tls.js:1046:11)
    at new Server (https.js:35:14)
    at Object.exports.createServer (https.js:54:10)
    at Object.exports.createServer (node_modules/http-proxy/lib/node-http-proxy.js:178:13)
    at Object.<anonymous> (nodejs_test/ssl_test2.js:43:11)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Function.Module.runMain (module.js:497:10)

---

I created the key and the certificate as the nodejs documentation: http://nodejs.org/api/tls.html
openssl genrsa -out ryans-key.pem 1024
openssl req -new -key ryans-key.pem -out ryans-csr.pem
openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem

How is possible if the first one run perfectly? Am I doing  any mistake?

Thanks in advance!
",fuentecilla86,2013-06-15 02:20:25
399,2013-04-09 09:33:39,"Same issue here. It's pretty simple to replicate, just take the latest code from node.js npm repository and try the two certficates example.

The issue seems to be that the function to return the secure context simply returns blank when returning outside of the function. Not sure why, it doesn't make sense.
",hongkongkiwi,2013-06-15 02:20:25
399,2013-04-11 02:28:09,"same issue here
",niftylettuce,2013-06-15 02:20:25
399,2013-04-11 02:50:01,"line 386 of node-http-proxy.js doesn't contain 'pfx'
",niftylettuce,2013-06-15 02:20:25
399,2013-04-11 04:06:34,"have same issue as @andysavage anyone have a solution?
",niftylettuce,2013-06-15 02:20:25
399,2013-04-11 04:09:20,"I believe it has nothing to do with PFX or not, for some reason the context is null after returning from that method. Inside the helper method it resolves to an object but as soon as that method returns it gets 'released'. 

I'm wondering if this is a lower level bug with the crypto library rather than this, but it's a pretty massive show stopper for us, hopefully the coders can fix this ASAP. Perhaps downgrading the crypto library may help?
",hongkongkiwi,2013-06-15 02:20:25
399,2013-04-11 04:16:30,"fwiw here's the commit log, i'm not familiar with this code base though https://github.com/joyent/node/commits/v0.10.2-release/lib/crypto.js
",niftylettuce,2013-06-15 02:20:25
399,2013-04-30 17:07:34,"same here
",pkarc,2013-06-15 02:20:25
398,2013-04-02 02:18:36,"I've gotten the command line usage working, without a config file. But when I try it with the config file, I'm not sure where to put what values. Can you possibly give an apples-to-apples demo of the first ""Setup a basic stand-alone proxy server"" example, done via the config file?

Thank you!
",dylanized,2013-04-02 03:18:01
398,2013-04-02 03:18:01,"Oops, I get it now, the config file's router is the same as the router property above. A couple command line examples might help. thanks!
",dylanized,2013-04-02 03:18:01
397,2013-04-01 19:13:47,"ERROR : WebSocket connection to 'ws://eduardodiaz.draw socket.jit.su/socket.io/1/websocket/2towomjqHWP_O9_E8wgh' failed: Unexpected response code: 500

---

var express = require('express'),
    app     = express(),
    server  = require('http').createServer(app),
    io      = require('socket.io').listen(server),
    path    = require('path');

app.configure(function () {
  app.set('port', process.env.PORT || 3000);
  app.set('views', __dirname + '/views');
  app.set('view engine', 'jade');
  app.use(express.favicon());
  app.use(express.logger('dev'));
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(app.router);
  app.use(express.static(path.join(__dirname, 'public')));
});

app.get('/', function (req, res) {
    res.render('index.jade', {layout: false});
});

io.on('connection', function (client) {

<S_CODE_TOKEN>

});

server.listen(app.get('port'), function () {
    console.log('Server startup on port ->', app.get('port'));
});
",eduardiazf,2013-04-01 22:15:25
397,2013-04-01 22:15:25,"Please try the example with a vanilla node-http-proxy setup and reopen if the issue persistss
",indexzero,2013-04-01 22:15:25
396,2013-03-31 10:07:37,"Redirection has four cases:
1. redirect to the same target with changeOrigin
2. redirect to the same target without changeOrigin
3. redirect to the different target with changeOrigin
4. redirect to the different target without changeOrigin

the existing code can handle case 2, the fix is for case 1. case 3 and case 4 need to handle proxy response event to add proxy entry by user logic. 
",sequoiar,2013-12-27 07:32:03
396,2013-04-05 18:24:19,"+1
",thefosk,2013-12-27 07:32:03
396,2013-09-28 03:27:09,"I was just affected by this. Would definitely help my current project to have this merged.
",tonyarkles,2013-12-27 07:32:03
396,2013-09-28 09:00:18,"We're almost done with a major rewrite that has been under way for several months. Check it out on the `caronte` branch. We haven't decided what to do with pull-request maintenance before that. 

We will likely publish `0.10.99` with most open pull-requests before publishings `1.0.0`. cc/ @yawnt 
",indexzero,2013-12-27 07:32:03
396,2013-09-28 17:05:38,"Ok, cool. I'll just fork and pull these commits into my branch to use for now. Thanks for the hard work!
",tonyarkles,2013-12-27 07:32:03
395,2013-03-30 20:23:09,"I don't know this is related to node-http-proxy or node.js itself but when I burden a large amount of binary transfer to a simple proxy such as:

<S_CODE_TOKEN>

And I direct it to youtube (playing some video) the cpu usage goes to 99.9% and about 70% of memory. The machine runs latest version of Ubuntu server, node, and node-http-proxy on a 1GB VPS server from Linode.com.
",sesaretah,2013-03-31 18:46:37
395,2013-03-31 18:46:37,"You're doing it wrong. You don't need to buffer because you aren't doing anything async:

<S_CODE_TOKEN>

The memory usage you are experiencing is by buffering some huge video.
",indexzero,2013-03-31 18:46:37
395,2015-10-16 16:25:53,"I'm also trying to proxy a youtube video, based on @indexzero 's example, I tried:

<S_CODE_TOKEN>

and

<S_CODE_TOKEN>

but when I'm connecting to the new server, i'm getting:

<S_CODE_TOKEN>

The `.googlevideo.com` link works fine if I load it in the browser thought (it's the direct video link from a random youtube video)

Any hints on how I might get this working?
",jaruba,2013-03-31 18:46:37
395,2015-10-16 21:47:59,"@jaruba Please read the updated readme as this module has changed since this issue has been closed and has a different API
",jcrugzz,2013-03-31 18:46:37
395,2015-10-16 22:03:55,"@jcrugzz thanks for answering, my first issue was that I indeed did not read the readme carefully the first time.. I had to proxy an entire website (not just a page), I got it working with:

<S_CODE_TOKEN>
",jaruba,2013-03-31 18:46:37
395,2015-10-16 22:20:03,"@jcrugzz @indexzero I seem to have a different sort of problem now though, the proxy seems to be created successfully, so these links both work:

<S_CODE_TOKEN>

<S_CODE_TOKEN>

but when I change the server ip to my LAN ip, it just gives me a blank page (even from the same PC that creates the server, no errors in the console):

<S_CODE_TOKEN>

what could cause this?
",jaruba,2013-03-31 18:46:37
395,2015-10-18 01:00:14,"It was a ssl issue, I got it working with the example code at:
https://github.com/nodejitsu/node-http-proxy/blob/302d981dd2cf06dbf751b1f64e3dfea08d0f9476/examples/http/proxy-http-to-https.js

Awesome module, thanks. :)
",jaruba,2013-03-31 18:46:37
394,2013-03-30 00:06:05,"This allows you to specify what the target path should be passed just the hostname.
",Zariel,2013-12-27 07:31:30
394,2013-09-17 06:52:33,"I need this functionality too - will it be merged?
More specifically, what I need is to proxy requests based on path names to different servers without modifying the path. AFAICS the removal of the path part is hard-coded to the current implementation.
If that's already possible somehow without this patch, please let me know.
",ahochsteger,2013-12-27 07:31:30
394,2013-09-17 06:59:42,"Nevermind - I found a solution for my use case in the following comment:
https://github.com/nodejitsu/node-http-proxy/issues/386#issuecomment-15096437
",ahochsteger,2013-12-27 07:31:30
394,2013-12-27 07:31:30,"We're dropping the `ProxyTable` in `node-http-proxy@1.0.0`. If you want to take ownership of it `proxy-table` is available on `npm`! :-D
",indexzero,2013-12-27 07:31:30
393,2013-03-29 10:41:05,"@indexzero 

Does anyone have plan to support HTTP to CoAP proxy? 

CoAP is RESTful http-like protocol for Internet of Things.

http://en.wikipedia.org/wiki/Constrained_Application_Protocol
",sequoiar,2015-10-30 21:21:03
393,2013-04-21 21:06:21,"Would look at a PR for this. No plans in the roadmap tho.
",indexzero,2015-10-30 21:21:03
393,2015-10-30 21:21:03,"This sounds like a candidate for a separate module. Would love to see it!
",jcrugzz,2015-10-30 21:21:03
392,2013-03-28 10:48:08,"module.js:337
    throw new Error(""Cannot find module '"" + request + ""'"");
          ^
Error: Cannot find module 'socket.io-client'
    at Function._resolveFilename (module.js:337:11)
    at Function._load (module.js:279:25)
    at Module.require (module.js:359:17)
    at require (module.js:375:17)
    at Object.<anonymous> (/home/rajuk/Documents/nodeSamples/node_modules/socket.io/lib/socket.io.js:12:14)
    at Module._compile (module.js:446:26)
    at Object..js (module.js:464:10)
    at Module.load (module.js:353:32)
    at Function._load (module.js:311:12)
    at Module.require (module.js:359:17)
",kongaraju,2013-03-28 17:42:29
392,2013-03-28 17:42:29,"Please include more details. This isn't enough.
What were you trying to run and how does it relate to `http-proxy`?
Closing for now until more details provided.
",mmalecki,2013-03-28 17:42:29
391,2013-03-25 02:02:56,"for example, pathnameOnly proxy routing table is below

'/bar' -> 127.0.0.1:81
'foo' -> 127.0.0.1:82

if GET /bar, response a html with href '/img.jpeg', 
then, user request to GET /img.jpeg, that should be wrong.
the right GET request should be GET /bar/img.jpeg

Any ideas on this issue?
",sequoiar,2015-10-30 21:19:42
391,2015-10-30 21:19:42,"This is referenced to the older version of `http-proxy`
",jcrugzz,2015-10-30 21:19:42
390,2013-03-23 05:04:39,"Can node-http-proxy forward proxy a whole website, like youtube.com?
",sequoiar,2013-03-23 12:19:58
390,2013-03-23 12:19:58,"Yes. See [this](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/basic-proxy.js) example.
We use it at nodejitsu to do exactly that.
",mmalecki,2013-03-23 12:19:58
390,2013-03-23 15:31:46,"@mmalecki  which exact example you mean?
",sequoiar,2013-03-23 12:19:58
390,2013-03-23 16:06:47,"The one I linked: https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/basic-proxy.js
",mmalecki,2013-03-23 12:19:58
389,2013-03-22 23:08:10,"trying to put node-http-proxy in front of some node instances and also legacy apps, so far looks extremely complicated compared to apache httpd that I'm trying to replace :(.

any plans to offer the user a simplified config mode, not a coding based one?

regards.
",amanu,2013-03-23 03:06:28
389,2013-03-23 03:06:28,"There is one already ... rtfm? https://github.com/nodejitsu/node-http-proxy/blob/master/bin/node-http-proxy#L9-L22
",indexzero,2013-03-23 03:06:28
389,2013-03-23 08:39:57,"> There is one already ... rtfm? 

Sorry but there there's really no FM to start with :). 
(wiki is empty, official website not existing not as many other projects; or not linked from the readme).

There's only the long(thankfully) readme that shows that if anything can be done, it must be coded by hand in JavaScript. While I enjoy coding in JavaScript, in most companies, one WON'T be able to pass it to those from admin/maintenance :).

> https://github.com/nodejitsu/node-http-proxy/blob/master/bin/node-http-proxy#L9-L22

BTW, I haven't asked about the command line parameters :).

Just tried to push as small node based app in production, so a proxy replacement was required too :).
Pointing the admins to this project (there are not that many node proxy projects :) ), got the answer to give them something production ready that just needs to be configured (like the apache.org httpd), not just a library to code against :).
",amanu,2013-03-23 03:06:28
389,2013-03-23 11:51:40,"[There](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/basic-proxy.js) [are](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-https-to-http.js) [multiple](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/forward-proxy.js) [examples](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/balancer/simple-balancer.js) in the [`examples`](https://github.com/nodejitsu/node-http-proxy/tree/master/examples/) directory. 
The thing about `http-proxy` is that it offers countless possibilities and there's no easy way to simply configure it with a JSON file or anything like that. It'd simply become a mess. I believe that everyone should be able to understand as little JavaScript as it's required to configure a basic proxy (if not, I think that basically explaining the code to them would do the job).

Of course, you are welcome to write a tool to create a proxy basing on a config file, which will suit _your_ needs. Keep in mind that it won't suit everyone's needs.

If you have problems with configuring the proxy, feel free to reach out to us in `#nodejitsu` channel on Freenode. I'm `mmalecki` there. I'd be happy to help.
",mmalecki,2013-03-23 03:06:28
388,2013-03-21 23:52:01,"In some cases, when there is an error, the headers are sent twice which throws an exception. I was able to reproduce by doing this:

<S_CODE_TOKEN>

`foobar' is a valid proxied website. A proxy using node-http-proxy is running on localhost:1080.

This produces the following error:

<S_CODE_TOKEN>

The problem here is that netcat does not read anything. I tried with a script that reads the response and the error does not occur. The simple `if' statement I added prevents the bug to happen and everything then works normally.
",samalba,2013-12-27 07:50:31
388,2013-03-22 01:16:52,"@samalba Could you add a test case for this?
",indexzero,2013-12-27 07:50:31
388,2013-03-22 01:51:58,"I could yes, however I tried to run the tests and they're hanging on my machine: http://pastie.org/private/syspc2w6h0yl98u1kivnw

Did a miss a step? I tested this fix by running hipache's test (https://github.com/dotcloud/hipache/blob/master/test/test_parseerror.py#L95). However I'd be glad to provide one for node-http-proxy!
",samalba,2013-12-27 07:50:31
388,2013-03-22 03:04:54,"What node version are you on? 
",indexzero,2013-12-27 07:50:31
388,2013-03-22 03:10:02,"That's a good test; would love to see it in node.js. Create a `net.Server` instance and write a bad header line to it. Should be straight-forward.
",indexzero,2013-12-27 07:50:31
388,2013-04-30 17:38:31,"Please merge, I'm having this problem too.
",bwaters,2013-12-27 07:50:31
388,2013-05-22 15:04:22,"Me too... pleaseeeeee :tongue: 
",bfx81,2013-12-27 07:50:31
388,2013-05-23 07:58:08,"@bwaters @bfx81 We will merge when there is a test for this.
",indexzero,2013-12-27 07:50:31
388,2013-05-31 23:09:29,"I'm getting the same problem.
",kadishmal,2013-12-27 07:50:31
388,2013-06-08 14:49:28,"I've tested the patch and this didn't solve the problem... checked at a ""lower"" level in http.js nodejs core module.
This solved my problem
https://github.com/bfx81/node/commit/0149cce82838f98ea80191127a5bf84b21081cfd
",bfx81,2013-12-27 07:50:31
388,2013-06-08 15:05:59,"Sorry not sure anymore... this problem happens in a very chaotic way!
",bfx81,2013-12-27 07:50:31
388,2013-07-25 16:00:41,"What's the latest with this bug?
",bslayton,2013-12-27 07:50:31
388,2013-07-25 22:43:30,"Did someone find a way to reproduce the bug ?
",nfroidure,2013-12-27 07:50:31
388,2013-10-03 21:49:12,"I was hit today by that nasty `Error: Can't render headers after they are sent to the client.` error.

It obviously is caused by setting headers after some data has already been sent.
It took me a while but I found that in my case the `proxyError`-event handler is causing that issue:
Data has already been sent, the `proxyError`-handler sets the header 'Content-Type' and it blows up.

For the time being I simple commented out the `writeHead`-call:
`//res.writeHead(500, { 'Content-Type': 'text/plain' });`
",davidsteinberger,2013-12-27 07:50:31
388,2013-12-12 10:43:13,"Is this issue resolved yet? Admittedly it is hard to reproduce. I encountered the

<S_CODE_TOKEN>

today.
",achselschweisz,2013-12-27 07:50:31
388,2013-12-12 11:58:36,"@achselschweisz checkout the [`caronte`](https://github.com/nodejitsu/node-http-proxy/tree/caronte) branch. It is a complete refactor that will become `node-http-proxy` 1.0. Please open a new issue if you find this to be the case
",jcrugzz,2013-12-27 07:50:31
388,2013-12-12 17:49:19,"Nice! @jcrugzz any ETA for this 1.0 release?
",samalba,2013-12-27 07:50:31
388,2013-12-12 17:53:36,"cheers, I will try that and report back (btw., just had the error again).
 I cannot though offer any help in reproducing the problem since this happens sporadically when streaming data to services which are proxied through node-http-proxy. Just now it took a few hours, numerous requests and about 40GiB of streaming data to make this bugger reappear.
",achselschweisz,2013-12-27 07:50:31
388,2013-12-20 04:23:54,"I am experiencing this same error, using https://github.com/drewzboto/grunt-connect-proxy to proxy to my backend API in development. Only happens on file upload. Don't know if I am being naive or if I am experiencing the same issue.

<S_CODE_TOKEN>

If it seems like the same issue I'd be interested to know.
",kahnjw,2013-12-27 07:50:31
388,2013-12-20 05:42:49,"Nevermind, im dumb
",kahnjw,2013-12-27 07:50:31
388,2013-12-27 07:46:40,"Despite @samalba _never_ submitting a test for this I'm going to roll this into the last `0.10.x` maintenance release because the logic is sound. 

@samalba write moar tests!
",indexzero,2013-12-27 07:50:31
388,2013-12-27 07:50:31,"Cherry-picked. Thanks!
",indexzero,2013-12-27 07:50:31
388,2014-01-05 07:16:46,"I am still getting this error when trying to proxy http://www.amazon.de/ website. Can someone reproduce the bug for this website?
",inian,2013-12-27 07:50:31
388,2014-05-26 00:44:22,"FWIW, I'm seeing this error constantly as well, using http-proxy version 0.10.4, when I set up an http-proxy in front of CouchDB:

<S_CODE_TOKEN>

Whose responsibility is it to fix a bug like this?  Node?  This module?  The implementor (e.g. `proxy.on('error')`?  I'm not sure.
",nolanlawson,2013-12-27 07:50:31
388,2014-05-26 00:48:36,"Ah wait, I am using a super old version of this module.  Please ignore the above comment.
",nolanlawson,2013-12-27 07:50:31
387,2013-03-19 08:13:18,"a simple test:

var util = require('util'),
    http = require('http'),
    httpProxy = require('http-proxy');

try {
  var io = require('socket.io'),
      client = require('socket.io-client');
}
catch (ex) {
  console.error('Socket.io is required for this example:');
  process.exit(1);
}

//
// Create the target HTTP server and setup
// socket.io on it.
//
var server = io.listen(8080);
server.set('transports', ['websocket']);
server.sockets.on('connection', function (client) {
  util.debug('Got websocket connection');

  client.on('message', function (msg) {
    util.debug('Got message from client: ' + msg);
  });
  client.send('from server');
});

//
// Create a proxy server with node-http-proxy
//
httpProxy.createServer(8080, 'localhost').listen(8081);

//
// Setup the socket.io client against our proxy
//
var ws = client.connect('ws://localhost:8081');

ws.on('message', function (msg) {
  util.debug('Got message: ' + msg);
});

in node.js version 0.10.0 we are never got a message 'Got message: from server'.. In ver. 0.8.18 all work fine.. 
",llevkin,2013-04-21 21:05:05
387,2013-03-19 08:30:55,"+1, I traceback from LearnBoost's up (depends on LB's distrubute, which in turn depends on NJS's node-http-proxy).
NPM test results in timeout while trying

<S_CODE_TOKEN>
",truongsinh,2013-04-21 21:05:05
387,2013-03-25 15:24:26,"anyone?
",truongsinh,2013-04-21 21:05:05
387,2013-03-25 15:38:34,"nobody cares... =)
",llevkin,2013-04-21 21:05:05
387,2013-03-25 16:11:08,"Hey guys, we are currently in the process of testing node 0.10.x on our platform. Sometimes the newest versions have some kinks that need to be worked out when our whole system is built on node :). A patch with tests would of course be welcome though!
",jcrugzz,2013-04-21 21:05:05
387,2013-04-02 15:31:21,"@jcrugzz is the issue reproducible for you? I have found the same problem. 
",desunit,2013-04-21 21:05:05
387,2013-04-02 19:41:27,"Lets call it an issue; someone want to submit a PR? 
",indexzero,2013-04-21 21:05:05
387,2013-04-07 20:59:07,"It seems it's related to this prev issue:
https://github.com/nodejitsu/node-http-proxy/issues/97
",pkarc,2013-04-21 21:05:05
387,2013-04-21 21:05:05,"Fixed in #402 
",indexzero,2013-04-21 21:05:05
387,2013-04-22 21:01:02,"@indexzero  Can you reopen the issue at least, since the fix is buggy as described in https://github.com/nodejitsu/node-http-proxy/pull/402#issuecomment-16539748  ?  (It sometimes double-sends the first chunk of the post-headers part of the proxied websocket data).  I know that you said you're planning to do a full rewrite of this code for the 0.10 API but it might be worth keeping open the record of the fact that the current code is buggy...
",glasser,2013-04-21 21:05:05
386,2013-03-19 01:44:51,"When using a proxy table, like below:

<S_CODE_TOKEN>

All requests to the root of the proxy server (localhost:3000) reach the destination, including the full path. IE: A GET request to localhost:3000/scripts/main.js reaches localhost:8000/scripts/main.js with the path in tact. However, any request to localhost:3000/accounts/login, reaches the destination without the full path. IE a POST request to localhost:3000/accounts/login reaches the destination as a POST to localhost:8001, no path is included. This same behavior persists if the destination includes the full path.

My proxy server script, in total:

<S_CODE_TOKEN>
",viridisdev,2015-10-30 21:17:46
386,2013-03-19 04:04:30,"The problem exists because of my use of pathnameOnly: true.

Within lib/proxy-table.js on line 226 the matching route is replaced with an empty string for the request being sent to the proxy destination.

A workaround that I found is the following:

<S_CODE_TOKEN>

While this isn't ideal, one could make use of environment configurations for defining routes within a given environment, it will work. Ideally, it would be nice to be able to set an option:

<S_CODE_TOKEN>

This would bypass the behavior of omitting the path from the the target.
",viridisdev,2015-10-30 21:17:46
386,2013-06-08 00:10:13,"What about a regex router options like:

<S_CODE_TOKEN>

The path is lost.
",masterkain,2015-10-30 21:17:46
386,2013-10-20 11:56:10,"I just saw this one in action :). Any update on this?
",mcollina,2015-10-30 21:17:46
386,2013-10-20 12:14:49,"hey @mcollina, the new branch (caronte) does't have proxytable support (i think it would make more sense to distribute it as a on-the-top module instead of directly with the proxy) so i don't think this one is going to land any time soon.. i'm sorry 
",yawnt,2015-10-30 21:17:46
386,2013-10-20 16:20:54,"@yawnt I agree with a separate module.
People are you using this in production, so provide an alternative for the new release.

Even if you are not going to release it with 'caronte', having a very simple routing table example for 'caronte' will be very helpful!
",mcollina,2015-10-30 21:17:46
386,2015-10-30 21:17:46,"Yes this should be provided through a separate module. Would love to see it created!
",jcrugzz,2015-10-30 21:17:46
385,2013-03-18 05:51:33,"This is a minor breaking change. I'm inclined to make this `0.10.0`. It was always my intention to have the event emitted on the `HttpProxy` or `RoutingProxy` instance, but I missed the edit in the PR.
",indexzero,2013-03-18 05:51:50
384,2013-03-16 12:22:43,"As requested by @indexzero https://github.com/nodejitsu/node-http-proxy/issues/382 
Not sure exactly where I should put the text but middleware seemed to be the best section to me. 
",No9,2013-03-16 14:56:27
384,2014-03-04 21:20:06,"@indexzero @No9 This merge/code has been lost to later merges. This is a very useful information, and should be in the README!

Please re-pull this.
",gurjeet,2013-03-16 14:56:27
384,2014-03-04 21:56:27,"@gurjeet while this is an awesome plugin it is no longer compatible with the newest implementation as `node-http-proxy` has been simplified. 
",jcrugzz,2013-03-16 14:56:27
384,2014-03-04 21:59:24,"@jcrugzz Thanks for letting me know! I was planning on using it, but you saved me some head-banging :)

Are there any alternatives packages available?
",gurjeet,2013-03-16 14:56:27
384,2014-03-10 15:09:05,"@gurjeet harmon is OPEN open source.
If you make an accepted pull request to upgrade to 1.0.0 http-proxy I will add you as an administrator
",No9,2013-03-16 14:56:27
384,2014-04-16 22:12:32,"@jcrugzz Thanks for your kind words!  

So i have updated the harmon docs and tests to reflect the 1.x release version of http-proxy and we have upgraded trumpet. Can you let me know if you would accept a pull request on the README again or are you putting it somewhere else now? 
cc @gurjeet @indexzero  
",No9,2013-03-16 14:56:27
384,2014-04-17 00:25:13,"@No9 I would totally accept a PR to put that in the docs :). 
",jcrugzz,2013-03-16 14:56:27
383,2013-03-15 02:10:04,"This pull request fixes a bug that generates the following exception:

<S_CODE_TOKEN>
",thefosk,2013-03-18 05:50:17
382,2013-03-13 04:21:33,"Hi, I really need to know how to get the response HTML as a string and modify it.

This question has been asked before at stackoverflow but I don't see how to do it.

http://stackoverflow.com/questions/13596942/using-node-js-to-proxy-http-and-modify-response 

In general, I need to get access to all request data and all response data and change the response data in some cases. Thanks!
",PhilAndrew,2013-03-13 05:34:44
382,2013-03-13 05:34:44,"This short answer is you can't. You can _observe_ it, but you cannot modify it, `node-http-proxy` writes to the response for you. In `0.9.0` we add the `proxyResponse` event which allows you to **observe** the response data for caching purposes, but _not to modify it._

e.g. 

<S_CODE_TOKEN>

In general **_this is really bad practice_** unless you can do the modification in a streaming manner because you will have to _buffer the entire response._
",indexzero,2013-03-13 05:34:44
382,2013-03-14 05:42:08,"Hi there,

What I want to do is have a Wordpress website and proxy it with NodeJS, then when a webpage comes back from Wordpress at some particular URL then I want to modify the contents of the webpage to insert a form.

The idea is that its slightly difficult to develop in Wordpress and easier to develop in NodeJS (for me). So by proxy Wordpress I thought I can add extra things to my Wordpress page. Wordpress is good for business cases, fast development of site at a cheaper price and easy for user to use as a CRM. 

Can you suggest a way to go about doing this? I would really appreciate any thoughts you have on this.

I want to intercept all incoming and outgoing and modify the request/response data in insert my own data, ie a form.

Thanks! Philip
",PhilAndrew,2013-03-13 05:34:44
382,2013-03-14 09:29:24,"@PhilHongKong Harmon is designed to plug into node-http-proxy https://github.com/No9/harmon 
It uses trumpet and so is stream based to work around the buffering problem that @indexzero mentions. It uses an element and attribute selector to enable manipulation of a response. 
",No9,2013-03-13 05:34:44
382,2013-03-14 10:18:41,"Nice. @No9 could you make a pull-request to README.md about this? We get this question a lot.
",indexzero,2013-03-13 05:34:44
382,2013-03-14 13:01:59,"Thanks, yes my first thought was to google for a proxy to NodeJS. The question is in general, how to find the Harmon/Trumpet in the first place for a person who is searching for a way to change the data coming out of a web-server passing through the proxy, I didn't find Haron/Trumpet from google.
",PhilAndrew,2013-03-13 05:34:44
382,2013-03-16 12:26:48,"Pull done. Also did a little bit of house keeping on the repo readme too.
",No9,2013-03-13 05:34:44
382,2013-12-04 12:25:04,"How about JSON responses? What what module similar to this can I use to modify JSON responses? 
",emanuelsaringan,2013-03-13 05:34:44
382,2015-02-26 13:37:12,"How about using [replacestream](https://www.npmjs.com/package/replacestream)?
",Skyross,2013-03-13 05:34:44
382,2015-04-11 22:29:31,"Harmon / Trumpet allow you to replace a html element, but what if you want to insert elements at various points in the document being returned?
",akshayl,2013-03-13 05:34:44
382,2015-04-11 22:49:35,"Hi @akshayl  
https://github.com/No9/harmon/blob/master/examples/rotate.js 
Demonstrates adding an additional style tag in the head without replacing. 

Does this fit your use case? 
",No9,2013-03-13 05:34:44
382,2015-04-11 23:52:42,"Thanks for your reply @No9 
That example seems to replace the entire head tag including the script tag which outputs the message ""The piece of javascript also inside the head tag wasn't touched :)""

Before:
`<html><head><script>window.onload = function () {document.getElementById(""message"").innerHTML = ""The piece of javascript also inside the head tag wasn't touched :)"";}</script></head><body><h3>A simple example of injecting some css to rotate an image into a page before it is rendered.</h3><image src=""http://i.imgur.com/fpMGL.png"" /><div id=""message""></div></body></html>`

After:
`<html><head><style type=""text/css""> img { -webkit-transform: rotate(-90deg); -moz-transform: rotate(-90deg); filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);}</style></head><body><h3>A simple example of injecting some css to rotate an image into a page before it is rendered.</h3><image src=""http://i.imgur.com/fpMGL.png"" /><div id=""message""></div></body></html>`
",akshayl,2013-03-13 05:34:44
382,2015-04-12 00:13:15,"@akshayl ah now I get you. 
So https://github.com/No9/harmon/blob/master/examples/doge.js#L22 
Shows how you can hold the content of the node and then use it afterwards. 
The sample just logs it to console but I think this might be what you are looking for?
",No9,2013-03-13 05:34:44
382,2015-04-30 11:40:33,"hi guys i am working with the same solution 

//
// Create a proxy server with custom application logic
//
httpProxy.createServer(function (req, res, proxy) {
  //
  // Listen to the `proxyResponse` event. Make note that 
  // the first two arguments to this handler are the `req`
  // and `res` in the existing scope and I'm indicating that 
  // they are meaningless by assigning them the var name `_` 
  //
  req.on('proxyResponse', function (_, _, proxyRes) {
    proxyRes.on('data', function (chunk) {
      //
      // This is the data from the target server, but modifying
      // it will not affect the outgoing `res`. 
      // 
    });
  });

  //
  // Put other custom server logic here
  //

  // Now make the proxy request.
  proxy.proxyRequest(req, res, {
    host: 'localhost',
    port: 9000
  });
}).listen(8000);

but in sum cases i am getting only half of the data 
is there a way to get all the data no mater the size?

shlomi
",shlomihassan,2013-03-13 05:34:44
382,2016-04-26 14:49:31,"Sorry to hijack this issue, but I want to do exactly what this issue says I _should_ be able to. I want to inject an httpProxy between clients and a JSON API server, _only_ observe the JSON data before passing it back, and perform server-side logic. This seems like it should be easy but it isn't. Here is my code:

<S_CODE_TOKEN>

I just get a bunch of `finish` events and no data. Using this issue because it was what I found when I searched, and I'd have expected the code above to work but either I'm putting it in the wrong place or this solution is outdated.

I'm stuck on Node 0.10.43 if that makes a difference--not my choice, unfortunately.
",ndarilek,2013-03-13 05:34:44
382,2016-04-26 15:00:25,"And of course 5 minutes after I post that issue, I spot my typo:

<S_CODE_TOKEN>

I.e. The first parameter to the event callback is a `res`, not a `req`. Sorry for the spam folks. The lesson for the day is coffee first, then code.
",ndarilek,2013-03-13 05:34:44
382,2016-08-10 13:56:25,"I had same problem and only solution I've found I peeped in the very same harmon module: https://github.com/No9/harmon/blob/master/examples/gzipped.js#L47-L64
When the author creates an server which listens 9000 port he uses such a hack when he gzipes the response. He uses zlib.Gzip which is a Transform stream and forwards his regular data through it to gzip it.
So we could do the same, here is the example:

<S_CODE_TOKEN>

Or you can just use https://github.com/philippotto/transformer-proxy
",Armalon,2013-03-13 05:34:44
382,2017-03-02 22:01:48,"I needed to apply some throttling to node-http-proxy, so not really a transformation of the body but still the best implementation that I could think of is to use a throttle stream (for example [node-stream-throttle](https://github.com/tjgq/node-stream-throttle)). As I didn't want a hackish solution, I made a small addition to the options in this fork: https://github.com/koumoul-dev/node-http-proxy/commit/4db8736ed6d28018d5cb2f541370e6de0972d534

The resTransformStream and reqTransformStream options are exactly what their names suggest: optional transform streams that can be piped between req to proxyReq and proxyRes to res.

If some people are interested and the maintainers are ok with the idea I am willing to work on a proper PR, with doc, test, etc.",albanm,2013-03-13 05:34:44
381,2013-03-11 17:20:55,"Thanks for the timeout options. Unfortunately, it does not work when using a router. This small modification does the trick. Is it correct?

related to #372
",valette,2013-12-27 07:42:44
381,2013-03-12 08:05:53,"The build failed on Travis. I will consider merging this when the tests pass.
",indexzero,2013-12-27 07:42:44
381,2013-12-27 07:42:44,"On second examination: this is the wrong approach. These are not the `options` you're looking for.
",indexzero,2013-12-27 07:42:44
380,2013-03-06 00:58:17,"I have been using node-http-proxy to proxy requests to different web services.  IE

<S_CODE_TOKEN>

So I made that simple to do by adding a pathnameOnly flag similar to hostnameOnly.  
",mikkel,2013-03-09 08:18:26
380,2013-03-09 08:18:26,"Cherry-picked. Thanks!
",indexzero,2013-03-09 08:18:26
379,2013-03-05 20:17:41,"I'm creating a multi-tenant web application and need to dynamically add new customers without having to change my proxy table settings. I was hoping to use RegExp values in the proxy table, but am finding that this doesn't work.

Here's an example of various mappings I need to go to the same backend service:

https://mysite.com/api/1/
https://api.mysite.com/1/
https://customerA.mysite.com/api/1/
https://customerB.mysite.com/api/1/

I was attempting to use a routing table that contains regex values for the sources, such as this:

<S_CODE_TOKEN>

Unfortunately, this doesn't work. Even though the source string is converted into a `RegExp` properly, it is also processed by `url.parse()`. The resulting object doesn't contain the correct values in the properties of the `URL` object.

So, I'm currently having to hard-code every customer's username into the routing table, like this:

<S_CODE_TOKEN>

Manually changing this table isn't going to scale long-term. I believe there is a way to dynamically reload the routing table, and I'll probably look at doing that as well. But this table will get very large if I need an entry for every customer. That is not a scalable solution either since this proxy sits in front of every request to my entire infrastructure.

It would be far better if I could just use a `RegExp` in the table itself. Is there a way to do this and I'm just not aware of it? Would this be of interest to others if I implemented it and submitted a pull request? Any other thoughts?
",tauren,2013-03-09 09:24:52
379,2013-03-09 09:24:52,"Checkout 5d515e4, should resolve your issue.
",indexzero,2013-03-09 09:24:52
378,2013-03-02 22:59:09,"I want to use URLs like these:
1. App X at gizur.com/X
2. App Y at gizur.com/Y

The requests should transparently be routed to:
1. App X at x.paas.com
2. App Y at y.paas.com 

How is this achived with http-proxy?

Any help is greatly appreciated!
",colmsjo,2013-03-09 08:28:35
378,2013-03-03 08:48:13,"I realized that the solution below is what should be used (which should be obvious I guess).

<S_CODE_TOKEN>

The problem seams to be in the other end. Heroku for instance answers like this:

<S_CODE_TOKEN>

Is there any way I can make Heroku (or any other app server) believe that it was 'wip.herokuapp.com' that is the original URL?
",colmsjo,2013-03-09 08:28:35
378,2013-03-09 08:28:35,"We currently dont support header rewriting in `node-http-proxy`
",indexzero,2013-03-09 08:28:35
378,2013-03-10 19:32:50,"@indexzero You actually supports header rewriting of the `Host` header. And thats probably all @colmsjo needs.

@colmsjo It should be as simple as setting `changeOrigin: true` in the `options` object.

If you need more advanced header rewriting, it can easily be implemented by a middleware which changes `req.headers`.
",tellnes,2013-03-09 08:28:35
377,2013-03-02 21:26:04,"I've found the following error in my logs. Unfortunately I cannot provide a meaningful context, and I'm not really sure why it happened, so just in case I report it here. Feel free to close this issue if it leads to nowhere.

<S_CODE_TOKEN>
",thefosk,2013-03-09 07:05:38
377,2013-03-05 12:35:33,"look on squence of events from bottom up.
seems like it is write on a closed socket
",shimondoodkin,2013-03-09 07:05:38
377,2013-03-09 07:05:38,"The backend you are proxying to is not running. 
",indexzero,2013-03-09 07:05:38
376,2013-02-24 17:18:09,"This is a fix with tests that should solve issue #318 Reverse Proxy port rewriting for HTTP3xx Location headers.
",jayv,2013-12-27 07:18:14
376,2013-03-25 23:58:27,"in case redirect to the different host instead of origin target host, the proxy target entry need to overwrite as well.  
",sequoiar,2013-12-27 07:18:14
376,2013-03-26 08:14:22,"@sequoiar 

I've spent a couple hours writing this patch with full test coverage, it's been used by quite a few people and it should merge in cleanly. Yet still no word (good or bad) from nodejitsu in almost 6 months, if you want this fix I guess you're on your own.
",jayv,2013-12-27 07:18:14
376,2013-04-07 21:11:16,"@indexzero @dscape Any updates on this ?
",vojtajina,2013-12-27 07:18:14
376,2013-05-09 01:05:17,"+1
",MattWalker,2013-12-27 07:18:14
376,2013-05-09 01:13:41,":+1:  @indexzero @nodejitsu Any word on getting this merged in?
",stickel,2013-12-27 07:18:14
376,2013-05-24 09:45:05,"Would be very useful if merged.
Does anybody have some update on this?
",antoine-richard,2013-12-27 07:18:14
376,2013-12-19 12:45:49,"@nodejitsu +1
",rsboarder,2013-12-27 07:18:14
376,2013-12-27 07:18:14,"See my comments on #519. This can be accomplished without a bunch of new code.
",indexzero,2013-12-27 07:18:14
375,2013-02-24 02:25:59,"when proxy to target, cache target server's static content in proxy server side. any idea?
",sequoiar,2013-03-09 06:49:15
375,2013-03-09 06:49:15,"Fixed in #356 
",indexzero,2013-03-09 06:49:15
374,2013-02-10 22:42:11,"For this issue I just commented instead of deleting the unneeded code because I only tried the normal http parts, not the web sockets but I believe that 99,9% is correct.

After some research this part is causing the problem:

<S_CODE_TOKEN>

This is not needed as node.js' `ClientRequest` object (here the `reverseProxy`) attaches a listener to the socket 'error'

<S_CODE_TOKEN>

The `socketErrorListener` just re-emits the error from the `ClientRequest` object.

Look in https://github.com/joyent/node/blob/master/lib/http.js for the `socketErrorListener` references.
",erasmospunk,2013-03-09 05:11:57
374,2013-02-12 19:20:46,"Your logic is sound, but if you're going to remove code, remove it. Don't comment it out with big comments saying why it shouldn't be there.
",indexzero,2013-03-09 05:11:57
374,2013-02-12 19:46:36,"You are right, just removed.
",erasmospunk,2013-03-09 05:11:57
373,2013-02-06 18:58:20,"We hit an issue with this node proxy. Webkit-based
browsers do not send Content-Length header when there
is no content for DELETE. DELETE requests have no
content, which causes node-http-proxy to add a
""Transfer-Encoding: chunked"" header. This causes any
upstream Nginx server to fail with a 411.

<S_CODE_TOKEN>
",philwhln,2013-03-09 07:40:14
372,2013-02-03 21:16:53,"When proxying to a source whose response may be >2 minutes the request is actually resubmitted and ultimately never returns to the original request. If it is known that you will have larger request periods allow for a timeout option for the server.
",pdoran,2013-03-09 08:04:51
372,2013-02-12 19:16:09,"This looks fine
",indexzero,2013-03-09 08:04:51
372,2013-03-09 08:04:51,"Cherry-picked. Thanks!
",indexzero,2013-03-09 08:04:51
371,2013-02-02 07:59:35,"I install the Node 0.8.18 with http-proxy 0.8.7 on Mac Lion and I tried with the following command but failed:

MacBook-Pro:~ ccp999$ node-http-proxy --port=8000
usage: node-http-proxy [options] 

Starts a node-http-proxy server using the specified command-line options

options:
  --port   PORT       Port that the proxy server should run on
  --host   HOST       Host that the proxy server should run on
  --target HOST:PORT  Location of the server the proxy will target
  --config OUTFILE    Location of the configuration file for the proxy server
  --silent            Silence the log output from the proxy server
  -h, --help          You're staring at it
MacBook-Pro:~ ccp999$ 
",ccp999,2013-02-12 19:16:54
371,2013-02-02 08:17:39,"try with ""--port 8000"" instead of ""--port=8000""
",yawnt,2013-02-12 19:16:54
371,2013-02-02 08:22:04,"I tired all combinations that I can think of:
--port 8000
-port=8000
port=8000
-port='8000' --port='8000'...etc
But all failed
",ccp999,2013-02-12 19:16:54
371,2013-02-03 10:11:56,"You need to provide a target in order to get this working.

<S_CODE_TOKEN>
",julianduque,2013-02-12 19:16:54
371,2013-02-03 11:00:15,"Thanks that!
Actually, I just want to setup a standalone forward proxy.  Can I do it from command line?
",ccp999,2013-02-12 19:16:54
371,2013-02-05 15:43:34,"Same need here, the point is to have a forward proxy (that uses my machine hosts) configured on iOS devices for quick development testing. Using Charles.app for now.
",mgcrea,2013-02-12 19:16:54
371,2014-03-20 02:38:17,"For those looking for this repo's CLI, it seems to have been removed in `1.x.x`. The last version that had the CLI was `0.10.4`, so to install that, do a `npm install -g http-proxy@0.10.4` which should create a `node-http-proxy` in your path.
",jpillora,2013-02-12 19:16:54
371,2014-06-17 19:01:17,"DaProxy is also a good solution. https://www.npmjs.org/package/daproxy
",stutrek,2013-02-12 19:16:54
370,2013-01-24 23:46:08,"See: https://github.com/jmatthewsr-ms/node-slab-memory-issues
",jmatthewsr-ms,2013-04-09 18:02:56
370,2013-01-25 04:45:07,"Putting this on hold as I believe that a node core fix is the most appropriate.  Buffer can also retain an 8k slab on it's own, ideally node core should emit a buffer that is not backed by any slab.

https://github.com/joyent/node/pull/4660
",jmatthewsr-ms,2013-04-09 18:02:56
370,2013-03-22 16:09:52,"@jmatthewsr-ms I'm reopening after @3rd-Eden bought it to my attention because because it appears the fix for underlying issue in node core was not resolve. Is this correct?
",indexzero,2013-04-09 18:02:56
370,2013-03-22 17:28:59,"Yes. My understanding is that this won't be fixed until possibly 0.12:
https://github.com/jmatthewsr-ms/node-slab-memory-issues/issues/1
https://github.com/joyent/node/issues/4964
",jmatthewsr-ms,2013-04-09 18:02:56
370,2013-03-23 03:52:26,"You're correct. It will probably take the entire v0.11 development cycle to vet the new allocator. Also note that it currently just mirrors the way  Buffers pool data. The first step is just to get the thing working. This will require a substantial overhaul. Then once everything is allocating from the same source we can focus on improving the allocation algorithm.
",trevnorris,2013-04-09 18:02:56
370,2013-04-09 07:39:01,"@indexzero @mmalecki 

I'd advise us to accept this pull request. I've been doing a lot of WebSocket proxy tests lately because I was interested in to seeing how our proxy solution compares to other proxies such as `nginx` and `haproxy`.

I've deployed the proxy on a 512mb joyent virtual machine running the latest ubuntu and hit it using [observing/thor](/observing/thor) with: 

<S_CODE_TOKEN>

I saw a peak memory of `280mb` before this patch. After applying this patch and re-running the command it saw a maximum of `102mb` which is significant decrease. So even if this is going to be fixed in later version of Node. It makes sense to pull this asap.
",3rd-Eden,2013-04-09 18:02:56
370,2013-04-09 11:49:33,"Re-ran the test suite and everything is passing now, it was probably a failure on travis side that marked these commits as broken.
",3rd-Eden,2013-04-09 18:02:56
370,2013-04-09 16:02:18,"Note that this is being worked on in node core: https://github.com/joyent/node/pull/4964. 

The buffer copy in this fix may not be required once node core buffer is fixed.  The fix here shouldn't hurt performance if left in, but worth checking once node core is updated.
",jmatthewsr-ms,2013-04-09 18:02:56
370,2013-04-09 16:36:48,"@jmatthewsr-ms yes, it's being worked on but it would only be made available in node 0.12, which still another stable release away and as we have no idea how long it will take before 0.12 is released, it makes sense to merge this in IMHO (as well as in all other projects).
",3rd-Eden,2013-04-09 18:02:56
370,2013-04-09 16:38:09,"Agreed.
",jmatthewsr-ms,2013-04-09 18:02:56
370,2013-07-03 22:13:58,"fyi: https://github.com/joyent/node/commit/ec90e6e
",trevnorris,2013-04-09 18:02:56
369,2013-01-24 23:34:56,"if I POST to a route on my server with some data, let's say ""aaa=bbb"", and try to proxy that post to another external server, it shows up on that server as:

{""{\""aaa\"":""=>nil}

Here's the route:

<S_CODE_TOKEN>

I tried to convert the req.body back to a url-encoded string but then this got posted to the external server:

{""\""aaa""=>""bb""}

It has an extra quote in the the front and has truncated the last character. Here's the route:

<S_CODE_TOKEN>

I'm new to Node and Express to I apologize if this is an incredibly stupid question. I can't seem to figure out why an ajax call directly to the server works but then when I run it through the above proxy, the data sent is messed up.

*edit to format code better
",griddle,2013-03-09 07:16:41
369,2013-03-09 07:16:41,"Assuming that `this.match` is async you need to buffer the request first. See: https://github.com/nodejitsu/node-http-proxy#setup-a-stand-alone-proxy-server-with-latency-eg-io-etc
",indexzero,2013-03-09 07:16:41
368,2013-01-17 19:31:54,"How do this?

If the ""createServer"" of GeddyJS is calling inside of the framework, how i can add a proxy in a running server?

I have a server running in the port 4000, but i dont have access to the function that start the server, but i need to put a proxy to... something like this:

var http = require('http'),
    httpProxy = require('http-proxy');
//
// Create your proxy server
//
httpProxy.createServer(4000, 'localhost').listen(8000);

But ""localhost:4000"" already running or already started before the httpProxy.createServer
",celorodovalho,2013-01-18 05:48:08
368,2013-01-18 05:48:08,"See: https://github.com/nodejitsu/node-http-proxy#proxy-requests-within-another-http-server
",indexzero,2013-01-18 05:48:08
367,2013-01-16 17:10:50,"Currently, the test test-http-many-keep-alive-connections is failed but the build is considered as fine by travis. Is it normal?

So, should we pass the build as failed if a test in the core section fails?
Actually, I don't understand the interest of the tests of the core folder since they seem to test Node http module itself rather than the http-proxy module.
",abarre,2015-10-30 21:10:25
367,2015-10-30 21:10:25,"This is no longer relevant with the current version of `http-proxy`
",jcrugzz,2015-10-30 21:10:25
366,2013-01-16 15:03:43,"I've got this code for proxy requests:

<S_CODE_TOKEN>

Every route except for the `www2.domainonhttps.com`  route is working. When I set `target`, I get a 400 bad request error. If I don't set target, I get a ""502 bad gateway error"". The destination domain + path is working fine through a browser. 

What could be the issue here? Is there some options I've neglected to add? I was trying to find a working http-> https example for this application, but it's nowhere to be found.
",phun-ky,2013-03-09 08:26:54
366,2013-03-09 08:26:53,"Yes, should be:

<S_CODE_TOKEN>
",indexzero,2013-03-09 08:26:54
365,2013-01-13 03:58:59,"I think this was a bug in the RoutingProxy listener binding code. But I'm not sure. Anyway, it works better for me now in my application, where I'm binding multiple ""once"" listeners to a single proxy.
",adjohnson916,2013-03-09 05:14:14
365,2013-01-21 17:01:08,"+1
",abarre,2013-03-09 05:14:14
364,2013-01-10 08:16:47,"I created a simple proxy server that tries to proxy the request to a non existent server. I've written this to return an error message when the final host is unreachable. 
After I make the request, when the `proxyError` is caught, I keep getting two times the same error:

<S_CODE_TOKEN>

I'm expecting the error to be thrown only once. This is the code I'm using:

<S_CODE_TOKEN>

Assuming that nothing is running on `127.0.0.1:10000`, trying to execute:

<S_CODE_TOKEN>

prints two times the same error message to the console.

I'm running:
- node v0.8.17
- node-http-proxy v0.8.7
",thefosk,2013-03-09 05:13:49
364,2013-01-10 10:10:26,"This is caused by handling an error on both socket and request.
",mmalecki,2013-03-09 05:13:49
364,2013-01-10 23:32:53,"Is this my fault or the lib's fault?
",thefosk,2013-03-09 05:13:49
364,2013-01-10 23:42:40,"Our fault. I'll get to fixing it soon.
",mmalecki,2013-03-09 05:13:49
364,2013-01-21 17:01:31,"+1.
",abarre,2013-03-09 05:13:49
364,2013-02-06 08:44:25,"+1
",angn,2013-03-09 05:13:49
364,2013-02-10 16:07:48,"The offending code is in http-proxy.py:314-317 (and something similar for proxyWebSocketRequest on lines 732-735).

<S_CODE_TOKEN>

Is it possible that one is fired and the other no?
",erasmospunk,2013-03-09 05:13:49
364,2013-02-10 22:34:29,"After some research this part is causing the problem:

<S_CODE_TOKEN>

This is not needed as node.js' `ClientRequest` object (here the `reverseProxy`) attaches a listener to the socket 'error'

<S_CODE_TOKEN>

The `socketErrorListener` just re-emits the error from the `ClientRequest` object.

Look in https://github.com/joyent/node/blob/master/lib/http.js for the `socketErrorListener` references.
",erasmospunk,2013-03-09 05:13:49
364,2013-03-09 05:13:47,"Fixed in #374 
",indexzero,2013-03-09 05:13:49
363,2013-01-10 02:00:25,"I've been using node-http-proxy on Windows 7 64, Mac OS X 10.7, and Ubuntu 12.10. On Ubuntu I'm getting the following exception which I can't reproduce in other OSes:

mirocha@ubuntu:~/eclipse_workspace/pollapplication$ sudo node nodeProxy.js

node.js:201
        throw e; // process.nextTick error, or 'error' event on first tick
              ^
Error: socket hang up
    at createHangUpError (http.js:1092:15)
    at Socket.<anonymous> (http.js:1175:27)
    at Socket.emit (events.js:88:20)
    at Array.1 (net.js:300:10)
    at EventEmitter._tickCallback (node.js:192:40)
mirocha@ubuntu:~/eclipse_workspace/pollapplication$ sudo node nodeProxy.js
^Cmirocha@ubuntu:~/eclipse_workspace/pollapplication$ sudo node nodeProxy.js
[sudo] password for mirocha: 

node.js:201
        throw e; // process.nextTick error, or 'error' event on first tick
              ^
Error: socket hang up
    at createHangUpError (http.js:1092:15)
    at Socket.<anonymous> (http.js:1175:27)
    at Socket.emit (events.js:88:20)
    at Array.1 (net.js:300:10)
    at EventEmitter._tickCallback (node.js:192:40)

This error happens everytime I'm try to reach a resource that returns a 400 error code.

This is the script I'm using:

<S_CODE_TOKEN>
",maiko-rocha,2013-03-09 06:32:29
363,2013-03-09 06:32:29,"Your backend isn't listening, so that `Error: socket hang up` means your backend hung up.
",indexzero,2013-03-09 06:32:29
362,2013-01-09 00:19:49,"I am trying to proxy content and the target server is running NTLM auth. The NTLM spec requires a certain handshake where the first 401 is sent, and the client responds.

http://www.innovation.ch/personal/ronald/ntlm.html

<S_CODE_TOKEN>

I've run wireshark and fiddler and I can see that the connection is NOT being re-used even though the req and res object include the required connection = 'keep-alive'.

I've attached screenshots of wireshark showing different ports being used during the multiple stages of NTLM authentication. Doing some research I got conflicting stories on if keep-alive actually does work, and if it does / does not work in node-http-proxy.

so far, running through squid-proxy, fiddler, and other proxies wireshark reports the correct re-using of the connection. The only one that does not show this is node-http-proxy (and it's also the only one that isn't able to auth the user correctly).

In addition it seems like the headers for www-authenticate are being mangled when there are multiple ones so I had to put in a patch... Without this Firefox, Chrome, IE were not prompting for NTLM authentication because there was only ONE www-authenticate header being returned rather than two separate ones.

<S_CODE_TOKEN>
### Bad (through node-http-proxy)

![Capture2](https://f.cloud.github.com/assets/379950/52193/f173d856-59f1-11e2-86d3-306ab1a7664c.PNG)

As shown above you can see for each request we grab a new socket (which destroys NTLM auth and proves that it is not doing keep-alive).
### Good (through fiddler, squid, etc)

![Capture](https://f.cloud.github.com/assets/379950/52197/29f9baf6-59f2-11e2-80b0-5a0c53e51fe1.PNG)

The above capture shows that with a proxy running (fiddler, squid, etc) we get the re-use one would expect.
",terrancesnyder,2015-10-30 21:02:15
362,2013-02-15 09:28:53,"Is there any chance that node-http-proxy will support more than one request on a single connection in the future?
We would love to be customers at nodejitsu, but currently users of our client app that talks to our jitsu app can't get proper performance when making 10+ requests after oneanother. The handshake needed for https at each connection is adding up to the total request time. 
Now that's the practical thing about it, the other thing is that on the nodejitsu frontpage it says  If it works in localhost, it works for us!"". That statement isn't quite true when persistent connections aren't allowed through node-http-proxy.

I don't know if it is wrong to bring up nodejitsu related stuff here, but after speaking with nuno on IRC, he told me to continue my questions here :)

Thanks.
",porsager,2015-10-30 21:02:15
362,2013-02-15 12:40:45,"Is your issue really with the keepalive or is it the https handshake performance?

I thought you were doing some advanced https1.1 stuff, but if its related to the handshake we actually would need to take different steps.

Anyway thanks for bumping up this, also do you remember the pull request that was related to this?
",dscape,2015-10-30 21:02:15
362,2013-02-17 14:22:01,"Our issue is with keepalive. 

About handshake performance i don't think it is relavent since the problem is worst if latency is High which it often is on Mobile connections (and our api is used mainly by iphone users). Then improving the handshake wouldn't do anything about the trips back and forth. 

It would be solved if note-http-proxy did persistent connections between proxy and client. I don't think there's an urgent need to implement it between server and proxy, since there's almost no latency and no handshake? Correct?

I'll see if I can find the pull request, when I'm back on my comp, but I think it was a smaller fix, and not an implementation for a solution. 
",porsager,2015-10-30 21:02:15
362,2013-02-17 15:30:48,"Sounds awesome. Thanks for clarifying.

My point was that ssh performance in node is a far more understood topic. @indutny has a repo called tls-snappy that tackles it, but to the best of my knowledge nothing beats putting a tls terminal in front of node yet :(

I think you saw some discussion from @mranney and @mikeal on the topic on a request issue. Not entirely sure how voxer is currently dealing with this though.
",dscape,2015-10-30 21:02:15
362,2013-02-17 20:00:17,"Yeah, i've been reading through it, and found that Voxer made this module/agent that they're using:
https://github.com/ceejbot/keep-alive-agent

Unfortunately i don't have more time to look into this, cause we have to be ready for production within 2 weeks - so for now we will need to host our app by ourselves :( 
That is - until (hopefully) nodejitsu get's support for it ;)
",porsager,2015-10-30 21:02:15
362,2013-03-21 13:32:17,"I'm seeing the same problem - without @terrancesnyder's patch (which I put in at https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L262 ) there was no prompt for username and password, but I still see a new source port number for each part of the negotiation, which means NTLM doesn't work.
",GraemeF,2015-10-30 21:02:15
362,2013-03-22 09:23:59,"Another update after messing about some more yesterday - I substituted the default Node http agent with https://github.com/ceejbot/keep-alive-agent and that seemed to make the negotiation happen on the same connection, and it now gets as far as prompting for username and password (in Chrome). Unfortunately, it doesn't get any further than that because submitting the credentials results in another 401 and another prompt.

I don't know what other effect dropping keep-alive-agent in there might be having, either... :confused: 
",GraemeF,2015-10-30 21:02:15
362,2013-05-23 14:39:31,"@GraemeF, did you actually get any further with this? I'm trying to run NTLM authentication over an HTTPS-to-HTTP reverse proxy and see similar results. I have included the abovementioned patch but would probably need a hint on how to include the keep-alive-agent you mention. Are there any other choices to proxy NTLM authenticated calls? (have tried SQUID which didn't help, contrasting to what @terrancesnyder reports above) I just need to get _one_ single call through that doesn't even have any content, it just authenticates a user and returns a token/cookie, and subsequent requests are normal http requests that use this token/cookie for authentication...
",HelgeL,2015-10-30 21:02:15
362,2013-05-23 14:43:44,"No I didn't, sorry.
",GraemeF,2015-10-30 21:02:15
362,2013-05-23 15:11:07,"Thanks anyway!
",HelgeL,2015-10-30 21:02:15
362,2014-08-20 01:44:26,"We're running node-http-proxy in front of our Web and API servers, and we critically need keep-alive. Any plan to support it in the near future? The old http-proxy@0.1.x used to support keep-alive. Since upgrade all connections with the client get instantly closed.
",kadishmal,2015-10-30 21:02:15
362,2014-10-06 22:05:31,"Any updates on this? I've been testing node-http-proxy as a transparent proxy by simply running 

<S_CODE_TOKEN>

But most of the content do not pass as connection is closed:

With proxy enabled:
![captura de pantalla 2014-10-06 a la s 17 03 00](https://cloud.githubusercontent.com/assets/6343659/4534358/b714a14c-4da4-11e4-9f1b-8c40fee58712.png)

With proxy disabled:
![captura de pantalla 2014-10-06 a la s 15 59 23](https://cloud.githubusercontent.com/assets/6343659/4534371/d104294c-4da4-11e4-8ebb-84bdbd72cdb7.png)
",ezabaw,2015-10-30 21:02:15
362,2014-10-31 21:36:12,"Is there any sort of update as to how to fix or at least by pass this issue? I'm trying to proxy an ntlm authenticated server and running into the same issues.
",mburbea,2015-10-30 21:02:15
362,2015-06-11 15:19:41,"+1
",robertlevy,2015-10-30 21:02:15
362,2015-10-30 21:02:15,"This is something that is supported. Will move the example from #727 into the examples folder.
",jcrugzz,2015-10-30 21:02:15
361,2013-01-05 14:59:01,"This part of the code needs to be changed: https://github.com/nodejitsu/node-http-proxy/blob/v0.8.7/lib/node-http-proxy/http-proxy.js#L250-L257

to

<S_CODE_TOKEN>

The changes are:
1. Status code 303, 307 and 308 are recognized and correctly rewritten.
2. When some stupid server does not include the Location header with the status, the server will still stay alive (opposed to crashing with message ""Cannot call method 'replace' of undefined"")

(and a minor change: Removed the backslash before the colon in the RegExp)
",Rob--W,2015-10-30 20:59:13
361,2013-01-09 20:51:29,"this patch, works for me, thanks!
",genbit,2015-10-30 20:59:13
361,2013-09-15 01:44:27,"Why would it not be accepted by upsteam??
",Rush,2015-10-30 20:59:13
361,2013-09-15 08:37:34,"The existence-check of the `location` header has already been added some time ago: https://github.com/nodejitsu/node-http-proxy/blob/ebbba73eda49563ade09f38bdc8aef13d1cf6c00/lib/node-http-proxy/http-proxy.js#L272-L273

Though 307 and 308 redirects are still not supported. Are you referring to that?
",Rob--W,2015-10-30 20:59:13
361,2015-10-30 20:59:13,"This is related to an older version of http-proxy. Closing.
",jcrugzz,2015-10-30 20:59:13
360,2013-01-04 16:16:56,"I'm writing a nodejs web server which is published to cloudfoundry.

and a 3rd service will visit my web server.

now I want to debug at local but don't have a standalone ip.

so I wonder could I do this:
1. set up a proxy web server at cloudfoundry, call A
2. start a web server at local, call B
3. start a net connection to A, then pipe them.
4. when 3rd service visit A, the request will send to B , and response.
5. then I can develop & debug at local machine , don't need to vmc push after every save.

can I do this by writing some nodejs code? how? thx.
",atian25,2013-03-09 08:19:42
360,2013-03-09 08:19:42,"That logic is sound.
",indexzero,2013-03-09 08:19:42
359,2013-01-03 07:57:46,"In some cases, the target site may redirect the request to external url
which is not our proxying target. It is better not to modify the
protocol in this case.
",bunnyyiu,2013-03-09 07:35:55
359,2013-01-07 05:06:32,"+1
",colinmollenhour,2013-03-09 07:35:55
358,2013-01-02 20:39:35,"routing-proxy.js sends a 404 (line 197) when request hostname does not match the table.
It would be useful to have an event ('proxyError' for example) to let the app manage a fallback (default hostname for example).
",openhoat,2013-01-03 09:59:42
358,2013-01-03 10:02:33,"A solution is to add a function callback and manage error there :

<S_CODE_TOKEN>
",openhoat,2013-01-03 09:59:42
357,2012-12-30 21:36:49,"the following code http://pastie.org/private/esae5stq8jxw1lioo8vclq
works if you gave 2 browsers on 127.0.0.1:8000/notify 
and execute 

<S_CODE_TOKEN>

in the console of one, then refresh the other

but on 127.0.0.1/notify the proxying blocks server sent events
",caub,2015-10-30 20:58:51
357,2012-12-30 21:53:37,"more simply  
just one browser to 127.0.0.1:8000/notify

<S_CODE_TOKEN>

source.readyState prints 0 (connecting), as expected

then 127.0.0.1/notify
source.readyState prints 2 (closed)
",caub,2015-10-30 20:58:51
357,2013-10-08 18:38:19,"Were you ever able to find a solution to this?
",go1dfish,2015-10-30 20:58:51
357,2013-10-08 20:19:18,"no, but anyway websocket does the job
",caub,2015-10-30 20:58:51
357,2015-02-02 18:06:06,"This is an issue for us too!!!!!
",afterthought,2015-10-30 20:58:51
357,2015-10-30 20:58:51,"If this is still a problem for people, open a new issue. This seems like a candidate for a separate module
",jcrugzz,2015-10-30 20:58:51
356,2012-12-29 06:24:11,"I am implementing a caching layer on top of http-proxy and without these changes see no good way to intercept the upstream response so that it can be stored in a cache or replace a 304 response with a 200 response or manipulate headers in a few places. None of these changes will break backwards compatibility.

Note, the caching proxy layer is fully implemented but is still in beta: colinmollenhour/node-caching-proxy
",colinmollenhour,2013-03-09 06:48:53
356,2012-12-30 18:23:24,"This seems reasonable.
",indexzero,2013-03-09 06:48:53
356,2013-01-06 09:06:23,"Just added another commit. This is the last change I need to be able to add the caching layer. With this change I can replace a 304 response with a 200 response and I can filter headers which are not meant for the client.
",colinmollenhour,2013-03-09 06:48:53
356,2013-01-08 13:27:30,"@colinmollenhour Can you add tests for this? 
",indexzero,2013-03-09 06:48:53
356,2013-01-08 21:35:54,"None of the tests use the arguments from the request 'end' event so no changes needed. Do you want a test that confirms that the new argument exists?

The second block of code has no effect unless there is an event observer for the proxyResponse event and that observer throws an exception. So I'm not sure how to add a test specifically for this since the outcome on an observer that does nothing is the same as no observer and the tests should not predict what the observer will do or not do. Basically if there is an observer it is up to the author of that observer to test the outcome, right?
",colinmollenhour,2013-03-09 06:48:53
356,2013-03-09 06:48:53,"Cherry-picked. Thanks.
",indexzero,2013-03-09 06:48:53
356,2013-03-11 14:42:03,"Thanks, Charlie!
",colinmollenhour,2013-03-09 06:48:53
356,2013-07-09 08:18:42,"Hi @colinmollenhour, @indexzero 

I'm trying to leverage proxyResponse event to modify response headers that get setted up by the proxied server. 
This means that the server behind the proxy put some data in an ""x-cust-field"" on the `res` object so and Proxy can read and process it on proxyResponse. Now I dont want this info to be sent to the client, options are: 
removing the field or just edit it removing sensible data.

<S_CODE_TOKEN>

I'm not sure if I should act on `res`  or `response` (the latter has no setHeader methods), this seems possible so what am I missing?
Thanks
",Giuliano84,2013-03-09 06:48:53
356,2013-07-09 13:44:25,"`res` is the response to the client, `response` is the response from upstream. however, it has been a while since I looked at this code so I don't know offhand if it is sufficient to use `res.setHeader`. You might need to remove the header from `response` instead..
",colinmollenhour,2013-03-09 06:48:53
355,2012-12-28 08:33:46,"Hi, if I do the following, then `www.foobar.com` doesn't work:

<S_CODE_TOKEN>

To make `www.foobar.com` work I have to add it manually:

<S_CODE_TOKEN>

I would also have to add any other subdomains manually. How can I avoid doing that so that for example all requests to `barfoo.com` go to apache regardless of the subdomain? If those were regex, then `foobar.com` would match `anything.foobar.com` but that's not the case.
",trusktr,2013-03-09 07:30:08
355,2012-12-28 08:47:05,"Wait, nevermind, I forgot to remove the `hostnameOnly: true` option. Doh.
",trusktr,2013-03-09 07:30:08
355,2012-12-28 09:19:43,"Wait, nevermind. I'm still having some trouble. So If I have

<S_CODE_TOKEN>

and I try to visit `www.barfoo.com`, it works. If I try to visit `one.two.three.foobar.com`, it still doesn't work unless I do something like the following.

<S_CODE_TOKEN>

Can we prevent having to add the extra line for `one.two.three.foobar.com`?
",trusktr,2013-03-09 07:30:08
355,2013-01-26 22:16:41,"I also had this issue. I think the general solution would be to allow a callback function for when there is no match in the router table. We are using such a solution in production. Pull request:

https://github.com/nodejitsu/node-http-proxy/pull/333
",breck7,2013-03-09 07:30:08
355,2013-01-31 08:47:26,"@breck7 That's a good idea. I think changing the router functionality so that regex can be used would be very nice. Or maybe something like Google Chrome's settings where you can add domain exceptions to various settings like [*.]foobar.com which matches anything.foobar.com or whatever.foobar.com.
",trusktr,2013-03-09 07:30:08
354,2012-12-25 07:54:52,"I'm able to use the proxy just fine if previous middleware calls next() syncronously. But if I put it in a db callback, or just a simple setTimeout(), it stalls and never responds. I've confirmed that it's entering the middleware function made with httpProxy.createServer, but the proxy.proxyRequest doesn't ever come back. Any ideas?
",ghost,2015-10-30 20:56:26
354,2015-10-30 20:56:26,"Closing due to old age and relation to old version of `http-proxy`
",jcrugzz,2015-10-30 20:56:26
353,2012-12-24 14:32:40,"Hello,

I set up the following code with node-http-proxy to proxy the requests to a [pow](http://pow.cx/)'s domain `http://foo.dev`:

<S_CODE_TOKEN>

But it redirects to pow's local home page `http://localhost`, instead of `http://foo.dev`. It looks like the domain name has been resolved to `127.0.0.1` before passing along. 

Thanks,
Owen 
",jingweno,2013-03-09 07:15:27
353,2012-12-24 15:25:48,"To give you more context, I have a couple apps setup locally with pow and am on my way to build an API proxy. Say there are app1.foo.dev, app2.foo.dev and apis.foo.dev. I would want apis.foo.dev/app1 to route requests to app1 and so on for app2. Is it a good use case for node-http-proxy?

In production, I can totally see this approach works since node-http-proxy will bind to app's IP and each app will have its own IP on an individual machine. But in development with pow, I met the problem as I mentioned.
",jingweno,2013-03-09 07:15:27
353,2012-12-25 03:19:56,"I have no idea how pow works so I have no idea why this wouldn't work. @sstephenson do you have any thoughts on why this wouldn't work? We transparently proxy headers, etc.
",indexzero,2013-03-09 07:15:27
353,2012-12-26 16:29:55,"@indexzero I followed [this example](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/url-middleware.js#L40-L43) and it seemed to work after using [proxy-by-url](https://github.com/dominictarr/proxy-by-url). I am trying to understand how proxy-by-url does it differently. Is [setting the headers](https://github.com/dominictarr/proxy-by-url/blob/master/index.js#L49-L53) making it work?
",jingweno,2013-03-09 07:15:27
353,2013-03-09 07:15:27,"I think this would work instead because `localhost` is resolved to `127.0.0.1`:

<S_CODE_TOKEN>
",indexzero,2013-03-09 07:15:27
353,2013-03-09 14:13:14,"@indexzero I tried `0.9.1` with the following:

<S_CODE_TOKEN>

curl with the following:

`curl http://127.0.0.1:8001/path` still routes to the home page of pow instead of foo.dev. As I mentioned earlier, I think the problem is due to the url and the host name are not set. With `porxy-by-url`, stuff works (https://github.com/dominictarr/proxy-by-url/blob/master/index.js#L49-L51). 

Is this expected behaviour? Otherwise how can I help?

Cheers,
Owen 
",jingweno,2013-03-09 07:15:27
353,2014-08-08 09:47:44,"Did anyone figure this out. I just ran into the same problem trying to set up a proxy in an ember-cli application.
",mattbeedle,2013-03-09 07:15:27
353,2014-08-12 17:30:47,"@mattbeedle this issue is not relevant to the current issue of http-proxy. Please checkover the readme as the api has change significantly.
",jcrugzz,2013-03-09 07:15:27
353,2014-08-13 11:15:16,"@jcrugzz The api has changed, but I am still not able to proxy to a pow domain. I haven't looked into exactly what is causing the issue, but this seemed like a relevant place to post.
",mattbeedle,2013-03-09 07:15:27
353,2014-08-13 11:16:22,"I also posted on stackoverflow, but haven't had a chance to look into whether or not it is cors yet. http://stackoverflow.com/questions/25205086/ember-cli-proxy-to-a-pow-server
",mattbeedle,2013-03-09 07:15:27
352,2012-12-18 02:54:50,"The following gist produces a `socket.io/socket.io.js 404 (Not Found)` error on the browser's side:
https://gist.github.com/4324446

This gist does not reproduce that error: 
https://gist.github.com/4324576
",mrryanjohnston,2015-10-30 20:55:20
352,2012-12-19 01:45:10,"This has nothing to do with `node-http-proxy`. The `/test/` prefix in your html file is wrong: https://gist.github.com/4324446#file-gistfile1-html-L1
",indexzero,2015-10-30 20:55:20
352,2012-12-19 15:41:48,"Actually, that's what is currently written in the index.html file. I thought I'd revised that gist to the current implementation, but I guess not. This bug was confirmed in the #nodejitsu channel a few nights ago.
",mrryanjohnston,2015-10-30 20:55:20
352,2012-12-19 17:12:14,"Try it without the router. Just do a straight proxy.
",indexzero,2015-10-30 20:55:20
352,2012-12-20 03:33:34,"@mrryanjohnston What version of node-http-proxy are you using? I think I may have saw something from an old version and gotten confused. Or maybe I was really too tired that night, I was sure I saw a `""/"" +` somewhere. That wouldn't be the first mistake I realized I made that night. :laughing: 

In any case, if you want to come into #nodejitsu again we can try to debug it some more.
",coderarity,2015-10-30 20:55:20
352,2012-12-20 03:48:04,"@mrryanjohnston I think I know the problem. Try using 'dev.example.com/test/' in the proxy table.

@indexzero The test prefix makes sense. He's requesting the 'dev.example.com/test' thing, so if he doesn't use the '/test/' prefix, it won't route to that express server, thereby not finding that path. The fact that he got that express error shows that it's connecting to the express server, like he wants. It's just due to the way I wrote the URL replacement code. I think we can fix this by adding a '/' at the end of the origin URL if the user didn't add it, or removing the first '/' in the request URL, and adding it back in if it's not there at the end of that transformation process. I think the latter is a better idea.
",coderarity,2015-10-30 20:55:20
352,2012-12-23 05:17:36,"@mrryanjohnston Can you please try it without the `router` option when calling `httpProxy.createServer()`? 
",indexzero,2015-10-30 20:55:20
352,2012-12-27 18:29:35,"Sorry about the delay on this one, guys. Holidays and whatnot :)

@coderarity package.json says `""version"": ""0.8.5""`. I did try using dev.example.com/test in the routing table, but to no avail. I'll pop back in irc when I'm back from holiday related festivities. Thank you for your patience, once again.

@indexzero If I change the line to the following, the socket.io script is placed at localhost:8080/socket.io/socket.io.js as expected: `var proxyServer = httpProxy.createServer(9000, 'localhost').listen(8080);`
",mrryanjohnston,2015-10-30 20:55:20
352,2012-12-27 19:47:05,"@mrryanjohnston I suspect this is related to the ProxyTable somewhere. I'll leave this open to investigate, but I won't lie the `ProxyTable` is not high on my list of priorities.
",indexzero,2015-10-30 20:55:20
352,2012-12-28 05:45:46,"@mrryanjohnston Heh, that's not the URL I suggested, yo. You've got to use ""dev.example.com/test/"" (note the ending /). :D
",coderarity,2015-10-30 20:55:20
352,2013-01-04 00:46:36,"@coderarity So this does two things:
1. You can no longer go to dev.example.com/test in a browser window; only dev.example.com/test/ will work.
2. This produces an error that seems to be on part of socket.io: `GET http://dev.example.com/socket.io/1/?t=1357260316641 404 (Not Found)`. This occurs in socket.io.js on line 1659. Correct me if I'm wrong, but this seems to be an error on part of socket.io.
",mrryanjohnston,2015-10-30 20:55:20
352,2013-01-04 04:14:38,"How are you connecting to socket.io? I think that might be where the
problem is from here.

About #1, that's part of fixing the proxy table issues.

On Thursday, January 3, 2013, Ryan Johnston wrote:

> @coderarity https://github.com/coderarity So this does two things:
> 1. You can no longer go to dev.example.com/test in a browser window; only
> dev.example.com/test/ will work.
> 2. This produces an error that seems to be on part of socket.io: GET
> http://dev.example.com/socket.io/1/?t=1357260316641 404 (Not Found). This
> occurs in socket.io.js on line 1659. Correct me if I'm wrong, but this
> seems to be an error on part of socket.io.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/352#issuecomment-11867985.

## 

Christian Howe (coderarity)
",coderarity,2015-10-30 20:55:20
352,2013-01-29 00:20:10,"@coderarity Sorry for the delay on this. Haven't had a chance for fun side-projects for a while :)

I'm currently connecting with an absolute link: `var socket = io.connect('http://dev.example.com/test/');`

I understand it's not a super high-priority thing for this project. All the same, thanks for all of your help on this. 
",mrryanjohnston,2015-10-30 20:55:20
352,2013-09-15 23:49:38,"Hi, i had the same issue and solved it:

<S_CODE_TOKEN>
",marcilioleite,2015-10-30 20:55:20
352,2015-10-30 20:55:20,"Closing due to old age and related to old version of `http-proxy`
",jcrugzz,2015-10-30 20:55:20
351,2012-12-12 03:19:55,"Added Run Button to readme file so developers can play with node-http-proxy in a browser
",ykumar6,2012-12-12 15:39:12
351,2012-12-12 15:39:12,"This is not enough information about your service, it's stability, or how links urls are tied to actual Github repositories for this to make sense to add.

e.g.

<S_CODE_TOKEN>

How does that tie to this repo? Or did you just add that manually? If it is the latter then I strongly suggest you just map it to files in github repos at certain SHAs.
",indexzero,2012-12-12 15:39:12
351,2012-12-12 16:03:28,"Hi indexzero, your concerns make sense. Maybe I can give you the pitch? Would love to skype.
",ykumar6,2012-12-12 15:39:12
350,2012-12-11 14:48:15,"At the moment when using the `router` option when using httpProxy.createServer(), each of the entries in that object is required to have a hostname in order to be mapped correctly. It would be awesome if you could map solely based on the path.

If you were to deploy the same code on multiple machines which have slightly different host names, there's not really a way to do this ""cleanly"" since it's not possible to map based on path alone. Is there any reason this is not allowed at the moment?

I'll see if I can patch it and perhaps send a pull request. In the meantime it would be great to know if there's a specific reason this is currently now allowed.

Thanks
",chielkunkels,2013-09-15 09:04:07
350,2013-03-09 09:23:53,"Fixed in #380
",indexzero,2013-09-15 09:04:07
350,2013-09-15 01:48:19,"If this is fixed why not close the issue?
",Rush,2013-09-15 09:04:07
350,2013-09-15 09:04:11,"Closed.
",mmalecki,2013-09-15 09:04:07
349,2012-12-10 00:25:25,"It's said its handled automatically, however from my experience this isn't the whole story, and to save someone else a headache this should be remedied in the docs.

Just some background I had a connect middleware for no-www, and options..

<S_CODE_TOKEN>

The websockets connections aren't made automatically because I was using middleware, so you need to add..

<S_CODE_TOKEN>

This should just be documented somewhere is all. It would have saved me the hour of ""hmm, why is this falling back to xhr-polling?"" time and source-reading lines to see the ""magic""

<S_CODE_TOKEN>

But, more than willing to give up that hour for the total amount of time you've saved me :+1: 
",itsjamie,2013-03-09 04:49:05
349,2013-02-21 17:00:17,":+1: i'm not using any middleware and still had to manually listen for `'upgrade'`
",aeosynth,2013-03-09 04:49:05
349,2013-02-22 04:11:14,"@jamie-stackhouse @aeosynth A documentation pull-request would be welcomed.
",indexzero,2013-03-09 04:49:05
348,2012-12-08 00:02:09,"Without this commit, Node versions 0.9.1 and earlier cause the process to
terminate with no recourse if upstream HTTP servers return malformed HTTP
responses.

Fixes issue #347
",jcheng5,2012-12-08 00:20:21
348,2012-12-08 00:20:21,"I'm sorry but I just tested on Node 0.9.3 and it seems that WITH my patch the crash returns. Somehow my patch negates the fix in Node.
",jcheng5,2012-12-08 00:20:21
347,2012-12-07 23:59:03,"We have a production app that uses node-http-proxy running in front of some (admittedly sketchy) webservers running R code. (http://www.r-project.org) We've been seeing our node process crash several times a day. It turns out to be a bug in node with a known workaround but node-http-proxy prevents us from using that workaround.

There was a bug in the R code that caused the Content-Length to be inaccurately reported upstream. The issue here though is that the content-length caused [Node issue 3776](https://github.com/joyent/node/issues/3776) to come into effect; when an http request is made and the node http parser encounters an error, that error is emitted on the socket/connection object. In the case of node-http-proxy's proxyRequest method, the caller can never catch that error, and therefore the node process exits. Obviously we would rather gracefully deal with the error than have the process exit.

Issue 3776 was fixed in Node 0.9.2 but since Node 0.8.15 is still the latest stable version, it would be great if this bug could be worked around in node-http-proxy as well. I'm about to submit a pull request that approximates the Node 0.9.2 fix.
",jcheng5,2012-12-21 01:30:48
347,2012-12-19 02:55:17,"Seems reasonable. Wondering what @isaacs thinks about this.
",indexzero,2012-12-21 01:30:48
347,2012-12-19 14:30:35,"@jcheng5 we've seen this in production a few days ago. I'm not really comfortable with admitting that the fix was:

<S_CODE_TOKEN>

I think that on 0.9.x this is related to `process.nextTick` refactor which makes next tick happen before I/O, but no idea on the cause in 0.8.x.

@isaacs opinions?
",mmalecki,2012-12-21 01:30:48
347,2012-12-20 23:46:56,"This appears to be fixed by joyent/node@827b2a9b0b2b938f458a7569bf6c73b6be25ddc7.
",mmalecki,2012-12-21 01:30:48
347,2012-12-21 01:30:48,"@mmalecki Great news, thanks! Looking forward to v0.8.17!
",jcheng5,2012-12-21 01:30:48
347,2012-12-21 01:44:50,"@jcheng5 I just pushed a [custom build branch](https://github.com/mmalecki/node/compare/joyent:v0.8.16...mmalecki:v0.8.16-http-parse-error), in case you wanted to use it.
",mmalecki,2012-12-21 01:30:48
347,2012-12-22 05:00:57,"Great, thank you @mmalecki, much appreciated!
",jcheng5,2012-12-21 01:30:48
346,2012-12-07 13:23:24,"The problem was with websocket only. The req.connection.socket was always null and x-forwarded-for was never sent.
",otaviojr,2013-03-09 05:20:58
346,2012-12-19 02:54:28,"lgtm
",indexzero,2013-03-09 05:20:58
346,2013-03-01 14:44:54,"+1 for me for this patch -- I'm running a fork in production until this can be merged.
",yourcelf,2013-03-09 05:20:58
346,2013-03-09 05:20:58,"Cherry-picked. Thanks.
",indexzero,2013-03-09 05:20:58
345,2012-12-06 04:16:07,"When using a routing table the x-forwarded-\* headers aren't send to the destination server. I synced with http-proxy's file and now it is working properly.

regards,
Ot√°vio Ribeiro
",otaviojr,2012-12-07 13:21:15
345,2012-12-07 13:16:31,"now i think that a get it. The problem was with websocket only. The req.connection.socket was always null and x-forwarded-for was never sent.

This last commit fix it in a better way than the oldest one.
",otaviojr,2012-12-07 13:21:15
344,2012-12-02 15:43:51,"When proxying to an app that is rather strict about it's HTTP headers, I was finding that the path was being set to the URL, causing 404 responses.

I've checked this does not break any of the vows, but I can't figure out how to test this in an acceptable way.

Any ideas?
",tomlea,2013-03-09 07:48:12
344,2012-12-19 02:53:11,"Why would this ever happen? Seems like a node.js core bug and not related to node-http-proxy
",indexzero,2013-03-09 07:48:12
344,2012-12-22 20:26:23,"@indexzero is correct. Do you have a reproducible example of such behavior?
",mmalecki,2013-03-09 07:48:12
344,2013-01-07 08:41:26,"good patch, very helpful to me.
",luolonghao,2013-03-09 07:48:12
344,2013-01-08 23:47:07,"@luolonghao can you reproduce this behavior? What source are those requests coming from?
",mmalecki,2013-03-09 07:48:12
344,2013-01-29 11:25:37,"Further investigation shows that I'm wrong, but not for the reasons thought.

The proxy works perfectly when used as a reverse proxy in front of an app. The problem only seems to come up when using it as a forwarding proxy (one that is set up as the HTTP proxy server for my machine).

This very minimal app, when used as a forwarding proxy, demonstrates the problem:

<S_CODE_TOKEN>

When requesting via a proxy, we get requests from browsers that look like this:

<S_CODE_TOKEN>

Compared to this where no proxy is configured, and a direct connection is made:

<S_CODE_TOKEN>

As you can see, the GET line has the full URI. Looking into this (http://www.ietf.org/rfc/rfc2616.txt 5.1.2), we find that the use of an absolute URI here is normal.

node-http-proxy then does a permissible thing by the spec, and passes it on to the destination HTTP server. Unfortunately, not all servers are conformant, and some fail when given an absolute URI rather than an absolute path (one such server serves the page at http://bits.wikimedia.org/en.wikipedia.org/load.php, although this is just one example of many).

From rfc2616:

> To allow for transition to absoluteURIs in all requests in future versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies.

Basically, all down stream servers _should_ accept it, but in practice, they _do not_.

Anyway, the patch will allow users to use node-http-proxy as a forwarding proxy in the real world.
",tomlea,2013-03-09 07:48:12
344,2013-03-09 07:48:12,"This is too much overhead to support incorrect backends.
",indexzero,2013-03-09 07:48:12
343,2012-11-28 23:04:46,"I think I've got SPDY working on the https proxy.

It uses node-spdy to do the actual spdy stuff, but when testing with the https-to-https example Chrome flags SPDY is working
",kennydude,2013-12-27 07:11:40
343,2012-11-29 11:16:55,"@kennydude So how should I test this is working? Is there a spdy client you're requesting with?
",indexzero,2013-12-27 07:11:40
343,2012-11-29 11:46:32,"Chrome Extension that detects SPDY by putting a lightning bolt in the
address bar. It's on the chrome webstore
On 29 Nov 2012 11:16, ""Charlie Robbins"" notifications@github.com wrote:

> @kennydude https://github.com/kennydude So how should I test this is
> working? Is there a spdy client you're requesting with?
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/pull/343#issuecomment-10843403.
",kennydude,2013-12-27 07:11:40
343,2012-11-29 11:47:27,"Right, but using Chrome in unit-tests isn't feasible. Is there a spdy client for node?
",indexzero,2013-12-27 07:11:40
343,2012-11-29 12:46:15,"Not yet, sadly I don't have much time and urge to work on it
",indutny,2013-12-27 07:11:40
343,2012-11-29 12:50:36,"@indutny It's hard to merge this without some kind of reproducible test.
",indexzero,2013-12-27 07:11:40
343,2012-11-29 12:52:24,"Yes, I know... I'll try to sketch something.
",indutny,2013-12-27 07:11:40
343,2012-11-29 13:00:34,"Awesome
On 29 Nov 2012 12:52, ""Fedor Indutny"" notifications@github.com wrote:

> Yes, I know... I'll try to sketch something.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/pull/343#issuecomment-10846005.
",kennydude,2013-12-27 07:11:40
343,2012-11-29 21:03:59,"Not NodeJS, but this may help as I can't find anything about a NodeJS client lib: https://github.com/mtourne/gurl
",kennydude,2013-12-27 07:11:40
343,2013-09-09 20:15:22,"Any update on this? Would be interesting to play with SPDY.
",Rush,2013-12-27 07:11:40
343,2013-09-09 20:28:26,"I've found a couple things that could help with testing,

https://github.com/mtourne/gurl - gURL written in GO

## http://spdylay.sourceforge.net/package_README.html#spdy-client-and-server-programs

spdycat written in C

There is also, https://github.com/nasss/spdy-client

Although this pull is probably outdated

On 9 September 2013 21:15, RushPL notifications@github.com wrote:

> Any update on this? Would be interesting to play with SPDY.
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/pull/343#issuecomment-24110809
> .
",kennydude,2013-12-27 07:11:40
343,2013-11-11 04:05:13,"Is SPDY not supported in the http-proxy? Is there any update on this? 
",SunilAgrawal,2013-12-27 07:11:40
343,2013-12-27 07:11:40,"Decided to close this because it is outside of scope. Anyone who wants to create a `spdy` server and use a proxy inside it is welcome to it. 
",indexzero,2013-12-27 07:11:40
343,2014-02-10 15:28:57,"[![Coverage Status](https://coveralls.io/builds/506358/badge)](https://coveralls.io/builds/506358)

Changes Unknown when pulling **42d3f84276387fa0c9cf82c415d56e96e73c90ab on kennydude:master** into *\* on nodejitsu:master**.
",coveralls,2013-12-27 07:11:40
343,2015-10-12 13:59:13,"@indexzero: SPDY/HTTP2 is becoming more widespread, is it still out of scope for this project? I'd greatly appreciate it if you'd reconsider.
",JakeHedman,2013-12-27 07:11:40
342,2012-11-28 13:39:37,"Wrong  repo
",speigg,2012-11-28 14:29:45
341,2012-11-27 03:48:50,"My understanding is that x-forwarded-port should be set to the server port that the request came in on: 80, 443, etc.

If that's the case, it's not happening. `req.connection.remotePort` is the requesting client's remote port. I didn't see an obvious way to get the server from the request, but it seems easy enough to determine it from the host header/protocol.

Assuming I'm understanding x-forwarded-port correctly, I've got a branch that fixes the issue here:

https://github.com/blahed/node-http-proxy/compare/x-forwarded-port
",blahed,2013-12-18 11:34:41
341,2013-01-02 07:22:18,"+1
I have used x-forwarded-port with nginx; the expected value of the header is the port of the original request before it was proxied.

Say my node server is running on 3000 and is proxied by node-http-proxy on 3001.
I would like to know when crafting URLs for the original client that the public port is 3001.
At the moment node-http-proxy would give me something like 62112.

I have tested @blahed's patch and it works for me.
",hmalphettes,2013-12-18 11:34:41
341,2013-12-14 16:37:58,"Hello!

I'm just coming across this now. I was wondering if there was a planned resolution, or something I missed?

Installing  node v0.10.23 and node-http-proxy 0.10.3 shows the same behavior for me.

Edit: The [caronte](https://github.com/nodejitsu/node-http-proxy/tree/caronte) branch exhibits this behavior as well.
",fideloper,2013-12-18 11:34:41
341,2013-12-18 11:34:41,"@fideloper fixed in 97e4600 :)
",yawnt,2013-12-18 11:34:41
341,2013-12-18 12:12:47,"Awesome, thanks!
",fideloper,2013-12-18 11:34:41
340,2012-11-26 19:04:04,"Hi,

i despair. I think, this isn't big problem, but i can't find the problem.
I think, the best is, when i just post my classes and describe the problem, i've got. I stripped down the functionality, so the most i do will seem useless, but believe me, without stripped down code, it is useful :)

Everything works, fine, instead of the one point, i describe after the classes

First, my main.js, which is my startpoint

<S_CODE_TOKEN>

proxy.js

<S_CODE_TOKEN>

proxyhandler.js

<S_CODE_TOKEN>

so, when i query the proxy the first time, the browser just hangs, till he throws a timeout. handle() is called at //Marker 1
when i query again, everything works fine, when handle() is called at //Marker 2

I debugged, what i was able to debug, stepped into http-proxy, to http and was not able to find the problem. hope the code is enough to replay my problem.

A, forgot.... when i call proxyRequest() in proxy.js, without delegating to proxyhandler.js, everything works fine, even at //Marker 1.
",xFragger,2012-11-28 11:30:13
340,2012-11-28 11:30:11,"okay, solved -.-
forgot to buffer the data/end events, like in the example ""latent-proxy""

sorry for that
",xFragger,2012-11-28 11:30:13
339,2012-11-26 03:30:25,"Added a new example with round robin balancing and websocket support

I did also change the underlying object used from RoutingProxy to HttpProxy by creating an object for each target address and then picking the next proxy for each request. 
",oost,2013-03-09 05:24:14
339,2012-11-29 11:40:34,"@oost Nice. Will try to get this merged in soon. Thanks for the example!
",indexzero,2013-03-09 05:24:14
339,2012-11-29 12:25:20,"Here is how to test the example: https://gist.github.com/4179532

With this setup, the websocket handler in the cloned server needs to have a persistent backend for handshake to work...
",oost,2013-03-09 05:24:14
339,2013-03-09 05:24:14,"Cherry-picked. Thanks.
",indexzero,2013-03-09 05:24:14
338,2012-11-22 13:43:05,"Bug details can be found here: http://development.blog.saw.sonyx.net/2012/11/http-delete-failing-with-411.html
",ian7,2013-03-09 07:44:51
338,2012-11-22 19:36:35,"Interesting. I'll accept it, but please fix coding style:

<S_CODE_TOKEN>

and make sure that indentation matches rest of the code. Thanks!
",mmalecki,2013-03-09 07:44:51
338,2012-11-28 18:36:06,"Done. let me know if this is ok.
- M.

On Thu, Nov 22, 2012 at 8:36 PM, Maciej Ma≈Çecki notifications@github.comwrote:

> Interesting. I'll accept it, but please fix coding style:
> 
> if (req.method === 'DELETE') {
>   req.headers['content-length'] = '0';
> }
> 
> and make sure that indentation matches rest of the code. Thanks!
> 
> ‚Äî
> Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/pull/338#issuecomment-10643388.
",ian7,2013-03-09 07:44:51
338,2012-11-29 11:18:07,"Reluctantly +1
",indexzero,2013-03-09 07:44:51
338,2013-02-13 22:53:30,"In my case, as an observation, nginx is stripping the header's 'content-length'. When I run locally 'content-length' exists on the `req` and when I run remotely heroku 'content-length' is stripped from the `req`. The easy fix for me was to just add it back to the `req` before passing to node-http-proxy.
",rc1,2013-03-09 07:44:51
338,2013-02-14 11:18:19,"Similar problem for CORS features. When the browser makes the [preflight](http://www.html5rocks.com/en/tutorials/cors/) requestI get a 411 error. As far as the preflight is automatically made from the browser there is no way to set content-length to 0 and CORS will never work with node http proxy.
",andreareginato,2013-03-09 07:44:51
338,2013-02-14 12:53:03,"Actually, now that I think about it, a `DELETE` request can have a body. We happen to use such requests ourselves in production.
We should check if a `Content-Length` is already defined, I think.
@indexzero @ian7 opinions?
",mmalecki,2013-03-09 07:44:51
338,2013-02-14 14:44:12,"That is true. I check is needed. I would add also OPTIONS (for CORS preflight) on the list of verbs to check.
",andreareginato,2013-03-09 07:44:51
337,2012-11-21 08:22:49,"/cc @mmalecki
",indutny,2012-11-29 11:51:42
337,2012-11-29 11:51:39,"Good catch @indutny 
",indexzero,2012-11-29 11:51:42
336,2012-11-17 15:46:08,"Hellow 
I have trouble in Safari 5.1.7, socket.io and websockets

i use next example:
on node.js

<S_CODE_TOKEN>

on client

<S_CODE_TOKEN>

and proxy on node.js

<S_CODE_TOKEN>

if i navigate in safari http://localhost/1/1.html i have this log on nodejs server (by  use proxy-server):

> info: socket.io started
> debug: client authorized
> info: handshake authorized SSNP3bazdCmgZNlgBKFK
> debug: client authorized
> info: handshake authorized dzPUsJTm-KjTp2bZBKFL
> debug: setting request GET /socket.io/1/websocket/dzPUsJTm-KjTp2bZBKFL
> debug: set heartbeat interval for client dzPUsJTm-KjTp2bZBKFL
> debug: client authorized for 
> debug: setting request GET /socket.io/1/xhr-polling/dzPUsJTm-KjTp2bZBKFL?t=1353166673061
> debug: setting poll timeout
> debug: discarding transport
> debug: cleared heartbeat interval for client dzPUsJTm-KjTp2bZBKFL
> debug: clearing poll timeout
> debug: xhr-polling writing 5:::{""name"":""news"",""args"":[{""hello"":""world""}]}
> debug: set close timeout for client dzPUsJTm-KjTp2bZBKFL
> debug: setting request GET /socket.io/1/xhr-polling/dzPUsJTm-KjTp2bZBKFL?t=1353166673998
> debug: setting poll timeout
> debug: discarding transport
> debug: cleared close timeout for client dzPUsJTm-KjTp2bZBKFL
> debug: clearing poll timeout
> debug: xhr-polling writing 5:::{""name"":""news"",""args"":[{""hello"":""world""}]}
> debug: set close timeout for client dzPUsJTm-KjTp2bZBKFL
> debug: setting request GET /socket.io/1/xhr-polling/dzPUsJTm-KjTp2bZBKFL?t=1353166675002 

if i navigate it w\o proxy i have:

> info: socket.io started
> debug: served static content /socket.io.js
> debug: client authorized
> info: handshake authorized 9HxcJEKYo1yV6flwBixA
> debug: setting request GET /socket.io/1/websocket/9HxcJEKYo1yV6flwBixA
> debug: set heartbeat interval for client 9HxcJEKYo1yV6flwBixA
> debug: client authorized for 
> debug: websocket writing 1::
> debug: websocket writing 5:::{""name"":""news"",""args"":[{""hello"":""world""}]}
> debug: websocket received data packet 5:::{""name"":""my other event"",""args"":[{""my"":""data""}]}
> { my: 'data' }
> debug: websocket writing 5:::{""name"":""news"",""args"":[{""hello"":""world""}]}
> debug: websocket received data packet 5:::{""name"":""my other event"",""args"":[{""my"":""data""}]}
> { my: 'data' } 

but if at start i open page w/o proxy (http://localhost:88/1/1.html) and in the next time i open page with proxy (http://localhost/1/1.html) then i have good log (with websockets)

Trouble: i can`t use http-proxy with safari for socketio and WS
",alnikitich,2015-10-30 20:54:49
336,2015-10-30 20:54:49,"Closing due to old age.
",jcrugzz,2015-10-30 20:54:49
335,2012-11-17 03:39:55,"Some of the examples in the readme show proxyRequest taking some options, when actually proxyRequest's last argument appears to be a buffer object. This code in particular doesn't seem to work:

<S_CODE_TOKEN>
",catphive,2013-03-09 06:37:36
335,2013-03-09 06:37:35,"This is the correct method signature for a `RoutingProxy`, which is what is passed to the handler when no options (e.g. host and port) are passed to `httpProxy.createServer()`.
",indexzero,2013-03-09 06:37:36
334,2012-11-14 13:17:01,"Hi,
about this one, I am not really sure if it is an node.js or node-http-proxy issue, but I bet you can help me anyways :)

One of our node-http-proxy servers runs on node 0.4.10 and an quite old node-http-proxy version (before node 0.6.*).
That server manages concurrently 1500+ http long polling requests and about 100 casual http requests per second. No problems, but CPU usage is kind of high.

We wanted to update to node 0.8.\* and the current node-http-proxy version to boost performance, but our tests failed.
The performance drops down to 100-400 concurrent  long polling requests and about 10 http requests per second. So the proxy does not seem to be able to handle more than 400 requests at one time (just rough numbers because the casual requests and the long polling requests fight each other in numbers ;))

We did set this

var httpProxy = require('http-proxy');
httpProxy.setMaxSockets(5000);

and the ulimit is set to 65535.

Any hint why the performance decreased so drastically?

Thanks, Kim
",KimSchneider,2015-10-30 20:54:34
334,2012-11-14 22:52:14,"Hey Kim,

this is very interesting. Our proxies currently run node v0.8.14 and node-http-proxy v0.8.4 and we're seeing no performance problems. We confirmed that upgrade from node v0.6 increased proxy performance.

What's the exact node-http-proxy and node version you were using? Can you try profiling it? What operating system is that? Did you do any changes to backend service during the upgrade (as in, did you upgrade node on backend too)?

I'd be very happy to help with fixing it.
",mmalecki,2015-10-30 20:54:34
334,2012-11-15 08:43:52,"Hey Maciej,

thanks for your reply!

We are having this issue since the  0.6.\* release of node and the matching node-http-proxy release. I can not profile this error right now, because I don‚Äôt have a test environment that is big enough. I have to test this on the live system, so I would have to schedule a maintenance for this.

The servers behind the old proxy are exactly the same as behind the new proxy. We have a firewall that forwards all request to the proxy, we just changed the firewall to forward to the new proxy. So the only component that was updated in that test was the proxy.
The backend servers are all running on node 0.8.\* since a couple of weeks without any problems.
All servers are running Ubuntu 12.04.1 LTS (GNU/Linux 3.2.0-32-generic x86_64)
The proxy is running node v0.8.14 and node-http-proxy 0.8.4

By the way, all incoming requests to the proxy are SSL!

Thanks for your help!

Mit freundlichen Gr√º√üen

Herr Kim Schneider
Fachinformatiker
Fachrichtung Anwendungsentwicklung

Kr√§mer IT Solutions GmbH
Tel.: 0 68 81 / 9 36 29 - 76
Fax: 0 68 81 / 9 36 29 - 99

From: Maciej Ma≈Çecki [mailto:notifications@github.com]
Sent: Mittwoch, 14. November 2012 23:52
To: nodejitsu/node-http-proxy
Cc: Kim Schneider - Kr√§mer IT Solutions
Subject: Re: [node-http-proxy] Performance issues (#334)

Hey Kim,

this is very interesting. Our proxies currently run node v0.8.14 and node-http-proxy v0.8.4 and we're seeing no performance problems. We confirmed that upgrade from node v0.6 increased proxy performance.

What's the exact node-http-proxy and node version you were using? Can you try profiling it? What operating system is that? Did you do any changes to backend service during the upgrade (as in, did you upgrade node on backend too)?

I'd be very happy to help with fixing it.

‚Äî
Reply to this email directly or view it on GitHubhttps://github.com/nodejitsu/node-http-proxy/issues/334#issuecomment-10389586.
",KimSchneider,2015-10-30 20:54:34
334,2013-01-21 16:30:18,"hi @KimSchneider, 

Finally, did you fix the performance problem when the requests are in SSL with node 0.8?

What was the cause of the problem?
",abarre,2015-10-30 20:54:34
334,2013-01-22 08:22:59,"No, we didn't. We will move to nginx and replace the node-http-proxy.

Our backend servers that are running the current node version without SSL have no problems. So this is related to nodes' SSL or node-http-proxy. But nginx seems to be the better solution anyway.
",KimSchneider,2015-10-30 20:54:34
334,2013-01-22 22:03:20,"Meh. If you're into that sort of masochism go for it. This is an issue related to SSL performance in node that @indutny is working hard on.

In the meantime you can just put [stud](https://github.com/bumptech/stud) in front of node-http-proxy. But I'm pretty sure @KimSchneider is not interested in our advice as he has not provided any demostrable data for us to help debug the problem with besides node versions. 
",indexzero,2015-10-30 20:54:34
334,2013-01-23 08:05:53,"I can not give you any sample data, because I got none. The only data I've got is real time data that our customers produce and I am not allowed to post that.

Just try to open about 2000 long polling connections and try to blast 100 request/second through the proxy. Post data can be any JSON of about 200 chars, results are always { success : true }.

I'll take a look at stud, thanks.
",KimSchneider,2015-10-30 20:54:34
334,2013-01-23 08:38:58,"@indexzero, do you have the reference to the issue related to the SSL performance in node?
",abarre,2015-10-30 20:54:34
334,2013-09-11 23:13:28,"My setup: `node_modules/http-proxy/bin/node-http-proxy --config config-original.json --port 8081`

<S_CODE_TOKEN>

Benchmark command: `ab2 -c 100 -n 10000 http://test.pl:8081/de629fb8-ff7f-4920-ab29-6a0f2f4176bf`
Command comes from package `apache2-utils`

All node versions installed via nvn, for example: `nvm install 0.6`

Summary (3 runs each):
- Node 0.6.21  - Requests per second:    `737.89 [#/sec] (mean)  775.86 [#/sec] (mean) 799.24 [#/sec] (mean)`
- Node 0.8.23  - Requests per second:    `623.13 [#/sec] (mean)  583.87 [#/sec] (mean) 780.87 [#/sec] (mean)`
- Node 0.10.18 -  Requests per second:  `535.42 [#/sec] (mean)  633.88 [#/sec] (mean) 455.18 [#/sec] (mean)`
- Node 0.11.7 -   Requests per second:    `683.65 [#/sec] (mean)  611.34 [#/sec] (mean) 434.85 [#/sec] (mean)`
- No proxy       -  Requests per second:   `1269.88 [#/sec] (mean) 1397.67 [#/sec] (mean) 1148.50 [#/sec] (mean)`

In general what I observe: Node 0.6 seems to be consistently faster  Very rarely 0.8 seems to handle over 700 req/s. Node 0.10 on the other is quite consistent to never achieve > 700. I think something about 0.6 is better for node-http-proxy. Any idea how to speed things up?
",Rush,2015-10-30 20:54:34
334,2015-10-30 20:54:34,"Closing due to old age. 
",jcrugzz,2015-10-30 20:54:34
333,2012-11-13 18:05:36,"What happens when a request comes to the server that does not match a host in the proxy table? Right now, it always responds with a 404.

I added the ability to define a custom function to fire to handle these events.

Please let me know if you think this is an improvement and if you need any tests or formatting changes to include it.

Thanks,
Breck
",breck7,2013-03-09 07:30:08
333,2013-01-31 08:56:33,"This would be nice to add.
",trusktr,2013-03-09 07:30:08
332,2012-11-08 09:48:22,,ramitos,2013-03-09 05:45:31
331,2012-11-07 08:38:54,"My code handles `proxyError` event on `require('http-proxy').RoutingProxy`. But after several days of heavy use the module crashes with this error:

<S_CODE_TOKEN>

Please, help me debug the problem. I think the native `error` event gets fired multiple times.
",aimnadze,2012-11-09 18:07:26
331,2012-11-07 09:49:26,"In http-proxy.js lines: ![302](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L302) and ![316](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L316) 
`reverseProxy.removeListener('error', proxyError);`
`reverseProxy.once('error', proxyError);`

These two lines remove `error` listeners. But soon another `error` event occurs and no handler is registered that time. Unfortunately I have no steps to reproduce this.
",aimnadze,2012-11-09 18:07:26
331,2012-11-09 18:07:26,"I've investigated the problem and found a bug in Node.js which I'm gonna report now.
",aimnadze,2012-11-09 18:07:26
330,2012-11-06 15:39:24,"Hello,

I am getting the following error with standalone https proxy server:

An error has occurred: {""code"":""ECONNRESET""}

Here is my definitons:

<S_CODE_TOKEN>

Can someone suggest what am I doing wrong? Standalone http proxy works fine, but the error is encountered with https.

-Noman A.
",namirj,2012-11-06 16:07:54
330,2012-11-06 16:07:54,"Got it resolved! Added below to my code:

<S_CODE_TOKEN>
",namirj,2012-11-06 16:07:54
329,2012-11-05 12:09:33,"The middleware example refers to `connect-gzip`. However, recent node.js versions include native zlib bindings. At least the `connect-compress` middleware uses those. Is that module now preferred? Should the example be changed as well? This middleware can be used by writing: `require('connect').compress()`
",tuomassalo,2012-11-05 12:38:52
329,2012-11-05 12:38:52,"Oops, I didn't notice #316, and I mischecked that my code was working. This should probably wait for #316's fix (https://github.com/senchalabs/connect/issues/524).
",tuomassalo,2012-11-05 12:38:52
328,2012-11-05 09:41:22,"I'd like to add some logging to my reverse proxy in an `end` function. Is there a way to get the number of bytes that was sent to the client? I'm using `connect-gzip` middleware that enables `Transfer-Encoding: chunked` and thus disables the `Content-Length` header.
",tuomassalo,2012-11-06 12:46:14
328,2012-11-05 12:11:35,"I changed to `connect-compress` (see #329). Now I can see the byte count in `res._headers`, which is a string of all sent headers. But that's very hackish. Any ideas?

(Note: for now, I had to define a custom filter that does not depend on Content-Type. See #316.)
",tuomassalo,2012-11-06 12:46:14
328,2012-11-06 12:46:14,"Argh. `connect-gzip` seems to give me problems with keepalive every now and then, and `connect-compress` too. I think I'll wait for the `connect-compress` issue to be resolved and get back to this later.
",tuomassalo,2012-11-06 12:46:14
327,2012-11-04 17:44:02,"This patch fixes a edge case bug, which randomly causes chunked transfers to be silently truncated.

The scenario is the following:
- a ""slow"" client tries to fetch a ""big"" resource, served by a backend server in chunked encoding
- since the client is slower than the backend, node-http-proxy will pause the response stream
- when reaching the end of the chunked response, the underlying socket will emit a 'end' event
- this 'end' event will terminate the response stream; pending events (i.e. the data received between the pause and the EOF) will be silently discarded
- the amount of queued data depends of the speed and latency of both client and backend connections, so it is pretty random, making the bug pretty hard to debug

The bug was particularly visible in the following conditions:
- client = typical DSL/cable consumer link on the West Coast
- proxy and server = EC2 instances in us-east-1
- resource = ~160 KB JS file, served gzipped+chunked by nginx (size: ~60 KB after compression)

The problem appears only when the response is chunked; probably because when a Content-Type is present, the HTTP module will fetch only the required amount of data, and therefore not hit EOF.

I'm not extremely satisfied with this fix because it doesn't feel very clean; so feel free to provide a better solution. It might involve changing things in Node.js libraries themselves, but I didn't feel like doing that myself, having virtually zero experience with Node.js.

Alternatively, the issue can be avoided by removing the response throttling, i.e. not calling pause; but then it becomes trivial to DOS the server by memory exhaustion by retrieving a very big resource with a (artificially) slow client.
",jpetazzo,2013-03-09 06:27:08
327,2012-11-07 02:35:59,"I confirm the bug. I had to switch to jpetazzo's fork temporarily to workaround the bug: https://github.com/dotcloud/hipache/commit/f29e9de278f4c999d1639a08a3707a21cf95deaa

I hope I can switch back to the main repository soon!
",samalba,2013-03-09 06:27:08
327,2013-01-29 22:55:43,"@mmalecki Any plan to merge this one?
",samalba,2013-03-09 06:27:08
327,2013-03-09 06:04:03,"@jpetazzo This looks good. I'll cherry-pick it. Been looking at hipache the last few days; nice work.
",indexzero,2013-03-09 06:27:08
327,2013-03-09 06:27:08,"Cherry-picked. Thanks.
",indexzero,2013-03-09 06:27:08
326,2012-11-02 17:32:05,"Hi,

When I use Express with RoutingProxy I get 

proxy.error: Error: socket hang up

using node 0.8.2.

I've been at it for a few hours and was wondering if the problem is with connect and express and if it was workable or if I should just  downgrade the packages.

Sorry for the vagueness. I can post more details if someone thinks it's worthwhile.

Thanks
",sirganya,2012-11-29 11:54:06
326,2012-11-16 05:55:37,"Need more details and code. This error means that backend server didn't respond in timely fashion or that connection was closed forcefully.
",mmalecki,2012-11-29 11:54:06
326,2012-11-16 10:32:31,"I should have replied to myself, it turned out to be the issue covered here previously with express doing non standard things to the body. After a lot of hair pulling I've decided to abandon http-proxy. It seems that I'm going to run into problems combining express with nodejitsu software. I've spent a few days debating wether to move to flatiron but it seems that express is favored so I've bet the house on that. I like that flatiron seems to be closer to the ideals of node but I've been swayed by the very few comparisons I can find online. If anyone here would like to throw their two cents in favor of flatiron I'd be very happy to hear them. I think the nodejitsu stuff is super solid but time is against me to allow me to learn and move to flatiron. 
",sirganya,2012-11-29 11:54:06
326,2012-11-29 11:54:06,"@sirganya Thousands of `express` based apps run on nodejitsu which uses this library to proxy. There is no incompatibility between `express` and `http-proxy`
",indexzero,2012-11-29 11:54:06
326,2013-05-07 02:42:10,"I'm back with this issue again....
express@2.5.11
formidable@1.0.14
http-proxy@0.10.2
node v0.10.5

It proxies everything correctly except a POST with a body.

<S_CODE_TOKEN>

Formidable then gives this error.

<S_CODE_TOKEN>

Here's the code from incoming_form.js lines 99 - 124

<S_CODE_TOKEN>

I had used connect-restreamer to fix it before, but it looks like it's not the issue anymore.

https://github.com/dominictarr/connect-restreamer
",sirganya,2012-11-29 11:54:06
326,2013-05-07 18:39:27,"found the answer here

http://stackoverflow.com/questions/11295554/how-to-disable-express-bodyparser-for-file-uploads-node-js
",sirganya,2012-11-29 11:54:06
325,2012-11-02 07:12:15,"Hi guys I have a very similar scenario to #202 but based on cookies. For some reason the cookie in `on('upgrade', function (req, socket, head)` is always undefined. I was wondering if somebody here could point me into the right direction. Here is my current setup:

Balancer:

<S_CODE_TOKEN>

Server:

<S_CODE_TOKEN>

Client:

<S_CODE_TOKEN>
",mkuklis,2013-03-09 07:24:38
325,2013-03-09 07:24:38,"Check the headers. if the `cookie` header isn't set then this is a core issue.
",indexzero,2013-03-09 07:24:38
324,2012-10-29 18:50:36,"- also added some info to the error object when we catch 503s from backend DROPs to aid in debug/log output
",joemiller,2012-10-29 18:50:59
323,2012-10-25 21:41:57,"@mmalecki.

eafdc744 has introduced really unexpected behaviour, please process it as soon as you will get this message :) Otherwise I'll pull it by myself :)
",indutny,2012-10-26 01:13:59
323,2012-10-25 21:43:18,"lgtm :-)
",piscisaureus,2012-10-26 01:13:59
323,2012-10-26 01:14:16,"Good catch, Fedor. Thanks.
",mmalecki,2012-10-26 01:13:59
322,2012-10-24 23:59:13,"The end event should also be emitted for 304 (Not modified) responses.

Starting with commit 182dcd34555f361c1bb2b8d2777689e64ce32f87, there is no need to special handle these response statuses.

Ensures that end is emitted also for 304 responses.
",smh,2013-03-09 06:10:09
322,2012-11-04 22:37:11,"@mmalecki any hope of getting this in? As it stands, a 304 response will not emit an end event, unlike all other responses.
",smh,2013-03-09 06:10:09
321,2012-10-24 06:11:00,"I'd like to set up a proxy server like so:

<S_CODE_TOKEN>

If I set an environment variable for PORT I'm fine but doing the same for PROXIEDPORT breaks things because it expects a number instead of a string. Looks like node handles this in the net library with a handy toNumber function.

(Also, as an aside, it would be nice if the proxied host defaulted to 127.0.0.1 when missing that parameter.)
",gsf,2012-11-06 22:51:08
321,2012-11-06 21:58:54,"If you want to turn it into a number, you should use:

<S_CODE_TOKEN>
",Southern,2012-11-06 22:51:08
321,2012-11-06 22:19:34,"I prefer 

<S_CODE_TOKEN>

but I think others might get caught up on this as well, so it should be fixed in the project.
",gsf,2012-11-06 22:51:08
321,2012-11-06 22:53:56,"Fixed in master.
",Southern,2012-11-06 22:51:08
320,2012-10-23 19:55:41,"- http-proxy: emit websocket:start
- routing-proxy: allow listening for websocket:\* event

/cc @mmalecki
",indutny,2012-10-23 19:59:33
320,2012-10-23 20:03:36,"Merged and published as 0.8.4
",mmalecki,2012-10-23 19:59:33
319,2012-10-22 18:54:20,"Apache's [mod_proxy_html](http://httpd.apache.org/docs/2.4/mod/mod_proxy_html.html) improves reverse proxy support by rewriting (X|HT)ML content returned to the user agent. This functionality would be incredibly useful in node-http-proxy, making it possible to support a much wider variety of reverse proxy scenarios.
",DavidSouther,2012-11-29 12:36:44
319,2012-11-29 12:36:43,"It would also make it slow and memory constrained instead of I/O constrained. We get this request a lot. Probably never going to happen. 

You can build something which does this using `http-proxy`
",indexzero,2012-11-29 12:36:44
318,2012-10-19 09:39:00,"When receiving HTTP3xx server side redirects, the Location header is not entirely rewritten by the proxy, except for rewriting http to https, but in fact servername and port should be translated as well if they match the backend server and port, to make the process transparent to the browser. 

So if the Location header contains http://backendhostname:backendport/foo/bar it should be rewritten to http://proxyhost:proxyport/foo/bar while still applying the http to https conversion as currently implemented. 
",jayv,2015-10-30 20:53:52
318,2012-12-08 11:07:57,"@nodejitsu Any input on this?
",dignifiedquire,2015-10-30 20:53:52
318,2012-12-08 12:33:22,"I did write a patch that I should submit.
",jayv,2015-10-30 20:53:52
318,2013-02-21 10:54:50,"Would also like to +1 this, especially if someone has a potential fix already (@jayv ?). I came across this issue when using Testacular which relies on http-proxy for http forwarding.
",amirhhz,2015-10-30 20:53:52
318,2013-02-22 19:42:47,"I have a fix that solved my Testacular issues, let me see if I can send you a patch.
",jayv,2015-10-30 20:53:52
318,2013-02-24 17:23:28,"@Dignifiedquire @amirhhz I've submitted a pull request that I wrote a couple months ago:

https://github.com/nodejitsu/node-http-proxy/pull/376

You can install my node-http-proxy fork and link to that one from Testacular, it's how we currently run our tests.

https://github.com/jayv/node-http-proxy
",jayv,2015-10-30 20:53:52
318,2015-10-30 20:53:52,"This should be solved in the latest http-proxy. Please open a new issue if you see a problem
",jcrugzz,2015-10-30 20:53:52
317,2012-10-17 06:15:28,"This allows the connect.compress() middleware to work on proxied requests.

If this header is not manually set then the compress middleware will be invoked in the writeHead() call:

  https://github.com/nodejitsu/node-http-proxy/blob/1df2b30e84f078d86e744601bd6fc59381a1c7b3/lib/node-http-proxy/http-proxy.js#L260

before the header has been written. Therefore it will perform its content-type check:

  https://github.com/senchalabs/connect/blob/7b5621b8dd4d9d82296b9b5d7bf3bea10de37a6c/lib/middleware/compress.js#L94

and so the check will fail and compression will be disabled.
",fmarier,2012-10-22 07:46:54
317,2012-10-17 06:16:57,"This is a fix for #316
",fmarier,2012-10-22 07:46:54
317,2012-10-22 07:46:54,"This should be fixed in connect instead: https://github.com/senchalabs/connect/pull/524
",fmarier,2012-10-22 07:46:54
316,2012-10-17 06:12:54,"Looking at the middleware example that comes with http-proxy:

https://github.com/nodejitsu/node-http-proxy/blob/1df2b30e84f078d86e744601bd6fc59381a1c7b3/examples/middleware/gzip-middleware.js

I decided to write my own program which makes use of [connect.compress()](http://www.senchalabs.org/connect/compress.html) but is otherwise the same as the example that comes with http-proxy:

https://github.com/fmarier/node-compressed-http-proxy/blob/master/compress-example.js

Unfortunately, it doesn't work because the compress middleware looks at the headers before they are written out in order to decide whether or not a resource should be compressed. I can force compress to always compress everything by calling it like this:

<S_CODE_TOKEN>

but that's of course not a good idea since images will get gzipped too.

The result is that proxied content is never compressed by connect.compress().
",fmarier,2012-10-22 07:45:56
316,2012-10-19 00:55:25,"i.m.o. this is a bug in connect, as it is perfectly valid to send an object of headers with `writeHead`. connect patches the `writeHead` to emit a `header` event on the response object. The compress middleware is listening to that event to see if it should compress the response, but yet it seems like connect's own documentation suggests that the event is used to add headers just before they are written to the socket, meaning that compress may handle it's `header` event before something else listening to the event adds a `Content-Type` header and so compress will miss it. FWIW the `header` event is not part of node core, it is just something connect patches `ServerResponse` with.
",dougwilson,2012-10-22 07:45:56
316,2012-10-22 07:45:56,"@dougwilson is right, it is a problem in connect itself: https://github.com/senchalabs/connect/pull/524
",fmarier,2012-10-22 07:45:56
315,2012-10-14 18:28:47,"Fix for #313

Did i miss anything?

Thanks
",yawnt,2012-10-15 19:19:26
314,2012-10-04 13:01:33,"Hi,

I am having some issues with node-http-proxy. I am running node 0.8.10 on Linux (Debian Squeeze).

Without routing through node-http-proxy I see response times of 16 - 30ms. With I get 200+ms.

What am I doing wrong?

The code I have tried is below:

<S_CODE_TOKEN>

Regards,
Zac
",ZacS803,2015-10-30 20:53:15
314,2012-10-04 15:36:29,"Hey Zac, 
I was seeing some similar issues to and posted an issue on it, no response yet, but it turns out the dns lookup was the bottleneck.  I posted most of my notes with the issue.
https://github.com/nodejitsu/node-http-proxy/issues/305
Rob
",robertlmullen74,2015-10-30 20:53:15
314,2012-10-05 02:35:17,"Hi Rob,

I am not 100% sure if mine is the same issue, as I am proxying direct to an IP, so there shouldn't be a DNS lookup?

Did you find any workarounds or fixes to your issue? 

Cheers,
Zac
",ZacS803,2015-10-30 20:53:15
314,2012-10-09 19:54:45,"We haven't done anything yet, still testing out other options, but we're thinking of mapping the dns to IP's and doing lookups based on that, which for us has proven to be fast.
",robertlmullen74,2015-10-30 20:53:15
314,2012-10-30 14:28:25,"Could you profile it and find where it spends its time? We're using it in production with under 20 ms of round trip.
",mmalecki,2015-10-30 20:53:15
314,2012-12-18 13:41:58,"Same issue, with http-proxy : 200ms+ and without 5-20ms.
http listening on localhost:8080, proxy on localhost:80. (doing a simple res.write('hi') & res.end())

don't know if it can help: v8 profiling 
http://pastebin.com/Qv3NZC1b
",frizinak,2015-10-30 20:53:15
314,2012-12-18 16:47:50,"timestamp:
1355848457504 PROXY REQUEST   - createServer callback
1355848457543 RENDERED            - httpserver (8080) receives request 39ms later
1355848457547 SENT                     - http server has called response.end()
1355848457557 PROXIED                - proxyserver.proxy.on('end')
chrome : blocking 0ms, sending: 0-1ms waiting: 200-270ms, receiving: 0-2ms (dns lookup if not cached: 0ms)
1355848875418 RENDERED 
1355848875419 SENT 
chrome : blocking 0ms, sending: 0-1ms waiting: 5-7ms, receiving: 0-2ms

Hope this helps in any way, will be looking at the source later tonight trying to find the slowest callback in http-proxy
(note: I'm just starting out with nodejs so I might be doing something retarded, but as I've created numerous new projects with base httpserver + http-proxy, I'm pretty sure it's either http-proxy or my ubuntu server box )

edit: ran same script on windows box, no issues (with or without proxy 5-15ms round trip).
Back on linux I tried changing the port from 80 to >8000, (no sudo) same issue persists.
Tried with bouncy, same issue. Gonna look into that, will update when I find it (It obviously doesn't seem to be a bug in http-proxy).
",frizinak,2015-10-30 20:53:15
314,2012-12-18 17:37:05,"I suspect it is not http-proxy. I heard some noise about spurrious latency from the  DNS lookup in node.js core since lookups are not cached.
",indexzero,2015-10-30 20:53:15
314,2012-12-18 23:22:14,"Yeah it's not a bug in http-proxy, couldn't find any other info on the issue though.
To me it seems it can't be DNS lookup (or atleast in my case) cause all the servers are hosted on 1 box, referencing eachother through 127.0.0.1:port.

Funny thing is the only 3 people reporting this issue are running debian based OS's

If this isn't the right place to discuss this any further I'll post a link to stackoverflow or something.

edit: wrote a simple http proxy, 2 http server, first one creates a client and connects to second -> 260ms ubuntu, 10ms windows.
Tried bouncy again, thought it reproduced this issue but apparently it doesn't (20-30ms). Gonna have a look at that (Not using bouncy cause it causes other issues (stops sending chunks after 64kb etc))  
",frizinak,2015-10-30 20:53:15
314,2013-02-15 19:42:21,"I believe I am also experiencing this issue.

I am using Debian 6.0.6 x86_64 and using the local /etc/hosts file to do my DNS resolution (no DNS server available).
I have tried using both IPs and hostnames in the routes of http-proxy with the same results.
GET requests are failing randomly with a Status of ""(failed)"" and a Type of ""Pending"" but a Time that seems perfectly reasonable (6ms-60ms ish).
I too think it is odd that the only ones experiencing this issue are running a Debian-based OS.

Has anyone made any further progress on this?
",clayzermk1,2015-10-30 20:53:15
314,2013-05-04 17:43:32,"I'm using Fedora 13 and it's happening to me as well. Why is it even doing a DNS lookup for IP addresses? Is Node using the OS libraries to parse IP addresses? If they are only doing a parse and not a lookup there really shouldn't be a delay anyway. Am I missing something?
",download13,2015-10-30 20:53:15
314,2013-05-04 21:22:38,"There's no DNS lookup happening for IP addresses, checkout this gist I wrote to help illustrate the difference between DNS vs IP resolution.  https://gist.github.com/robertlmullen74/3834431

The DNS lookup was buried somewhere deep in the node.js C core libraries, I forget exactly how it's being done, but I do recall seeing that the result was never cached.
",robertlmullen74,2015-10-30 20:53:15
314,2013-07-31 03:59:13,"Also seeing this on Ubuntu.
",unusualbob,2015-10-30 20:53:15
314,2015-07-02 15:30:16,"+1 I'm using local-ssl-proxy (which only really calls node-http-proxy) and it's actually taking 3 or 4 minutes to load the page.
",wmill,2015-10-30 20:53:15
314,2015-10-30 20:53:15,"Closing due to old age.
",jcrugzz,2015-10-30 20:53:15
313,2012-09-29 05:02:08,"It would be nice to have some documentation with a list of `options` properties available. For example, without looking the source code it would have been hard to know that this existed:

<S_CODE_TOKEN>
",thefosk,2012-10-15 19:19:54
313,2012-09-29 05:29:22,"I agree. How would you feel about making a pull request?
",jfhbrook,2012-10-15 19:19:54
312,2012-09-27 22:45:51,"I tried to search for some release notes but I cannot find them. I understand it may be boring to write them every time, but it would be great having a list of features added/removed/updated for every release. At least for the major changes.

UPDATE: Never mind, I'm completely dumb I found them. I apologize. I was looking in the wiki.
",thefosk,2012-09-27 22:46:55
311,2012-09-27 15:03:49,"disable timeouts on connections, related to issue #278
",valette,2013-03-09 05:18:09
311,2012-11-29 12:40:17,"@valette This is correct, but it only fixes your issue. What about users who want a timeout? The solution is (of course) to make this configurable as an option passed around.

Please implement it as an option and add tests.
",indexzero,2013-03-09 05:18:09
311,2013-03-09 05:18:09,"No traction on tests. Closing. Would accept this as a feature with:
- configurable timeout
- tests.
",indexzero,2013-03-09 05:18:09
310,2012-09-27 14:18:23,"When I'm running the following code:

<S_CODE_TOKEN>

I get the following Error instantly:

<S_CODE_TOKEN>

Am I doing something wrong? I'm using node.js 0.8.10.
",drd0rk,2012-09-28 05:47:38
310,2012-09-28 05:47:37,"nevermind....forgot the 'new' before RoutingProxy()...
",drd0rk,2012-09-28 05:47:38
309,2012-09-21 19:19:46,"It looks like proxy paths that are longer than two steps deep aren't proxied through: 

<S_CODE_TOKEN>

The first path will work, the second doesn't. Is this by design, or a bug? 

cheers,
   Peter
",rigolepe,2012-09-21 19:24:45
309,2012-09-21 19:24:45,"Sorry, my mistake, the first path conflicts with the second and that causes the trouble. If you switch them around, the order of the routing paths makes it work after all: 

<S_CODE_TOKEN>
",rigolepe,2012-09-21 19:24:45
308,2012-09-13 07:57:37,,peters,2012-09-24 23:20:16
308,2012-09-24 23:20:24,"Awesome, thanks!
",mmalecki,2012-09-24 23:20:16
307,2012-09-11 21:38:52,"I need to provide a proxy for a source web server that protects its resources behind session-based authentication. (see below)

The proxy simply needs to instead protect those resources behind basic authentication.

Can node-http-proxy help me with this?

Thanks,
   Martin.

e.g.. Session Based Login 
    request.post ( {
        uri: ""https://server.example.com/login""
        , qs: {
              username: ""user@myserver.com""
            , password: ""mypasswd""
          }
        }
        , function(error, response, body) {
        console.log(request);

<S_CODE_TOKEN>
",mrjcleaver,2012-11-29 11:35:09
307,2012-11-29 11:35:09,"Yes. Check the session in the proxy request handler than based on that (potentially async) response make the proxy request; otherwise 401 (or 403)
",indexzero,2012-11-29 11:35:09
306,2012-09-11 18:33:45,"It seems like I've troubles when proxying the request to an HTTPS endpoint whose SSL cert is unverified (like a self-signed certificate)
",thefosk,2012-11-29 12:42:00
306,2012-09-14 23:40:11,"More informations on this issue: 
version 0.8.1 works, but using latest version, 0.8.2, the proxy responds with:

<S_CODE_TOKEN>

while in access.log of the final server (the one with custom SSL) the related line is:

<S_CODE_TOKEN>

It looks like version 0.8.2, with https on the final server, sends malformed headers and no path+query string.
Downgrading to 0.8.1 solved this issue
",shatsar,2012-11-29 12:42:00
306,2012-11-29 12:41:23,"@shatsar Are you referring to `node@0.8.2` or `node-http-proxy@0.8.2`?
",indexzero,2012-11-29 12:42:00
306,2012-11-29 12:41:59,"Looks like this was fixed in 2e7d8a88f4b470dcc9da1639fe2a69e03251036c
",indexzero,2012-11-29 12:42:00
306,2012-11-29 18:07:18,"I was referring to `node-http-proxy@0.8.2`, so yeah, it should be fixed (we'll give it a try asap)

Thanks @indexzero 
",shatsar,2012-11-29 12:42:00
305,2012-09-06 22:00:36,"Hey all,
I have been running some ab tests against the basicproxy.js service and have noticed it's about 3 times slower using the proxy than not.  I'm on node 0.8.8 and ubuntu 11.10.

Using proxy

> ab -c 10 -n 1000 http://127.0.0.1:8000/  
> Total response time was approx. 4 seconds 

No proxy

> ab -c 10 -n 1000 http://127.0.0.1:9000/
> Total response time was approx. 1.7 seconds 

I ran the proxy with node http debugging enabled for a single request and this was the output.
NODE_DEBUG=http node basic-proxy.js

1 request through proxy
HTTP: SERVER new http connection
HTTP: server response shouldKeepAlive: false
I'm proxyrequest
get base result
HTTP: outgoing message end.
HTTP: SERVER new http connection
HTTP: server response shouldKeepAlive: true
HTTP: write ret = true
HTTP: outgoing message end.
HTTP: AGENT incoming response!
HTTP: AGENT isHeadResponse false
HTTP: write ret = true
HTTP: AGENT socket keep-alive
HTTP: outgoing message end.
HTTP: server socket close
HTTP: server socket close

1 request without proxy
HTTP: SERVER new http connection
HTTP: server response shouldKeepAlive: false
HTTP: write ret = true
HTTP: outgoing message end.
HTTP: server socket close

Is the performance difference simply because we're asking the proxy to do that much more, that 3x increase seems like something is askew here.  I tested this with different ab parameters, played around with the maxSockets settting and tried a different http agent, but nothing seemed to speed up going through the proxy.    I'm surprised at the discrepancy here, am I missing something?  

Thanks,
Rob
",robertlmullen74,2015-10-30 20:49:25
305,2012-10-04 15:34:59,"So I identified the majority of the bottleneck is in the dns lookup call done from in the node.js source from http.js > net.js > dns.js.  I added some debug statements to the node.js source and found this:

DEBUG - http.js socket write ms:796ms
DEBUG - 2012-09-24T18:52:28.797Z <trace> simpleproxy-withlisteners.js:35 (ClientRequest.<anonymous>) socket assigned to backend request!
DEBUG - net.js lookup dns callback  ms:880ms

That's 84ms of what was a 100ms request just in processing the dns lookup. Node is doing no caching of this either, so you take that hit every time.

I created this test script to help narrow down where the 
https://gist.github.com/3834431
",robertlmullen74,2015-10-30 20:49:25
305,2012-11-29 12:38:58,"Interesting. 
",indexzero,2015-10-30 20:49:25
305,2013-04-04 08:53:31,"Is there any fix for this?
",Rush,2015-10-30 20:49:25
305,2014-05-16 16:41:14,"same issue here. ab-client machine and http-proxy machine are both Ubuntu 13.10 Servers. is used the basic-proxy.js example code:

without proxy: ab -n 10000 -c 100 http://10.10.10.1:9003/ :
Requests per second:    1975.13 [#/sec](mean)
Time per request:       50.630 [ms](mean)

with http-proxy: ab -n 10000 -c 100 http://10.10.10.1:8003/ :
Requests per second:    371.78 [#/sec](mean)
Time per request:       268.975 [ms](mean)

setNoDelay(); is set to true AND http.globalAgent.maxSockets is set to 10000 AND further more i did some linux-kernel tuning mentioned here: http://urbanairship.com/blog/2010/09/29/linux-kernel-tuning-for-c500k/ 

but without any better results. even a local benchmark returns the same result.

AND it does not seem to be an prob with the DNS resolving, i used this script https://gist.github.com/gabrielf/7746695#file-nodejs-dns-vs-ip-lookup-test-js by (https://gist.github.com/gabrielf) and the results looked fine:

lookup of 10.10.10.1: 1ms
lookup of 10.10.10.1: 0ms
lookup of 10.10.10.1: 0ms
",zlaoz,2015-10-30 20:49:25
305,2014-05-16 16:55:11,"@zlaoz That looks similar to the 200ms fixed overhead from small requests I saw in anything greater than Node v0.10.15. 
",grantkl,2015-10-30 20:49:25
305,2014-05-16 17:02:42,"@grantkl so in an older node version this delay does not took place? which version? (i am on v0.10.28)
",zlaoz,2015-10-30 20:49:25
305,2014-05-16 17:25:31,"same with node v0.10.10
",zlaoz,2015-10-30 20:49:25
305,2014-05-16 17:28:23,"I didn't see the same delay in v0.10.15 or before. There were changes in v0.10.16 that introduced a 200ms hit for my use case. It has been a couple of months since I looked into this as I started vetting other solutions for my problem.
",grantkl,2015-10-30 20:49:25
305,2014-05-16 17:31:07,"@zlaoz i would personally try using `wrk` to benchmark as `ab` sends `http 1.0` requests rather than `http 1.1` iirc. See if the issue is reproducible there. Otherwise I would try passing in an agent to `http-proxy` as it does not use the global agent by default, it uses no agent. 
",jcrugzz,2015-10-30 20:49:25
305,2014-05-16 17:47:40,"@jcrugzz thanks for the hints. with wrk the results are the same:

Running 10s test @ http://10.10.10.1:9003/ (direct)
  1 threads and 100 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    40.56ms    2.25ms  62.01ms   88.99%
    Req/Sec     2.47k    99.67     2.54k    87.34%
  24376 requests in 10.00s, 4.95MB read
Requests/sec:   2437.32
Transfer/sec:    506.56KB

Running 10s test @ http://10.10.10.1:8003/ (http-proxy)
  1 threads and 100 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   256.17ms   20.93ms 297.68ms   65.28%
    Req/Sec   390.72     44.85   500.00     72.22%
  3900 requests in 10.01s, 0.86MB read
Requests/sec:    389.60
Transfer/sec:     88.27KB

passing an agent to http-proxy is the next thing... hold on
",zlaoz,2015-10-30 20:49:25
305,2014-05-16 17:51:40,"@zlaoz and when passing in an agent make sure it has maxSockets set reasonably high as well.
",jcrugzz,2015-10-30 20:49:25
305,2014-05-16 17:55:00,"same result using:

var agent = new http.Agent();
agent.maxSockets = 10000;

var server = httpProxy.createServer({
        agent: agent,
        target: 'http://localhost:9003'
}).listen(8003);
",zlaoz,2015-10-30 20:49:25
305,2014-05-16 18:45:29,"@zlaoz hmm and this is on ubuntu only? Do you have the code that reproduces this that i can grab and test myself? I want to see if its reproducible on OS X. I would also try and run this on `0.11.x` to see if this issue may be fixed already for the next version (as it seems to be core related).

Paste the `wrk` command you are using as well if you could :).
",jcrugzz,2015-10-30 20:49:25
305,2014-05-17 11:11:07,"@jcrugzz i created a gist with all required code-snippets and infos: https://gist.github.com/zlaoz/4a730bfe7f322f6442fd#file-node-http-proxy-slow-performance
",zlaoz,2015-10-30 20:49:25
305,2014-05-22 16:45:42,"@zlaoz ive tested your same code locally on my macbook and it shows an overhead of 60ms of latency with the proxy (7ms -> 60ms). Have you been able to try this on `0.11.13` and see if you get the same performance?
",jcrugzz,2015-10-30 20:49:25
305,2014-07-16 13:47:18,"@jcrugzz sry for the late response! tried it using `0.11.13` i got 50ms (direct) and 200ms (proxied). i tried it locally too and i got 12ms (direct) and 90ms (proxied).
",zlaoz,2015-10-30 20:49:25
305,2015-10-30 20:49:25,"It would be good to have benchmarks related to the newest version of `http-proxy` on node `4.x.x` and forward. Open a new issue if there are any issues here but there will inevitably be some overhead.
",jcrugzz,2015-10-30 20:49:25
304,2012-09-01 00:17:52,"Hi,

I'm a node/node-http-proxy novice, and I'd like to use node-http-proxy to create an HTTP->HTTPS proxy server. I.e. a client would connect to the proxy over HTTP, and on the back-end it would talk to an HTTPS target web server. The two examples given are for HTTPS->HTTP and HTTPS->HTTPS, but not HTTP->HTTPS.

Maybe it's obvious from these examples how to do it, but I'm not able to figure it out.

Here's a sample of my code:

<S_CODE_TOKEN>

When I try to connect to http://localhost:8000 I get a 500 Internal Server Error with the body

<S_CODE_TOKEN>

If anyone can show me what I'm doing wrong, that would be greatly appreciated! Thanks!
",cweichen,2012-09-03 07:51:34
304,2012-09-03 07:51:34,"Never mind, I figured it out. I just had to ignore all the extraneous code in the HTTPS->HTTPS example. This will do it:

<S_CODE_TOKEN>

Beautiful! Thanks node-http-proxy!
",cweichen,2012-09-03 07:51:34
304,2013-09-06 19:57:30,"This doesn't work for me. I get:

<S_CODE_TOKEN>

(I have tried different hosts, of course)

See also: http://stackoverflow.com/questions/15801014/how-to-use-node-http-proxy-for-http-to-https-routing

Update: This did the trick:

https://gist.github.com/aaronshaf/6469450
",aaronshaf,2012-09-03 07:51:34
304,2013-11-06 00:23:17,"Can you repost your gist? :)
",sheldonkwok,2012-09-03 07:51:34
304,2014-02-18 20:43:41,"Figured this out myself after tearing my hair out a bit. The above solution wouldn't work for me because I needed to inspect the request before proxying it. You need to place the `https: true` option inside a target object.

<S_CODE_TOKEN>
",gumballhead,2012-09-03 07:51:34
304,2014-08-07 21:02:33,"There's an example in the examples folder now: https://github.com/nodejitsu/node-http-proxy/blob/caronte/examples/http/proxy-http-to-https.js

<S_CODE_TOKEN>

Worked for me.
",jasonsanjose,2012-09-03 07:51:34
304,2016-09-14 14:10:49,"https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-http-to-https.js
",patoi,2012-09-03 07:51:34
304,2017-01-24 17:54:05,"In case someone's having problem with it, I've created a simple working repo: https://github.com/ericmdantas/simple-node-https-proxy",ericmdantas,2012-09-03 07:51:34
303,2012-08-28 09:58:12,"Hey,

shouldnt following snippet proxy every request made to localhost:8000 to my local nginx virtual host which runs under the domain ""auth-request""? I am asking this because all request get forwarded to the default ""localhost/127.0.0.1"" virtual host. It seems that the request gets forwarded to the ip but the hostname is discarded?

<S_CODE_TOKEN>
",omares,2012-11-29 12:37:09
303,2012-10-17 22:37:56,"@omares by default http-proxy doesn't change the `Host` header to the targeted hostname, so Nginx doesn't know which host to match to.
You can force it by setting the `changeOrigin` option to true.
",1stvamp,2012-11-29 12:37:09
302,2012-08-27 15:38:04,,janl,2012-08-27 15:48:41
302,2012-08-27 15:39:38,"This pull request [passes](http://travis-ci.org/nodejitsu/node-http-proxy/builds/2251176) (merged 1db95427 into 4f6387c1).
",travisbot,2012-08-27 15:48:41
301,2012-08-24 17:14:00,"node-http-proxy is great for reverse proxies.  It's also wildly intimidating at first glance.

Sometimes you just want a simple vanilla forward-proxy.  Also, forward proxying is conceptually simpler to explain.  Thus here's two suggestions:

1)  Start the documentation with a forward proxy example ... it's a clean way of explaining the core proxy loop.

eg, 

<S_CODE_TOKEN>

And perhaps a quick ""terms definition"" would be helpful. forward_proxy=xxx, reverse_proxy=yyyy

2) How on earth do you proxy an HTTPS request?????

I got as far as this:

<S_CODE_TOKEN>

But it didn't work.  I get ""Proxy CONNECT aborted"" when I do ""curl https://foo.bar.baz"" --proxy1.0 localhost:7878
",ddopson,2013-02-12 19:15:14
301,2013-02-01 22:08:50,"This is EXACTLY what I want to do! I want to write my own ""Forward Proxy"" according to the definition http://en.wikipedia.org/wiki/Proxy_server#Forward_proxies

This is the type of proxy you can configure a system to use 
![MacProxySettings](https://f.cloud.github.com/assets/13620/119795/25f4f18e-6cb5-11e2-87b1-6f4a21ab8da1.png)

The documentation only addresses the ""user story"":
When a browser make a request on the port that this proxy is listening to, forward it to a specific port on a specific host.

That is technically creating a ""Reverse Proxy"" http://en.wikipedia.org/wiki/Reverse_proxy To people who understand the networking technology and jargon, it is very confusing that the ""forward"" option to httpProxy.createServer creates a Reverse Proxy.

The ""user story"" that we are interested in is:
When this proxy is specified as a app specific or system wide HTTP/web proxy, forward the request to the requested URL and apply the specifies callback.

I cannot find ANY documentation on how to do this because of the misuse of the term ""forward"" in node-http-proxy's API. Sigh.
",RichardBronosky,2013-02-12 19:15:14
301,2013-02-12 19:15:14,"https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L792
",indexzero,2013-02-12 19:15:14
300,2012-08-23 23:49:56,"Hi, I'm using node-http-proxy to create a proxy to n rails applications serving some services. In local everything works just fine, but in production I'm not able to reach the desired services. You can find the source code in [here](github.com/lelylan/api) in case you want to try it.

Here part of the server implementation.

<S_CODE_TOKEN>

And here the environment variables on heroku.

<S_CODE_TOKEN>

I've tried different solutions, but none works. Here you can find a discussion on [Stackoverflow](http://stackoverflow.com/questions/12096528/proxy-server-with-node-js-on-heroku).

Thanks a lot.
",andreareginato,2012-08-24 00:27:54
300,2012-08-24 00:27:54,"Please feel free to reopen if you find a bug, for now this seems like a Q&A and people have been helping you in SO.

Issues are more for reporting bugs, if you do find one (in your local environment) feel free to resubmit.
",dscape,2012-08-24 00:27:54
299,2012-08-23 13:53:48,"Hi,

I try to use node-http-proxy as a reverse proxy which resolves the target url to send the request to by making a lookup on the path in the request url. The path in the request url is looked up in a DB table and subsequently the target url to be used is sent to the proxy server. 

E.g. http://myhost/app1 ==> http://myserver:myport/key1/app1

However I get a 404 on all the associated scripts, stylesheets which are a part of the original document returned by the server. 
Short of defining handlers for all paths on the hostname is there anyway i can handle this scenario. I do not want to use a hostname only based proxying approach. 

<S_CODE_TOKEN>
",baradas,2012-08-23 14:55:01
299,2014-08-15 17:12:38,"@baradas. What was the fix for this? Trying to do something similar...
",tybenz,2012-08-23 14:55:01
299,2014-08-15 17:14:53,"@tybenz open a new issue if you cant figure out how to get it to work. Node automatially buffers requests for you so there is no need to do manual buffering in this case when doing an async lookup for a host. Checkout the readme for the latest API 
",jcrugzz,2012-08-23 14:55:01
298,2012-08-17 04:52:42,"Currently if a backend doesn't return `Connection` header, http-proxy sets it to `Connetion: close` regardless  of the request HTTP version.

We should respect request HTTP version and if HTTP 1.1 is used, return `Connection: keep-alive`. *
- Quoted from the [RFC](http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01.html#Connection):

<S_CODE_TOKEN>
",Kami,2013-03-09 06:11:38
298,2012-08-17 04:54:20,"This pull request [passes](http://travis-ci.org/nodejitsu/node-http-proxy/builds/2148694) (merged 850171cd into 4f6387c1).
",travisbot,2013-03-09 06:11:38
298,2012-12-17 02:41:03,"bump ^^
",Kami,2013-03-09 06:11:38
298,2012-12-19 02:57:43,"Seems reasonable. We'll try to get this merged in soon. We try to perform maintenance in groups to make releases more stable, so apologies if it is not immediate.
",indexzero,2013-03-09 06:11:38
298,2012-12-19 04:27:51,"OK, thanks for the heads up.
",Kami,2013-03-09 06:11:38
297,2012-08-15 23:47:17,"I'm trying to apply an OAuth 1.0a signature on the fly to every request. This requires the app to read the body parameters before proxying the request (required to generate the signature) and then add an `Authorization` header to the request object. 

The problem is that if I read the request body before proxying, at that point the buffer would be entirely read before proxying the request, so it won't be correctly piped to the final destination. 

Also, because I'm doing this before proxying:

<S_CODE_TOKEN>

the request `data` and `end` events have actually been paused so doing something like:

<S_CODE_TOKEN>

Just doesn't work.

Any tips?
",thefosk,2012-08-17 03:38:41
297,2012-08-17 03:38:41,"@thefosk That's not true, we don't actually pause the `req` in `.buffer` (see: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L202-255) So your `req.on('data' ...` statements should work. 

Perhaps the data has already been emitted before you add the listener?
",indexzero,2012-08-17 03:38:41
297,2012-08-27 18:13:50,"Yes you're right, I apologize I got confused with a couple of lines.

The following snippet works. To make it work I added `request.removeAllListeners();`, but it seems a quick and dirty solution to me, I wonder if it can break something.

<S_CODE_TOKEN>
",thefosk,2012-08-17 03:38:41
296,2012-08-10 00:46:40,"I'm trying to install but I'm getting a strange error:

Has anyone else been able to get it to install on Ubuntu Server recently?

<S_CODE_TOKEN>
",pixelcort,2012-08-10 01:35:05
296,2012-08-10 00:54:07,"Update your node version - that's a very old `npm` version, and an update will most likely rectify the issue.
",AvianFlu,2012-08-10 01:35:05
296,2012-08-10 01:06:51,"@AvianFlu thanks! updating `node` and `npm` helped find the real issue: My network filesystem (VirtualBox's shared folders) doesn't support creating symlinks apparently.

It's not very common for filesystems to not to support symlinks, so I'll let someone else decide if it's worth supporting. I can workaround it by moving to a different filesystem.
",pixelcort,2012-08-10 01:35:05
296,2012-08-10 01:09:54,"Actually, it looks like it might be an `npm` limitation: it's the symlink `node_modules/.bin/node-http-proxy` that can't be created, failing.
",pixelcort,2012-08-10 01:35:05
296,2012-08-10 01:35:05,"Yeah, this would be an `npm` issue - but symlinks are a tricky thing, and get very complex across many operating and file systems.  `npm install --force` may or may not help here, but it might be worth a try.  Worst case, you could clone the git repo - but that's far from ideal.

Closing, as it's not really a proxy issue.
",AvianFlu,2012-08-10 01:35:05
296,2012-08-10 01:42:00,"BTW, if anyone else comes across this, a npm bug that appears to be the culprit is https://github.com/isaacs/npm/issues/2380 .
",pixelcort,2012-08-10 01:35:05
295,2012-08-06 15:07:47,"Headers ""x-forwarded-for"" and ""x-forwarded-proto"" are set, but these should read ""X-Forwarded-For"" and ""X-Forwarded-Proto. Things break with ""trust proxy"" mode from expressjs which expects proper caps.
",wellawaretech,2012-08-06 19:00:53
295,2012-08-06 19:00:53,"OOPS. HTTP headers are case insensitive. Something else seems to be amiss. Closing issue.
",wellawaretech,2012-08-06 19:00:53
294,2012-07-31 12:09:44,"This pull request is to replace #260 (https://github.com/nodejitsu/node-http-proxy/pull/260)

It contains the same changes + TESTS:
1. Set the connection header only if not already set by the target server.
2. Copy response headers case-insensitively

In addition it contains another fix:
support unix domain sockets and windows named pipes (socketPath) - This was transparent in node 0.6.x by using port for named pipe, but in node 0.8.x it should be passed explicitly.
",gilad61,2013-03-09 06:00:53
294,2012-07-31 13:03:56,"Doing a copy of headers on every request isn't a good thing to do - I'm worried about memory usage. Can you explain exactly why is it needed (an example would be appreciated)? Test case doesn't tell me much.
",mmalecki,2013-03-09 06:00:53
294,2012-11-15 16:22:33,"If response headers are copied using the res.writeHead() function, then the copy is case sensitive. It means that eventually we may have two headers with same name but different casing, for example: x-My-Header: ""a"", x-my-header: ""b"", and then it is unpredictable which value will be taken by the client, and doesn't meet HTTP standard.
HTTP headers are case insensitive, so the copy needs to be done with res.setHeader(), which overrides existing headers case-insensitively.

I don't see a difference in mem usage as in one case we copy all the headers at once, and in another case we copy them one by one.
I would even say the opposite - if you use the current implementation you'll use more memory. 
For example:
If I have ""myheader: x"", and then I get a request with ""MYHEADER: y"", then I'll end up with two headers. And same thing if I get another header ""MyHeader: z"", and ""MyHeAdEr: a"" and so on...
But - if I copy them with setHeader() then the headers will be overridden and I will have only one header with the same name.
",gilad61,2013-03-09 06:00:53
294,2013-03-09 05:52:45,"@gilad61 @mmalecki This is a subtle but good fix; we should be setting header names consistently. `res._renderHeaders()` is still case sensitive even in the latest stable versions of node:
- `v0.8.22`: https://github.com/joyent/node/blob/v0.8.22/lib/http.js#L713-L727
- `master`: https://github.com/joyent/node/blob/master/lib/http.js#L740-L754
",indexzero,2013-03-09 06:00:53
294,2013-03-09 05:57:51,"I spoke with @isaacs, this behavior is not going to change even in 0.10.0, but likely in 0.12.0. So going to pull this in if all the tests pass.
",indexzero,2013-03-09 06:00:53
294,2013-03-09 06:00:51,"Cherry-picked. Thanks
",indexzero,2013-03-09 06:00:53
293,2012-07-30 21:38:10,"Http-proxy has a big memory leak when forwarding websockets. Test case: socket.io client establishes websocket to a socket.io server, via http-proxy. The client holds the connection for some time (e.g. 10 sec), closes the connection, establishes another one, holds it open for a while, closes, etc. in a loop. Use several hundred clients to observe a consistent memory growth,  hundreds of MB in a few minutes. Garbage collection  does not reclaim the lost memory.

The fix is in node-http-proxy/http-poxy.js by registering on 'close' handlers of incoming and outgoing socket, in addition to already present on 'end' handlers. The test case described above stopped leaking memory completely after applying this fix. 

Repro test case can be made available upon request.
",jkorycki-skype,2013-03-09 05:40:11
293,2013-03-09 05:40:11,"Cherry-picked. Thanks.
",indexzero,2013-03-09 05:40:11
292,2012-07-30 06:28:44,"Hi,

I did some google search but still not found any example/tutorial for my case.

Assume I have a nodejs app using socket io, and I want to use node-http-proxy as load balancer.

My app is replicated in 2 servers with the same port.

server1: myapp_url:8000
server2: myapp_url:8000

How I can configure through node-http-proxy so user just browse to http://proxy_url:proxyport, then request will be redirected to server1 or server2 automatically based on load balancing algorithm?

And does node-http-proxy support load balancing algorithm efficiently and transparently? I saw on github site just a simple round robin algorithm, I'm supposed that such thing should be transparent with developer, we just need to configure only?

Thanks for your time. 
",dnguyen2107,2012-07-30 06:34:03
292,2012-07-30 06:34:02,"Exact duplicate of #291 and #288
",Marak,2012-07-30 06:34:03
291,2012-07-30 06:28:43,"Hi,

I did some google search but still not found any example/tutorial for my case.

Assume I have a nodejs app using socket io, and I want to use node-http-proxy as load balancer.

My app is replicated in 2 servers with the same port.

server1: myapp_url:8000
server2: myapp_url:8000

How I can configure through node-http-proxy so user just browse to http://proxy_url:proxyport, then request will be redirected to server1 or server2 automatically based on load balancing algorithm?

And does node-http-proxy support load balancing algorithm efficiently and transparently? I saw on github site just a simple round robin algorithm, I'm supposed that such thing should be transparent with developer, we just need to configure only?

Thanks for your time. 
",dnguyen2107,2012-07-30 06:34:13
291,2012-07-30 06:34:13,"Exact duplicate of #292 and #288
",Marak,2012-07-30 06:34:13
290,2012-07-29 23:52:20,"Need advice on this scenario. After the target server flushes out the response is there a way we could intercept it in the proxy before it is actually sent out to the server. Just like how the request is buffered, is there a way we can count in the latency as well? Thanks in advance.
",kimo,2012-07-30 00:07:02
290,2012-07-29 23:57:50,"I'm not sure we've added anything for bufferring responses out of the box, but since the response is a stream, you should be able to pipe the stream to a buffer, inspect and manipulate that buffer, then re-emit.

If you one have one proxy target ( i.e. one host you are proxying to ), you might find the request module an easier solution: https://github.com/mikeal/request
",Marak,2012-07-30 00:07:02
290,2012-07-30 00:05:19,"Marak

Thanks for the quick response. I am trying to implement something where I would be injecting some cookie information for response and possibly more later. Can I use this module against any target web server(not necessarily nodejs).

// Krishna
------Original Message------
From: Marak
To: Krishna Guda
Subject: Re: [node-http-proxy] How to intercept the response in proxy? (#290)
Sent: Jul 29, 2012 4:57 PM

I'm not sure we've added anything for bufferring responses out of the box, but since the response is a stream, you should be able to pipe the stream to a buffer, inspect and manipulate that buffer, then re-emit.

If you one have one proxy target ( i.e. one host you are proxying to ), you might find the request module an easier solution: https://github.com/mikeal/request

---

Reply to this email directly or view it on GitHub:
https://github.com/nodejitsu/node-http-proxy/issues/290#issuecomment-7357797

Sent from my Verizon Wireless BlackBerry
",kimo,2012-07-30 00:07:02
290,2012-07-30 00:07:01,"Sure
",Marak,2012-07-30 00:07:02
289,2012-07-28 01:19:47,"The steps to reproduce the issue are somewhat complex, but we encountered it when proxying concurrently to many different back-end servers.  Somewhere between 30 and 50% of the time the handshake would get corrupted.  It appears that the assumption was being made that if the second socket.write had been flushed, the first one would have been flushed as well - but that apparently that is not always the case or perhaps, because noDelay is set they were being split into separate responses instead of as the single response they are supposed to be?  Either way, the source of the problem was the double socket.write that was being done to push the string data and the binary data.

I condensed these into a single write by reconstructing the buffer if modifications were necessary and the handshake failures seem to have stopped.
",ashaffer,2013-03-09 05:34:51
289,2012-07-30 18:50:58,"@piscisaureus @AvianFlu @mmalecki Thoughts? This is clearly your realm of expertise. 
",indexzero,2013-03-09 05:34:51
289,2012-07-30 19:22:32,"@ashaffer Copying all data into a single buffer makes this particular problem go away, but it doesn't solve the underlying cause. Making two write calls should just work. So I'm curious what kind of ""corruption"" you're seeing, e.g. are buffers truncated, are bytes changed, do packets arrive in the wrong order?
",piscisaureus,2013-03-09 05:34:51
289,2012-07-30 19:31:20,"Unfortunately I never pinned down the exact nature of the corruption that was occurring.  My best guess as to what was happening is that the first write was sometimes being flushed completely before the second write happened, and this response splitting was causing issues in some way.   Perhaps a chunked encoding header would fix it as well (since during the handshake its still using standard HTTP which cares about such things?).

If there are any decent debugging tools out there for websockets then i'd be happy to run some tests for you, but the best i've found was manually poring through tcpdump logs which was incredibly tedious and didn't end up yielding me much.
",ashaffer,2013-03-09 05:34:51
289,2012-07-30 19:37:45,"@ashaffer Unless your backend service is very poorly written, response splitting should never be a problem. Remember that tcp is a stream-oriented protocol. If this is _really_ the cause then you probably want to fix your backend. What I would advice you to look into however is whether the handshake entirely makes it to the backend. If you see a tcp FIN or RST packet (an 'end' or 'error' event, in node terms) before the handshake is done, then that could be caused by a node-http-proxy bug.
",piscisaureus,2013-03-09 05:34:51
289,2012-07-30 20:12:21,"Sorry I should elaborate on the structure of our setup.  We are proxying twice (both times through node-http-proxy) with the final backend of SockJS (0.3.1).  The foremost proxy splits requests between 3 backend node-http-proxy servers, which in turn only proxy to one final server instance.  We have this somewhat odd setup because we have extended the Meteor project to support instanced sub-applications and so have sat our own proxy in front of several Meteor instances, each of which already does one layer of proxying.  However, the Meteor proxy instances are a 1:1 mapping between proxy and backend, whereas our subapp proxy is not.

Each client will at any given time be connected (via the proxys) to all 3 backend server instances.  We have localized the issue to occurring in the foremost proxy instance in which the fan-out occurs.  It seems to occur around 30% of the time, which means often we would get 1 socket failing and two working, although plenty of the time we'd get other configurations like all 3 working or all 3 failing.

The response splitting issue is only my best guess as I can't think of why else two separate socket.write's as opposed to one would so completely resolve the issue for us.  Definitely not saying that is the issue and based on my understanding of TCP as well it _shouldn't_ be the issue, but it or something like it fits the evidence more closely than any other explanation I can think of, though i'd certainly be interested to hear any other ideas as i've been trying to nail this down for a few weeks now and this was the solution I came up with.
",ashaffer,2013-03-09 05:34:51
289,2012-07-30 21:09:13,"Bjorn Stromberg:

> @ashaffer It sounds like your backend isn't handling things well. Looking at SockJS, this isn't very pretty:
> 
> <S_CODE_TOKEN>

Yeah, that looks wrong. Maybe file an issue with SockJS ?
",piscisaureus,2013-03-09 05:34:51
289,2012-07-30 21:36:26,"That looked promising, but I just tested it and neither the else case of that if nor the catch are being hit when the connections fail.
",ashaffer,2013-03-09 05:34:51
289,2012-07-30 22:10:20,"So, that code is not being run at all, or `message` comes out healthy?
",piscisaureus,2013-03-09 05:34:51
289,2012-07-30 22:56:35,"Message seems to be coming out healthy
",ashaffer,2013-03-09 05:34:51
289,2012-08-08 23:45:48,"Also this code is proxying data on its way back to the client, not going to the back-end, so I think it being a SockJS bug is fairly unlikely, as sockjs isn't touching the data between when this happens and when the connection breaks.

The only options to me seem to be that it's a bug in node-http-proxy, a race condition in node itself's handling of write flushes, or in chrome and firefox's implementation of websockets.  Whichever way happens to be the culprit, condensing to a single socket.write fixes the problem.
",ashaffer,2013-03-09 05:34:51
289,2012-08-09 00:35:52,"@ashaffer Can you condense this to a reproducible test case? Nodejitsu uses `node-http-proxy` in production, load-balancing websockets on a very large scale, and we have never seen this problem.

Your infrastructure is very complex, you haven't described the exact nature of the handshake corruption, and there isn't a simple, standalone reproduction of the problem.

We're happy to help, but there isn't really a lot to go on, here.
",AvianFlu,2013-03-09 05:34:51
288,2012-07-27 11:20:24,"Hi,

I did some google search but still not found any example/tutorial for my case.

Assume I have a nodejs app using socket io, and I want to use node-http-proxy as load balancer.

My app is replicated in 2 servers with the same port.

server1: myapp_url:8000
server2: myapp_url:8000

How I can configure through node-http-proxy so user just browse to http://proxy_url:proxyport, then request will be redirected to server1 or server2 automatically based on load balancing algorithm?

And does node-http-proxy support load balancing algorithm efficiently and transparently? I saw on github site just a simple round robin algorithm, I'm supposed that such thing should be transparent with developer, we just need to configure only?

Thanks for your time. 
",dnguyen2107,2012-07-30 06:38:42
288,2012-07-30 06:38:42,"Please do not post the exact same issue multiple times.

Here is a simple example of using a round-robin load balancing strategy: https://github.com/nodejitsu/node-http-proxy/blob/master/examples/balancer/simple-balancer.js

No other load balancing strategies are built-in or provided.
",Marak,2012-07-30 06:38:42
287,2012-07-26 15:06:37,"Hi,

(Disclaimer: being new to Node.js I really suspect this isn't a bug/feature request but simply a my misunderstanding of the usage of node-http-proxy, but since I did not find a forum for node-http-proxy, I'm asking here...)

I'm trying to create a proxy with node-http-proxy that checks whether a request is authorized in a mongodb.

Basically, I created a middleware module for the node-http-proxy that I use like this:

<S_CODE_TOKEN>

What the middleware module does is using mongojs to connect to mongodb and run a query to see if the user is authorized to access the resource:

<S_CODE_TOKEN>

Now the problem is that as soon as I add the asynchronous call to mongodb using mongojs the proxy hangs and never send the response back.

While debugging I noticed that actually the response is immediately closed as soon as I add a callback. On the other hand, if I do nothing async in the middleware the proxying works like a charm....

Any clue?
",domguinard,2012-07-27 06:13:56
287,2012-07-27 06:13:56,"If the user is not confirmed you don't respond to `next()`. You should try responding to it with an error, or ending the res with 403. e.g. `res.end(403)`.
",indexzero,2012-07-27 06:13:56
287,2012-07-27 07:24:19,"Hi,

Well I actually do exactly what you said, I just omitted it from the snippet for simplicity (my bad!), here is the exact code:

<S_CODE_TOKEN>

So to clarify the problem: on a ""User not confirmed"" everything works fine and the 403 is returned. On a ""user confirmed"" however I see the log but the browser then hangs forever and the request isn't proxied.

Now, if I remove the ""user confirmed"" and next() part outside of a callback it does work:

<S_CODE_TOKEN>

}

but I can't do that since the mongojs query is meant (rightfully I guess) to be executed asynchronously, the callback being triggered only when the db replied...
",domguinard,2012-07-27 06:13:56
287,2012-07-30 08:42:27,"Still pretty stucked on that... any idea? hint? Could it be an actual bug?
Btw, started a stackoverflow thread on that: http://stackoverflow.com/questions/11672294/invoking-an-asynchronous-method-inside-a-middleware-in-node-http-proxy
",domguinard,2012-07-27 06:13:56
287,2012-07-30 12:43:50,"Eventually found the solution which was in the documentation (buffering the request: http://stackoverflow.com/questions/11672294/invoking-an-asynchronous-method-inside-a-middleware-in-node-http-proxy). I haven't found a way to make that work with the Middleware appoarch but at least it is now working with async calls as well.
",domguinard,2012-07-27 06:13:56
287,2012-07-30 18:47:58,"If you're going to use the middleware approach I believe you actually need a middleware that performs the proxy:

<S_CODE_TOKEN>
",indexzero,2012-07-27 06:13:56
287,2012-07-30 18:48:42,"Also, you do need to buffer the request. This is by-definition so you'd need a middleware before the `./example-middleware` which calls `httpProxy.buffer(req)` and keeps that in context.
",indexzero,2012-07-27 06:13:56
286,2012-07-25 15:08:20,"<S_CODE_TOKEN>
",Almad,2012-07-26 08:30:30
286,2012-07-26 07:50:36,"@Almad Thanks. I'll make a pass at updating the examples soon. We completely refactored tests in `0.8.2` and the examples got over-looked. We should add tests to ensure all examples run correctly. 
",indexzero,2012-07-26 08:30:30
286,2012-07-26 08:30:30,"Fixed in fd648a529090cefc202613fff3fdfec9ba0e6a72 with new tests. 
",indexzero,2012-07-26 08:30:30
285,2012-07-25 13:20:00,"We use a standalone `httpProxy.RoutingProxy` instance inside our app to handle adhoc HTTP proxy requests. The `changeOrigin` option re-added in 0.8.2 isn't passed through to `httpProxy.HttpProxy` instances when passed to routing proxy instances, so I've tried to match the current way options are passed on in this patch.
",1stvamp,2012-07-26 07:51:10
285,2012-07-26 07:51:07,"lgtm
",indexzero,2012-07-26 07:51:10
284,2012-07-22 13:01:35,"Since Node.js 0.8 has SPDY support, are there any chances that node-http-proxy will support it? The code might be lifted from [node-spdyproxy](https://github.com/igrigorik/node-spdyproxy).
",mikl,2013-02-03 10:04:13
284,2012-07-22 13:05:36,"Sure, send a PR. :)
",dscape,2013-02-03 10:04:13
284,2012-07-22 19:53:16,"@mikl Yes, that's basically it. I'm not against it, but there are other things that are much higher priority than this. If you'd like to implement it and send a PR you'd make my day :)
",indexzero,2013-02-03 10:04:13
284,2013-02-03 10:04:13,"Duplicate #343 
",julianduque,2013-02-03 10:04:13
283,2012-07-22 07:11:53,"In the last API version it was easy to proxy the socketPath through all the functions. Now it's almost impossible.

It would be great if you could keep socket paths in mind when renewing the API.
",buschtoens,2012-07-22 19:55:54
283,2012-07-22 19:55:51,"Sure. Duplicate of #104. Closing
",indexzero,2012-07-22 19:55:54
282,2012-07-22 05:41:35,"Tests are simpler and use saner `vows` idioms. 
",indexzero,2012-07-22 06:49:50
281,2012-07-19 12:39:59,"Hello there!

Any ideas how to serve multiple hosts with diffenrent certs, all in one machine?

Thank's!
",cranic,2012-07-22 06:10:30
281,2012-07-22 06:10:30,"I think you would need to use SNI if they're all listening on port 80. This is going to go into nodejs core in the `0.9` timeframe I believe.
",indexzero,2012-07-22 06:10:30
281,2012-07-22 06:11:05,"See: https://github.com/nodejitsu/node-http-proxy/pull/275/files
",indexzero,2012-07-22 06:10:30
280,2012-07-16 20:34:26,"Under some circumstances which i was unable to reproduce in a test close_wait sockets start to gather up and dont get freed up. when replacing node-http-proxy with my own code, see below, this does not happen.

var proxy = {
  proxyRequest: function(req, res, dest) {
    var copts = {method: req.method, path: req.url, host: dest.host, port: dest.port, headers: req.headers};
    var creq = http.request(copts, function(cres){
      cres.pipe(res);
      _writeHead(res, cres.statusCode, cres.headers);
    });
    creq.on('error', function(e) {
      res.write(e.message);
    });
    req.pipe(creq);
  }
};
",rimar,2012-07-24 15:00:00
280,2012-07-17 15:15:04,"Hey,

So we were having this problem as well, and I made a patch for it that I seemed to have forgotten to put on node-http-proxy master. In any case, here's the patch: https://gist.github.com/517b82523f2e60a20982

Essentially, if anything listens on 'webSocketProxyError' that does not close the socket, then the socket will stay open, which could leave the sockets in this state. This patch fixes that and closes the socket before 'webSocketProxyError'. Do you mind giving this patch a try and seeing if it fixes anything? I can't really reproduce this test either.

Thanks.
",coderarity,2012-07-24 15:00:00
280,2012-07-24 14:59:59,"This should be fixed by 0d00b06af307dc5c70c36e89617a08486eb665e2. If it's not, please let me know and I'll reopen.
",mmalecki,2012-07-24 15:00:00
280,2012-07-24 18:10:54,"Thanks for the quick reply, unfortunately i cant test it - it only happened in production and for me i fixed it using the code snippet above. If i get a chance to test it i will let you know. Thanks again.
",rimar,2012-07-24 15:00:00
279,2012-07-16 10:31:22,"I develop my javascript on localhost but want to test them against remote webservices. To avoid same-origin-policy issues, i like to have a proxy in front of my local development server and the remote webservice server that routes the requests accordingly. How can i accomplish this with node-http-proxy?

I'd prefer a solution that doesn't require me to change my browser's proxy settings. Instead, node-http-proxy should start a ""front-facing""webserver (e.g. localhost:9000) that masks the other two webservers.
",fbuchinger,2012-07-22 06:41:43
279,2012-07-22 06:41:43,"@fbuchinger Yes. You can do this with node-http-proxy. Checkout some of the examples.
",indexzero,2012-07-22 06:41:43
278,2012-07-16 08:39:53,"I think this is due to underlying node.js http module which also has a similar timeout. The api should provide an option and method to override this.
",kul,2013-03-09 08:29:34
278,2012-07-16 08:42:16,"Interesting. How does the http module expose this option? I've never had an inactive ajax request sit that long so it never came up.
",jfhbrook,2013-03-09 08:29:34
278,2012-07-16 08:43:53,"I think this could be of help, http://nodejs.org/api/http.html#http_request_settimeout_timeout_callback
",kul,2013-03-09 08:29:34
278,2012-07-16 08:46:40,"Actually looking at node.js http module code it seems to be 2 minutes but i am not sure how its timing out at 4
https://github.com/joyent/node/blob/master/lib/http.js#L1658
",kul,2013-03-09 08:29:34
278,2012-07-21 01:10:36,"+1
",mlin,2013-03-09 08:29:34
278,2012-09-27 15:04:27,"this modification did the trick for me...
",valette,2013-03-09 08:29:34
278,2013-03-09 08:29:34,"Use `options.timeout`: https://github.com/nodejitsu/node-http-proxy#options
",indexzero,2013-03-09 08:29:34
277,2012-07-14 10:29:45,"I have a websocket server running at localhost:9000

With a router proxy it works flawlessly,

<S_CODE_TOKEN>

But with the following custom logic proxy the ws requests never reaches server!

<S_CODE_TOKEN>
",kul,2012-07-16 14:28:58
277,2012-07-14 10:29:58,"Do something!
plz
",kul,2012-07-16 14:28:58
277,2012-07-14 16:54:22,"The [Readme](https://github.com/nodejitsu/node-http-proxy#proxying-websockets) explain clearly how to set up a proxy for websockets using the `proxyWebSocketRequest()` method. Please try using that method and tell me how goes.
",cronopio,2012-07-16 14:28:58
277,2012-07-16 08:03:08,"Yes that works, but it also mentions ""Websockets are handled automatically when using httpProxy.createServer()"", I am not clear on the part how websockets work without anything special in router but not in custom proxy, which makes the api design unclear to me. Anyways i will close this if you think that is normal.

Thanks
",kul,2012-07-16 14:28:58
277,2012-07-16 13:55:31,"Yeah in custom proxy you can handle any kind of request, so you should handle websocket requests. When you create the server without custom logic internally happen something like this for handle websocket requests:

<S_CODE_TOKEN>

And Im guessing but I see it as a normal behavior.
",cronopio,2012-07-16 14:28:58
277,2012-07-16 14:28:57,"Closing this issue.
",kul,2012-07-16 14:28:58
276,2012-07-04 08:31:37,,rimar,2013-03-09 05:28:55
276,2012-07-04 15:43:54,"lgtm
",cronopio,2013-03-09 05:28:55
276,2012-07-22 06:56:25,"This should be a `typeof response.headers.location !== 'undefined'` check
",indexzero,2013-03-09 05:28:55
275,2012-07-03 19:27:42,"Hi after some experiments I came to this way of using different certificates for different domains, it works great and it will be nice to have it on your readme.

thanks
",jfromaniello,2012-07-22 06:17:58
275,2012-07-22 06:17:56,"lgtm. We should probably have tests for this.
",indexzero,2012-07-22 06:17:58
274,2012-06-28 17:17:07,"I'm asking in case this is already in built but just not mentioned? Else I was curious where might be a suitable hook point to throttle the consumed bandwidth to the requesting client, eg: to simulate a slow connection.

Unlike squid and some other proxies, I'm particularly looking for a constant flow rate limit; in squid the throttling is burst-y, in that it retrieves x00k at full capacity, but then hits the cap so freezes any further throughput temporarily before resuming another burst. The net effect is peaks and troughs of throughput. 
",franklywatson,2012-06-28 18:32:33
274,2012-06-28 18:32:33,"We don't have anything _special_ for rate-limiting, though I'm not aware of anything that would get in your way either. We do have multiple examples of using a settimeout to simulate a laggy connection. Probably not what you're looking for though.

Closing this issue but only because we don't have plans to add such functionality in the future. Feel free to continue posting.
",jfhbrook,2012-06-28 18:32:33
274,2012-06-28 18:33:58,"Thanks
",franklywatson,2012-06-28 18:32:33
273,2012-06-27 06:17:26,"In the proxy script below, I would like to put routing settings as a separate json file, and reflect them to the running server when the file is modified.
Is this possible now?
If it is not, is there another way to achieve the goal?

<S_CODE_TOKEN>
",hnakamur,2012-07-02 10:01:33
273,2012-07-02 04:35:09,"ProxyTable allows you to define either an object or a JSON file containing your routes in the router option. If you specify a JSON file it will poll for changes every 5 seconds.
See: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/proxy-table.js#L54-73

Here's an example.

**routes.json**

<S_CODE_TOKEN>

**server.js**

<S_CODE_TOKEN>

Do be aware that it isn't catching `SyntaxError`'s when it parses the route file and will crash the server if it contains one.
",hathvi,2012-07-02 10:01:33
273,2012-07-02 10:01:33,"Hi, thanks for a tip!
I confirmed it works.
",hnakamur,2012-07-02 10:01:33
272,2012-06-26 19:07:52,"Hello,
I need help about how node-http-proxy works.
I need to use node-http-proxy to redirect to another server: if I route myserver.com:80 to otherserver.com:80, will the connection be kept alive by myserver.com where node-http-proxy is running and otherserver.com responses return to the node-http-proxy or will otherserver.com become the unique server used ?

In fact, I need more explanations to know if node-http-proxy can redirect connections to another server without keeping connections .

When proxying websockets, is it a redirection and httpProxy.setMaxSockets(n) sets httpProxy max sockets or websocket nodejs server max sockets ?

Thanks in advance for your help.
",Alphapage,2013-03-09 06:38:31
272,2012-06-26 21:14:04,"<S_CODE_TOKEN>
",peters,2013-03-09 06:38:31
272,2012-06-27 08:24:08,"So, if I understand peters, you tell me that node-http-proxy was not made to do redirection because of your code.
But it acts only as a single entry point to distribute work inside a private network and send back the response to the client ?
",Alphapage,2013-03-09 06:38:31
272,2013-03-09 06:38:31,"Yes, that is correct.
",indexzero,2013-03-09 06:38:31
271,2012-06-25 08:59:24,"First of all, this is not an issue with http-proxy.. I'm rather looking out for an answer.

I am using http-proxy and In my server code,

socket.sockets.on('connection', function(client){ 
    var ip = client.handshake.address.address;
    ..
}
ip always returns 127.0.0.1 and most likely, this is because the server sits behind a proxy. 
How do I get remote address properly ?

In my proxy server code, I am using,

server.on('upgrade', function(req, socket, head) {
  proxy.proxyWebSocketRequest(req, socket, head);
});
",parindam,2012-06-25 09:55:41
271,2012-06-25 09:55:40,"var ip = client.handshake.headers['x-forwarded-for'] || client.handshake.address.address;

working for me.

I am properly getting the remote IP address and not 127.0.0.1
",parindam,2012-06-25 09:55:41
270,2012-06-25 06:18:05,"Hello nodejitsu!

I am migrationBot, an [open-source](https://github.com/blakmatrix/node-migrator-bot) bot, and I'm here to help you migrate your codebase to node v0.8!

Did you know that the ""sys"" module throws an error if your program tries to require it in node v0.8? To help keep your code running, I automatically replaced `var sys = require('sys')` with `var util = require('util')`.

If you'd like to know more about these changes in node.js, take a look at https://github.com/joyent/node/commit/1582cf#L1R51 and https://github.com/joyent/node/blob/1582cfebd6719b2d2373547994b3dca5c8c569c0/ChangeLog#L51 and http://blog.jit.su/introducing-blakmatrix-and-migratorbot .

As for myself, I was written by your friendly neighborhood node ninjas at [Nodejitsu](http://nodejitsu.com), and you can find them at #nodejitsu on irc.freenode.net or with http://webchat.jit.su .

Enjoy!

--[migrationBot](https://github.com/blakmatrix/node-migrator-bot)
",node-migrator-bot,2012-06-25 12:28:12
270,2012-06-25 12:28:23,"Nice! Thanks @blakmatrix.
",mmalecki,2012-06-25 12:28:12
269,2012-06-23 18:12:22,"Hello nodejitsu!

I am migrationBot, an [open-source](https://github.com/blakmatrix/node-migrator-bot) bot, and I'm here to help you migrate your codebase to node v0.8!

Did you know that the ""sys"" module throws an error if your program tries to require it in node v0.8? To help keep your code running, I automatically replaced `var sys = require('sys')` with `var util = require('util')`.

If you'd like to know more about these changes in node.js, take a look at https://github.com/joyent/node/commit/1582cf#L1R51 and https://github.com/joyent/node/blob/1582cfebd6719b2d2373547994b3dca5c8c569c0/ChangeLog#L51 and http://blog.jit.su/introducing-blakmatrix-and-migratorbot .

As for myself, I was written by your friendly neighborhood node ninjas at [Nodejitsu](http://nodejitsu.com), and you can find them at #nodejitsu on irc.freenode.net or with http://webchat.jit.su .

Enjoy!

--[migrationBot](https://github.com/blakmatrix/node-migrator-bot)
",node-migrator-bot,2012-06-25 13:59:57
269,2012-06-25 14:00:01,"dup
",blakmatrix,2012-06-25 13:59:57
268,2012-06-20 15:03:58,"This patch adds support for a host to be set with the node-http-proxy executable. It adds the `--host` argument meaning you can do

<S_CODE_TOKEN>

My use case is that I have a server that has the following IP addresses assigned to it
- 192.168.3.5
- 192.168.3.37

Port 80 on 192.168.3.5 is used by Nginx and I want to use port 80 on 192.168.3.37 for node-http-proxy. Without the patch the executable binds to INADDR_ANY and because Nginx is already listening to port 192.168.3.5:80 I get

<S_CODE_TOKEN>
",shapeshed,2012-07-22 06:17:23
268,2012-06-20 15:07:45,"sounds useful, nice pull request!
",coderarity,2012-07-22 06:17:23
268,2012-06-20 17:24:45,"Can you do just a little style change?, just use a positive verification `if (host) {`

Thank you!
",cronopio,2012-07-22 06:17:23
268,2012-06-20 20:58:21,"ok, looks good to me.
",cronopio,2012-07-22 06:17:23
267,2012-06-20 03:34:18,"Hello nodejitsu!

I am migrationBot, an [open-source](https://github.com/blakmatrix/node-migrator-bot) bot, and I'm here to help you migrate your codebase to node v0.8!

Did you know that the ""sys"" module throws an error if your program tries to require it in node v0.8? To help keep your code running, I automatically replaced `var sys = require('sys')` with `var util = require('util')`.

If you'd like to know more about these changes in node.js, take a look at https://github.com/joyent/node/commit/1582cf#L1R51 and https://github.com/joyent/node/blob/1582cfebd6719b2d2373547994b3dca5c8c569c0/ChangeLog#L51 .

As for myself, I was written by your friendly neighborhood node ninjas at [Nodejitsu](http://nodejitsu.com), and you can find them at #nodejitsu on irc.freenode.net or with http://webchat.jit.su .

Enjoy!

--[migrationBot](https://github.com/blakmatrix/node-migrator-bot)
",node-migrator-bot,2012-06-25 14:00:12
267,2012-06-25 14:00:12,"dup
",blakmatrix,2012-06-25 14:00:12
266,2012-06-19 06:41:20,"When routed via multiple proxies, x_forwarded_proto set as httphttps or
wswss instead of http,https or ws,wss, since + operator seems to have a
higher precedence than the terniary operator and the expression was
getting evaluated to true always
",rampr,2012-06-19 06:42:51
266,2012-07-18 10:00:40,"Do you plan to publish this fix with a new npm package anytime soon?
",bkw,2012-06-19 06:42:51
266,2012-07-18 10:05:48,"Good question. @cronopio Do you feel comfortable coordinating a release of the http-proxy? I see you're on the publisher's list.
",jfhbrook,2012-06-19 06:42:51
266,2012-07-18 12:35:23,"Well... We are trying to close two other issues before next minor release. Feel free to clone the `master` branch and install it, you will get the newest changes. I hope close the issues and release very soon. 
",cronopio,2012-06-19 06:42:51
266,2012-07-18 19:18:51,"@cronopio sounds great! Thanks. :)
",jfhbrook,2012-06-19 06:42:51
266,2012-07-24 14:39:57,"@bkw Hi, this fix come in the version `0.8.2` recently published.
",cronopio,2012-06-19 06:42:51
266,2012-07-25 09:59:33,"Thank you guys!
",bkw,2012-06-19 06:42:51
265,2012-06-16 17:11:29,"I can't seem to figure out how to log the response data. Attaching to the 'end' event of the proxy returns 'undefined' for the 'res' variable:

<S_CODE_TOKEN>
",chrisnicola,2013-03-09 06:49:49
265,2012-06-16 17:17:46,"Ok sorry I was just having some problems with my code reloading, and didn't diagnose the issue correctly. So it's `res.header`, though there appears to be no obvious way to get the body. I'm assuming I have to attach to the data event or something?
",chrisnicola,2013-03-09 06:49:49
265,2012-07-22 06:41:07,"@lucisferre We don't currently emit the data from the proxy target. We could do this although I'm unsure of the implications. 
",indexzero,2013-03-09 06:49:49
265,2012-11-07 19:12:12,"@indexzero wow, I wish you said that on the homepage. I've been struggling to find that out for hours now.
",lookfirst,2013-03-09 06:49:49
265,2013-01-20 04:48:04,"I need this. I guess I need to change the source code then.
",PhilAndrew,2013-03-09 06:49:49
265,2013-03-09 06:49:48,"Fixed in #356 
",indexzero,2013-03-09 06:49:49
264,2012-06-16 15:38:07,"Is there a way to catch proxy error? I mean, if the target didn't respond or isn't availabe..
I was thinking about something like this:

<S_CODE_TOKEN>
",alanhoff,2012-06-17 05:10:47
264,2012-06-17 03:32:46,"In [this example](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/custom-proxy-error.js) you will see the use of `proxyError` event.
",cronopio,2012-06-17 05:10:47
264,2012-06-17 05:10:45,"Worked like a charm, thx.
",alanhoff,2012-06-17 05:10:47
264,2013-07-15 22:44:18,"This does not work well for the RoutingProxy.

If I get ECONNRESET from the backend server, doing res.writeHead(500) in the proxyError handler will give me the ""Can't render headers after they are sent to the client."" error.

Any ideas?

EDIT: Actually, the proxy already resets the connection for me, but does not give me the alternative to call res.send(500)
",alum,2012-06-17 05:10:47
264,2013-07-16 13:17:24,"@alum this is expected. When you start proxying and the backend server sends the headers and _then_ breaks the connections, the headers were already proxied back to the client. You have to catch the `""Can't render headers after they are sent to the client.""` error.
",mmalecki,2012-06-17 05:10:47
264,2013-12-18 01:07:07,"Hi, i've met this error in my proxy, i follow your guide to catch the error like this: 

var proxy = new httpProxy.RoutingProxy();
proxy.on(""Can\'t render headers after they are sent to the client."", function(err, req, res){
      if(err) console.log(err);
      res.writeHead(500);
      res.end('Ooops, something went very wrong....');
});

But the proxy still throws the error, and i can't caught it.
Do you have any advice ? 
THank you very much.
",checkraiser,2012-06-17 05:10:47
264,2013-12-18 05:49:36,"So it's actually not the proxy that's throwing that error, but rather the response object. Also, there is not event called ""Can\'t render headers after they are sent to the client."" Most events are called things like ""error"" or ""finish"".
Basically I think you need to wrap res.writeHead() in a try-catch and handle the error that way.
",alum,2012-06-17 05:10:47
264,2014-02-18 13:24:25,"Hi all, is there any way to identify which backend server failed to serve the request, so that we can mark that server as down.
",arjunrp,2012-06-17 05:10:47
264,2014-02-19 18:00:03,"@arjunrp 
You probably want to set up one proxy per backend server. That way you will always know which server failed and you will have a nice separation between proxies.
",alum,2012-06-17 05:10:47
264,2014-02-20 04:59:03,"@alum thanks for the reply, i have got another solution
proxy.web(req, res, target, function (e) {
      // check the error object and mark the target as down 
    });
is this the correct way to do this?
",arjunrp,2012-06-17 05:10:47
263,2012-06-16 14:30:02,"i has a backend server, provide file download serviceÔºåfor http request,i set a header:  Content-Disposition:attachment;filename=myfile.txt"", if i direct access backend server, everying work well,but if i use http-proxy,not work,
http-proxy always close backend connection. if i not set that header, http-proxy work well.
",cole-dda,2013-03-09 07:06:39
262,2012-06-15 05:11:22,"Using the configuration of nodejitsu for `jshint`https://gist.github.com/1263182
I do this fixes.

There is `Too many var statements.` errors but in places where I guess is necessary. Also the use of `__proto__` was reported.
",cronopio,2012-07-22 06:27:15
262,2012-07-22 06:27:15,"Since the tests have been rewritten to be simpler in the `0.8.2` branch, we you rebranch of that and re-run JSHint compliance? 

Consider this low-priority.
",indexzero,2012-07-22 06:27:15
261,2012-06-13 08:32:08,"  fs.watchFile(this.routeFile, function () {
      fs.readFile(self.routeFile, function (err, data) {
        if (err) {
          self.emit('error', err);
        }
console.log(data);

logs - &lt;Buffer &gt;

SyntaxError: Unexpected end of input
    at Object.parse (native)
    at /home/bazjapan/app/node_modules/http-proxy/lib/node-http-proxy/proxy-table.js:69:29
    at [object Object].<anonymous> (fs.js:123:5)
    at [object Object].emit (events.js:64:17)
    at Object.oncomplete (fs.js:1190:12)

The json is fine, however readFile is returning a buffer and thusly json.Parse freaks out.
",bazjapan,2012-07-22 06:42:25
261,2012-07-22 06:42:25,"You want to use `fs.readFile(self.routeFile, 'utf8', function (err, data) { ...`
",indexzero,2012-07-22 06:42:25
260,2012-06-12 15:27:00,"In http-proxy.js line 227 - if the original request didn't have a 'connection' header, and the target server set this header to any value, it will always be overridden and set to 'close'.
This proposed fix set the connection header only if not already set by the target server.
",gilad61,2012-07-31 12:11:21
260,2012-07-19 14:20:55,"Adding another fix - 
If response headers are copied using the res.writeHead() function, then the copy is case sensitive. It means that eventually we may have two headers with same name but different casing, for example: x-My-Header: ""a"", x-my-header: ""b"".
HTTP headers are case insensitive, so the copy needs to be done with res.setHeader(), which overrides existing headers case-insensitively.
",gilad61,2012-07-31 12:11:21
260,2012-07-22 06:57:43,"Could you try adding tests for this? It would be greatly appreciated. 
",indexzero,2012-07-31 12:11:21
260,2012-07-31 12:11:38,"Closing this pull request, and opening a new one instead #294 (https://github.com/nodejitsu/node-http-proxy/pull/294)
The new pull request also contains tests.
",gilad61,2012-07-31 12:11:21
259,2012-06-06 17:27:33,"@CodeRarity knows more about this. Any light on this are welcome. ;)
",cronopio,2012-07-22 06:12:55
259,2012-06-06 20:28:30,"I think we should get rid of socket.io in the tests, I think it is extraneous for the purpose of testing web sockets and very liable to breaking again in the future.
",coderarity,2012-07-22 06:12:55
259,2012-06-06 22:05:23,"I think we can have tests for websockets using [ws](https://github.com/einaros/ws) but I think we should conserve the socket.io tests on differents files just for be sure `node-http-proxy` works fine with socket.io too.

The [ws](https://github.com/einaros/ws) have client and server we can use it for test ws-to-ws.

But if we have some time we can write tests using [socket.io](https://github.com/LearnBoost/socket.io) as server and use [socket.io-client](https://github.com/LearnBoost/socket.io-client) as client just for be sure the proxy works great too.
",cronopio,2012-07-22 06:12:55
259,2012-06-13 18:58:19,"Ok, in resume. The socket.io tests are top priority over just websockets, we have more apps using socket.io than just websockets.

Im dealing with this under `gh-259` branch, if someone want to review.
",cronopio,2012-07-22 06:12:55
259,2012-07-22 06:12:55,"I rewrote all of the tests from scratch on `0.8.2` branch, now working with `socket.io-client@0.9.6` and `ws`
",indexzero,2012-07-22 06:12:55
258,2012-06-02 21:17:07,"When using the file watch routing table approach on windows  

<S_CODE_TOKEN>

where table.json is defined as a file with the following contents:

<S_CODE_TOKEN>

it fails with the following error

<S_CODE_TOKEN>
",No9,2013-03-09 07:10:05
258,2012-06-20 15:16:24,"Interesting, I thought the point of using `fs.watchFile` was that it was more cross-platform than `fs.watch`. I think it might be better if we used `fs.watch` anyways, it's a lot better than stat polling.
",coderarity,2013-03-09 07:10:05
258,2013-03-09 07:10:05,"This is ancient. The underlying windows compat issues in node.js core are likely resolved.
",indexzero,2013-03-09 07:10:05
258,2013-03-09 08:20:46,"If you would like me to check i can. Fs.watch is still marked unstable in 0.8.22 http://nodejs.org/docs/latest/api/fs.html. So my hunch is this is probably still an issue. 
",No9,2013-03-09 07:10:05
258,2013-03-09 11:39:48,"@indexzero tested and ran with no problems
This issue is resolved.
Thanks
",No9,2013-03-09 07:10:05
257,2012-06-01 16:47:57,"Hello,

I'm having an issue with my proxy properly routing when a domain earlier in the proxy (such as _myothersite.ca_) is present in the query arguments of a later site.

The structure of the proxy file looks like this:

<S_CODE_TOKEN>

With the example above the following cases won't route correctly:
- http://mysite.ca/?email=example@myothersite.ca
  - This will route to _myothersite.ca_
- http://example.mysite.ca/?refer_url=example2.mysite.ca
  - This will route to _example2.mysite.ca_

But the following will route correctly:
- http://myothersite.ca/?email=example@mysite.ca
  - This will route to _myothersite.ca_
- http://example2.mysite.ca/?refer_url=example.mysite.ca
  - This will route to _example2.mysite.ca_

Can someone point me at the lines that do this parsing? It should be a straight forward fix after that.
",danielfay,2012-06-05 15:37:55
257,2012-06-02 12:20:36,"Here you go: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/proxy-table.js#L117
This behaviour isn't really a bug. By default _http-proxy_ checks for hostname and path, where the path check is more important than the host check. This is why your URLs get routed to the ""wrong"" host.

A quick ""fix"" for now would be to do this:

<S_CODE_TOKEN>

This is more of a design flaw. Most users would only want to do some host routing. `hostnameOnly` should be `true` by default.
",buschtoens,2012-06-05 15:37:55
257,2012-06-02 17:59:14,"The keys are converted to a regular expression, so use that to your advantage. Maybe add a $ at the beginning of your router keys?

We have to match the routes in some order. It's going from beginning to end and using the first route that matches. I think this is fine.
",coderarity,2012-06-05 15:37:55
257,2012-06-05 15:37:54,"@silvinci Sorry my example was a little misleading. I have hostnameOnly off for a reason. I also use the proxy to route to a static-file server. Thanks though.

@CodeRarity Appending '^' to the beginning of the keys solves my issue. Thanks for the hint - I have a better idea of how http-proxy operates now, which has helped me simplify much of the routing list.

Might as well update the initial example to reflect my new proxy:

<S_CODE_TOKEN>
",danielfay,2012-06-05 15:37:55
256,2012-05-31 20:15:53,"Just update the changelog selecting some changes between tags. I just select the more important changes for the users, the file its update to v0.8.0 tag

This close #137
",cronopio,2012-06-05 21:19:52
256,2012-05-31 23:25:12,"Awesome!
",indexzero,2012-06-05 21:19:52
255,2012-05-30 14:32:03,"Hi. Thanks for the free code. Having problems running it on Wndows.

Installed node - version 0.6.18
comes with npm version 1.1.21
Run npm install node-http-proxzy
wrote a simple test script 

<S_CODE_TOKEN>

Get error message

<S_CODE_TOKEN>
",gotofritz,2012-05-30 18:39:11
255,2012-05-30 18:39:10,"The package published to `npm` is `http-proxy` not `node-http-proxy`. The convention is to drop `node-` from package names. You should run:

<S_CODE_TOKEN>
",indexzero,2012-05-30 18:39:11
255,2012-05-30 18:56:18,"its not free, its open source :)
",maxogden,2012-05-30 18:39:11
255,2012-05-30 19:15:09,"_Free_ software...
",booo,2012-05-30 18:39:11
255,2012-05-31 08:06:34,"Thanks for the free support... :-) 
",gotofritz,2012-05-30 18:39:11
254,2012-05-29 14:46:35,"http-proxy finally supports unix socket paths. This closes [this issue](https://github.com/nodejitsu/node-http-proxy/issues/104). You can now do stuff like this:

<S_CODE_TOKEN>

I mainly altered the ProxyTable.getProxyLocation function. Before it tries to split the given target string into `host` and `port` it now looks for a leading slash which determines a `socketPath`.

This commit is tested on normal routing like shown above. I haven't tested it on direct `target`s and `WebSockets` but it should work.
",buschtoens,2012-07-22 06:54:58
254,2012-07-22 06:54:58,"The implementation here has changed significantly since this was originally implemented. Still open to the feature, but you will need to pull and re-implment.
",indexzero,2012-07-22 06:54:58
253,2012-05-26 19:38:32,"How-to don't send proxy information - now I'm have - proxy from 127.0.0.1
",qxfusion,2012-05-31 06:47:19
253,2012-05-30 20:18:02,"Can you please elaborate on this? I'm having trouble understanding what your problem is.
",coderarity,2012-05-31 06:47:19
252,2012-05-22 20:13:53,"configuration:

<S_CODE_TOKEN>

The backend with a django application which is expecting part of the form data to be a ""csrfmiddlewaretoken"" field, because the POST data is not sent correctly the backend responds with 403.
",nevins-b,2012-05-22 20:40:24
252,2012-05-22 20:24:56,"`http-proxy` can definitely proxy multipart form data. 

What exactly do you mean by ""not sent correctly"". What is being sent? How is it not correct?

I also see you are using a routing proxy with buffering, but you are not actually using any of the buffered data. Why are you using the buffering API if you aren't doing anything with the posted body before proxying? 
",Marak,2012-05-22 20:40:24
252,2012-05-22 20:40:27,"hmm, it may not be a proxy issue. The data does appear to be arriving and exactly the same as direct data. I'll look into it more and open a new issue if I can find and actual issue with http-proxy.

Thanks!
",nevins-b,2012-05-22 20:40:24
252,2012-05-22 20:44:05,"Without more information, I can only guess that you are upsetting django's cross site request forgery protection. Probably has to do with the request being reverse proxied.
",Marak,2012-05-22 20:40:24
252,2012-05-22 21:59:15,"Yeah, the issue was due that I was was testing with port 444. When django does the csfr prevention it does a strick check on the referer headers which was set to example.com:444 instead of example.com.
",nevins-b,2012-05-22 20:40:24
251,2012-05-22 19:43:49,"The ternary was evaluating truthy for "","" + req.connection.pair which is always true because its always a non empty string.  Wrapped actual condition to properly concatenate the product of the ternary.  let me know if you prefer the style   (req.connection.pair ? 'https' : 'http')

https://github.com/nodejitsu/node-http-proxy/issues/250
",ryanstevens,2012-05-22 19:56:25
251,2012-05-22 19:56:26,"lgtm, cherry-picked. :D Thanks!
",jfhbrook,2012-05-22 19:56:25
251,2012-05-22 19:59:38,"@ryanstevens nice catch.
",indexzero,2012-05-22 19:56:25
251,2012-06-16 07:00:34,"Seems like I still have the issue.

Only changing it to,
var protoToAppend = "","" + (req.connection.pair ? 'https' : 'http');

fixes it.

Looks like + has a higher precedence compared to the ternary operator
https://developer.mozilla.org/en/JavaScript/Reference/Operators/Operator_Precedence
",rampr,2012-05-22 19:56:25
251,2012-06-19 01:08:06,"@rampr Interesting. If you'd like to make another pull request I will gladly accept. :)
",jfhbrook,2012-05-22 19:56:25
251,2012-06-19 06:41:50,"Sure. Here you go - https://github.com/nodejitsu/node-http-proxy/pull/266
",rampr,2012-05-22 19:56:25
251,2012-06-19 06:43:26,"Thanks!
",jfhbrook,2012-05-22 19:56:25
250,2012-05-22 19:23:44,"When receiving proxied traffic from http-proxy the x-forwarded-proto is set as httpshttps.  

This line https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L151

which is currently 
var protoToAppend = "","" + req.connection.pair ? 'https' : 'http';

needs to be changed to 
var protoToAppend = "","" + (req.connection.pair ? 'https' : 'http');

With this change, x-forwarded-proto should be set to https,http
",ryanstevens,2012-05-22 21:40:29
250,2012-05-22 19:32:11,"@ryanstevens Wanna PR us this change? I'll pull it. :D
",jfhbrook,2012-05-22 21:40:29
250,2012-05-22 19:44:04,"https://github.com/nodejitsu/node-http-proxy/pull/251
",ryanstevens,2012-05-22 21:40:29
250,2014-12-16 12:53:18,"Actually because of that, the code under FAQ ""How to force SSL"" is not working and causes infinity loop as req.get('X-Forwarded-Proto') !== 'https' always returns false (because it's http,https).
",grabbou,2012-05-22 21:40:29
250,2014-12-16 17:27:49,"@grabbou make sure you are using the 1.x.x version of http-proxy
",jcrugzz,2012-05-22 21:40:29
250,2014-12-17 14:07:20,"@jcrugzz thanks for the response, how can I check/change that on nodejitsu? Command line / packages.json settings?

For now I only have node engine specified. Actually, I think that forcing SSL's should be done by default if one specified SSL certificates in Nodejitsu dashboard (as it's the only reasonable approach to be honest)
",grabbou,2012-05-22 21:40:29
250,2014-12-17 16:56:37,"@grabbou if this is about the nodejitsu product please open a support ticket, this is the wrong context for this conversation.
",jcrugzz,2012-05-22 21:40:29
250,2014-12-19 07:34:21,"ok, thanks
",grabbou,2012-05-22 21:40:29
249,2012-05-21 18:40:04,"Do not keep a reference of the req object through the
req.headers object. Create a copy of the headers object instead.

Could you maybe check this? I'm trying to use node-http-proxy in a production env. but in 30 minutes and 200 req/s the app is out of memory. I tried to profile the app with node-webkit-agent. I suspect the following line to be part of the problem. I'm not 100% sure...

Best Regards
Philipp
",booo,2012-08-08 00:41:17
248,2012-05-18 21:03:16,"Node: v0.7.6
http-proxy: v0.8.0 (via NPM)
MacOS

Problem:

RoutingProxy.prototype.proxyRequest modifies the 'options' parameter by adding new properties to the object. This is unexpected and leads to unintended consequences as described below. I was expecting the API to not modify the options parameter. 

Scenario:

I have a single node process that runs two reverse proxies on two different TCP ports: an HTTPS->HTTP proxy and HTTP->HTTP proxy. The two reverse proxies use two instances of RoutingProxy, but the data structure that defines routing rules is shared between the two proxies. Specifically, the object instance I pass as 'options' parameter to RoutingProxy.proxyRequest has a global lifetime. What I notice is that whenever the first routing request is HTTPS, the modifications RoutingProxy.proxyRequest makes in the 'options' parameter cause subsequent HTTP routing requests to fail. It appears that the RoutingProxy is picking HTTPS module instead of HTTP to make the outbound request to the backend. 
",tjanczuk,2013-03-09 07:21:37
248,2012-05-18 21:22:24,"Could you create a failing test that replicates the issue?
",Marak,2013-03-09 07:21:37
248,2012-05-18 21:32:21,"It would be something along these lines:

<S_CODE_TOKEN>
",tjanczuk,2013-03-09 07:21:37
248,2012-05-18 21:39:05,"I'm not sure what you are trying to say with that code snippet. It not runnable and contains method names not in `http-proxy`, i.e. `proxy.routeRequest`.

You mentioned the issue only occurs when you have two proxies? I see only one in that demo.

I want to help you, but without an adequate test to replicate the issue, there is little I can do. 
",Marak,2013-03-09 07:21:37
248,2012-05-18 21:47:23,"The method name should have been `proxyRequest` not `routeRequest`, fixed it inline. 

The snippet simplifies my scenario to the barebones without introducing the complexity of a second proxy. The key point is that the `route` object passed to `proxyRequest` should not have any new members added to it by `proxyRequest`. I am finding it not the case. 
",tjanczuk,2013-03-09 07:21:37
248,2012-05-18 21:52:00,"Without more information, I can make a guess. 

If you are seeing `options` being modified when it shouldn't, would it be possible to solve this if you declared your options in two different variables. Using each options hash for each server?
",Marak,2013-03-09 07:21:37
248,2012-05-18 22:02:21,"Yes, the issue has a very simple workaround once you identify it. It just took me 4 hours of pulling my hair out before zeroing in on the issue, so I thought a fix in http-proxy could save this time for others. As far as I could tell one place that adds members to the instance is https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/routing-proxy.js#L87. 
",tjanczuk,2013-03-09 07:21:37
248,2012-05-18 22:26:25,"I think I got it now. 

Maybe we can just create a new object internally and copy all the options props so this won't happen?

What do you think? 
",Marak,2013-03-09 07:21:37
248,2012-05-18 22:58:32,"Either that or wrap the options I am passing you and make sure they remain immutable while you can add whatever state you need to the wrapper object. The former is probably less intrusive to the code base, the latter probably easier on the garbage collector.  
",tjanczuk,2013-03-09 07:21:37
248,2012-05-19 19:50:13,"Yeah, could just clone the options object, like `options = utile.clone(options);`.
",coderarity,2013-03-09 07:21:37
248,2012-05-20 03:55:22,"Yes, probably better to just clone the object inside http-proxy so that the passed in options don't get modified. 
",Marak,2013-03-09 07:21:37
248,2012-05-21 17:44:26,"So the immutability of the `options` object is preserved for every call to `RoutingProxy.prototype.proxyRequest` and `RoutingProxy.prototype.proxyWebSocketRequest` **except the first one.** With that in mind the following:

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/routing-proxy.js#L205-207 
(and)
https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/routing-proxy.js#L242-244

should be:

<S_CODE_TOKEN>

@chjj I'd prefer not to bring the entire `utile` dependency for a single method which we could better implement specifically for this task.
",indexzero,2013-03-09 07:21:37
247,2012-05-17 19:43:59,"While readme suggests that path based proxying can't be used with Host header, and that's why Host is only used with host based routing, there is nothing stopping us adding the Host HTTP header for each request, from the target host, to ensure virtualhost targets still work as expected.
",1stvamp,2012-06-09 19:57:41
247,2012-05-18 00:54:42,"+1
",thefosk,2012-06-09 19:57:41
247,2012-05-18 00:57:08,"+1
",sonicaghi,2012-06-09 19:57:41
247,2012-05-21 17:47:26,"I don't like this because it no longer makes the proxy transparent (i.e. we are adding headers that were not sent along in the original request).

I'm willing to hear more arguments to convince me.
",indexzero,2012-06-09 19:57:41
247,2012-05-22 09:44:15,"@indexzero I can see your point, although I would argue that supporting a standard method for HTTP stream aggregation, even in most ""transparent"" proxies is worth bending the rules.

Would this be perhaps acceptable as an option?
Alternatively I might have a go at making this work with the start event, but for some reason I couldn't make it work when I tried it.
",1stvamp,2012-06-09 19:57:41
247,2012-05-31 00:33:41,"Yeah, @indexzero is right, we shouldn't add headers by default. Maybe only set it when the `changeOrigin` option is set, as in nodejitsu/node-http-proxy#247.
",coderarity,2012-06-09 19:57:41
247,2012-06-09 19:57:41,"Closing in favour of previously unnoticed pull req by @CodeRarity #231
",1stvamp,2012-06-09 19:57:41
246,2012-05-17 03:52:05,"Returns the proxy object so we can call the close method. Maybe it should be possible to set a flag that will automatically do it?
",tellnes,2012-07-22 06:33:07
246,2012-06-20 15:12:31,"Maybe it should close it automatically and not return the proxy at all? I think that it's abstracting away the `HttpProxy` objects so it should continue to hide that complexity and close the proxy itself.
",coderarity,2012-07-22 06:33:07
246,2012-06-20 23:19:12,"If I remove a proxy does not mean I want to end all active connections to the server. It just mean I want no more connections to the server.
",tellnes,2012-07-22 06:33:07
246,2012-07-22 06:33:04,"lgtm.
",indexzero,2012-07-22 06:33:07
245,2012-05-15 02:45:26,"Small patch to detect if a route path begins with a slash (/) and if so treat it as a path only route, e.g. we don't care about routing via hostname.

This because for our own purposes we only need to route from a single thin layer server, with paths defining routing (e.g. /bar => bar.example.com, /baz => baz.example.com, /foo/test?q= => foo.example.com/test?q= etc.).

Given the simple slice and match required I think this should make a negligible production performance difference and there must be other peeps out there with this use case.
",1stvamp,2012-07-22 06:52:23
245,2012-07-22 06:52:23,"The implementation here has changed significantly since this was originally implemented. Still open to the feature, but you will need to pull and re-implment.
",indexzero,2012-07-22 06:52:23
244,2012-05-13 20:18:40,"Each of the various examples in the `README` all seem to use the API in very different ways so I'm having trouble figuring out how to use `http-proxy` in a way that isn't explicitly spelled out in the there. My goal is to have an internal HTTP(S) server that proxies requests to another HTTPS server outside of our network. I also need to perform custom logic on each request. We don't have a hard requirement to use HTTPS internally (versus HTTP) so I'll likely use whichever is simpler.

Thanks!
",bloudermilk,2012-05-19 19:39:38
244,2012-05-13 22:15:11,"I would just use [this](https://github.com/nodejitsu/node-http-proxy#setup-a-stand-alone-proxy-server-with-custom-server-logic), it's the easiest way to do it.
",coderarity,2012-05-19 19:39:38
244,2012-05-13 22:33:14,"Thanks, @CodeRarity. Any idea what it would look like with an HTTPS proxy?
",bloudermilk,2012-05-19 19:39:38
244,2012-05-13 22:41:18,"It should be very similar. I want to say that you just need to add `https: true` to the target options object for `proxyRequest`, but you might also have to add an `agent` option to that. I would just try it with `https: true`, and I imagine it will work just swimmingly.
",coderarity,2012-05-19 19:39:38
243,2012-05-11 14:02:48,"Trying to do a straight up `npm install -d` give me this trash:

<S_CODE_TOKEN>

Ugh, what a mess. Narrowed down the problem to socket.io@0.6.18. If install socket.io@0.6.17 first, then do `npm install -d`, everything's gravytown.

You should probably hardcode 0.6.17 in `package.json` for now, but do you want me to look at potentially updating the tests to the latest stable versions of the packages (~0.9.6 for socket.io, ~2.9.202 for request)?
",brianloveswords,2012-06-05 23:37:05
243,2012-05-11 14:34:37,"Yeah, seriously. I'm working on upgrading tests to Socket.io 0.9.x.
",coderarity,2012-06-05 23:37:05
243,2012-05-11 14:57:55,"@CodeRarity Awesome dude. You want me to try to tackle `request` or are you handling that as well?
",brianloveswords,2012-06-05 23:37:05
243,2012-05-17 20:08:39,"FYI #233 has a change hard-coding to 0.6.17 until 0.9.x is supported
",bts,2012-06-05 23:37:05
242,2012-05-09 21:26:47,"Should be a one line fix here: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/routing-proxy.js#L94

<S_CODE_TOKEN>
",indexzero,2012-06-15 16:02:57
242,2012-05-09 21:27:00,"@CodeRarity Can you tackle this?
",indexzero,2012-06-15 16:02:57
242,2012-05-09 21:29:37,"I already did. nodejitsu/node-http-proxy#216
",coderarity,2012-06-15 16:02:57
241,2012-05-08 04:04:29,"for hostname only routing:
- a default route '*' is used for a host that is not listed, or a request with no host headers
- a route can be returned by the proxy directly, for example a custom 404 page (in the router):

<S_CODE_TOKEN>

I guess you could do redirects, 500s and all sort of interesting things
",haraldrudell,2012-07-22 06:52:53
241,2012-07-22 06:52:53,"The implementation here has changed significantly since this was originally implemented. Still open to the feature, but you will need to pull and re-implment.
",indexzero,2012-07-22 06:52:53
240,2012-05-02 12:36:25,"I can create a proxy that does a single route as per the examples **BUT** I need to create multiple routes and I cannot figure out how to do it.

I've tried a variety of options but I cannot get the https, target and router options to work together.

Can anyone help please?
",TotallyInformation,2012-07-22 06:16:21
240,2012-06-20 04:31:12,"+1
",martindale,2012-07-22 06:16:21
240,2012-06-20 15:19:59,"Are you using a `RoutingProxy`? That's probably what you're looking for, you can reverse proxy to any address you want with `proxyRequest` on a `RoutingProxy`.
",coderarity,2012-07-22 06:16:21
240,2012-06-20 15:26:01,"You mean the callback yes?

I know that I can do that. The issue is that the documentation implies that the routing TABLE option should work with HTTPS and it doesn't it only works with HTTP. I don't want to have to hand-craft a proxy, I might as well use a more mature, non-Node tool in that case. On the other hand, it would be great to have all of this in Node.
",TotallyInformation,2012-07-22 06:16:21
240,2012-06-20 15:27:18,"Oh, you're saying that you want some routes in the table to do HTTPS and some to do HTTP?
",coderarity,2012-07-22 06:16:21
240,2012-06-20 15:47:31,"Can you provide an example of what you want to do with actual code? That'd help a lot.
",coderarity,2012-07-22 06:16:21
240,2012-06-20 17:14:44,"Example of this case, see the comment about options.router

<S_CODE_TOKEN>

Additionally, doing load balancing with routing does not appear to be possible, as the third parameter of the createServer callback appears to be a buffer, and not a proxy:

<S_CODE_TOKEN>

I suppose one could chain the http-proxy instances together, but that adds extra layers of handshaking and thus additional and undesired latency.
",martindale,2012-07-22 06:16:21
240,2012-06-21 08:55:06,"re comment about mixed connections: actually, I'd be happy just to be able to to all HTTPS though mixed would certainly be an advantage.

The use-case I have is putting up a number of services from a single VPS that need to be accessible from behind a firewall that I'm not allowed to change and that only has a severely limited number of ports open. Namely, 80, 443, 8000 and 8080. Worse still, ports 80, 443 & 8080 are already in use with other services.

So I need to be able to reverse proxy these services onto either virtual folders (e.g. https://foo.com:8000/svc1, https://foo.com:8000/svc2, etc.) or onto sub-domains (e.g. https://svc1.foo.com:8000/, https://svc2.foo.com:8000/)

I might have 1/2 dozen or even more of these services given the way that Node works so I'm looking for something that is easy to reconfigure as the services change.
",TotallyInformation,2012-07-22 06:16:21
240,2012-07-22 06:16:21,"This is fixed in the `0.8.2` branch. Specifically in 55286a7c499c0fe267f75d8e8441ff89f1e65f99
",indexzero,2012-07-22 06:16:21
239,2012-05-01 09:22:58,"I may not understand things to well, but what I am trying to accomplish is to create a HTTP server that gets it's data from a HTTPS source.

I have this:

var http = require('http'),
    httpProxy = require('http-proxy');

// Create a proxy server with custom application logic
httpProxy.createServer(function (req, res, proxy) {
  proxy.proxyRequest(req, res, {
    host: 'secured.host.com',
    port: 80,
  });
}).listen(8001);

Which works except that I get the message that my requests are not secured. I've tried adding all sorts of parameters, but I simply can't figure it out. Can anyone modify this request so that it pulls it's data over HTTPS? 
",tjeerdkramer,2012-05-01 17:39:27
239,2012-05-01 17:39:27,"This is how to proxy from HTTPS to HTTP. 

https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-https-to-http.js
",Marak,2012-05-01 17:39:27
238,2012-04-30 10:56:05,"it's useful some where.
",hackwaly,2012-05-09 20:56:34
237,2012-04-27 23:54:29,"Setup: socket.io client in chrome browser connects to http-proxy which forwards to socket.io server. The connection is setup using websocket, and functionally everything works well. http-proxy version 0.8.0, socket.io version 0.9.6, node version 0.6.8.

Problem: http-proxy sends a flood of TCP keep-alives to the client, at a rate of about 30 per sec (!). This was confirmed using wireshark. In the test, the websocket connection is kept open but it is otherwise completely idle, we send no messages over it. 

Attempted fix: proxyHttpServer.on('upgrade', function(request, socket, head) { socket.setKeepAlive( false); ...}. Unfortunately this has no effect, and the keep-alives keep on getting sent at high rate.
",jkorycki,2015-10-30 20:47:24
237,2012-04-27 23:58:32,"That doesn't sound good. I have a feeling this might be due to something specific in your environment. 

Could you possibly post your logs or a minimal reproducible case of code we can run?

Thanks!
",Marak,2015-10-30 20:47:24
237,2012-04-30 23:01:18,"I created a very simple repro sample. Can you let me know where to post it? 

Note: the issue occurs on Windows, using node.exe. It works fine on Unix (tested on Mac).
",jkorycki,2015-10-30 20:47:24
237,2012-04-30 23:04:32,"Just windows! Hrmm....I wonder if this could be a core issue. 

Just post a link to the gist here.
",Marak,2015-10-30 20:47:24
237,2012-04-30 23:22:13,"Gist link: https://gist.github.com/2563580

This problem disappears when http-proxy is bypassed, i.e. client connects directly to socket.io. I contacted also node developers at Microsoft, and got the following response:

""This sounds like a Windows-specific issue with http-proxy.  By default, we don‚Äôt send keep-alive packets in node core.  Most likely http-proxy enables keep-alive (using http://nodejs.org/api/net.html#net_socket_setkeepalive_enable_initialdelay). ""
",jkorycki,2015-10-30 20:47:24
237,2012-05-01 23:43:47,"I did dome more digging. The problem is with setting the keepalive on a socket in proxyWebSocketRequest() in a helper function _socket(). On Windows this results in the keepalive flooding, on Mac no such issue. For the purposes of my application, which already has a heartbeat in socket.io layer, the fix is to reset the keepalive after proxyWebSocketRequest():

 proxyHttpServer.on('upgrade', function(request, socket, head) {
    logger.debug('upgrade ' + request.url);
    proxy.proxyWebSocketRequest(request, socket, head, getRoutingTarget(request));
    socket.setKeepAlive(false, 0);
  });

I think this is something that can still be improved in http-proxy, maybe in the documentation, since someone else that makes use of http-proxy on Windows in conjunction with websocket will surely run into this problem again.
",jkorycki,2015-10-30 20:47:24
237,2012-05-07 21:05:44,"Any thoughts on this issue by anyone?
",itay,2015-10-30 20:47:24
237,2015-10-30 20:47:24,"No longer relevant, closing due to old age.
",jcrugzz,2015-10-30 20:47:24
236,2012-04-24 20:44:23,"I'm trying to access the headers that are passed back from the proxied server and I can't find a way to access them. I tried accessing the response object on the 'end' event emitted from the RoutingProxies internal HttpProxy:

<S_CODE_TOKEN>

Is there no way to accomplish this currently or am I overlooking something?
",jrolfs,2013-03-09 07:06:59
236,2012-04-25 09:55:16,"I am having a similar issue, the cookies I am sending in response are not received when I am using the proxy.
",madhums,2013-03-09 07:06:59
236,2012-04-25 15:45:43,"I managed a hack of a solution for this. You'll need to use the my fork of node-http-proxy and something along the lines of this: https://gist.github.com/2490760. Keep in mind I am fairly new to Node.js and either way this server should not be used in production or anything critical as I have only done minimal testing and have just been using it as a development server.
",jrolfs,2013-03-09 07:06:59
236,2012-04-28 00:11:37,"The problem with `response.getHeader` is that the header has to be ""queued but not sent to the client."" You essentially need to get `response.headers` from inside the reverse proxy, but I don't think that's in the API at this time.
",coderarity,2013-03-09 07:06:59
236,2012-04-28 00:12:43,"Yeah if you look at my fork, I exposed them. If that is a desired feature I would be happy to fully flesh it out and document it.
",jrolfs,2013-03-09 07:06:59
236,2012-05-24 01:51:04,"+1 for this - it'd be very useful for me to be able to read/write the response headers before returning them to the client
",joshkoenig,2013-03-09 07:06:59
236,2012-05-24 03:43:53,"Awesome, there's some interest! haha. I'd be more than happy to discuss an ideal solution for exposing this stuff.
",jrolfs,2013-03-09 07:06:59
236,2012-07-11 01:00:30,":+1:
",crossman,2013-03-09 07:06:59
236,2012-07-11 16:40:02,"+1
",madhums,2013-03-09 07:06:59
236,2012-08-03 23:43:54,"+1 and statusCode would be great as well.
",blahed,2013-03-09 07:06:59
236,2012-08-19 01:50:42,"+1 but @jrolfs, I just installed from your fork and you have some conflict markers checked in.

https://github.com/jrolfs/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L292
",jshirley,2013-03-09 07:06:59
236,2012-08-19 02:42:14,"Hey, sorry about that. It was a while ago when I was working with this.
I'll take a look at the conflicts I checked in O_o. Ultimately I want to
come up with a way to expose the headers consistent with the node/express
API. I'll try and do that soon.
",jrolfs,2013-03-09 07:06:59
236,2013-03-09 07:06:59,"Fixed in #356 
",indexzero,2013-03-09 07:06:59
235,2012-04-24 07:27:01,"Hi, 

I struggled to debug an `Error: getaddrinfo ENOENT`.

I parsed my target string with `url`

<S_CODE_TOKEN>

And pass this object to `node-http-proxy`. 

Then the following code is executed : 

<S_CODE_TOKEN>

But host === '127.0.0.1:3000', and it fails.

That's why I would prefer 

<S_CODE_TOKEN>

because hostname always === '127.0.0.1'

This is also a nodejs recommendation: 

http://nodejs.org/api/http.html#http_http_request_options_callback

> host: A domain name or IP address of the server to issue the request to. Defaults to 'localhost'.
> hostname: To support url.parse() hostname is preferred over host
",Filirom1,2012-07-22 06:31:35
234,2012-04-24 07:20:57,"I have an apache server running on port 82.

<S_CODE_TOKEN>

when i request   http://www.xxxx.com/a/b
it always redirect to http://www.xxxx.com:82/a/b
Because of firewall. it will failed.
why port 82 will be shown up?
",zzswang,2012-06-05 23:19:44
234,2012-04-28 00:02:32,"huh, that's weird, it definitely shouldn't redirect in your browser. That would require sending back a 300 redirect and stuff, which is a little crazy, are you sure apache isn't sending back a 300 redirect?
",coderarity,2012-06-05 23:19:44
234,2012-04-28 15:18:25,"I am not very familiar with apache. 
Once I used nginx as front. it can work well with apache2. 

Also I google it, and find there are same issues about this. like
http://comments.gmane.org/gmane.comp.lang.javascript.nodejs/22110
",zzswang,2012-06-05 23:19:44
234,2012-04-28 16:00:32,"Yeah, that's what I thought. Apache is sending back a redirect, like that guy says in that thread you sent. In that thread, he did state the solution:

> I've found that the port number only appears when the URL points to a
> directory but lacks a trailing slash. This means that I can write some
> Node.js code to check the URL and, if necessary, do a 301 redirect to
> a fixed URL. I haven't had time to implement this yet, but I think it
> will solve the problem.

(indexzero also provided an example in response to that, check it out [here](https://gist.github.com/945283))
",coderarity,2012-06-05 23:19:44
234,2012-05-04 02:22:06,"thank you, i use another ip address for apache2. So currently my problem is resolved. 
",zzswang,2012-06-05 23:19:44
233,2012-04-19 01:51:02,"- socket.io 0.6.18 seems to be broken:
  
  <S_CODE_TOKEN>

Here are some others affected by this issue: https://gist.github.com/2387930
",bts,2012-04-19 02:02:20
233,2012-04-19 01:57:59,"This is until node-http-proxy is ready to move to socket.io >= 0.7, which doesn't seem to currently be the case
",bts,2012-04-19 02:02:20
233,2012-04-19 02:02:20,"socket.io is a devDependency used for testing

the error you posted looks like npm error, try `npm cache clean` also, upgrade to latest npm. 
",Marak,2012-04-19 02:02:20
233,2012-04-19 02:15:05,"npm is pulling down socket.io as a devDependency because I'm trying to make some changes to this project. `npm cache clean` doesn't fix my problem unfortunately. upgrading npm though, does shed some more light on the root cause in the form of expanded error information:

<S_CODE_TOKEN>

socket.io-client has vendored ""uglifyjs"" which contains an improperly-formatted .json file:

<S_CODE_TOKEN>
",bts,2012-04-19 02:02:20
233,2012-04-19 21:00:12,"I'm also stuck on this.  I'm using npm version 1.1.18.  @Marak is there something socket.io 0.6.18 provides that socket.io 0.6.17 does not?
",gordoncww,2012-04-19 02:02:20
232,2012-04-15 09:37:24,"I've noticed there is currently no support for paths on the target host in a Proxy Table: 

<S_CODE_TOKEN>

The first route will work, but the second and third will hang on the '/appB' and '/appC' part behind '127.0.0.1:9090'. I sometimes have multiple apps in the same servlet container that I wish to proxy. I was able to do that in a Apache reverse proxy configuration and I hoped to be able to do the same with node. 

Is any support for this planned? 
",rigolepe,2012-06-06 06:59:45
232,2012-04-18 18:40:31,"Yeah, a lot of people have asked for this. I have a pull request open that would allow it, see nodejitsu/node-http-proxy#218
",coderarity,2012-06-06 06:59:45
232,2012-06-05 23:19:04,"@rigolepe 0.8.1 is out, can you test it again to see if still its an issue. Thanks
",cronopio,2012-06-06 06:59:45
232,2012-06-06 06:59:45,"Works as a charm :) 

I was using CodeRarity's fix before, but now 0.8.1 does the job as well. Thanks! 
",rigolepe,2012-06-06 06:59:45
231,2012-04-13 22:57:34,"This was reverted a long time ago. I don't know why, because nobody explained it. I added it back, as it seems necessary looking at nodejitsu/node-http-proxy#150. There seemed to be some discussion saying it was unnecessary, but note that was before it used the changeOrigin option. This shouldn't change anything for anyone not using changeOrigin. If there's a reason to not use it, please document it this time. Thanks!
",coderarity,2012-07-22 06:24:37
231,2012-04-16 21:41:58,"+1 would really like to see this pulled in
",johnsheehan,2012-07-22 06:24:37
231,2012-04-23 20:06:43,"+1

I'm writing a simple Node+CouchDB backend for a client-side single-page webapp (a learning game).

One of the backend's jobs is to reverse-proxy two legacy services we provide via Apache name-based virtual hosts. Without @CodeRarity's patch, the name based virtual hosts will not respond. Setting X-Forwarded-For is not sufficient. 

Thanks...
",rklancer,2012-07-22 06:24:37
231,2012-04-26 22:21:24,"+1
",abernier,2012-07-22 06:24:37
231,2012-06-08 17:15:49,"+1
",thefosk,2012-07-22 06:24:37
231,2012-06-09 19:56:55,":+1:
",1stvamp,2012-07-22 06:24:37
231,2012-06-09 19:58:12,"#247 also got 3 or 4 +1's before I closed it in favour of this one.
",1stvamp,2012-07-22 06:24:37
231,2012-07-19 16:57:01,"I would also like to see this pulled in.
",adrianlee,2012-07-22 06:24:37
231,2012-07-22 06:24:37,"Cherry-picked. Thanks.
",indexzero,2012-07-22 06:24:37
230,2012-04-13 02:36:13,"Does node-http-proxy support HTTP CONNECT requests, like:

<S_CODE_TOKEN>

The proxy would then maintain the two connections, and forward the SSL traffic between the client and the target server.

If so, how do I set this up?

Thanks
",tonygambone,2012-04-14 01:19:44
230,2012-04-13 18:20:27,"I don't know too much about HTTP CONNECT requests, but it looks like you can do this. You just need to change the method to a GET request when forwarding it to the target server. Here's a (basic) example:

<S_CODE_TOKEN>

(You can add your proxy's SSL certificate to the createServer function, see the documentation.)

From what I can see, an HTTP CONNECT request can be used with any type of TCP/IP tunnel, but node-http-proxy should only be used to proxy to another HTTP(S) server.
",coderarity,2012-04-14 01:19:44
230,2012-04-14 01:19:44,"Thanks - I'll try that, it looks closer to the mark than what I was trying.  

The proxy shouldn't need an SSL cert - it should establish a connection to the remote server and port, and then from that point on it's just a plain network proxy, forwarding data back and forth.  Not really HTTP at all, or as you say, just a generic TCP tunnel.  

It's what a browser would send if it were connecting to an SSL site through a proxy - like in a corporate environment.  I'm trying to write a proxy server that can handle both - so maybe the trick is to look for that CONNECT method, and if so set up a tunnel under a different code path, and use node-http-proxy for regular HTTP.

Thanks for your help.
",tonygambone,2012-04-14 01:19:44
230,2012-04-14 01:25:15,"The proxy's SSL certificate would be for the client connecting to the proxy, not for the proxy connecting to the server. If you just wanted it to be HTTP between the client and the proxy, then you wouldn't need an SSL certificate.

I mean, if you just want to proxy TCP sockets (like the net module), that's beyond the scope of node-http-proxy at this point - it's just an HTTP proxy. But as you said, you should probably set up a tunnel using a different code path, and just use node-http-proxy for the HTTP stuff.
",coderarity,2012-04-14 01:19:44
230,2012-04-19 17:07:57,"Just wanted to update this with some working code:
https://gist.github.com/2422322

It uses node-http-proxy for regular HTTP and sets up a tunnel for CONNECT requests.

This works well, although there are some occasional ETIMEDOUT errors (which I'm not sure is the fault of the proxy, or if they would have timed out anyway).

Thanks for the help, very nice project you've made here.
",tonygambone,2012-04-14 01:19:44
230,2012-04-19 17:10:42,"cool! Interesting that it send an upgrade event for CONNECT requests, although I guess it makes sense.
",coderarity,2012-04-14 01:19:44
230,2012-04-19 17:25:40,"Yes, that was the key - I found that in the http module source code.  It looks like 'connect' should work too, but it didn't for me.
",tonygambone,2012-04-14 01:19:44
230,2012-12-30 16:51:37,"@mogrify: This was really helpful. Thank you! I guess the connect module changed because now the 'connect' event works but 'upgrade' does not.
",rbdixon,2012-04-14 01:19:44
229,2012-04-11 20:16:22,"It would be nice to have some documentation showing how to make an HTTPS proxy use different SSL certificates for different hosts. It's something I've been trying to make work, but have not yet found a way.
",nlf,2012-07-22 06:18:23
229,2012-04-11 20:21:14,"You probably have to create a different `HttpProxy` object for each host for which you want to have a different SSL certificate.
",coderarity,2012-07-22 06:18:23
229,2012-07-22 06:18:23,"Fixed in #275
",indexzero,2012-07-22 06:18:23
228,2012-04-11 05:39:10,"This is just a simplification of the code really - I removed a lot of code that was just pretty much a copy of `stream.pipe`, and used `stream.pipe` instead.

I also removed a test that caused a bunch of subsequent tests to fail. The reasoning for this removal was that the test _shouldn't_ pass. In the case that it was testing, it was aborting the connection, which in turn caused the proxy to abort the connection. Since this happened before the target server received any data, the test would hang, waiting for the connection to be made. `http.request` didn't send the data since it was aborted too early. The only way I can think of fixing this is to abort the request (without this other tests would fail), and then send a 'dummy' request so that the test passes. Since this is obviously the inappropriate behavior, and since I wanted to be able to use the subsequent tests, I removed the test in this pull request.

This leaves one more test that doesn't pass. This isn't any different from the master branch - a test is failing because the connection object has a circular reference, and assert.equal uses `JSON.stringify`. I'm not sure why the connection object has a circular reference, and if this is because of inaccurate behavior, so I left it alone.
",coderarity,2012-05-09 20:47:47
228,2012-05-09 20:47:47,"We can't use pipe. It will crash the node processes. This is why we `try {} catch (ex) {}` around most attempts to write back to things.
",indexzero,2012-05-09 20:47:47
228,2012-05-09 20:48:43,"I don't think that applies anymore in node v0.6, that's why this pull request was made. @AvianFlu do you know more about this?
",coderarity,2012-05-09 20:47:47
228,2012-05-11 07:54:21,"Maybe I'm wrong. @isaacs is the man to summon here if you want a more detailed explaination. He put in the `try {} catch (ex) {}` blocks after some dilligent production debugging.
",indexzero,2012-05-09 20:47:47
228,2012-05-11 14:41:54,"In my opinion, it'd be good to hold off on removing the try/catch blocks until we get the stream api cleaned up in node 0.9.

At that point, we'll revisit this use case explicitly, and probably add a bunch of tests that try to reproduce the production problems we were seeing.  The goal is definitely to make node-http-proxy a much smaller module. :)
",isaacs,2012-05-09 20:47:47
228,2012-05-20 18:17:50,"I use this patch to fix the problem where node-http-proxy over uses memory.
",uberscientist,2012-05-09 20:47:47
228,2012-05-21 17:28:09,"@naked That's a good point. We should remove the event listeners when these things emit `end` or `close` events.
",indexzero,2012-05-09 20:47:47
227,2012-04-10 06:58:29,"I am using node-http-proxy with the following code:

<S_CODE_TOKEN>

Currently, this is breaking my omniauth for facebook. When I click ""login with facebook"" on my site,

I am 404'ed with the following url in my url bar:

<S_CODE_TOKEN>

Another attempt at this will produce port 49602. Which is extremely weird as I was testing my site on http://mysite.com. Where does the random port come from?

I have decided to test what is causing this, so I wget to see the url redirection:

<S_CODE_TOKEN>

If I remove the port from the url, I am actually able to login. Anyone know why I am seeing this random port being inserted into my url?
",vicngtor,2015-10-30 20:46:52
227,2012-05-09 20:58:22,"Not sure. Could be a Facebook issue behind proxies.
",indexzero,2015-10-30 20:46:52
227,2013-03-09 07:11:12,"This looks related to #341 and you're getting the ephemeral port.
",indexzero,2015-10-30 20:46:52
227,2015-10-30 20:46:52,"No longer an issue.
",jcrugzz,2015-10-30 20:46:52
226,2012-04-09 08:34:35,"Hi,

I've got an express & socket.io server running, and got node-http-proxy in front of it. 
When I do this:

var server = httpProxy.createServer(function (req, res, proxy) {
        proxy.proxyRequest(req, res, {
          host: '127.0.0.1',
          port: '3000'
        })
  }).listen(8080, '[snip]');

Then it does not seem to proxy websockets. Now the README has something to say about that, but I'm confused - should or shouldn't this work out-of-the-box in my case? 

When using the example going with the README, it works fine.. However, that example sets up a specific HttpProxy object in combination with a regular http.createServer(). But I really want to stick to the httpProxy.createServer(), and I do not see how to do that.

Any thoughts?
",wellawaretech,2012-04-09 11:27:53
226,2012-04-09 11:27:47,"There're two ways to proxy websocket requests with `.createServer(...)` API:
1. https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L184 <- do not use request handler (callback), provied target server's address as argument of `.createServer`
2. Listen for `upgrade` event on `server` object in your example and do `server.proxy.proxyWebSocketRequest(req, socket, head);`
",indutny,2012-04-09 11:27:53
226,2012-04-09 12:54:42,"Alright, got it to work after your suggestions, thanks. But maybe there's room for improvement, in case I'd love to hear more.

There are several websites running on multiple ports on the same server, the proxy should route these including support for websockets, but there are also other things happening such as redirection. So there's a server instantiated via httpProxy.createServer(), which based on req.headers.host will take appropriate action.

Then there's an extra listener for the upgrade event. There again is checking of the req.headers.host, and then the proxyWebSocketRequest is called with additional options specifying the target.
",wellawaretech,2012-04-09 11:27:53
226,2012-07-18 15:52:47,"sorry, typo in the issue number, I meant 266.
",bkw,2012-04-09 11:27:53
225,2012-04-03 07:28:58,"I've added missing {} and call server.listen().
",darashi,2012-04-03 07:34:11
225,2012-04-03 07:32:04,"lgtm!
",jfhbrook,2012-04-03 07:34:11
224,2012-04-03 03:21:47,"Some libraries such as socket.io can fall back Flash based sockets when the client does not support WebSockets. To achieve this, the client's Flash program first needs to request a 'socket policy file' from the server. This request consists of a self-closing XML node followed by the null byte sent over raw TCP:

<S_CODE_TOKEN>

node-http-proxy will drop this request, causing the Flash socket connection to fail.
",rthais,2012-05-31 15:07:58
224,2012-04-11 20:27:52,"Just run this wonderful thing [here](https://github.com/3rd-Eden/FlashPolicyFileServer) on your proxy server! Pretty much, it looks like this:

<S_CODE_TOKEN>

And then all of your problems should be solved, almost like magic. (Socket.io uses this library for it's Flash Policy File Server as well)
",coderarity,2012-05-31 15:07:58
224,2012-05-31 14:28:42,"@rthais Works this lib for you?

@rthais @CodeRarity can we close this?
",cronopio,2012-05-31 15:07:58
224,2012-05-31 15:07:58,"Yes, that works. I think we can close this issue.
",rthais,2012-05-31 15:07:58
224,2012-11-24 01:38:42,"For anyone visiting this thread later with the same question - the code that worked for me is:

<S_CODE_TOKEN>

where `server` is the server you already created via `http.createServer()`.
",konklone,2012-05-31 15:07:58
224,2013-04-02 22:51:52,"does this work today?

There is a problem with non 80 ports on nodejitsu right?
https://www.nodejitsu.com/documentation/a-quickstart/faq/#how-can-i-make-my-app-use-a-port-other-than-port-80

Is there any chance to have it running on nodejitsu?
",nerdyglasses,2012-05-31 15:07:58
224,2015-02-23 00:19:25,"@konklone I followed your instructions for policyfile but I get an error that the address is in use. I have been going in circles with this for a bit. Any help would be greatly appreaciated

<S_CODE_TOKEN>
",dvideby0,2012-05-31 15:07:58
224,2015-02-23 00:35:22,"@dvideby0 It sounds like you might already have an instance of the server running in some other terminal?
",konklone,2012-05-31 15:07:58
224,2015-02-23 02:35:58,"@konklone Unfortunately no and the code I put above fails all on its own (without any other logic). Not sure if there is something additional I am supposed to add but I should probably point this issue to the author. Thank you for the help sir! 
",dvideby0,2012-05-31 15:07:58
223,2012-03-30 22:35:41,"It seems that the previous pull request didn't completely remove the hidden char. 

This should finally fix it. Thanks.
",thefosk,2012-03-30 22:54:22
223,2012-03-30 22:38:39,"Cool, I'll pull it in.
",jfhbrook,2012-03-30 22:54:22
223,2012-03-30 22:55:15,"https://github.com/nodejitsu/node-http-proxy/commit/11315e63faeb9f0d4c7da79406d6ca909739fab5

Thanks!
",jfhbrook,2012-03-30 22:54:22
222,2012-03-30 22:17:05,"Fixed syntax error.
",thefosk,2012-03-30 22:25:15
222,2012-03-30 22:24:01,"Syntax error? This doesn't look like something that would break code..? I could be wrong? Seems more like a stylistic faux pax than anything.
",jfhbrook,2012-03-30 22:25:15
222,2012-03-30 22:25:32,"Merged thanks!
",Marak,2012-03-30 22:25:15
222,2012-03-30 22:26:50,"Actually there was a hidden char after `target`. If you opened it in Eclipse (UTF-8) it showed `this.target¬¨‚Ä†      = {};`

It is just a small fix, probably it was harmless but there's no reason to keep it in the code.
",thefosk,2012-03-30 22:25:15
222,2012-03-30 22:31:04,"> Actually there was a hidden char after target. 

Whoa! That's bizarre.

> It is just a small fix, probably it was harmless but there's no reason to keep it in the code.

Oh, I didn't meant to, like, defend the current code or anything. Marak just beat me to pulling this in. Really I agree with him; I just talk too much. ;)

Thanks again!
",jfhbrook,2012-03-30 22:25:15
221,2012-03-30 19:42:48,"This is a basic example for using the connect-gzip middleware with a `ProxyTable`. See nodejitsu/node-http-proxy#212.
",coderarity,2012-07-22 06:55:30
220,2012-03-29 05:04:26,"It would be great to provide some simple Round Robin Load balancing OOB.Like 

 var options =
{
    balance:
    {
        'localhost:'localhost:8181',
        'localhost':'localhost:8182'
    }
};

var proxyServer = httpProxy.createServer(options);
proxyServer.listen(80);
",kul,2012-03-29 05:44:28
220,2012-03-29 05:44:28,"I'm not sure if it's a good idea to include balancing logic in the core module. Balancing should be the responsibility of another library.

I did add a simple http load balancing example to the project. :-)

https://github.com/nodejitsu/node-http-proxy/blob/master/examples/balancer/simple-balancer.js
",Marak,2012-03-29 05:44:28
219,2012-03-29 04:46:29,"Support for caching would be an awesome addition. Something along the lines of nginx

location ~\* .(jpg|png|gif|jpeg|css|js|mp3|wav|swf|mov|doc|pdf|xls|ppt|docx|pptx|xlsx)$ {
        proxy_buffering           on;
        proxy_cache_valid 200 120m;
        expires 864000;
}
",kul,2012-03-29 06:00:07
219,2012-03-29 06:00:07,"I think that this functionality would be best suited in another library that uses `http-proxy` as a dependency. 
",Marak,2012-03-29 06:00:07
219,2012-03-29 13:13:52,"This should be easy to do as a middleware or using a connect middleware like https://github.com/tdebarochez/connect-cache

?
",vvo,2012-03-29 06:00:07
219,2012-03-29 20:24:40,"Awesome suggestion @vvo 

Thanks! i will try this tomorrow.
",kul,2012-03-29 06:00:07
219,2012-03-30 09:04:15,"i have given up on this,

<S_CODE_TOKEN>

The request gets cached and everything works fine but once i do ctrl f5 a few time the connect-cache blows out. i have to say its a sad cache.
",kul,2012-03-29 06:00:07
219,2012-03-30 10:00:16,"`blows out` ?

ctrl+f5 will send out 'cache-control:no-cache' headers which means 'refresh the cache' so there's must be something in the connect cache code to handle this.

Im sure it will work, debug, read the connect cache code.

good luck
",vvo,2012-03-29 06:00:07
219,2012-03-30 10:27:14,"i think i got it..https://github.com/kul/connect-cache/commit/7b4b7a50536b03de7a11b6aa0c2c78eb3f42f24a
",kul,2012-03-29 06:00:07
219,2013-02-20 14:55:43,"@kul how did you get this to work? I can see how using the `connect-cache` middleware allowed the cache to handle it if it is already stored. But if it is not (cache miss), then it just passes through to the proxy, so the results of the proxy do not get cached. How did you ever populate the cache?
",deitch,2012-03-29 06:00:07
219,2013-02-21 03:22:42,"oh i am sorry i deleted the fork by mistake but the original repo had merged the pull request https://github.com/tdebarochez/connect-cache/commit/05bfdc61f0b9720772e48b61624c509a4781b9e2.
So the idea is to treat it as cache miss which is just send to the server and cached for subsequent requests.
",kul,2012-03-29 06:00:07
219,2013-02-21 06:35:58,"I get that it is a cache miss; what I didn't get is how you got the data in the cache in the first place. 

Once you have a cache miss, and you pass it on to http-proxy, how did you intercept the response to add it to the cache?
",deitch,2012-03-29 06:00:07
219,2013-02-21 07:53:47,"I am sorry if i am missing something here, did you try reading the node http proxy's and connect-cache's home page ?
https://github.com/nodejitsu/node-http-proxy#middleware 
https://github.com/tdebarochez/connect-cache#how-it-works
Basically node-http-proxy provides middleware support which are like plugins in node.js world. Caching is taken care by connect-cache from that point onwards. 

I may be a little rusty here, long time since i used node-http-proxy. Apologies.
PS: nginx release websocket support.

:space_invader: 
",kul,2012-03-29 06:00:07
219,2013-09-10 15:37:20,"@deitch Did you happen to work out how to intercept a response?
",philjackson,2012-03-29 06:00:07
219,2013-09-10 16:38:49,"Yeah, I used `http-proxy`, but I wrapped the response. In other words, I have middleware like this:

<S_CODE_TOKEN>

where myMiddleware is like:

<S_CODE_TOKEN>

`wrapResponse` wraps every single send\* and other relevant calls, and caches everything with a particular key

Conceptually simple, in practice was a beast, but works nicely.
",deitch,2012-03-29 06:00:07
219,2013-09-10 17:14:28,"Thanks, @deitch.
",philjackson,2012-03-29 06:00:07
218,2012-03-28 20:38:25,"This fixes nodejitsu/node-http-proxy#215. It changes the method to use url.parse (because it's easier to read, that old stuff took me a while to wrap my head around), and fixes it by replacing the path's part of the URL with the target's part of the URL, instead of just getting rid of it completely.
",coderarity,2012-06-05 20:04:19
218,2012-03-29 17:04:01,"What the... there's something added onto the end of a line! Let me fix that =P
",coderarity,2012-06-05 20:04:19
218,2012-03-29 17:08:04,"There we go =D (I did run tests on this btw, so I probably typed into the wrong window while committing.)
",coderarity,2012-06-05 20:04:19
218,2012-03-31 01:56:49,"Please wait before merging this pull request. I need to add tests and fix a few more cases based on other people's pull requests.
",coderarity,2012-06-05 20:04:19
218,2012-04-11 20:16:25,"There we go, now it can be pulled in. =D
",coderarity,2012-06-05 20:04:19
218,2012-05-09 19:15:42,"Any news on this pull request?
",itay,2012-06-05 20:04:19
218,2012-06-02 11:06:27,"Hey @CodeRarity do you know if this is this going in or not?
",No9,2012-06-05 20:04:19
218,2012-06-02 11:46:58,"Not yet.

On Saturday, June 2, 2012 at 7:06 AM, Anton Whalley wrote:

> Hey @CodeRarity do you know if this is this going in or not?
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/pull/218#issuecomment-6076663
",coderarity,2012-06-05 20:04:19
218,2012-06-02 11:48:16,"Thanks. Any clue what is blocking release? 
",No9,2012-06-05 20:04:19
217,2012-03-28 18:34:26,"This simple proxy server
 <pre>    var httpProxy = require('http-proxy');
     httpProxy.createServer(function (req, res, proxy) {
     var options = {
           host: ""localhost"",
           port: 5984
         };
      proxy.proxyRequest(req, res, options);
     }).listen(5000);
</pre>

if i change host:""localhost""  to  host:""subdomain.domainoninternet.com""
if get 'Host not found'  back,   is this the ""www . host"" issue? https://github.com/nodejitsu/node-http-proxy/issues/150

on a related question, is there a way to set request headers before they are sent to destination?  (to set Auth headers from the server)

thank you
",Agamennon,2012-07-22 06:44:25
217,2012-03-29 17:10:58,"About the request headers: you have access to the req object passed into the `httpProxy.createServer` function.
",coderarity,2012-07-22 06:44:25
217,2012-04-13 22:52:51,"It works for me on master - what domain are you trying to use? Note that it will use the 'Host' header from the original request. (Hopefully this will change soon, so you can just specify ""changeOrigin: true"" to fix things.)
",coderarity,2012-07-22 06:44:25
217,2012-04-13 22:56:08,"http://mydomain.cloudant.com
",Agamennon,2012-07-22 06:44:25
217,2012-04-13 23:05:30,"I see! Let me look into it.
",coderarity,2012-07-22 06:44:25
217,2012-04-14 11:24:49,"It seems like it's not related to nodejitsu/node-http-proxy#150.
",coderarity,2012-07-22 06:44:25
217,2012-04-14 11:29:51,"Oh - you're not using the ""http"" in your `options.host`, are you? It should look like this.

<S_CODE_TOKEN>

(which works for me)
",coderarity,2012-07-22 06:44:25
217,2012-04-18 20:31:54,"i am using  host: ""mydomain.cloudant.com/mydb""   and it is not working  
if i use that url on the browser i get the expected couchdb response,    but node proxy just freezes this request and never comes back 

if a try a different couchdb host like iriscouch  (host: ""mydomain.iriscouch.com""), i get back a ""Host not found""    if i qualify it like host:""mydomain.iriscouch.com/mydb""   i get the same as the first problem
",Agamennon,2012-07-22 06:44:25
217,2012-04-18 20:37:07,"When I go to mydomain.cloudant.com/mydb in my web browser it gives me a 503 error. The ""Host not found"" error, however, is probably related to nodejitsu/node-http-proxy#150. I fixed that issue in my pull request here, nodejitsu/node-http-proxy#231, if you want to try to use my branch and see if it fixes the problem.
",coderarity,2012-07-22 06:44:25
217,2012-07-22 06:44:25,"Looks like this should be fixed from the PR from @coderarity  
",indexzero,2012-07-22 06:44:25
217,2013-04-02 03:48:18,"@indexzero I'm not quite sure how this was fixed, I still can't get a similar proxy usecase to run:

<S_CODE_TOKEN>
",pulkitsinghal,2012-07-22 06:44:25
217,2013-08-03 20:25:13,"FYI, here is how I was able to get this working:

<S_CODE_TOKEN>

Non-obvious, but it works.
",jbeard4,2012-07-22 06:44:25
217,2013-12-14 23:53:48,"Anyone point me to how to fix up mine?

I am running multiple domains off one machine using this proxy, one domain with SSL, the others without.
My current implementation is: https://gist.github.com/brutalhonesty/fe66bf64f95f9d3ccb2d

Can  you tell me what I need to do to get the 'status' subdomain working?

Thanks!
",brutalhonesty,2012-07-22 06:44:25
216,2012-03-28 02:02:31,"Fixes nodejitsu/node-http-proxy#214. This will re-emit more events from RoutingProxy so that you can listen for those events yourself. Be VERY careful for the following case, which will add a new listener for every request:

<S_CODE_TOKEN>

It would be good if we could fix this case! This is a very easy problem to run into!
",coderarity,2012-05-10 16:34:48
216,2012-03-28 02:58:28,"The reason that this case exists is because you only have access to the RoutingProxy inside of the server function. The RoutingProxy never gets recreated between requests, so it will end up adding a new listener every time a request is made. 

One solution to get around this right now is to not use `httpProxy.createServer` at all, instead making your own server, like so:

<S_CODE_TOKEN>

You could also use the `server.proxy` object to do this:

<S_CODE_TOKEN>

I'm not sure how to fix the case with listening for events on the proxy object inside the server function. You could remove the old listener every request, but adding and removing a listener on every request is very inefficient. If it recreated the `RoutingProxy` every request, that would almost be as inefficient. I'm not sure if it's even reasonable to eliminate this case - although it is likely to be a common mistake.
",coderarity,2012-05-10 16:34:48
216,2012-03-28 04:01:22,"+1
",thefosk,2012-05-10 16:34:48
216,2012-03-31 01:00:04,"This last commit fixes many problems people have had with `RoutingProxy` hanging. It will now return a real error from the matched `HttpProxy` to the client. Fixes nodejitsu/node-http-proxy#185 and will provide error information for a bunch of issues that have reported node-http-proxy to be hanging. I added it to this pull request since it changes how I handle some of the event's redirection in the first round of commits.
",coderarity,2012-05-10 16:34:48
216,2012-05-10 05:16:48,"@CodeRarity Looks good to me. Merge at will.
",indexzero,2012-05-10 16:34:48
215,2012-03-27 16:31:39,"I have following setup
$ node -v
v0.6.11
$ npm list
blah/blah/blee/nodex
‚îú‚îÄ‚î¨ express@2.5.8 
‚îÇ ‚îú‚îÄ‚î¨ connect@1.8.5 
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ formidable@1.0.9 
‚îÇ ‚îú‚îÄ‚îÄ mime@1.2.4 
‚îÇ ‚îú‚îÄ‚îÄ mkdirp@0.3.0 
‚îÇ ‚îî‚îÄ‚îÄ qs@0.4.2 
‚îú‚îÄ‚î¨ http-proxy@0.8.0 
‚îÇ ‚îú‚îÄ‚îÄ colors@0.6.0-1 
‚îÇ ‚îú‚îÄ‚î¨ optimist@0.2.8 
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ wordwrap@0.0.2 
‚îÇ ‚îî‚îÄ‚îÄ pkginfo@0.2.3 
‚îî‚îÄ‚î¨ socket.io@0.9.1-1 
  ‚îú‚îÄ‚îÄ policyfile@0.0.4 
  ‚îú‚îÄ‚îÄ redis@0.6.7 
  ‚îî‚îÄ‚î¨ socket.io-client@0.9.1-1 
    ‚îú‚îÄ‚î¨ active-x-obfuscator@0.0.1 
    ‚îÇ ‚îî‚îÄ‚îÄ zeparser@0.0.5 
    ‚îú‚îÄ‚îÄ uglify-js@1.2.5 
    ‚îú‚îÄ‚î¨ ws@0.4.8 
    ‚îÇ ‚îú‚îÄ‚îÄ commander@0.5.0 
    ‚îÇ ‚îî‚îÄ‚îÄ options@0.0.2 
    ‚îî‚îÄ‚îÄ xmlhttprequest@1.2.2 

Issue:

I have this simple express server

<S_CODE_TOKEN>

And following simple proxy.js

<S_CODE_TOKEN>

Just doesnt works!
$ curl -XGET http://localhost:8080/  -v
...
ok!
...
$ curl -XGET http://localhost:8081/  -v
blah blah...
NOT FOUND
..blah bleh
..
",kul,2012-06-06 06:53:35
215,2012-03-27 16:34:59,"Do Something!
plz
",kul,2012-06-06 06:53:35
215,2012-03-27 23:05:33,"Don't include the port in the incoming routes. You've already specified this when you call proxyServer.listen(8081);

<S_CODE_TOKEN>
",coderarity,2012-06-06 06:53:35
215,2012-03-28 11:47:27,"OK Got it! Thanks , Before i close this please help me get this working too..

Server:

<S_CODE_TOKEN>

and proxy:

<S_CODE_TOKEN>

The curl request ""curl -XGET localhost:8282/hello -v"" never returns!
",kul,2012-06-06 06:53:35
215,2012-03-28 17:16:02,"I see. `ProxyTable` actually cuts out the path segments, so it will only send a request to `localhost:8181` (with no URL). At this point I'm not sure that this behavior is possible. Let me look into it a bit more.
",coderarity,2012-06-06 06:53:35
215,2012-03-28 18:14:35,"I'm working on making this function properly. It seems like someone just forgot the second half of the implementation.
",coderarity,2012-06-06 06:53:35
215,2012-03-28 18:45:37,"Ok - here's the problem with doing this. Since node-http-proxy supports both HTTP and WebSockets, you can't route to a path, since paths are invalid in WebSocket URLs. This is in the specification that you can read [here](http://dev.w3.org/html5/websockets/#parse-a-websocket-url-s-components).

Sorry, you shouldn't try to use node-http-proxy in this way. I hope this helped you understand!
",coderarity,2012-06-06 06:53:35
215,2012-03-28 18:49:11,"Waaaaaiiiiiit. I think I can still add this - give me a few minutes more.
",coderarity,2012-06-06 06:53:35
215,2012-03-28 20:11:08,"Yeah, I've got this working. That was harder than I thought it would be. Pull request for this incoming. A few things - I was wrong, WebSockets can have paths, I misread the specification. (Maybe I shouldn't be reading specifications anyways =D).

In any case, after the pull request is merged, this should work correctly. This is indeed a bug. Thanks for pointing it out!
",coderarity,2012-06-06 06:53:35
215,2012-03-29 04:24:50,"Are you sure what you did was what you wanted!? you seems to be little confused. 
Anyways so what i did should work now once your changes are pulled in?
Also what kind of fix was it..you added http:// to target location...what about if it was https or ws or wss?
and req.url = url.format(requrl);sour <--??!
",kul,2012-06-06 06:53:35
215,2012-03-29 10:35:01,"I explained adding the `http://` in a comment - it's just used to make url.parse work correctly. It doesn't actually get used in the final URL.

`url.format` returns a string from a url object - see the Node.js documentation.

It did take me a few tries to get this right, mostly because it was hard to understand what the old code was actually doing. =P

On Thursday, March 29, 2012 at 12:24 AM, kul wrote:

> Are you sure what you did was what you wanted!? you seems to be little confused. 
> Anyways so whats i did should work now once your changes are pulled in?
> Also what kind of fix was it..you added http:// to target location...what about if it was https or ws or wss?
> and req.url = url.format(requrl);sour <--??!
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/215#issuecomment-4796651
",coderarity,2012-06-06 06:53:35
215,2012-03-29 13:21:19,"And yes - it will work after the pull request is merged and the package is published to npm.

On Thursday, March 29, 2012 at 6:34 AM, Christian Howe wrote:

> I explained adding the `http://` in a comment - it's just used to make url.parse work correctly. It doesn't actually get used in the final URL.
> 
> `url.format` returns a string from a url object - see the Node.js documentation.
> 
> It did take me a few tries to get this right, mostly because it was hard to understand what the old code was actually doing. =P
> 
> On Thursday, March 29, 2012 at 12:24 AM, kul wrote:
> 
> > Are you sure what you did was what you wanted!? you seems to be little confused. 
> > Anyways so whats i did should work now once your changes are pulled in?
> > Also what kind of fix was it..you added http:// to target location...what about if it was https or ws or wss?
> > and req.url = url.format(requrl);sour <--??!
> > 
> > ---
> > 
> > Reply to this email directly or view it on GitHub:
> > https://github.com/nodejitsu/node-http-proxy/issues/215#issuecomment-4796651
",coderarity,2012-06-06 06:53:35
215,2012-06-05 23:10:50,"The 0.8.1 version is out, @kul can you test again please?
",cronopio,2012-06-06 06:53:35
215,2012-06-06 06:53:35,"Tested. OK.
",kul,2012-06-06 06:53:35
214,2012-03-26 21:56:30,"My code:

<S_CODE_TOKEN>
",thefosk,2012-05-31 16:46:37
214,2012-03-27 23:19:45,"You should listen to request's end event:

<S_CODE_TOKEN>
",coderarity,2012-05-31 16:46:37
214,2012-03-28 00:39:25,"But if the `req` ends it doesn't imply the that `res` is closed as well, and that the response has been proxied successfully and completely.
",thefosk,2012-05-31 16:46:37
214,2012-03-28 01:02:07,"Yeah, I see what you mean. The request would have been proxied, but the response back might not necessarily be done. 

`res.end` seems to have been called just fine. Also, it seems that the proxy emits an `end` event when this happens. I'm not seeing either. Let me see if I can't figure out more.
",coderarity,2012-05-31 16:46:37
214,2012-03-28 01:06:43,"http://nodejs.org/api/http.html#http_class_http_serverresponse

Apparently `res` is not supposed to emit an end event!

However - the proxy should emit an end event. I'm still not sure why this isn't happening.
EDIT: It's a RoutingProxy, it's the HttpProxy that emits the event. Let me see if I can't find the right way to get the HttpProxy object so you can listen for the end event.
",coderarity,2012-05-31 16:46:37
214,2012-03-28 01:16:50,"I've already pointed out this issue in #157
",thefosk,2012-05-31 16:46:37
214,2012-03-28 01:25:01,"Cool, thanks for linking that! I'll try to fix this right now.
",coderarity,2012-05-31 16:46:37
214,2012-03-28 02:04:42,"Hey, I made a pull request for this here: https://github.com/nodejitsu/node-http-proxy/pull/216

You'll probably want to use the following code to do this, otherwise you'll run into the case I mentioned in that pull request:

<S_CODE_TOKEN>

Note that this will only work after the pull request is merged!
",coderarity,2012-05-31 16:46:37
214,2012-03-28 03:12:45,"Check the pull request for an alternative way to do it. It might work better for you. Documentation was added in the pull request as well for this case.
",coderarity,2012-05-31 16:46:37
214,2012-03-28 03:31:31,"Thanks, anyways I think this should be pushed in master.
",thefosk,2012-05-31 16:46:37
214,2012-03-28 03:42:20,"@thefosk You should say that in the pull request =D
",coderarity,2012-05-31 16:46:37
214,2012-03-31 03:47:40,"I think that the following code fixes it in the current non-patched version. Basically I've monkey patched the `res.end()` method:

<S_CODE_TOKEN>

This should be reliable as well. Thoughts?
",thefosk,2012-05-31 16:46:37
214,2012-03-31 04:01:57,"Yeah, sure, if you're fine with your code like that. I mean, you're patching the `res.end` function every single request, but since a new `res` object is made every request, I guess that works. (although it's a little excessive to have to add the function every request) However, once the pull request is merged in and published, I would use the supported method with `server.proxy` anyways.
",coderarity,2012-05-31 16:46:37
213,2012-03-22 14:49:44,"Using node-http-proxy I ran into need of perform URL rewriting only for some of the routes specified into routes table.
I have implemented the possibility of specify multiple parameters for every route of the routes table and configured a new ""rewriteURL"" parameter that permits to conditionally check if the URL rewriting must be performed or not for  the matched entry of the routes table.

In this way, the routes must be specified as follows:

router: {
    'www.example.com/route1': { target:'127.0.0.1:8000' },
     //For the following entry I need to perform rewriting:
    'www.example.com/route2': { target:'127.0.0.1:8001', rewriteURL:true},
    'www.example.com': { target:'127.0.0.1:3000' }
  }

For my needs, this feature is very useful! I hope that will be useful for others too!
",Mattyx,2012-07-22 06:36:43
213,2012-07-22 06:36:43,"There have been changes to this internal API. If you continue to have these issues after we publish the next version then feel free to re-implement this feature from that. 
",indexzero,2012-07-22 06:36:43
212,2012-03-18 05:59:05,"the only example for now I can find is the basic server with connect-gzip middle ware,   thank you for your hard work.
",haohello,2012-09-24 23:22:49
212,2012-03-29 20:18:53,"Yeah, I'll make a pull request for it.
",coderarity,2012-09-24 23:22:49
212,2012-03-30 08:25:00,"Also, can you confirm that node-http-proxy works with socket.io flash transport?  I was testing with IE for a site behind your http-proxy, it was complaining that the flash security policy file cannot be found, any ideas to work around this issue?
",haohello,2012-09-24 23:22:49
212,2012-03-30 12:05:13,"From what I've read, Flash requires a socket policy to connect to the server. It should request for this on TCP port 843. You could try hosting this socket policy file on the proxy server (or proxy it to the Socket.io if it's an HTTP request). 

You can read more about hosting socket policy file severs [here](http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html). 

On Friday, March 30, 2012 at 4:25 AM, haohello wrote:

> Also, can you confirm that node-http-proxy works with socket.io flash transport? I was testing with IE for a site behind your http-proxy, it was complaining that the flash security policy file cannot be found, any ideas to work around this issue?
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/212#issuecomment-4838365
",coderarity,2012-09-24 23:22:49
212,2012-03-30 16:34:09,"Hi there, thanks for prompt reply, from what I've found on both adobe website and socket io site, the default flash policy server is serving on port 843 the same as what you've observed, however there is a three-second timeout setting of requesting the policy file on port 843 of the server, if the browser cannot get the policy file after 3 second timeout, it'll resort to the default port of the server that you're requesting. 

I tried to serve the policy file on port 843 and also the port 10843 (this is a default policy server port setting in socket.io), and it'll surely resolve my problem in this case, unfortunately this would create another problem, as usually is the case that major firewall software would block port 843 and 10843 (I've tested this on several of my computers here),

Since after the timeout the browser will try to request the policy file on the default requested port, as for all my socket.io apps, I'm using http-proxy for the reverse proxy and this http-proxy is listening on port 80,  so I think it would be better off if we could serve the flash policy file on port 80 on the reverse proxy side, other than port 843 as which would normally be blocked and prevent the user from using the site any more.
",haohello,2012-09-24 23:22:49
212,2012-03-30 16:43:46,"The thing is, if the request isn't on an HTTP or WebSocket protocol, I don't think it will be forwarded. I think that the policy file server doesn't use these protocols, but I'm not sure about that.
",coderarity,2012-09-24 23:22:49
212,2012-03-30 16:54:40,"There is this npm package that may be able to give you some hints on how to work around, https://github.com/3rd-Eden/FlashPolicyFileServer

Also how the socket.io is using this package in its flash socket source is also a good pointer on this.
https://github.com/LearnBoost/socket.io/blob/master/lib/transports/flashsocket.js
",haohello,2012-09-24 23:22:49
211,2012-03-16 06:41:43,"I currently have this set up: 

port 80: note-http-proxy
port 3000: rails
port 8888: nodejs server (connection made via socket.io)

I have the following in my node-http-proxy: 

<S_CODE_TOKEN>

basically any socket.io connection will be forced to port 8888. 

When I run this on firefox, I am noticing the following error: 

When I run this on chrome, I am seeing about a 10 second delay before socket.io can make its first communication. 

Please look at the screen shot at http://i.imgur.com/Y0rHk.png
",vicngtor,2012-05-09 20:50:52
211,2012-03-17 04:17:44,"So I did a little hacking and I found something:

I ditched node-http-proxy and switched over to nginx with the following setup: 

nginx.conf:

<S_CODE_TOKEN>

To my surprise, I am seeing the same delay! Actually, this wasn't a delay because no connection could be made. 

I realized that the delay was caused by socket.io degrading to ""lower"" levels of communication. 

As far as I know, node-http-proxy supports WebSockets. Why am I seeing this delay with node-http-proxy? 
",vicngtor,2012-05-09 20:50:52
211,2012-03-18 19:15:58,"[http-proxy definitely supports websockets.](http://wsping.jit.su/) Most likely something in your code is amiss.
",jfhbrook,2012-05-09 20:50:52
211,2012-03-22 15:44:39,"> To my surprise, I am seeing the same delay!

nginx does not support websockets.
",jfhbrook,2012-05-09 20:50:52
211,2012-03-25 02:26:38,"@jesusabdullah fyi https://github.com/LearnBoost/socket.io/wiki/Nginx-and-Socket.io

I kind of gave up on http-proxy already sorry. 
",vicngtor,2012-05-09 20:50:52
211,2012-03-31 01:15:26,"Oh, this is easy. It's `proxy.proxyWebSocketRequest`. See the README, under ""Proxying WebSockets"".
",coderarity,2012-05-09 20:50:52
211,2012-04-06 14:49:41,"@vicngtor I had the exact same issue and @CodeRarity's solution fixed it immediately.
",mhseiden,2012-05-09 20:50:52
211,2012-04-07 07:37:51,"Oh thanks guys definitely will check it out. 
",vicngtor,2012-05-09 20:50:52
211,2012-04-09 07:13:07,"I am still having trouble. Anyone willing to help me out? 

My new server.js 

<S_CODE_TOKEN>

My client.js 

<S_CODE_TOKEN>

I am basically getting an error from io.connect. The response is a ROUTING_ERROR html page from my rails server. 

Anyone here knows how I can get Socket.io to work with node-http-proxy's socket.io('upgrade') ? 

Thanks
",vicngtor,2012-05-09 20:50:52
211,2012-04-09 07:24:56,"You're listening for the upgrade request on port 80, thus you proxy the WebSocket request to the RoR server. You need to use another proxy object where the target is the host and port for the Node/Socket.IO instance. 

I think you're going to run into more issues though... Socket.io uses HTTP to perform the auth handshake and to ping the server every once and a while. So while all of your HTTP UPGRADE requests will proxy correctly, Socket.IO requests meant for the Nodejs instance will actually hit the RoR server. 

I ran into this with an app I'm working on... A good solution is to use different subdomains for the WebSocket requests and the RoR requests. That way you can use a specific proxy based on the subdomain given in the headers. 
",mhseiden,2012-05-09 20:50:52
211,2012-04-09 23:09:05,"@mhseiden I see. 

Do you by any chance have that code available for me to use as a guide? 

Thanks
",vicngtor,2012-05-09 20:50:52
211,2012-04-10 00:43:09,"I made a Gist of a proxy that's been working fine for me. Not sure how it'll handle load (though that's more a question about node-http-proxy in general) but it works just fine for development. 

https://gist.github.com/2347637
",mhseiden,2012-05-09 20:50:52
211,2012-05-09 20:50:52,"This looks fixed. 
",indexzero,2012-05-09 20:50:52
210,2012-03-15 21:23:41,"Inside a flatiron app I'm trying to proxy requests to another server, but the proxy request just hangs and never reaches my other server. I don't know if I'm doing something wrong here or if a bug with flatiron/director. 

Here is an example of my flatiron app code:

<S_CODE_TOKEN>
",ryanfitz,2012-05-09 20:49:34
210,2012-03-29 19:04:31,"This is happening because you're not buffering the requests, and Flatiron is executing some asynchronous operations before it gets to your route handler. See ""Setup a stand-alone proxy server with latency (e.g. IO, etc)"" in the readme. You'll need to start buffering the requests before performing any async operations, i.e. once you get the request.
",coderarity,2012-05-09 20:49:34
210,2012-03-29 20:07:51,"I did try buffering the requests, similar to how it was mentioned in the README. However, I tried buffering the request, inside a route. It sounds like I need to create the buffer in middleware first and then I could use that in a route?
",ryanfitz,2012-05-09 20:49:34
210,2012-03-29 20:22:25,"Yeah, that sounds right.
",coderarity,2012-05-09 20:49:34
210,2012-05-09 20:49:34,"You need to use the `{ stream: true }` option

<S_CODE_TOKEN>
",indexzero,2012-05-09 20:49:34
209,2012-03-14 02:52:23,"Hi guys, its possible to make a transparent reverse proxy like apache mod_proxy ??

something like ...

<S_CODE_TOKEN>

i try this but doesnt work for me =(
",outaTiME,2012-03-14 23:50:03
209,2012-03-14 23:19:17,"> its possible to make a transparent reverse proxy like apache mod_proxy ??

Yes. The only real limitation of the http-proxy is that modifying the response is not expected and takes quite a bit of effort. There is at least one other project that implements this, if it interests you.

> i try this but doesnt work for me =(

Try changing the latter to 127.0.0.1 ?
",jfhbrook,2012-03-14 23:50:03
209,2012-03-14 23:22:45,"ok, but the first rule never works with this version not ?? its not implemented ... or i misunderstood ??
",outaTiME,2012-03-14 23:50:03
209,2012-03-14 23:37:59,">  its not implemented ... or i misunderstood ??

I'm still investigating. Will update when I know more.

> ok, but the first rule never works with this version not ??

For future reference: The more you tell us from the get-go, the less we have to discover ourselves. Please be as specific in issues as possible. :)
",jfhbrook,2012-03-14 23:50:03
209,2012-03-14 23:50:03,"@outaTiME I can replicate your issue but it seems to only occur with sites that use https, which is expected.

Try connecting to a site that doesn't attempt to use ssl, such as `google.com` and it'll work fine.

In your use case (convenience?), not using the proxy and instead responding with 302 redirects, may be enough.
",jfhbrook,2012-03-14 23:50:03
208,2012-03-14 00:10:27,,larsburgess,2012-03-14 00:29:20
208,2012-03-14 00:29:32,"Thanks!
",Marak,2012-03-14 00:29:20
207,2012-03-13 17:41:44,"Hi there,

I've found http-proxy to be the most complete proxy framework for NodeJS, thank you very much!

However, here's a proxy setup that I'd like to implement using http-proxy, and I got slightly stuck,
so I would appreciate some pointers (otherwise, please just consider this a feature request).

The proxy setup is such that:
- I have a pool of x proxy addresses stored in a database (along with auth info for each proxy)
- I want to set up a local forwarding proxy which acts as a rotating proxy based on some custom criteria (callback)
- Whenever a request is forwarded using a specific proxy, I need to keep track of this (i.e. to rotate based on delays between requests to the same hostname/IP)
- I need to provide a callback to quickly parse the HTML response to see if the request succeeded or failed (DOM/jQuery)
- if it failed, I need to switch to another proxy and retry again
- if the pool is empty I need to make an API call to refresh the pool and get new proxy addresses

So, I can see some distinct components/features not currently supported by http-proxy ""out of the box"":
- dynamic proxy pools to match proxies against host names and apply heuristics, i.e. in order to implement delays between requests using the same IP
- a rotating proxy abstraction to rotate proxies in a pool based on callback predicates
- detailed proxy usage logging, so that IPs don't get reused too frequently
- a fail/succeed pattern that provides for a possibility to specify a callback to tell if a proxy invocation succeeded or failed
- proxy pool refreshing based on external API invocations 

As you can see, this is probably a little ""non-standard"", so suggestions and pointers would be really appreciated.

Thank you very much
",woncount,2012-07-22 06:34:43
207,2012-03-31 01:30:15,"You can create your own HTTP server and route the proxies based on your own logic. See this example from the README:

<S_CODE_TOKEN>
",coderarity,2012-07-22 06:34:43
206,2012-03-02 07:09:28,"Much happier :)
",quartzjer,2013-03-09 09:42:56
206,2012-03-03 08:04:44,"@quartzjer This looks good. So good that I would ask that you update other places you see `flushed = *.write(...`  with this pattern.
",indexzero,2013-03-09 09:42:56
206,2012-03-10 23:23:16,"Ok, I honestly tried to fix this elsewhere, but I got in the weeds quickly on knowing what kind of larger impact it would have, I don't know the internals of http-proxy well enough to have any confidence in twiddling these bits.  It seems that for all the instances of tracking flushed, paused, and attaching drain listeners, that there needs to be some way to check if the drain listener is attached _for-the-specific-paired-socket_, and using a paused variable could actually result in some edge cases of a full standstill.

I'm not sure how to do this properly in all the other places with my relatively shallow understanding of http-proxy, and may not have the time to do a deep dive and learn it all any time soon :(

cc @temas
",quartzjer,2013-03-09 09:42:56
206,2012-03-11 00:12:24,"I decided to go the safest route possible, and just have a variable per instance. I tested this everywhere we were seeing the event emitter leak on the locker project and it runs clean now. Should be good to go I think?
",quartzjer,2013-03-09 09:42:56
206,2012-03-14 19:15:45,"Does the current patch look good?
",quartzjer,2013-03-09 09:42:56
206,2013-03-09 09:42:56,"Things have diverged so much from this that I can't merge it in. If you encounter this in `v0.9.0` when it is released let us know. Sorry.
",indexzero,2013-03-09 09:42:56
205,2012-03-02 04:36:35,,drewp,2012-03-02 04:37:43
205,2012-03-02 04:37:51,"Thanks!
",Marak,2012-03-02 04:37:43
204,2012-02-29 10:28:02,"We required the proxy table supports multiple random destinations for each configured request target.

var http = require('http'),
    httpProxy = require('http-proxy');

var options = {
    router: {
        '192.168.99.29': ['127.0.0.1:8000','127.0.0.1:9000']
    }
};

var proxyServer = httpProxy.createServer(options);
proxyServer.listen(80);

http.createServer(function (req, res) {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.write('request successfully proxied to srv1: ' + req.url +'\n' + JSON.stringify(req.headers, true, 2));
    res.end();
}).listen(8000);

http.createServer(function (req, res) {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.write('request successfully proxied to srv2: ' + req.url +'\n' + JSON.stringify(req.headers, true, 2));
    res.end();
}).listen(9000); 
",KimSchneider,2012-07-22 06:35:41
204,2012-03-31 01:20:18,"What's wrong with something like this?

<S_CODE_TOKEN>
",coderarity,2012-07-22 06:35:41
204,2012-04-18 12:02:24,"That's a different solution that doesn't fit my solutions use-case :)

We use mainly the routing table functionality of the proxy, so we can route different requested urls to different servers. My request provides an easy way to route diffenret sources to random servers.
",KimSchneider,2012-07-22 06:35:41
204,2012-04-18 18:45:03,"I see. If there was an API like this, shouldn't it do something more predictable, like a round-robin between all of the proxies? Maybe this could be part of a feature like nodejitsu/node-http-proxy#213, and then there could be an option for how to select a target from the list, round-robin or random. You're both suggesting an API change to the same part of the API, after all.
",coderarity,2012-07-22 06:35:41
204,2012-07-22 06:35:41,"This is quite non-standard. Enough so that I don't think it belongs in the core. 
",indexzero,2012-07-22 06:35:41
203,2012-02-27 22:38:59,"Problem: Don't want to run my standalone proxy server as root to bind to privileged ports (e.g. 80, 443).

Solution: support privilege drop after socket bind via new --user <username> parameter.

Example:

sudo node-http-proxy --user nobody --port 80 --target localhost:3000
",niallo,2013-03-09 08:13:15
203,2012-02-28 03:37:37,"Also added support for setting the ""ca"" option to createServer() via config.json. This is necessary if you have an SSL cert which requires additional CA certs (like many cheap SSL certs do these days).
",niallo,2013-03-09 08:13:15
203,2012-02-28 17:22:30,"Would that affect GH-193?
",astronouth7303,2013-03-09 08:13:15
203,2012-02-29 22:39:14,"No, but making requestCert settable via the config file as I did with ca in this diff should also solve it.
",niallo,2013-03-09 08:13:15
203,2012-07-22 06:58:28,"lgtm. I'll look into merging this soon.
",indexzero,2013-03-09 08:13:15
203,2012-07-23 20:43:59,"@indexzero thanks, that would be great.
",niallo,2013-03-09 08:13:15
203,2012-10-18 14:02:55,"+1
",svnlto,2013-03-09 08:13:15
203,2013-03-09 08:13:15,"Cherry-picked. Thanks!
",indexzero,2013-03-09 08:13:15
202,2012-02-24 16:28:41,"Hi forks.

I want to use node-http-proxy for revers proxy in front of socket.io server.

scale to 3 socket.io server and redis.
like this

<S_CODE_TOKEN>

redis is for sharing socket.io broadcast with pub/sub.
socket.io server is stands on express server.

and I wrote proxy setting like this.

<S_CODE_TOKEN>

but this has a problem.
websocket request needs http request first.
so first request is proxyed by proxy object at A.
and upgrade requrest comming to server,
but proxy object at B is different target from A,
because I choose target server in random.

I want to use same target proxy object at B
but I can't get 

""which target this connection looking for?""

how to write in this case?

sorry for my poor english :p
",Jxck,2012-06-06 09:47:26
202,2012-02-24 17:20:08,"Do you mean socket.io or websocket? Websockets are a single request,
while socket.io has a handshake HTTP request prior to the transport
request.

If you are talking about socket.io, I would use cookies as a means to
discern which client has connected or recording the remote IPs of
clients.

On Fri, Feb 24, 2012 at 10:28 AM, Jxck
reply@reply.github.com
wrote:

> Hi forks.
> 
> I want to use node-http-proxy for revers proxy in front of socket.io server.
> 
> scale to 3 socket.io server and redis.
> like this
> 
> <S_CODE_TOKEN>
> 
> redis is for sharing socket.io broadcast with pub/sub.
> socket.io server is stands on express server.
> 
> and I wrote proxy setting like this.
> 
> <S_CODE_TOKEN>
> 
> but this has a problem.
> websocket request needs http request first.
> so first request is proxyed by proxy object at A.
> and upgrade requrest comming to server,
> but proxy object at B is different target from A,
> because I choose target server in random.
> 
> I want to use same target proxy object at B
> but I can't get
> 
> ""which target this connection looking for?""
> 
> how to write in this case?
> 
> sorry for my poor english :p
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/202
",bmeck,2012-06-06 09:47:26
202,2012-02-24 17:31:00,"bmeck

thank for reply.
I'm talking about socket.io server.

You means that I need to share session strage between socket.io cluster ?
",Jxck,2012-06-06 09:47:26
202,2012-02-24 17:38:02,"Yes you will need to use a shared storage if you want to round robin
the load balancing, you can do this with socket.io's or a way that is
more flexible by having node-http-proxy look it up for you and create
sticky sessions (always redirect same session to one machine).

On Fri, Feb 24, 2012 at 11:31 AM, Jxck
reply@reply.github.com
wrote:

> bmeck
> 
> thank for reply.
> I'm talking about socket.io server.
> 
> You means that I need to share session strage between socket.io cluster ?
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/202#issuecomment-4161166
",bmeck,2012-06-06 09:47:26
202,2012-02-25 03:54:03,"Ok I see.

So I need to use Socket.IOs new feature RedisStroe.
however this feature isn't stable yet.. :(

anyway. thanks !
",Jxck,2012-06-06 09:47:26
202,2012-06-05 22:56:02,"@Jxck still an issue for you?, can we close it?
",cronopio,2012-06-06 09:47:26
201,2012-02-21 02:46:20,"I was trying to have Socket.io and HTTP requests over SSL and it works except for usually after 2.5 hours, the CPU IOWait spikes to 95% in top and the server loads becomes really high (9.0 + ) and doesn't subside. The server then has to be rebooted. I was wondering if anyone has any ideas. The setup is:

<S_CODE_TOKEN> javascript
var fs = require('fs');

var https = require('express').createServer({
    key: fs.readFileSync('/home/app/server/server.key'),
    cert: fs.readFileSync('/home/app/server/ssl.crt'),
    ca : fs.readFileSync('/home/app/server/intermediate.crt')
});

var httpProxy = require('http-proxy');<S_CODE_TOKEN>```
",ghost,2013-03-09 07:07:55
201,2012-06-05 22:48:05,"still an issue for you @yuriydyrenko ??
",cronopio,2013-03-09 07:07:55
201,2013-03-09 07:07:55,"Suspect this is just node.js core not handling SSL that well.
",indexzero,2013-03-09 07:07:55
200,2012-02-20 08:13:54,"I just got started with Node this weekend so forgive me if this is a stupid question.

I've run:

npm install http-proxy

and I've verified that http-proxy works by running a small proxy server on my localhost.

However, I have not been able to run the node-http-proxy from the command line.  I keep getting:

node-http-proxy: command not found
",uglymunky,2012-02-20 08:45:27
200,2012-02-20 08:21:20,"Try installing it with the `-g` flag, for ""global"":

<S_CODE_TOKEN>

You may or may not need to use `sudo` depending on your configuration.
",jfhbrook,2012-02-20 08:45:27
200,2012-02-20 08:45:27,"Yep, that did it!  Thanks @jesusabdullah 
",uglymunky,2012-02-20 08:45:27
199,2012-02-19 03:27:17,"If you define both a hostname route along with folder routes on the same hostname, the hostname route MUST be defined after all of its folder routes or any folder routes defined after the hostname route will return a ""Cannot GET /folder"". 

To repro, in `test/http/routing-proxy-test.js`, add a baz.com route to `defaultOptions`:

<S_CODE_TOKEN>

If you move baz.com after baz.com/taco, the test will pass. 

I suspect the test runner (`assertProxied` method) will need fixing too. Because this repro will fail with an ""address in use"" error even though the ports are unique. 

<S_CODE_TOKEN>

Even when I added a specific assertion for baz.com

<S_CODE_TOKEN>

the expectations still aren't correct even though the correct test is failing (baz.com/taco).

<S_CODE_TOKEN>

I'll send a pull request if I get a chance.
",don-smith,2012-06-09 01:22:57
199,2012-03-29 19:07:40,"It runs the routes in order until it finds one that matches - I think this is supposed to happen. Look at `ProxyTable`. Just remember to sort your routes by priority.
",coderarity,2012-06-09 01:22:57
198,2012-02-18 14:47:14,"Has anyone made some test and  see which one performs better in terms of performance as http proxy?

What about functionality?

Thanks
",aristidesfl,2012-07-22 06:39:36
198,2012-03-26 22:47:27,"If those benchmarks are missing I think you could be the one to do them. It shouldn't take too much time.
",thefosk,2012-07-22 06:39:36
198,2012-04-13 12:12:19,"This recently came up again on the node mailing list. Is there any work being done here?

My feeling is that it's pretty fast. It does seem to leak memory a bit, though.
",chrisrhoden,2012-07-22 06:39:36
198,2012-04-13 14:11:21,"I dont' have much time right now..
",aristidesfl,2012-07-22 06:39:36
197,2012-02-16 18:10:26,"Hi,

I am trying to use Node.js + http-proxy to function as a transparent Forward Proxy, something like Squid/Tinyproxy. While proxy to HTTP site is ok, but currently facing problem proxy to HTTPS site. Below is what I did try.
# Forward Proxy for HTTP request - OK

httpProxy.createServer(function (req, res, proxy) {      //===> This create a Forward Proxy 
    uri = url.parse(req.url);
    var port = 80;
   proxy.proxyRequest(req, res, {
        host: uri.hostname,
        port: port
    });
}).listen(8000);

The above Forward Proxy can only  proxy to HTTP (not HTTPS) site,  for HTTPS site eg. https://github.com/nodejitsu/node-http-proxy  , this proxy simply fail to load it. 
# Forward Proxy for HTTPS request  -  How ????

var opts = helpers.loadHttps();
httpProxy.createServer(8000, 'localhost', {             //===> This create a Forward Proxy
  https: opts,
  target: {
    https: true
  }
}).listen(8080);

https.createServer(opts, function (req, res) {                     //==>This create a LOCALHOST Target HTTPS server
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.write('hello https\n');
    res.end();
}).listen(8000);

With referring to the sample ""proxy-https-to-https.js"", the above Forward Proxy only help to proxy all HTTPS request to the LOCALHOST Target HTTPS server which is running at PORT=8000. <b>How do we make this Forward Proxy to proxy to any EXTERNAL Target HTTPS site for example:  https://github.com/nodejitsu/node-http-proxy ?</b>

Anyone, pls help

Thanks .
",penkween,2012-07-22 06:48:12
197,2012-03-29 17:16:32,"I think you want to change 'localhost' that you passed into `httpProxy.createServer` to the target HTTPS website, and change the first argument (the port) to the port that you want it forwarded to. The standard port for HTTPS is 443, so you might want to try that. I'm not sure I completely understand what your issue is, however.
",coderarity,2012-07-22 06:48:12
197,2012-07-10 13:18:57,"I have the same question as you and I am keeping trying now. So far as I concerned, I doubt that it does NOT support **standalone https proxy**, which is a quite common use, since there is no reason for not being mentioned in all passages one could reach  in examples or even in Google. The two demos about **https** only work in **reverse** proxy scenario. @coderarity 
",kainliu,2012-07-22 06:48:12
197,2012-07-11 06:06:23,"With patience worn out I am leaving this module as a unsuccessful trial, and if anyone who is looking for **standalone proxy supports HTTPS** my suggestion is to traditional long-time-tested proxy software as **squid** . However, this module works stable in HTTP. @penkween 
",kainliu,2012-07-22 06:48:12
197,2012-07-22 06:48:12,"You just need to change the host of the target you are proxying to:

<S_CODE_TOKEN>
",indexzero,2012-07-22 06:48:12
197,2013-07-14 21:38:51,"indexzero, If I understand correctly, then this should work, however, it just returns an empty response:

httpProxy.createServer(function (req, res, proxy) { //===> This create a Forward Proxy
    var uri = url.parse(req.url);
    proxy.proxyRequest(req, res, {
        host: uri.hostname,
        port: 443,
        https: true
    });
}).listen(9000);
",jmealo,2012-07-22 06:48:12
197,2014-01-14 21:45:28,"So far this returns only `An error has occurred: {}` when `localhost:8080` is hit. It also returns a 500 error in the console.

Here's the code I'm running:

<S_CODE_TOKEN>
",jodytate,2012-07-22 06:48:12
197,2014-01-14 21:53:20,"test the caronte branch in this repo as it's the new release! thanks :)
",yawnt,2012-07-22 06:48:12
197,2014-01-14 22:38:28,"Thanks a ton for such a quick response. I believe I have the caronte branch installed now. This doesn't return the error now, but instead returns an empty response. 

I'm using the above code, but something tells me I'm missing something else that's crucial. 

I've tried changing `var proxy` to `http.createProxyServer` but I also get an empty response. 
",jodytate,2012-07-22 06:48:12
196,2012-02-15 04:06:28,"I am new to node.js and I am using the following sample code of a basic forward proxy. Testing this at my laptop (with Internet connection)  by setting my firefox to use a local proxy at localhost: 8000  and the browser can suft the Internet without any problem.

============== A basic Forward Proxy ======================
var http = require('http'),
httpProxy = require('http-proxy');

httpProxy.createServer(function (req, res, proxy) {

////////// I think Request Header can be filtered here/////////////

 proxy.proxyRequest(req, res, {
     host:req.headers['host'],
     port: 80
  });

////////// How to filter Response Header ???? /////////////

}).listen(8000);

My question is How do I delete some response header eg.Etag at this proxy before passing back to my browser ? 

**\* Middleware example below showing how to filter Response Body, but it didn't show how to filter Response Header***
https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/modifyResponse-middleware.js

Anyone, pls help !

Thank.
",penkween,2012-02-16 18:21:07
196,2012-02-15 06:11:11,"Hi @penkween ,

In the example you linked, they are able to modify the response by monkey punching res.write inside the middleware. By using a similar technique with res.writeHead and/or res.setHeader (you'll have to do some research to figure out all the relevant methods) you should be able to make this work. That said, monkey-punching is kind of a hack and the proxy module was designed more for quick transparent proxying than it was for arbitrarily modifying the http request and response.
",jfhbrook,2012-02-16 18:21:07
196,2012-02-16 06:20:53,"Hi @jesusabdullah,

<p>Thank you for your reply, for the res.setHeader or res.removeHeader is not effective of modifying the ultimate response header to client because the proxy.proxyRequest will basically append its own response header to form the ultimate response header back to client.<br /><br />

   
</p>

",penkween,2012-02-16 18:21:07
196,2012-02-16 18:18:37,"Finally, after monkey punching the http-proxy source, manage to delete some header.  The issue solved but I still hope that we can do it externally in a standard way without touching http-proxy source. Hi jesusabdullah, really thank a lot for your help. 
",penkween,2012-02-16 18:21:07
196,2015-02-19 15:55:16,"@penkween thanks man!
",swogger,2012-02-16 18:21:07
196,2015-04-04 14:51:32,"in case anyone else finds this, this now works just fine. here is some coffeescript code that removes the content length header:

<S_CODE_TOKEN>
",mkoryak,2012-02-16 18:21:07
195,2012-02-12 07:56:42,"I think it needs more tests/validation that I didn't mess something else up here, but it's a first stab at it.
",tglines,2012-04-02 21:34:03
195,2012-02-12 07:58:59,"Adresses:

https://github.com/nodejitsu/node-http-proxy/issues/111
https://github.com/nodejitsu/node-http-proxy/issues/126
https://github.com/nodejitsu/node-http-proxy/issues/60
",tglines,2012-04-02 21:34:03
195,2012-02-12 08:03:19,"I think it also needs a conditional for determining if it's a routing proxy or http proxy ... I'll wait for some feedback.
",tglines,2012-04-02 21:34:03
195,2012-02-13 20:56:01,"lgtm. I'll try to get this merged in this week.
",indexzero,2012-04-02 21:34:03
195,2012-03-02 07:01:02,"@indexzero could we get an update on this?
",AndreasMadsen,2012-04-02 21:34:03
195,2012-03-04 07:36:18,"@indexzero @Marak hearing crickets here ...
",tglines,2012-04-02 21:34:03
195,2012-03-09 08:22:21,"Sorry. Backlog of other work. I'll try to review this week, but Nodejitsu core is taking up the lion's share of the team's time.
",indexzero,2012-04-02 21:34:03
195,2012-03-09 23:58:31,"this would be pretty sweet - we will then replace all our nginx frontend with node-http-proxy
",devrim,2012-04-02 21:34:03
195,2012-03-22 15:15:50,"this would be awesome! we're currently moving from apache proxying to node-http-proxy and we'll be including this on our version...
",dudemeister,2012-04-02 21:34:03
195,2012-04-02 21:33:56,"Wanted to let everyone here know of a method that works just fine since nodejitsu didn't talke the pull request.

You can pass a string through into options.router that's a path to a file that has the routes as json.  The process then watches this file for changes and updates the routing.  Basically you can achieve the same effect I was trying to achieve with this pull by having a process that edits that file.

Routing file (router.json):

<S_CODE_TOKEN>

Options passed

<S_CODE_TOKEN>
",tglines,2012-04-02 21:34:03
194,2012-02-11 20:56:25,"I am writing a proxy script that uses PHP and CURL like Glype but open source I hate how Glype adds their name to your proxy it also will be way better could you help me with my project
",ghost,2012-02-11 22:38:14
194,2012-02-11 22:38:14,"Hi Nathan,

None of us have the time, interest or desire to use php to help you port the proxy to php.

Have you considered learning javascript enough to write the tool you want using node and this project? We even have a [nice cli framework](https://github.com/flatiron/flatiron/blob/master/scaffolds/cli/app.js) to make it extra easy.

If you have particular questions about how the proxy works, or think you've found a bug, feel free to get ahold of us, either here or at #nodejitsu on irc.freenode.net .
",jfhbrook,2012-02-11 22:38:14
194,2012-02-11 22:43:35,"you must of misunderstood me I am writeing a php and curl proxy from scratch please reconsider my proxy
",ghost,2012-02-11 22:38:14
194,2012-02-11 22:49:23,"No, I completely understand. I'm telling you that none of us are going to help write a proxy in php and curl from scratch, because we put a lot of time into THIS one, it's in the language/environment _we_ like, and honestly it was a lot of work.
",jfhbrook,2012-02-11 22:38:14
194,2012-02-11 22:50:26,"could you atleast help me start
",ghost,2012-02-11 22:38:14
194,2012-02-11 22:51:02,"if not could you find someone who will
",ghost,2012-02-11 22:38:14
194,2012-02-11 23:00:06,"Here's some reading to get you started:
- http://en.wikipedia.org/wiki/Http_proxy
- https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js
- http://php.net/curl

Also, the php community probably has an irc presence and they'd probably be more amenable to answering your php questions.
",jfhbrook,2012-02-11 22:38:14
194,2012-02-12 01:38:58,"thank you could you find me more information please list theme here I will be writeing the scripts soon...
",ghost,2012-02-11 22:38:14
193,2012-02-11 04:07:02,"I'm attempting to use `node-http-proxy` as an SSL unwrapper and application aggregator, with SSL certification authentication.

However, when I turn on `https.requestCert`, errors crop up, whether or not the browser has one of the requested certs. Sometimes, the first few requests are good, but then n-h-p gets mysteriously wedged. Other times, I just get SSL errors.

I have a self-signed CA cert, a server cert signed my CA, and a client cert signed by my CA.
",astronouth7303,2013-03-09 06:50:46
193,2012-02-12 03:01:36,"@astronouth7303 Have you tried a simple HTTPs server in node.js with the same certs? It could be a node.js core issue. @indutny would know more.
",indexzero,2013-03-09 06:50:46
193,2012-02-12 05:18:37,"Not yet. I don't know node at all, sadly.
",astronouth7303,2013-03-09 06:50:46
193,2012-02-13 20:56:43,"@astronouth7303 It's relatively simple: http://nodejs.org/docs/latest/api/https.html#https.createServer
",indexzero,2013-03-09 06:50:46
193,2012-02-19 18:35:37,"Ok, I set up a [basic HTTPS server](https://gist.github.com/1865021) using the same options I'm using in my proxy. It's working as expected.

I'm using the npm version of node-http-proxy.
",astronouth7303,2013-03-09 06:50:46
192,2012-02-10 06:16:18,"The pull req #165 introduced broken logic, it rewrites _every_ redirect, such that if a proxied services 302's any url (in our instance, our https-fronted and http-back-end sends a redirect to instagram's http cdn).

https://github.com/elfsternberg/node-http-proxy/blob/411bb51cc6/lib/node-http-proxy/http-proxy.js#L216

It rewrites every single redirect regardless :(
",quartzjer,2013-03-09 08:31:49
192,2012-02-11 23:48:48,"It also breaks redirects to other protocols (however uncommon that is).
",abh,2013-03-09 08:31:49
192,2012-02-12 02:45:28,"@quartzjer How would you go about fixing it? Honestly I'm not sure I follow what's wrong.
",indexzero,2013-03-09 08:31:49
192,2012-02-13 03:07:15,"If there's a front-end of https://external/ and a back-end of http://internal/ when the back-end sends a redirect to http://some-other-site.com/foo.bar this code will rewrite it to https://sime-other-site.com/foo.bar, which is generally a bad thing to be rewriting every redirect :)

I honestly don't understand the original issue to suggest a fix as I'm not sure what the desired behavior would be, all I know is the current one is not desirable.
",quartzjer,2013-03-09 08:31:49
192,2012-03-14 19:15:24,"Is there any way this can be fixed in master? I'm (undesirably) using a fork that just has this code commented out, and I don't know how this condition isn't horribly broken for everyone, every single redirect response is rewritten in this case.
",quartzjer,2013-03-09 08:31:49
192,2012-03-15 21:59:00,"+1

@quartzjer -> You could create a clean pull request from that fork to accelerate the fix.
",ovaillancourt,2013-03-09 08:31:49
192,2012-03-15 22:37:36,"I would, but I don't know what the problem is actually being solved so
I just commented it out :)

On Thu, Mar 15, 2012 at 4:59 PM, Olivier Vaillancourt
reply@reply.github.com
wrote:

> +1
> 
> @quartzjer -> You could create a clean fix + pull request from that fork to accelerate the fix.
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/192#issuecomment-4529924
",quartzjer,2013-03-09 08:31:49
192,2012-03-19 13:39:42,"Yeah, looking at it, these lines (those commented out) do solve the specific problem of the user that submitted the fix but I'm pretty sure it's not really a desirable behaviour for a proxy... 

You pretty much irreversibly loose control over your protocol with this ""fix"". I think it should either be configurable in the proxy or managed on the app side.

We're running an internal build of http-proxy that has the exact same lines commented out :P.
",ovaillancourt,2013-03-09 08:31:49
192,2012-07-24 16:24:55,"Has there been any update on this issue? 
",mansona,2013-03-09 08:31:49
192,2013-03-09 08:31:49,"Should be fixed in 6a278b3dd88d3b786cdaa9dec4c6011119e05a59
",indexzero,2013-03-09 08:31:49
191,2012-02-09 04:17:23," 1881 root      20   0  642m  12m 6352 S  0.0  2.5   --- Messenger Chatting Server Proxy ---

websocket (socket.io) connect
....

 1881 root      20   0  642m  117m 6352 S  0.0  2.5  --- Messenger Chatting Server Proxy ---

why??????? ;;
",nanha,2012-07-19 06:15:30
191,2012-02-12 02:48:46,"@nanha I'm not sure I understand. Can you please provide the code you are seeing a memory leak with? 
",indexzero,2012-07-19 06:15:30
191,2012-02-12 02:52:16,"Momentarily watching the RSS is not a good way to judge memory usage.  `v8` makes garbage collection passes, and the memory graph over time will contain many spikes as a result.  I would also recommend some more detailed profiling of the issue.
",AvianFlu,2012-07-19 06:15:30
190,2012-02-07 14:06:45,"some cleanups.
- add missing var statements
- remove unused variables
- make jslint happy
- strip white space
",fjakobs,2012-07-22 06:37:19
190,2012-02-12 02:30:54,"@fjakobs We do not use JSLint. We use JSHint with these settings: https://gist.github.com/1263182. We've been a bit lax on enforcing since we were waiting on `laxcomma` to his `jshint:master` which landed a couple weeks ago
",indexzero,2012-07-22 06:37:19
190,2012-02-12 10:57:58,"The first three commits I think are important. The other ones are more or less of a cosmetic nature.
",fjakobs,2012-07-22 06:37:19
190,2012-02-12 22:39:31,"Thanks for the tip. I'll look into reviewing this soon. 
",indexzero,2012-07-22 06:37:19
190,2012-07-22 06:37:19,"There have been enough changes in the codebase that this would hurt more than it helped. 
",indexzero,2012-07-22 06:37:19
190,2012-07-24 18:46:28,"no problem
",fjakobs,2012-07-22 06:37:19
190,2012-07-25 04:48:03,"@fjakobs Thanks anyway. FYI. The code base it pretty much JSHint compliant now. I did some work on it over the weekend.
",indexzero,2012-07-22 06:37:19
189,2012-02-07 01:16:33,,drewp,2012-02-12 02:41:04
188,2012-02-02 15:20:28,"Ran into some problems when proxying HTTP to one place and Socket.IO traffic to another because of the URL rewrite, so added an option to disable it.
",alexandernilsson,2012-07-22 06:50:46
188,2012-02-03 15:57:21,"+1 on that, I'd definitely like to see this feature in. (had to hack in something similar 5 days ago)

Suggestions on your edits:
1. I'd put the split from line 142 inside a first `if` that verifies the rewrite url option, then make the split, and then make a 2nd `if` that checks if the length is > 1 to prevent doing the split on every request (as the result from the split will never be used anyway if the rewriteUrl option is set to false).
2. I'd completely invert the option. For example, make it `keepUrlSegments` which **does not** rewrite if set to true. This way you keep the current default behavior (to rewrite everytime) the same if you omit the option, which preserves backward compatibility. Otherwise, everyone who's currently using the default behavior will have to go add a `rewriteUrl: true` to their code.
3. Write tests for the new cases, I don't think it's gonna be pulled in otherwise.
",ovaillancourt,2012-07-22 06:50:46
188,2012-02-03 16:38:28,"1. That's a good idea.
2. `rewriteUrl` defaults to `true`, so it wouldn't break backwards compatibility. But actually, I do kind off agree with you that `keepUrlSegments` sounds better.
3. True, will have a look at that.
",alexandernilsson,2012-07-22 06:50:46
188,2012-02-03 16:41:38,"Oops you're right for # 2! Didn't look close enough to your default. Sorry about that :D.
",ovaillancourt,2012-07-22 06:50:46
188,2012-07-22 06:50:46,"This implementation has changed significantly since this was originally submitted. Still open to the feature idea, but you need to pull and re-implement.
",indexzero,2012-07-22 06:50:46
188,2012-07-26 14:00:41,"Quick note:

This issue has been resolved by commit 55286a7c499c0fe267f75d8e8441ff89f1e65f99 - doesn't need to be pulled in anymore.
",ovaillancourt,2012-07-22 06:50:46
187,2012-02-02 13:17:45,"Hi,

I want to use http-proxy to listen to incoming requests on 80. I would like it to forward https requests to port 8000 (nginx) and forward websocket requests to port 9000 (socket.io). Is that possible to achieve? Can someone help me with sample code how to do this?
",vdurbha,2012-06-05 22:44:13
187,2012-04-04 10:57:35,"I don't think it's possible right now using `httpProxy.createServer`, but if you create your own server, it should be possible. If you create an `HttpProxy` for requests to forward to port 8000 and an `HttpProxy` for requests to forward to port 9000, you can use the `proxyRequest` and `proxyWebSocketRequest` functions on each to reverse proxy the requests to the servers you want.

I'll work on some sample code for this.
",coderarity,2012-06-05 22:44:13
187,2012-04-04 12:59:04,"You could also use a `RoutingProxy` which will end up just creating the `HttpProxy`s for you anyways, but either way is probably fine. I decided to use a `RoutingProxy` in this example.

<S_CODE_TOKEN>
",coderarity,2012-06-05 22:44:13
186,2012-02-01 15:56:09,"I'm using node-http-proxy as a hostname only proxy that redirects to local node servers I'm running.

I'm using connect's logger middleware on my servers (not the proxy) and although most of the information is correct, the origin of the request is coming from 127.0.0.1 - which I can assume is actually the IP of the proxy rather than the proxied request.

Any way this can be fixed (or is there some flag I've missed)?
",remy,2012-02-01 16:24:21
186,2012-02-01 16:24:21,"The IP address of the actual point of origin can be found in the `x-forwarded-for` HTTP header.  There are also usually `x-forwarded-port` and `x-forwarded-proto` headers for the port and protocol, respectively.

Connect's logger is probably logging `req.socket.remoteAddress`, which would give the ip of the proxy instead of the actual client.
",AvianFlu,2012-02-01 16:24:21
186,2012-02-01 16:26:17,"Hmm, I wonder if I can push a change to connect's logger to check for the forwarded details. Cheers all the same :)
",remy,2012-02-01 16:24:21
185,2012-02-01 00:39:00,"How the proxy behaves when a proxyError occurs seems to depend in odd ways on how the server was invoked.

When created like this (first example in README):

<S_CODE_TOKEN>

The proxy returns 500 with a message that the connection was refused.

However, if you start the proxy like this (second example in the README):

<S_CODE_TOKEN>

The proxied connections simply hang forever (until client timeout).

Adding custom error handling code works in both cases:

<S_CODE_TOKEN>

This is especially confusing since the README does not mention proxyError at all.
",n1mmy,2013-03-09 07:09:08
185,2012-03-29 19:36:32,"This is probably because a `RoutingProxy` is being created in one case, and an `HttpProxy` in the other. I bet this is just a matter of copying the error handler from `HttpProxy` to `RoutingProxy`!
",coderarity,2013-03-09 07:09:08
185,2012-03-29 19:39:59,"Guess it's not that simple! It never is.

`RoutingProxy` should re-emit errors from `HttpProxy`. There shouldn't be any differences. But `RoutingProxy` has been hanging when there's errors for me as well.
",coderarity,2013-03-09 07:09:08
185,2013-03-09 07:09:07,"Fixed by #216 
",indexzero,2013-03-09 07:09:08
184,2012-01-31 03:38:36,"I try to proxy a request to <b>
http://ptlogin2.qq.com/jump?ptlang=2052&clientuin=304290615&clientkey=0D399336F7C4F553C468779FC21FEC92B77EEE1F3D766C61BC3F3B19AD65E070&u1=http%3A%2F%2Fuser.qzone.qq.com%2F573692919</b> which actually send a ""302 Found"" status code, but the proxy failed to send any response which cause Chrome showing an ""ERR_EMPTY_RESPONSE"" error page.

i found visit that url cause proxyError, and i add some code found it to be <b>""error: { [Error: socket hang up] code: 'ECONNRESET' }""</b>

and i get the similar error when proxy to url <b>http://stats.sports.qq.com/NBAImages/TeamImages/Bulls-1.png</b>

my source code:

<pre>
var http = require('http'),
    httpProxy = require('http-proxy'),
    url  = require('url');
//
// Create your proxy server
//
httpProxy.createServer(function (req, res, proxy) {
  //
  // Buffer the request so that `data` and `end` events
  // are not lost during async operation(s).
  //
  var buffer = httpProxy.buffer(req);
  var parsed_url = url.parse(req.url);
  var host = ""localhost"";
  var port = 8001;
  if(typeof(parsed_url.host)=='undefined') {
  } else {
      port = parsed_url.host.split(':');
      host = parsed_url.hostname;
      if(port[1]) {
        port = port[1];
      }else{
        port = 80;
      }
  }
  //setTimeout(function () {
    proxy.proxyRequest(req, res, {
       'host': host,
       'port': port,
       'buffer': buffer,
    });      
  //}, 2000);
}).listen(8000);
</pre>
",terrywh,2012-04-10 02:31:33
184,2012-02-12 02:48:28,"The server you're trying to proxy to might be expecting certain headers that aren't being passed through - or it might be rejecting requests that have obviously been proxied.

`node-http-proxy` sets the `x-forwarded-*` headers, and your connections may be getting refused because of this.
",AvianFlu,2012-04-10 02:31:33
184,2012-03-29 19:24:32,"@wuhaocn2008 are you still having an issue with this?
",coderarity,2012-04-10 02:31:33
184,2012-03-30 02:02:17,"it seems the latter url is ok right now, but the first url is still having some kind of issue when i use the proxy server on CHROME to visit. It keeps loading for a very long time.
",terrywh,2012-04-10 02:31:33
184,2012-03-30 02:07:25,"I think the problem is the query part of the URL. I'm going to work on getting rid of the hanging problems in `node-http-proxy`, I think that's the source of a lot of people's problems. Clear error messages are far more useful than hanging.
",coderarity,2012-04-10 02:31:33
184,2012-03-31 01:32:49,"It sounds like it was hanging - I just added a pull request to give reasonable errors instead of just hanging. See nodejitsu/node-http-proxy#216. After that pull request is merged in and a new version is up on npm, can you try it again and tell me what error it gives you (if any)?
",coderarity,2012-04-10 02:31:33
184,2012-04-10 02:31:33,"USE proxyError to track the errors, here is what i got when proxy the first url:

{ [Error: socket hang up] code: 'ECONNRESET' }

it seems you are right about the x-forwarded-for thing. when i proxy some url, it will emit that reset error. For the specific url on top, the reason might be that there should not be a header ""x-forwarded"" or the server will close the connection.

Thank you for all your trouble.
",terrywh,2012-04-10 02:31:33
183,2012-01-29 21:16:05,"Greetings,

I'm just looking at the possibility of using node-http-proxy to intercept packets.

Does anyone have any idea if it is possible?

Many thanks,
",hynese,2012-01-29 22:40:38
183,2012-01-29 22:40:38,"It's technically possible, but kind of a pain and not really what http-proxy is for. What would probably work better is writing your server so that it makes a request in-turn. It won't really be transparent (as http-proxy) is, but in the context of, ""do this request and then do something to the returned stuff and THEN send it back"" you'll find it more natural.
",jfhbrook,2012-01-29 22:40:38
183,2012-01-29 22:40:52,"(If anyone disagrees with me, feel free to chime in.)
",jfhbrook,2012-01-29 22:40:38
183,2012-01-30 02:28:37,"No, it's not what http-proxy for.  But if hynese needs pointers, http://www.catonmat.net/http-proxy-in-nodejs/ will show how to write a simple proxy with node that he can do whatever he wants with.
",elfsternberg,2012-01-29 22:40:38
183,2012-01-30 10:23:47,"Thanks guys for the pointers. I guess what I'm trying to do is ""do this request and then do something to the returned stuff and THEN send it back"" as @jesusabdullah has pointed out. @elfsternberg: thanks for the code pointer. I'm actually using that code as a basis to my proxy server, but I'm having lots of trouble getting all to work. Seeing as this isn't related to issues with this project, I'll just try stackoverflow.com. Thanks guys.
",hynese,2012-01-29 22:40:38
183,2012-03-22 16:43:15,"It's actually not that hard @hynese, just not built-in in node-http-proxy. You can quickly gleam that the proxy is only calling `writeHead()`, `write()` and `end()` methods of the `res` object. Since `res` is already an `EventEmitter`, you can use it to broadcast your custom events. Code example here: http://stackoverflow.com/questions/9741607/how-to-listen-to-node-http-proxy-traffic/9826701
",zzen,2012-01-29 22:40:38
183,2012-10-06 06:42:48,"@zzen your example on SO is really helpful. But I'm not clear how to modify the data stream before it gets sent back to the client. 

I need to rewrite a specific header if the response contains that header. I'm checking the headers for a `set-cookie` header, and if one of the cookies matches a value, then I update the `Path` of that cookie to `/`. 

Your code enables me to listen to the data stream for headers, but I'm not clear how to change that data and pass the changed value back to the client. 
",tauren,2012-01-29 22:40:38
183,2012-10-06 10:49:07,"@tauren - thanks, responded on SO as appropriate.
",zzen,2012-01-29 22:40:38
183,2014-06-25 16:55:20,"Here http://benji-chaz.tumblr.com/post/89868067713/0x01-proxy-http-tunnel-ssl-man-in-the-middle-en, you'll find an alternative code in node.js wich read data through a http transparent proxy server even if there is a ssl layer wich makes connection secure 
",benjichaz,2012-01-29 22:40:38
182,2012-01-26 08:51:25,"Greetings,

I'm trying to run the examples, but keep getting the following error (I successfully did `sudo npm install pkginfo`):

sudo node basic-proxy.js 

node.js:201
        throw e; // process.nextTick error, or 'error' event on first tick
              ^
Error: Cannot find module 'pkginfo'
    at Function._resolveFilename (module.js:334:11)
    at Function._load (module.js:279:25)
    at Module.require (module.js:357:17)
    at require (module.js:368:17)
    at Object.<anonymous> (/home/hynese/Desktop/bytecache/new/node-http-proxy/lib/node-http-proxy.js:36:1)
    at Module._compile (module.js:432:26)
    at Object..js (module.js:450:10)
    at Module.load (module.js:351:31)
    at Function._load (module.js:310:12)
    at Module.require (module.js:357:17)

Can anyone help?

I'm using node version v0.6.8.
",hynese,2012-01-26 10:22:34
182,2012-01-26 08:59:01,"Did you run `npm install` after cloning the repo? That should install all npm deps for the project.

`pkginfo` should be part of the npm package as specified here: https://github.com/nodejitsu/node-http-proxy/blob/master/package.json#L20
",Marak,2012-01-26 10:22:34
182,2012-01-26 10:22:30,"Hi, thanks for that. I got it working now.
",hynese,2012-01-26 10:22:34
181,2012-01-25 21:21:12,"Hi, 
 I have simple problem with https proxy server! 
I make simple https proxy server (example files) and set my ip/port as proxy server in my browsers (HTTPS proxy server in Safari & SSL proxy in Firefox) but I could not receive any request when I try to open a secure website. I don't have problem with http servers and I can't handle incoming requests but in HTTP(S) websites, it doesn't work for me!

simple flow is:
1) running https server on localhost:9000 
2) setting http & https proxy in browser 
3) no log in https server! when I want open a secure website in browser (like https://google.com)

thanks
",pedramp,2013-03-09 06:39:02
181,2012-03-29 19:13:57,"> set my ip/port as proxy server in my browsers (HTTPS proxy server in Safari & SSL proxy in Firefox)

Are you sure that node-http-proxy is the type of proxy you're looking for?
",coderarity,2013-03-09 06:39:02
181,2012-03-30 08:27:27,"yes I'm sure that ""proxy-https-to-https.js"" (attention to ""s"") is the type of proxy I'm looking for. however I described above that I'm looking for ""httpS"" proxy, 
after that, when I test it by ""curl -k httpS://google.com"" it works because of that ""-k""
-k means: ""-k/--insecure      Allow connections to SSL sites without certs (H)""
thanks 
",pedramp,2013-03-09 06:39:02
181,2012-03-30 23:27:54,"Can you show me your code? Thanks.
",coderarity,2013-03-09 06:39:02
181,2012-04-01 16:23:32,"this is my code:  https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/proxy-https-to-https.js
1) run it
2) setting SSL Proxy in your FireFox (127.0.0.1:8080)  OR Secure Web Proxy HTTPS in Safari. 
3) opening the http://yahoo.com  (works)
4) opening httpS://google.com ( doesn't work ) please attention to that S.
",pedramp,2013-03-09 06:39:02
181,2012-04-02 13:35:03,"Right. Well, node-http-proxy isn't normally used this way, but let me try to build you a better example to try!
",coderarity,2013-03-09 06:39:02
181,2012-04-02 13:42:45,"Yeah, the reason the HTTP ones work fine is because it doesn't use the proxy for HTTP requests unless you set it up to do so.
",coderarity,2013-03-09 06:39:02
181,2012-04-02 18:25:10,"and any solution? to making a proxy server, compatible with browsers and standard protocols (like http & https & more!)
",pedramp,2013-03-09 06:39:02
181,2012-04-02 21:35:01,"Yeah, I'll make an example and link to it, so when I finish it you should see it show up here.
",coderarity,2013-03-09 06:39:02
181,2012-04-04 00:36:15,"I started writing an example - I would imagine it should look like this.

<S_CODE_TOKEN>

But for some reason, using ""Secure Web Proxy (HTTPS)"" isn't connecting to the server correctly. (Using a normal HTTP proxy is just fine) I tried setting the proxy to something else, like ""github.com"" on port 443, but that didn't work either. I can't find any documentation on this feature of OS X. Unless you have something that can help me, I'm not sure I know how to make this example work.

NOTE: This works fine with curling to the server, but curl bypasses the proxy for some reason.
",coderarity,2013-03-09 06:39:02
181,2012-04-04 08:19:54,"seems we're in starting point and you know what was my problem right now. 
anyway thanks for your pursuit. 
",pedramp,2013-03-09 06:39:02
181,2013-06-06 04:07:33,"@pedramp Hey, did you get something working? Trying to do something similar. 
",zkhalapyan,2013-03-09 06:39:02
181,2013-06-06 08:06:43,"@zkhalapyan nothing! I had problem in secure websites.
",pedramp,2013-03-09 06:39:02
180,2012-01-25 19:04:29,"Hi,
I'm using express and trying to proxy certain requests to a different server, as follows (simplified):

<S_CODE_TOKEN>

...but POST requests to my server appear to just hang, and never arrive at the target server.

I'm working on a stripped-down-but-working example of this but thought I'd ask first. Has anyone seen this behavior, or are there good examples of node-http-proxy coexisting with express?
Thanks!
",joeyAghion,2012-01-26 22:28:55
180,2012-01-25 19:09:17,"I believe your issue may be solved by using the `buffer` method.  A very good explanation can be found [here.](https://github.com/nodejitsu/node-http-proxy/issues/168#issuecomment-3289492)
",AvianFlu,2012-01-26 22:28:55
180,2012-01-26 21:39:08,"@AvianFlu: Thanks for the buffer pointer, but this ended up being caused by express's body-parsing.

Instead of declaring the API route (for proxying) within express routes, I configured it as middleware and `use`d it _before_ `express.bodyParser()`.

Some coffeescript of the solution:

<S_CODE_TOKEN>
",joeyAghion,2012-01-26 22:28:55
180,2012-01-26 22:28:55,"You're correct - express's body parsing turns the request stream into a regular object.  The solution is either to buffer it, as I was suggesting, or to deal with the request before the parsing, as you ended up doing.  Glad you figured it out!
",AvianFlu,2012-01-26 22:28:55
180,2012-02-16 07:23:38,"I ran into this problem too .. http-proxy@0.8.0, express@2.5.8, connect@1.8.5.

In my case, it turns out that http-proxy's buffer doesn't play well with connect's bodyParser middleware.  The buffer is adding listeners for the 'data' and 'end' events to the request object so that it can re-emit them later (on a call to proxyRequest, e.g.).  The bodyParser middleware is also adding listeners for the 'data' and 'end' events to the request object but they are never removed.  So when re-emitted by the buffer, they're picked up a second time by the bodyParser.

This can result in JSON parse errors and ""Can't render headers after they are sent to the client"" exceptions (and probably other errors).
",coldfire22x,2012-01-26 22:28:55
180,2012-12-07 04:14:39,"For those having issues with this, I found that this information seemed a bit out of date or difficult to implement (too much so for me, at least), compared to using connect-restreamer. That approach is outlined in the middleware example for using the bodyParser: https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/bodyDecoder-middleware.js
",eethann,2012-01-26 22:28:55
180,2012-12-30 10:20:37,"So, How to solve this problem? 
",ijse,2012-01-26 22:28:55
180,2013-01-14 23:00:26,"connect-restreamer worked for me.  The last thing in my middle-ware is:

<S_CODE_TOKEN>

Then I have a can do the proxy request normally:

<S_CODE_TOKEN>

Configuring the proxy as part of middleware before bodyParser (if this is an option for you) also worked for me.

I did not attempt the buffer solution.
",cesutherland,2012-01-26 22:28:55
180,2013-05-23 18:15:20,"Also, simply not using the `bodyParser` also works (for anyone's future reference).
",xixixao,2012-01-26 22:28:55
180,2013-06-27 22:28:40,"This thread has helped me. Thanks everyone.
",renatoargh,2012-01-26 22:28:55
180,2013-07-19 04:30:03,"Helpful, Thanks!
",nicolazj,2012-01-26 22:28:55
180,2013-09-13 23:45:47,"For some reason, `connect-restreamer` didn't fix it for me.

If anyone wants yet another fix, I ended up just calling bodyParser manually. So the proxying worked since bodyParser is not in the middleware. The code looked like:

<S_CODE_TOKEN>
",andyfischer,2012-01-26 22:28:55
180,2014-02-06 18:16:22,"@andyfischer 

Man, you saved my life!
",fonini,2012-01-26 22:28:55
180,2014-10-29 15:44:50,"Thanks for that solution it works fine 
Just configure the proxy as part of middleware before bodyParser
",tarek-salah,2012-01-26 22:28:55
180,2014-11-06 17:59:53,"Restreamer works for me.  I needed to leave bodyParser because my proxy was conditional upon the contents of the request body.  Here is a working example authored by someone else:

https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/bodyDecoder-middleware.js
",gdw2,2012-01-26 22:28:55
180,2015-04-14 15:11:35,"The example from [bodyDecoder](https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/bodyDecoder-middleware.js) pointed out by @gdw2 does not work for me. I get 

<S_CODE_TOKEN>

Using `connect-restreamer` results in the request continuing to hang.

I am using express instead of connect. 

<S_CODE_TOKEN>

This may related to [this issue however](https://github.com/nodejitsu/node-http-proxy/issues/777).
",FoxxMD,2012-01-26 22:28:55
180,2015-04-20 15:49:38,"@FoxxMD same behavior here
",franck34,2012-01-26 22:28:55
180,2015-04-28 17:51:36,"For those in the unfortunate position not being able to rearrange/remove the bodyparser middleware:
I've added the snippet from the example bodyDecode middleware right before I use proxy.web(...) and _it just werkz_

<S_CODE_TOKEN>

Hope that helps. This was really frustrating.
",schumacher-m,2012-01-26 22:28:55
180,2015-04-30 08:12:31,"restreamer didn't work for me.
Only way I was able to get it working with routing is like this:

<S_CODE_TOKEN>
",glebtv,2012-01-26 22:28:55
180,2015-05-19 13:18:06,"@schumacher-m thanks for that snippet...works for me
",darrinholst,2012-01-26 22:28:55
180,2015-07-28 23:33:54,"@schumacher-m BIG thanks for your tips. It works around the hang issue finally - after a whole day of debugging.
",aidanbon,2012-01-26 22:28:55
180,2015-11-03 16:43:27,"Thanks @schumacher-m . There's actually also an example in the repo itself that handles the same issue: https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/bodyDecoder-middleware.js
",dmkc,2012-01-26 22:28:55
180,2016-02-22 16:57:23,"Thanks all - I went with OP's suggestion and moved the proxy route above the bodyParser middleware
",homerjam,2012-01-26 22:28:55
180,2016-03-02 06:58:37,"I used all of the solution above, **_but it's not worked anyway**_.
So, I read the http-proxy source and request API, I found that's the question of request.
and http-proxy have no solution with the body parameters .
There is no need to use a middleware.

And this is my solution:

<S_CODE_TOKEN>
",vvpvvp,2012-01-26 22:28:55
180,2016-04-19 20:12:30,"@vvpvvp,Can i modify/add `req.newkey = 'a'` and send it to the proxy
",tomalex0,2012-01-26 22:28:55
180,2016-04-29 15:53:54,"None of these solutions work with the latest version of express & http-proxy, any suggestions? Here is what my code looks like - I still get the hanging POST request issue. I am just trying to read the POST body before conditionally proxying the request.

<S_CODE_TOKEN>

EDIT: I am now getting a 'write after end' error which is odd because I am using restreamer.
",narciero,2012-01-26 22:28:55
180,2016-06-20 06:39:52,"@vvpvvp big thinks for your tips
",gutenye,2012-01-26 22:28:55
180,2016-07-03 17:39:54,"@narciero I am also getting same error. Did you find any workaround for this ?
",akprats33,2012-01-26 22:28:55
180,2016-09-03 23:33:12,"Putting this before using the express body parser worked for me!  Thanks for the help guys.
",dansantner,2012-01-26 22:28:55
180,2016-11-05 07:22:14,"Hi

I have done slightly similar yet different fix for this, without using any restreamer, take a look [here](https://github.com/rajiff/express_proxy_example/blob/master/express_frontend/app.js) 

Idea is to not use the body-parser as middleware instead apply only to the matched routes in my local web server and hence don't bring in the body-parser at all in between proxy and the local web server

Comments, suggestions welcome
",rajiff,2012-01-26 22:28:55
179,2012-01-23 11:37:13,"Hello,

I'm facing a case where I would like to pass arguments between middlewares :
httpProxy.createServer(
    require('./middlewares/compute')(),
    require('./middlewares/use')(),
    require('./middlewares/use2')()
);

I would like to compute some value in middlewares/compute and then pass this value with next(argument).

Unfortunately next() only take one argument : error, do you think it would be a good use case or am I doing it wrong ?

Should middlewares be able to do that ?
",vvo,2012-11-05 09:33:06
179,2012-02-12 03:08:03,"You're trying to do enough with your middlewares that it seems like you might want to consider an actual middleware kernel in your project.  I recommend [Union](https://github.com/flatiron/union).

What, more specifically, are you trying to build?
",AvianFlu,2012-11-05 09:33:06
179,2012-03-31 01:35:09,"@vvo have you tried Union? `node-http-proxy` lets you use your own http server to route requests, see ""Setup a stand-alone proxy server with custom server logic"" in the readme. Union can fill the job of http.createServer for you.
",coderarity,2012-11-05 09:33:06
179,2012-07-12 13:45:28,"Sorry it took me a while to respond.

What I'm trying to do is build a wrapper around the node clientReq object.

I want to use this object wrapper in multiple middlewares, so I wanted to pass it to next(mySuperReq).

If I could pre-compute it in one middleware and then use it in other middlewares it could be cool. Atm I'm rebuilding it in each middleware.

I looked at union but could not figure out :
1. How to use it with node http proxy (I think I need to use a routing proxy?)
2. How to pass more arguments than req, res to my middleware?
",vvo,2012-11-05 09:33:06
179,2012-11-05 09:29:33,"@vvo As a hackish workaround, some connect middleware seem to invade the request object. See https://github.com/senchalabs/connect/blob/master/lib/middleware/logger.js#L136 for an example.
",tuomassalo,2012-11-05 09:33:06
179,2012-11-05 09:33:02,"Yes I never wanted to do it that way because I thought ""OMG I'm gonna add a property on the `req` object""

I guess as long as you do not add 10 properties it's ok..?
",vvo,2012-11-05 09:33:06
178,2012-01-21 16:23:26,"If this issue should be discussed elsewhere, please let me know the best place.

++

I have a very simple reverse proxy set-up. Here's the skeleton:

<S_CODE_TOKEN>

The app running at 8081 expects a query string.

(Note: I'm forwarding 80 to 8082.)

Loading mytest.local/mypath or mytest.local/mypath/ works as expected. However, when the query is thrown in (mytest.local/mypath?foo=bar), the server never responds. With a trailing slash (mytest.local/mypath/?foo=bar) all is good.

You may be thinking: 'so what, use the trailing slash.' On top of it, the server continues to respond though other clients are hung up and waiting forever. 

But, it just doesn't seem correct. It should work either way, no? 
",twhid,2013-03-09 07:13:08
178,2012-01-22 15:44:43,"In ProxyTable.prototype.getProxyLocation (proxy-table.js)...

If one ensures the request url begins with a '/' (after stripping out the pathSegments around line 145) then things work as I'd expect. 

e.g. `req.url = req.url[0] === '/' ? req.url : '/' + req.url;`

I may be coding to my particular use-case, but the browsers I've tested (Chrome, Safari, Firefox 9) all insert a slash for you if it's not in a url. 

The question is: should a proxy have this sort of error correction?
",twhid,2013-03-09 07:13:08
178,2012-01-23 20:28:52,"For my particular use I decided to add some logic to the proxy server before proxying.

E.g.

<S_CODE_TOKEN>
",twhid,2013-03-09 07:13:08
178,2012-01-24 11:32:56,"Oops. The code above has a huge bug where it fails to handle legit URLs where a file is passed a query. I.e. domain.com/file.php?foo=bar becomes domain.com/file.php/?foo=bar.

Probably be better to use a regular expression in the redirect condition.
",twhid,2013-03-09 07:13:08
178,2012-03-29 19:22:29,"Hmmm, can you try running this on [my branch](https://github.com/CodeRarity/node-http-proxy/tree/proxy-table-fix) and see if the problem still exists?
",coderarity,2013-03-09 07:13:08
178,2012-06-05 22:42:57,"@twhid can you check if this still its an issue? use the 0.8.1 version.
",cronopio,2013-03-09 07:13:08
177,2012-01-14 14:16:29,"ex) http://maps.google.com/maps/api/geocode/json?latlng=40.714224,-73.961452&sensor=true

With Nginx, 

<S_CODE_TOKEN>

Works nicely.

But somehow with node-http-proxy, 

<S_CODE_TOKEN>

Does not work.

I guess Nginx and node-http-proxy handles header differently :(    ex) X-Forwarded-For, Referer and etc.

I want to use node-http-proxy :)  instead of nginx to make this work.

Would you take some time to change header values when reverse proxying?
",inspiredjw,2013-03-09 07:27:15
177,2012-01-14 14:21:47,"Below is my example code snippet (jQuery code) that works well with Nginx's ""proxy_pass""

<S_CODE_TOKEN>
",inspiredjw,2013-03-09 07:27:15
177,2012-01-14 15:49:37,"Need some more info here:
1. What exact header values do you want changed? You mentioned `x-forwarded-for` and `referer`, others? The list needs to be exhaustive
2. What are the values of these headers now?
3. What should they be? And why?
",indexzero,2013-03-09 07:27:15
177,2012-01-14 15:54:10,"That was what I was asking you.. What those values of headers should be.. 

How nginx proxy headers are different from http-proxy headers..

and implementation.....
",inspiredjw,2013-03-09 07:27:15
177,2012-01-14 16:32:49,"I don't really know nginx ... we do set them. 
",indexzero,2013-03-09 07:27:15
177,2012-01-14 16:41:05,"What about making exact same behavior as access from a browser? That would work since 

ex) http://maps.google.com/maps/api/geocode/json?latlng=40.714224,-73.961452&sensor=true

url works through browsers :)
",inspiredjw,2013-03-09 07:27:15
177,2012-01-24 10:08:34,"@indexzero 
Do node-http-proxy actually set headers as a client or as a server? I think nginx is sending headers as a client.
",inspiredjw,2013-03-09 07:27:15
177,2012-03-31 01:44:55,"It's because you're using a subdomain, see nodejitsu/node-http-proxy#217 (which doesn't have much yet, but I'm going to work on this soon). Or at least - I think it is =D
",coderarity,2013-03-09 07:27:15
177,2013-03-09 07:27:13,"Fixed along with #217 
",indexzero,2013-03-09 07:27:15
176,2012-01-11 07:38:57,"Hello, nodejitsu folks!

I'm writing a little deploy guide here: https://github.com/Miserlou/NodeDeploy

the only problem I'm having is with the requirements of the websockets example. The ('../../vendor/websocket') import didn't work, so I set it to the full path ('/var/www/myapp/node_modules/http-proxy/vendor/websocket'), which worked.

Unfortunately, that gave this error:

node.js:201
        throw e; // process.nextTick error, or 'error' event on first tick
              ^
TypeError: Object #<Object> has no method 'getAgent'
    at /var/www/DirtyShare/node_modules/http-proxy/vendor/websocket.js:499:53
    at new <anonymous> (/var/www/DirtyShare/node_modules/http-proxy/vendor/websocket.js:627:6)
    at Object.<anonymous> (/var/www/DirtyShare/proxy.js:73:10)
    at Module._compile (module.js:432:26)
    at Object..js (module.js:450:10)
    at Module.load (module.js:351:31)
    at Function._load (module.js:310:12)
    at Array.0 (module.js:470:10)
    at EventEmitter._tickCallback (node.js:192:40)

Which is for this line:

var ws = new websocket.WebSocket('ws://localhost:8080/socket.io/websocket/', 'borf'); //why borf?

ws.on('open', function () {
  ws.send(utils.encode('from client'));
});

ws.on('message', function (msg) {
  util.debug('Got message: ' + utils.decode(msg));
});

What exactly is going on here? I don't understand what this section of code actually does, and why there is a 'borf'. 

What should I do here? I'm so close to getting this deployed!

Thanks guys!
",Miserlou,2012-01-11 08:37:36
176,2012-01-11 07:44:44,"Need running versions of _node.js, node-http-proxy, and npm_ to give more details. At first look though, why are you using `vendor/websocket.js`? It's used only for tests; there are much more robust node.js websocket clients out there.
",indexzero,2012-01-11 08:37:36
176,2012-01-11 07:49:14,"node -v
v0.5.11-pre

npm -v
1.0.106

cat ./http-proxy/package.json
..
  ""name"": ""http-proxy"",
  ""version"": ""0.7.6"",
..

The reason I am using these imports is because they are in this example, which is the one I am modifying:
https://github.com/nodejitsu/node-http-proxy/blob/master/examples/websocket/websocket-proxy.js

What should I be importing instead? Also, what is actually happening with the ""borf"" line?

Thanks for you swift reply!
R
",Miserlou,2012-01-11 08:37:36
176,2012-01-11 08:11:22,"You shouldn't be on `node@0.5.x` it is _unstable_. Upgrade to `node@0.6.7` and see if you have the same problem.
",indexzero,2012-01-11 08:37:36
176,2012-01-11 08:25:25,"node -v
v0.6.7

Good thought, but upgrading didn't do anything for the sockets. Still, what does 'borf' mean? Why does the example include the vendor version?
",Miserlou,2012-01-11 08:37:36
176,2012-01-11 08:32:36,"Because this pull-request was never accepted: https://github.com/pgriess/node-websocket-client/pull/9
",indexzero,2012-01-11 08:37:36
176,2012-01-11 08:33:05,"You should also be using node-http-proxy@0.8.0
",indexzero,2012-01-11 08:37:36
176,2012-01-11 08:37:36,"Wahey! That did it! ( I think. )  Made the error go away, at least. Noob mistake on my part.

Thanks very much! Great software, great support. You guys are awesome.
",Miserlou,2012-01-11 08:37:36
175,2012-01-09 05:12:04,"...tps-to-https.js, lines 37 and 46

(changed ""Crete"" to ""Create"")
(I had trouble rebasing on a previous fork so this is a new pull request from a fresh fork)
",metahack,2012-01-09 11:11:29
175,2012-01-09 11:11:29,"Thanks! Applied to `master` as 868f7e7a287c4709c541c077f3e2303f45b1f072.
",mmalecki,2012-01-09 11:11:29
174,2012-01-08 04:41:07,"...tps-to-https.js, lines 37 and 46

(changed ""Crete"" to ""Create"")
",metahack,2012-01-09 05:00:39
174,2012-01-08 07:43:01,"@metahack Seem to be several bad merges in this commit, e.g. https://github.com/metahack/node-http-proxy/commit/1d51b7897f4cc05e8387a12a03b8c5a1f0140b0a#L1R37
",indexzero,2012-01-09 05:00:39
174,2012-01-09 05:07:26,"I was't able to rebase that fork so I created a clean new fork and a new pull request.
",metahack,2012-01-09 05:00:39
173,2012-01-05 06:48:04,"In node-http-proxy v0.8.0:

<S_CODE_TOKEN>

[NodeJS v0.6.6's API](http://nodejs.org/docs/latest/api/http.html#response.writeHead) has changed this call to this:

<S_CODE_TOKEN>
",ming-codes,2012-02-12 03:00:44
173,2012-02-12 03:00:44,"This is irrelevant here - we have no reason to provide `reasonPhrase` for heads generated by proxy ([like this one](https://github.com/nodejitsu/node-http-proxy/blob/868f7e7a287c4709c541c077f3e2303f45b1f072/lib/node-http-proxy/http-proxy.js#L190)) and we have no way to get to know what was the reason phrase for proxied heads.
",mmalecki,2012-02-12 03:00:44
172,2012-01-02 16:29:05,"Given the following router (URL based),

<S_CODE_TOKEN>
- Requests to baz.com/taco will get proxied to  127.0.0.1:8098/
- Requests to baz.com/taco/hot will get proxied to 127.0.0.1:8098/hot
- Requests to biz.com will get proxied to  127.0.0.1:8088/taco
- Requests to biz.com/foo will get proxied to  127.0.0.1:8088/taco/foo

The behavior is the same for hostname based routers. For example, given the following router (hostname based): 

<S_CODE_TOKEN>
- Requests to biz.com/taco will get proxied to 127.0.0.1:8013/extra/taco
- Requests to buz.com/dude will get proxied to 127.0.0.1:8014/mega/extra/dude
- etc.

routing-proxy-test.js contains additional examples.
",MathieuTurcotte,2012-06-10 22:54:27
172,2012-01-26 07:29:59,"+1 on that
",ovaillancourt,2012-06-10 22:54:27
172,2012-03-05 18:05:53,"+1

Is there any movement on this or a workaround besides the patch?
",webxl,2012-06-10 22:54:27
172,2012-03-05 18:15:22,"Not to my knowledge.
",MathieuTurcotte,2012-06-10 22:54:27
172,2012-06-10 22:54:27,"Since commit 64c974755d767d79531065625580546d46236d36 seems to fix the same problem, I'll close the pull request.
",MathieuTurcotte,2012-06-10 22:54:27
172,2012-06-11 02:37:22,"@MathieuTurcotte -> Thx for the closing notification, wouldn't have found about that commit otherwise. Appreciated.
",ovaillancourt,2012-06-10 22:54:27
171,2012-01-01 11:52:48,"Hello,

I am having an issue where the first request to any domain which is handled by the proxy appears to take 2-3 seconds to load before it actually does.

This was all running on a dedicated server, so I tried it out locally and had the same issue, so I set it up locally on another pc (for sanity sake) and the issue is still happening.

This is the code I am using:

> var proxy = require(""http-proxy"");
> 
> proxy.createServer({
>   hostnameOnly: true,
>   router: {
>       ""admin.local"": ""localhost:8081"",
>       ""web.local"": ""localhost:8080""
>   }
> }).listen(80);

Seems to be happening on every version of node I have tested with (0.6.6, 0.6)

Is this a known issue with 0.6 compatibility, is this a known performance tradeoff when proxying like this? Have I done something silly? I am not sure!

Some clarity as to why this issue might be happening and would be great.

Thanks!

edit: The platforms I have tested this with are (osx 10.6, 10.7 and freebsd 8.2)
",steve220685,2012-02-14 18:28:20
171,2012-01-01 11:55:31,"Can you try using node's core http.request method or use mikeal's `request` library?

You should be able to get the same functionality, and be able to possibly isolate the performance bottleneck.
",Marak,2012-02-14 18:28:20
171,2012-01-01 12:27:46,"Hi,

Ultimately, I would prefer to use a plugin that has been developed and tested by a community (and is known to perform well for the exact purpose I am using it for) and does not reproduce existing functionality within express.

That said, to try and narrow down what could be causing this issue, I have revised my sample to include a simple core http server that does a simple text dump and the same issue is still happening.

Here is my revised sample.

> var http = require(""http""),
> proxy = require(""http-proxy"");
> 
> proxy.createServer({
>   hostnameOnly: true,
>   router: {
>       ""web.local"": ""localhost:3000""
>   }
> }).listen(80);
> 
> http.createServer(function(req, res) {
>   res.writeHead(200, {
>       ""Content-Type"": ""text/plain""
>   });
>   res.write(""OK"");
>   res.end();
> }).listen(3000);
",steve220685,2012-02-14 18:28:20
171,2012-01-23 10:10:34,"Hi,

I am having the same issue on node 0.6.7, also using a simple core http server and a proxy with the same kind of config as above.
",jeremyfa,2012-02-14 18:28:20
171,2012-01-24 10:59:32,"Bumping priority to medium.
",mmalecki,2012-02-14 18:28:20
171,2012-01-24 13:39:45,"Some infos after more tests:

It doesn't seem to be directly related to http-proxy as I could reproduce the same problem with simple node http server without proxy.

Also, I've got this issue only locally on OSX Lion. I could not reproduce it on the Debian machine I have.

And then, let's say I can access my local http server through localhost, 127.0.0.1, myhostname1.local and myhostname2.local, the issue appears only at the first request of myhostname1.local and myhostname2.local.

No idea of what is going on.
",jeremyfa,2012-02-14 18:28:20
171,2012-01-25 01:46:16,"Upon further investigation myself, it does indeed appear to be a Mac only issue, my freebsd servers have since fixed themselves up (Perhaps it was network latency as I am located in Australia and my servers are located in the USA and piped through locally via an SSH tunnel)

In addition to this, it does indeed appear to be not directly related to node-http-proxy as I have since tested bouncy, which is another node http proxy library, and it has the same fault.

In short, I have the exact same problem as jeremy, would be interesting to see if other mac users are having this problem too.
",steve220685,2012-02-14 18:28:20
171,2012-02-13 18:08:23,"I can confirm that this happens only on Mac OS X. Also, it happens only for domains with dots in names:

<S_CODE_TOKEN>

Same holds true for node's http client.

I've got some interesting output from `dtruss`:
- [`curl sub.local:8000`](https://gist.github.com/1818683#file_dtruss_sub.local)
- [`curl local:8000`](https://gist.github.com/1818683#file_dtruss_local)

I've used following script:

<S_CODE_TOKEN>

And `/etc/hosts` to map `sub.local` and `local` to `127.0.0.1`.

However, it's not related to `node-http-proxy` in any way - same happens for pretty much every server (tried with [`http-server`](https://github.com/nodeapps/http-server), [`luvit`'s example server](https://github.com/luvit/luvit/blob/0f107d185cc409fd0430dd91f4af2ddf0456141b/examples/http-server.lua) and `nginx`).

If there's anyone who can explain it, please do.
",mmalecki,2012-02-14 18:28:20
171,2012-02-13 18:18:16,"Dns or arp caching? Did you check for intermittent network requests with wireshark?
",einaros,2012-02-14 18:28:20
171,2012-02-13 18:34:36,"Something triggering IPv6 name resolution?
",bpanulla,2012-02-14 18:28:20
171,2012-02-13 18:35:43,"Is http://itand.me/mac-os-x-lion-local-domains-and-etchosts-oh-m related?
",Marak,2012-02-14 18:28:20
171,2012-02-13 18:44:37,"@marak, yep. First request does a forced dns lookup, subsequent use cache.
",einaros,2012-02-14 18:28:20
171,2012-02-13 18:45:43,"Thanks for the link! It is probably related. For now I will replace my "".local"" extensions to "".dev"" instead...
",jeremyfa,2012-02-14 18:28:20
171,2012-02-14 06:03:56,"Cool, thanks for the information, I too will replace .local with .dev and let you guys know if it resolves my problems.
",steve220685,2012-02-14 18:28:20
171,2012-02-14 15:01:50,"I confirm I do not have the issue anymore when I'm using *.dev addresses.
I guess we could tweak into OSX Lion in order to use *.local hostnames without 5s latency, but I think it will be wiser to use another extension.
",jeremyfa,2012-02-14 18:28:20
171,2012-02-14 18:28:20,"Awesome. Good to know it's not our fault. Thanks for heads up guys! @Marak, you won internets for finding it!
",mmalecki,2012-02-14 18:28:20
170,2011-12-24 15:52:47,"Hi guys, it possible to route something like this ...

im using routing table ... complete example :

<S_CODE_TOKEN>

thks !!
",outaTiME,2012-01-05 02:04:35
170,2012-01-05 02:04:35,"Previously, the proxy did not modify the requested path when proxying---that is, you could route localhost/images/badge.png to web.foo.com/images/badge.png . However, I believe there have been patches to allow for modifying the path.

My suggestion would be to try it and see. If it works, awesome! If not, either find a different way to solve the same problem or find/file an issue saying it's not working but should.

In the future: It would be better to chat with us in #nodejitsu on irc.freenode.net about questions like this, since the issues tracker is primarily for software bugs and features.
",jfhbrook,2012-01-05 02:04:35
169,2011-12-21 05:37:30,"also reverted cloud9's changes to changeOrigin which broke the functionality of changeOrigin for me
",jmonster,2012-07-22 06:53:18
169,2012-07-22 06:53:18,"The implementation here has changed significantly since this was originally implemented. Still open to the feature, but you will need to pull and re-implment.
",indexzero,2012-07-22 06:53:18
168,2011-12-15 15:28:34,"I am trying to call ""proxy.proxyRequest()"" within a callback function after reading some data, but this does not work at all (or at least i can't see my mistake :) )

Try to use my code below - with the request url ""http://localhost:8000/"" everything is fine and the request will be routed to the target server (same script - port 9000).
But when you try to load something with the url ""http://localhost:8000/no-routing"" first (or save or anything that needs a callback function), the target server never receives a request, no error will be raised and the client never receives a response and stays pending.
Nevertheless the function ""proxyRequest()"" and the node.js function ""http.request()"" will be called, but nothing goes to the target server.

Hope it stays an easy issue - any help is greatly appreciated :)
Cheers!

<S_CODE_TOKEN>
",taris,2011-12-28 09:55:44
168,2011-12-15 17:12:48,"As a sidenote: tried it the same way as the example ""Proxy requests within another http server"" as well - same behaviour
",taris,2011-12-28 09:55:44
168,2011-12-16 11:17:02,"It does work, when you use http.request() directly and i replaced node-http-proxy with an own small proxy module for now.
Maybe someone finds a bug or points me to my failtrain :D
",taris,2011-12-28 09:55:44
168,2011-12-26 07:12:35,"did anybody at least verified this already?
",taris,2011-12-28 09:55:44
168,2011-12-28 09:55:44,"Thanks to AvianFlu i got the right way. The clue is, that the request object is a stream and you need to handle it right away or buffer it. In this case the following code works:

<S_CODE_TOKEN>

Take a look at lines 18 and 29. You need to create the buffer, hand it over to the proxy and then start to route the request.
",taris,2011-12-28 09:55:44
167,2011-12-13 07:29:25,"I'd like to proxy requests to an API backend if the `Accept` header matches a certain regex. If it doesn't match, no proxying is done and instead a static page is served with Connect's `static` middleware.  I saw that `createServer` allows me to either pass in middleware, or to pass in a function to modify before proxying, but I don't see how to conditionally proxy based on request attributes.

How would one go about writing this?  In pseudocode, I'd want something like:

<S_CODE_TOKEN>
",jch,2012-03-30 13:39:21
167,2011-12-16 06:20:19,"I did something similar, but based on a url. First i tried it with the static middleware before using the proxy, but it didn't work out the way i wanted.

At the end i moved the static part to another connect server instance and proxied to it when my criterias matched. In your case i would do something like that:

<S_CODE_TOKEN>

Didn't test it, but it should give you a hint :)
",taris,2012-03-30 13:39:21
167,2011-12-23 21:13:06,"I'd like to use a URL approach also: handle requests to certain URLs with the primary app, but proxy certain URLs to a separate app. It seems from the examples that the components to do all this exist, but I can't get them to work together. Creating a 3rd server seems redundant... does anyone know another way? Thanks!
",benbuckman,2012-03-30 13:39:21
167,2012-03-30 02:15:38,"@jch does your example not work for you? If you don't call `next` in your middleware, it won't pass it on to the default handler anyways (next is a function passed into the third parameter in the middleware).
",coderarity,2012-03-30 13:39:21
167,2012-03-30 13:39:14,"@CodeRarity I ended up with a different architecture, so I no longer needed to proxy requests. It was more trouble than it was worth, so now I have my API and static web endpoints mounted together at the same place.
",jch,2012-03-30 13:39:21
167,2015-04-07 08:56:57,"Hi @jch ,

Could you tell me how did you overcome this issue?
Me too need implement a conditional proxy. 
",efkan,2012-03-30 13:39:21
166,2011-12-05 02:15:44,"when use http-proxy in this manner - i do not have a problem - the target is reached.

httpProxy.createServer(function (req, res, proxy) {
    var target = locations[1];
  proxy.proxyRequest(req, res, target);

but i want to create server with express
so i do the following 

  var proxy = new httpProxy.HttpProxy();
  proxy.proxyRequest(req, res, target);

i get the following 500 Error: Both `options` and `options.target` are required.

is there something else that is required. 
",alnoor,2012-01-04 23:31:11
166,2011-12-05 02:18:41,"That isn't how the API works, read the examples and the documentation.
",Marak,2012-01-04 23:31:11
166,2011-12-05 02:34:15,"hi i have been looking at the examples ( could be looking at the wrongs ones) - when i use the examples in http proxy - they work but the second way  was also derived from some example 

so is there a way to create a server using express and then using http-proxy to forward incoming requests
",alnoor,2012-01-04 23:31:11
166,2011-12-05 02:35:56,"Can you post the exact code you are trying to run?
",Marak,2012-01-04 23:31:11
166,2011-12-05 02:45:05,"<S_CODE_TOKEN>

 This one above works fine - the location content is retrieved from the database 

the second method ( one that does not work )

<S_CODE_TOKEN>
",alnoor,2012-01-04 23:31:11
166,2011-12-05 02:50:13,"Express is probably buffering your request and doing all sorts of other things that break streaming. You'd need to hook into `express` and do something like https://github.com/nodejitsu/node-http-proxy/blob/master/examples/http/latent-proxy.js

@visionmedia - Is there a `node-http-proxy` and `express` example floating around? People ask us about this all the time.
",Marak,2012-01-04 23:31:11
166,2011-12-05 02:50:44,"All my incoming request come to a single point and i do not know the server destination until i consult the incoming message and consult a db (or file) to figure out which server to target the message too. 

/page2 could go to any server (depending on the destination user should br targeted to) - so same application, many servers,

also bear with me, i am new to functional programming
",alnoor,2012-01-04 23:31:11
166,2011-12-05 03:00:53,"not that I'm aware of, express wont be doing anything to affect streaming though unless the dev wants to utilize bodyParser in which case the body will already be consumed, it's not broken, it's just the user's choice
",tj,2012-01-04 23:31:11
166,2011-12-05 03:17:16,"I have set (and commented out )   app.use(express.bodyParser()); note: i have note used any of the functions besides the configuration as i am progressively  building my app.

what are the difference between creating a http server using http-proxy vs express that they manifest in the options requirement for the proxy
",alnoor,2012-01-04 23:31:11
166,2011-12-05 03:32:52,"@alnoor this applies to any node app, not just Express, but you have to think about what is happening when you do a database query while you have an incoming request. The request body ""data"" events wont stop for you, they will still fire while the database query is processing, so when the query is complete you may have potentially ""missed"" several if not all of the body.
",tj,2012-01-04 23:31:11
166,2011-12-05 03:50:13,"at this point, i am single threaded but you right - i am using the async database. but more than that i am calling the database at app start up and creating a set of targets - when a request comes in  i consult the locations table and forward the request - 
1. because the table is created at start up it is not an issue as it is not consulted as the server is not created .
2. i would think that a second request coming in while i am searching through the locations table (in memory)  would not get cpu until this the first call had finished. 

but i take your point and am trying to make sure that concurrent requests are catered to. But at this point i am trying to move past the point where a single request is directed to the correct server 
",alnoor,2012-01-04 23:31:11
166,2011-12-05 03:53:30,"gotcha, you're right, I thought you were querying each time or something, but yeah that should be fine then as long as you dont use middleware that are designed to consume the body
",tj,2012-01-04 23:31:11
166,2011-12-05 04:02:18,"i want to thank both you and marak for taking the time to respond. Is there a proxy package built using express. maybe you have seen this,  what i want to make sure is that when a user comes back for page2 and page3 .. he is routed to the same server  as when they first came in. Now express gives you all the session stuff ( i am just learning all this so may not be clear ) that would allow me to send the user to the same server. 
",alnoor,2012-01-04 23:31:11
166,2011-12-05 04:06:14,"personally I would stay away from sticky load balancing unless you have a good reason for it, otherwise it's just a drain on perf
",tj,2012-01-04 23:31:11
166,2011-12-05 04:30:16,"I envision a service where i provided location independence to the client. So client one wants their back end data in Toronto and another client wants it in Vancouver (or Russia) but all the service is invoked through the same entry point. I thought the easy way is to replicate the service app and proxy to the server where the back end app is running. 
the problem is to proxy based on the client as well as the clients users whose session has to be targeted to the correct server  - further when a user comes in the client is unknown.  
so initial request - session unknown - go to default server - send back base page - ask question ascertain destination based on response - create session destination route table then ensure all subsequent requests are routed to the same server. 
so really looking for dynamic routing 
",alnoor,2012-01-04 23:31:11
165,2011-11-29 18:53:16,"This handles the case where a back-end web application such as Django or
Rails issues a redirect and automatically decorates the URL with the
protocol with which it was addressed.  If the back-ends are internal and
HTTP-only, then they'll issue a URL with 'http://' as the protocol.
This must be fixed before leaving the proxy.

This also handles the (unusual) case where a back-end speaks only
https://, but the user is deploying node-http-proxy to make that service
available to non-SSL capable browsers.  Works only with 301 and 302
codes.

May fix Issue #37.  All I know is it works for my use case.
",elfsternberg,2011-12-14 06:21:51
165,2011-11-30 19:39:32,"This pull request also contains the commit from your other pull request.  Did you want the other one closed, or was it an extraneous commit?
",AvianFlu,2011-12-14 06:21:51
165,2011-11-30 20:12:30,"I meant to only include the redirect issue.  Github, for some reason, thought I was including both.  Sorry, I'm a little new to pull requests. 
",elfsternberg,2011-12-14 06:21:51
164,2011-11-29 18:48:59,"Modified the ad-hoc proxy lookup to use _getKey(), rather than the error-prone in-line method.

_getKey() will look for options.target as well as options.host:options.port, and so is useful for a segmented proxy server where the destination proxies are not constructed before first references.
",elfsternberg,2011-12-14 06:21:07
164,2011-11-29 19:33:02,"Thanks!  We'll get this reviewed as soon as possible.
",AvianFlu,2011-12-14 06:21:07
163,2011-11-28 09:03:32,"Please see https://github.com/nodejitsu/node-http-proxy/issues/143.
",samyakbhuta,2011-12-08 22:07:21
163,2011-11-30 19:40:41,"Thanks!  We'll get this reviewed as soon as possible.
",AvianFlu,2011-12-08 22:07:21
162,2011-11-26 22:19:24,"With the actual 0.7.7 version i get a 

var reverseProxy = agent.appendMessage(outgoing);                           ^
TypeError: Object #<Agent> has no method 'appendMessage'

Exception when i access the proxy via websocket requests.
",macrauder,2011-11-26 22:33:34
162,2011-11-26 22:33:34,"`node-http-proxy` is not compatible with `node v0.6` yet, but this particular thing has been fixed in [0.6-compatibility](https://github.com/nodejitsu/node-http-proxy/tree/0.6-compatibility) branch, in c1d5bc9c2f07b7ffd5b723f17d663ad0e484e609.

Please note that websockets don't work on `node v0.6` yet.

Please see #159.
",mmalecki,2011-11-26 22:33:34
162,2011-12-06 20:56:58,"I get the same issue on `node v0.5.10` and `node-http-proxy v0.7.6`. I am trying to test websocket proxying with node-http-proxy.  This is what I'm doing:
https://gist.github.com/1439942

The code is adapted from the websocket code sample linked at this nodejitsu blog post:
http://blog.nodejitsu.com/http-proxy-intro

Fwiw, I am still struggling to get websockets proxying with `node-http-proxy` (v0.7.6, and node v0.5.10) when the target server is not running locally (I get the error referenced in #112). I'd love to see some sample code to do that.
",bantic,2011-11-26 22:33:34
162,2011-12-06 22:57:41,"`0.5.x` is the same compatibility as `0.6.x` node 

Why are you running an unstable version of node? Anything in an odd numbered Node minor release is considered unstable by definition.
",Marak,2011-11-26 22:33:34
162,2011-12-06 23:11:43,"My bad.  I didn't realize. I was just testing it and thought I'd get the latest non-0.6.x version of node.
",bantic,2011-11-26 22:33:34
161,2011-11-26 20:38:24,"I have socket.io setup for `slides.wavded.com` but when using the application its just using xhr long-polling, however I swear this was working before I upgraded from node 0.4.12 to node 0.6.3.  am I doing this right or should I be using the more verbose websocket proxying or is this a bug?  Here is my proxy server code:

<S_CODE_TOKEN>
",wavded,2012-01-02 19:57:08
161,2011-11-26 20:44:11,"Websockets don't work in `node-http-proxy` with `node@0.6` yet. Some work has been started in [0.6-compatibility](https://github.com/nodejitsu/node-http-proxy/tree/0.6-compatibility) branch.
I would :heart: a pull request for that.
",mmalecki,2012-01-02 19:57:08
161,2011-11-26 21:00:14,"Thanks for the heads up @mmalecki, I'll switch over to 0.4.12 to run node-proxy for now, glad I'm not crazy :)
",wavded,2012-01-02 19:57:08
161,2011-12-08 23:11:11,"Full 0.6 support should be in place sometime next week.  
",AvianFlu,2012-01-02 19:57:08
161,2012-01-02 19:57:08,"This should work in `http-proxy@0.8.0` - all known websocket issues were resolved.  Please let us know if you still have problems.  
",AvianFlu,2012-01-02 19:57:08
160,2011-11-22 16:44:34,"I'm not sure if this is a bug or rather a feature, but I need the `%2F` to remain in the req.url:

<S_CODE_TOKEN>

Maybe you could me to the place where I can change this behavior in an own fork?
",gr2m,2015-10-30 20:46:33
160,2011-11-22 19:09:18,"As far as I can tell, `node-http-proxy` doesn't modify the url at all.  It could potentially be happening in core's http library, but without more information, it's hard to say.  Can you gist a larger code sample for us to see?
",AvianFlu,2015-10-30 20:46:33
160,2011-11-22 19:09:22,"[This strikes me as a bug.](http://stackoverflow.com/questions/1957115/is-a-slash-equivalent-to-an-encoded-slash-2f-in-the-path-portion-of-a#1957168)
",jfhbrook,2015-10-30 20:46:33
160,2015-10-30 20:46:33,"No longe relevant.
",jcrugzz,2015-10-30 20:46:33
159,2011-11-22 01:51:39,"This is what I get when I try to install it via npm

<pre>
npm ERR! Unsupported
npm ERR! Not compatible with your version of node/npm: http-proxy@0.7.6
npm ERR! Required: {""node"":""0.4.x || 0.5.x""}
npm ERR! Actual:   {""npm"":""1.0.105"",""node"":""0.6.2""}
npm ERR! 
npm ERR! System Linux 3.1.1-1-ARCH
npm ERR! command ""node"" ""/usr/bin/npm"" ""install""
npm ERR! cwd /home/pita/yammercode/etherpad-lite-router
npm ERR! node -v v0.6.2
npm ERR! npm -v 1.0.105
npm ERR! code ENOTSUP
npm ERR! 
npm ERR! Additional logging details can be found in:
npm ERR!     /home/pita/yammercode/etherpad-lite-router/npm-debug.log
npm not ok
</pre>
",Pita,2012-01-02 19:56:01
159,2011-11-22 01:55:55,"We've got a branch under development working on full 0.6 compatibility - there are still a few bugs in the meantime.  For now, you can either `npm install --force` or `npm install --node-version 0.6.2` to override.
",AvianFlu,2012-01-02 19:56:01
159,2011-11-22 01:56:50,"that helps, thx
",Pita,2012-01-02 19:56:01
159,2011-11-23 18:59:48,"@AvianFlu: Would these issues be related to how, under 0.6.2, I've never seen and 'end' or 'close' event from the proxy?  
",elfsternberg,2012-01-02 19:56:01
159,2011-11-24 03:14:38,"@AvianFlu: Never mind.  That seems to be an oddity related to Chromium.  I get 'end' events when I use Lynx.  Weird.  Worrisome?
",elfsternberg,2012-01-02 19:56:01
159,2011-11-24 18:45:03,"Can you please publish the 0.7.7 changes to npm :D?
",timoxley,2012-01-02 19:56:01
159,2011-12-08 05:24:56,"Any update on when 0.6 support is going to land?
",thepatrick,2012-01-02 19:56:01
159,2011-12-08 23:09:57,"Next week.  There will be significant refactoring over this coming weekend, with 0.6 support at the top of the priority list.
",AvianFlu,2012-01-02 19:56:01
159,2011-12-28 09:26:12,"Just checking in if there's been progress on 0.6 compat, I'd love to help test it out with the locker project, just let me know if it's ready for that :)
",quartzjer,2012-01-02 19:56:01
159,2012-01-02 19:56:01,"`http-proxy@0.8.0` is v0.6.x-ready, and, in fact, in production use at Nodejitsu.  All issues should be resolved; please report any and all unresolved problems so that we can fix those too.

Thanks for your patience and support!
",AvianFlu,2012-01-02 19:56:01
159,2012-01-04 22:34:52,"Hi, 

I just tried ""npm install http-proxy"", but I still have the same error : 

npm ERR! Error: No compatible version found: http-proxy
npm ERR! No valid targets found.
npm ERR! Perhaps not compatible with your version of node?
npm ERR!     at installTargetsError (/usr/local/lib/node_modules/npm/lib/cache.js:424:10)
npm ERR!     at /usr/local/lib/node_modules/npm/lib/cache.js:406:17
npm ERR!     at saved (/usr/local/lib/node_modules/npm/lib/utils/npm-registry-client/get.js:136:7)
npm ERR!     at Object.cb [as oncomplete](/usr/local/lib/node_modules/npm/node_modules/graceful-fs/graceful-fs.js:36:9)
npm ERR! Report this _entire_ log at:
npm ERR!     http://github.com/isaacs/npm/issues
npm ERR! or email it to:
npm ERR!     npm-@googlegroups.com
npm ERR! 
npm ERR! System Linux 3.0.0-14-generic
npm ERR! command ""node"" ""/usr/local/bin/npm"" ""install"" ""http-proxy""
npm ERR! cwd /home/mod/modygo/trunk
npm ERR! node -v v0.6.1
npm ERR! npm -v 1.0.105
npm ERR! 
npm ERR! Additional logging details can be found in:
npm ERR!     /home/mod/modygo/trunk/npm-debug.log
npm not ok

Can you please help me?
",Philmod,2012-01-02 19:56:01
159,2012-01-04 22:52:08,"Looks like you're still on node 0.6.1, they set the minimum at 0.6.6.
",thepatrick,2012-01-02 19:56:01
159,2012-01-04 23:28:38,"The minimum version is node 0.6.6 because of bugs that were fixed in core - you'll need to update.
",AvianFlu,2012-01-02 19:56:01
158,2011-11-16 01:37:17,"When clients abort streamed connections, I've been noticing that the correspondent connections against my backend services remain alive indefinitely. While doing research I wrote this piece of code that seems to solve the problem. All the existing tests are still passing. 
",c4milo,2011-11-16 02:15:23
158,2011-11-16 02:16:20,"Thanks a lot!  
",AvianFlu,2011-11-16 02:15:23
158,2011-11-16 02:17:29,"no problem :), any idea when are you guys going to release a new version?
",c4milo,2011-11-16 02:15:23
158,2011-11-16 02:20:26,"Should be within the next day or so - it just needs another pair of eyes first.  This is an issue we've been running into periodically ourselves, so rest assured it won't be long.  
",AvianFlu,2011-11-16 02:15:23
158,2011-11-16 02:25:11,"nice, looking forward to the new release then. Thank you.
",c4milo,2011-11-16 02:15:23
158,2011-11-16 03:14:06,"lol, @github doesn't get rid of these references. 
",c4milo,2011-11-16 02:15:23
157,2011-11-15 04:58:39,"To know when a request has been successfully proxied.
",thefosk,2011-11-15 05:02:20
157,2011-11-15 05:02:20,"The `end` event is raised when this occurs: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L284
",indexzero,2011-11-15 05:02:20
157,2011-11-15 08:58:40,"just do res.on('end', callback)

On Tue, Nov 15, 2011 at 3:58 PM, Marco Palladino <
reply@reply.github.com

> wrote:
> 
> To know when a request has been successfully proxied.
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/157
",dominictarr,2011-11-15 05:02:20
157,2011-11-23 12:49:53,"It doesn't seem to work, my code:

<S_CODE_TOKEN>
",thefosk,2011-11-15 05:02:20
157,2012-03-28 01:16:25,"I think this one should be reopened, see #214
",thefosk,2011-11-15 05:02:20
157,2012-03-28 01:22:00,"The `end` event is raised on the HttpProxy object - this is correct. However, he is dealing with a RoutingProxy object here, which wraps the HttpProxy objects. You would have to expose this to the RoutingProxy object to be able to listen to it.

`res.on('end', callback)` will not work. Check `HttpServerResponse`, it does not emit an end event. Documentation [here](http://nodejs.org/api/http.html#http_class_http_serverresponse).
",coderarity,2011-11-15 05:02:20
156,2011-11-14 16:00:07,"if a callback but no static proxy is defined and
no routes are provided then handlers.length is 1.
However the upgrade event is still automagically
attached in spite of having an explicit callback.
",fjakobs,2011-11-17 00:57:24
156,2011-11-14 18:02:05,"This looks good to me. @dominictarr can you explain why you're rewriting `outgoing.headers.host` here? https://github.com/nodejitsu/node-http-proxy/commit/65b7872e6ad433deae4de823c63629cb341bd649#commitcomment-719213
",indexzero,2011-11-17 00:57:24
156,2011-11-17 00:57:24,"These changes have been merged.  Thanks!
",AvianFlu,2011-11-17 00:57:24
155,2011-11-11 18:06:08,"I want deploy my node app in port 80 that run Apache Server, than I configure the node-http-proxy to run in the same domain but in another path. My code is follow:

var proxyOptions = {
  hostnameOnly: true,
  router: {
   'localhost/validador': '127.0.0.1:3000'
  }
};

var proxyServer = httpProxy.createServer(proxyOptions);
proxyServer.listen(80);
app.listen(3000);
",maykon,2011-11-11 20:18:10
155,2011-11-11 18:52:27,"What is the exact error message are you seeing?

Listening on port 80 requires root access, are you running node as root?

Is apache already running on port 80? If so, how would you bind two http servers to the same port?

If you are going to file an issue, you need to provide way more information if you expect to get a good response ( what version of the proxy, what version of node, full error stacks, etc ). 
",Marak,2011-11-11 20:18:10
155,2011-11-11 19:02:08,"I run node as root, and I seeing the folling message:

""node.js:201
        throw e; // process.nextTick error, or 'error' event on first tick
              ^
Error: listen EADDRINUSE
    at errnoException (net.js:614:11)
    at Array.0 (net.js:704:26)
    at EventEmitter._tickCallback (node.js:192:40)
""
I use the node-http-proxy repository version, and Node 0.6.0.

My code:

var express = require('express'),
    routes = require('./routes'),
    httpProxy = require('node-http-proxy');

var app = module.exports = express.createServer();

// Configuration
app.configure(function(){
  app.use(express.logger('short'));
  app.use(express.profiler());
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(app.router);
  app.use(express.static(__dirname + '/public'));
});

app.configure('development', function(){
  app.use(express.errorHandler({ dumpExceptions: true, showStack: true })); 
});

app.configure('production', function(){
  app.use(express.errorHandler()); 
});

// Routes
app.post('/validar', routes.validar);
app.post('/download', routes.download);

var proxyOptions = {
  router: {
   'localhost/validador': '127.0.0.1:3000'
  }
};

var proxyServer = httpProxy.createServer(proxyOptions);
proxyServer.listen(80);
app.listen(3000);

console.log(""Express server listening on port %d in %s mode"", app.address().port, app.settings.env);
",maykon,2011-11-11 20:18:10
155,2011-11-11 19:20:20,"Is your apache already running on port 80? The message you are receiving is telling you that the port you are trying to bind to, is already running a service.
",Marak,2011-11-11 20:18:10
155,2011-11-11 20:01:10,"What the correct configuration for use the node app in the same domain and port.

http://localhost -> 127.0.0.1 # Apache Server
http://localhost/validador -> 127.0.0.1:3000 #Node.Js
",maykon,2011-11-11 20:18:10
155,2011-11-11 20:18:10,"You need to understand that with you are only going to be able to bind one service per port, it's impossible to have two different services bound to the same port. 
1. Start apache on port 3001
2. Start express on port 3000
3. Start node-http-proxy on port 80

Then, reverse proxy any incoming traffic on port 80 `/`, to your apache. Reverse proxy any incoming traffic on `/validador` to your express server.

Should be very simple.
",Marak,2011-11-11 20:18:10
155,2012-10-20 19:32:35,"As described I had similar issue but while trying to run web-server.js from Angular on port 8000 I tried to change it to 3000 but on 3000 I was running apache so failed again. Ended up with apache on 3000 and node server on 1234 :) 
described it <a href=""http://blog.i-evaluation.com/2012/10/20/angular-js-error-listen-eacces/"">here</a>
",ghost,2011-11-11 20:18:10
154,2011-11-11 16:24:53,"As a feature to consider, how about client authentication using X.509 certificates.
",brianhmayo,2012-02-10 22:32:01
154,2011-11-17 01:03:06,"We would accept a pull request for this, but we haven't got resources to devote to it in the short term.  Thanks for the suggestion, though!
",AvianFlu,2012-02-10 22:32:01
153,2011-11-10 07:43:32,"cannot get the following code to work

<S_CODE_TOKEN>

   });

<S_CODE_TOKEN>

The culprit appears to be the following line 

<S_CODE_TOKEN>

When this line is commented out, the proxy works correctly, but when the line is not commented out, I get a 500 error

<S_CODE_TOKEN>
",ramv,2011-11-23 00:24:05
153,2011-11-11 05:22:55,"I also have this issue.

If you move app.use(express.static...) to be the last app.use() it'll work. This doesn't help me, however, because I want to proxy requests if they can't be found locally/statically.
",jmonster,2011-11-23 00:24:05
153,2011-11-11 05:37:00,"observation: req.readable get's set to false by the static middleware -- something being mutated must be causing the problem?
",jmonster,2011-11-23 00:24:05
153,2011-11-11 05:49:25,"And incase it helps anyone identify a fix, here is the key difference in the response object:

WITH static middleware:

_idleNext:
        {
            repeat: 120,
            _idleNext: [Circular],
            _idlePrev: [Circular],
            callback: [Function]
        },

WITHOUT static middleware:

_idleNext:
        {
            bufferSize: 0,
            fd: 13,
            type: 'tcp4',
            allowHalfOpen: true,
            _readWatcher: [Object],
            destroyed: false,
            readable: true,
            _writeQueue: [],
            _writeQueueEncoding: [],
            _writeQueueFD: [],
            _writeQueueCallbacks: [],
            _writeWatcher: [Object],
            writable: true,
            _writeImpl: [Function],
            _readImpl: [Function],
            _shutdownImpl: [Function],
            remoteAddress: '127.0.0.1',
            remotePort: 50516,
            server: [Object],
            ondrain: [Function],
            _idleTimeout: 120000,
            _idleNext: [Object],
            _idlePrev: [Circular],
            _idleStart: Fri,
            11 Nov 2011 05: 41: 42 GMT,
            _events: [Object],
            ondata: [Function],
            onend: [Function]
        },
",jmonster,2011-11-23 00:24:05
153,2011-11-23 00:24:03,"This is an express problem.

The Connect / Express middlewares are doing non-standard things to your response object, breaks streaming. Try using the raw `request` module instead of `http-proxy`.

If you need proper middleware stack, check out https://github.com/flatiron/union
",Marak,2011-11-23 00:24:05
153,2014-01-12 20:21:15,"Unfortunately this still seems to be an issue two years later, but with express.session. Is the general advice still to use request or migrate to flatiron? 

Are there any workarounds in the line of caching or rebuilding the original unmodified request?
",rashkov,2011-11-23 00:24:05
153,2014-01-12 22:20:23,"I am using express with session and node-http-proxy (both old and new branch caronte). Works without problems.
",Rush,2011-11-23 00:24:05
153,2014-01-12 23:34:10,"You're absolutely right -- it turns out I was using an out-of-date version of Express. Thank you for commenting RushPL, it has made a big difference for me. 
",rashkov,2011-11-23 00:24:05
152,2011-11-09 17:30:55,"Just updating your package.json to enable installation under node 0.6.0
",ctide,2011-11-30 19:43:25
152,2011-11-10 15:27:05,"@ctide I'm pretty sure websocket support won't work in node@0.6.x until the `http2` branch is merged in. This updates the internal HTTP api that was rewritten by @mikeal. 

@mmalecki could you take a look at merging that in and then push a version of node-http-proxy that works on node >= 0.6.0

_To reiterate: there are breaking and incompatible changes between the 0.4.0 and 0.6.0 internal HTTP APIs that by definition make it impossible for node-http-proxy to work on both._
",indexzero,2011-11-30 19:43:25
152,2011-11-10 17:30:45,"Great, thanks for the info.  I'll keep watching this.  Do you know what the status for the http2 branch in node is?  I tried to find an open pull request to watch, and didn't find one, just an old branch on Mikeal's fork.
",ctide,2011-11-30 19:43:25
152,2011-11-10 18:38:37,"Not the http2 branch in node.js core. The http2 branch in this project. http2 is now the default http implementation in node.js  >= 0.5.5
",indexzero,2011-11-30 19:43:25
152,2011-11-10 18:42:54,"Perfect, thanks.
",ctide,2011-11-30 19:43:25
152,2011-11-10 23:25:44,"I'm on it.

Also, please don't merge this pull request here. `node-http-proxy` was force-pushed and merging this branch would reintroduce some old objects. I'll land it safely in `0.6-compatibility` branch.
",mmalecki,2011-11-30 19:43:25
152,2011-11-10 23:38:08,"I ripped that commit out of my branch, so it should be fine now.
",ctide,2011-11-30 19:43:25
152,2011-11-30 19:43:25,"We won't publish this with `0.6.x` support until we get a few more bugs ironed out - I'm going to close this for now.  
",AvianFlu,2011-11-30 19:43:25
151,2011-11-09 12:15:09,"How can I redirect it ?
some.domain.com 
to
user:password@127.0.0.1:5050

This will allow me to let users see public content but with authentication.
",manobi,2012-06-06 00:15:39
151,2011-11-16 23:23:08,"I am not sure we have the same issue but I thought I would add some comments here and avoid another issue.  I have spent hours trying to find a simple solution for the following.  

I typically always create an admin application for my node.js applications. For maintenance reasons I like putting everything in one app. I don't want to use apache, balance, nginx ... and so on. I want to start one application and manage one application.   I need to perform authentication.  I was trying to get Digest or Basic to work and was not able to get past the headers have already been sent error, when in reality they have not.  Can anyone suggest a solution to get basic Auth working with the proxy or suggest an alternative approach.  I have examples that don't work.  I did get something to work using hoxy but I don't want to have that custom of a solution. I want it to work in express and hoxy doesn't really work in express. 

The developer of http-auth was nice enough to suggest a solution and something they ma be able to do in the future.

I have looked at virtual hosts but I am unable to figure out how to cause a basic auth check to occur before the virtual server is used.
",digitalrinaldo,2012-06-06 00:15:39
151,2011-11-17 00:29:30,"My problem was solved verifying for each request the domain name, and if it's match my condition add basic Authentication Header in the request (That's is important, not in response). So route request using 'proxy.proxyRequest(req, res)'

Works for me.
",manobi,2012-06-06 00:15:39
151,2011-11-17 01:31:53,"If you have a small part of it that might answer my very long quest for something so simple. :)
",digitalrinaldo,2012-06-06 00:15:39
151,2012-03-31 02:07:52,"@manobi is this still a problem for you?
",coderarity,2012-06-06 00:15:39
151,2012-03-31 03:22:34,"@CodeRarity  no more, my current solution is not different from the described here. 
",manobi,2012-06-06 00:15:39
150,2011-11-08 18:04:59,"Suppose I wanted to proxy a site like cb2.com -- visiting this site, you'll see that it immediately redirects you to www.cb2.com. This is a problem, as I'm unable to proxy the content of the site as my browser begins accessing www.cb2.com directly instead of continuing to proxy via localhost.

I've tried simply setting the host to be www.cb2.com instead of cb2.com, but it fails. No errors, the browser just waits.

<S_CODE_TOKEN>
",jmonster,2013-03-09 09:22:26
150,2011-11-08 19:39:23,"Correction -- it doesn't hang, but for localhost:3000/stores it returns:

Invalid URL

The requested URL ""/stores"", is invalid.
Reference #9.85d17941.1320781106.11d7834e
",jmonster,2013-03-09 09:22:26
150,2011-11-08 22:03:54,"hmm, it looks like you may need to edit the response so that it does not redirect.

can your provide more information? I'm not really sure what you are trying to do.
a script that I could run to reproduce you problem would help. 
",dominictarr,2013-03-09 09:22:26
150,2011-11-08 22:18:03,"I'm using it in an Express app. My intention is that 95% of my webapp will do something interesting, but for routes that it doesn't it'll transparently return the original webpage. In this example, that webpage is cb2.com. Imagine the following is require'd at the start of an express app such that it starts responding to http://localhost/stores

var httpProxy = require('http-proxy'),
    proxy = new httpProxy.RoutingProxy();

module.exports = function(app) {
    app.get('/stores', function(req, res){
        proxy.proxyRequest(req,res,{
            host:'www.cb2.com',
            port:80
        });
    });
}

with the www there I get errors. Without the www, the reply from cb2.com is a redirect to www.cb2.com. Testing in a browser, they only redirect when the url is missing the 'www.' prefix. So if http-proxy were to respect the www. prefix properly, the redirect wouldn't be an issue.

Alternatively http-proxy could just follow the redirects, but that would still be a less-than-optimal solution since it would add latency to every request. (although it would be great for one-off pages)
",jmonster,2013-03-09 09:22:26
150,2011-11-08 22:26:20,"ah, I think that the problem is that http-proxy doesn't know that you are proxying from a url.
what if you do `req.url = req.url.replace('/stores','')` and then call http-proxy?
",dominictarr,2013-03-09 09:22:26
150,2011-11-08 22:30:30,"doesn't make any difference, but I don't understand why it would have?
just to reiterate, this works (but the result is an instruction to redirect to www.cb2.com):

<S_CODE_TOKEN>

while this gives Invalid URL error:
    app.get('/stores', function(req, res){
        proxy.proxyRequest(req,res,{
            host:'www.cb2.com',
            port:80
        });
    });
",jmonster,2013-03-09 09:22:26
150,2011-11-08 23:34:18,"okay, I've reproduced this. 
strange. this is not an error from http-proxy. 

www.cb2.com is actually responding with this error:

<S_CODE_TOKEN>
",dominictarr,2013-03-09 09:22:26
150,2011-11-10 22:09:51,"Any idea why? You're right, I tried www.amazon.com and do not have such issues ... but if I curl www.cb2.com it works, so ... huh. Thanks for looking into it so quickly, much appreciated!
",jmonster,2013-03-09 09:22:26
150,2011-11-10 22:17:26,"barnesandnoble.com does cause the same issue with including www (or redirects without it)
",jmonster,2013-03-09 09:22:26
150,2011-11-10 22:32:59,"(sorry for so many posts so close together)

It looks like this is the issue : https://github.com/nodejitsu/node-http-proxy/issues/59

not using www. is triggering the redirect and avoiding the problem. otherwise it goes through and sends an HTTP1.1 even though these serves only support HTTP1.0, which causes the error reply. Sucks.
",jmonster,2013-03-09 09:22:26
150,2011-11-10 23:18:01,"I'm facing the same issue and I think I know what is going on.

It looks like some sites (www.cb2.com, m.yahoo.com, sites hosted on dreamhost etc.) use the ""Host"" header for internal routing to the correct host and http-proxy does not change the Host header for the outgoing request. 

In other words, if I send a request to the proxy running on localhost, the target of the proxy also sees the Host header as localhost (instead of target.server.com).

There seems to be a changeOrigin option in the code that can be set to true to fix the Host header but:
1. It only seems to be implemented for websockets
2. It is also not passed down from the higher layers (RoutingProxy etc.) to the HttpProxy object.

A one line patch (as proof of concept):

  outgoing.headers.host = this.target.host + ':' + this.target.port; //around line 198 of http-proxy.js

fixes this issue.

Would it be possible to have the changeOrigin flag take effect for all proxy requests?

Awesome library, BTW.
",gotwarlost,2013-03-09 09:22:26
150,2011-11-10 23:45:59,"good catch @gotwarlost I think that should be the default behavior. I can't think of a reasonable situation where it should be otherwise.
",dominictarr,2013-03-09 09:22:26
150,2011-11-11 01:30:26,"this is fixed in https://github.com/nodejitsu/node-http-proxy/commit/b4d41c3628ade82792eb361b095ab014a88d537a
(`npm install http-proxy@0.7.5`)

<S_CODE_TOKEN>

then

<S_CODE_TOKEN>

...the real page...

can you check this works for you @jmonster ?
",dominictarr,2013-03-09 09:22:26
150,2011-11-11 02:45:58,"now www.cb2.com and cb2.com are causing a redirect :( so my request to localhost:3000/stores ends up redirecting me to www.cb2.com/stores instead of just returning the HTML and keeping the user at localhost:3000. Sigh. I guess cb2 sees that I'm using localhost and that triggers the redirect to be sent back?

I'll probably just go with a different approach of grabbing the body and then sending it to the user instead of trying to use a proxying package, shouldn't be that hard ... i hope.
",jmonster,2013-03-09 09:22:26
150,2011-11-11 03:09:08,"are you on the latest version?

I'm able to proxy www.cb2.com. I'm getting a redirect on www.cb2.com/stores . however www.cb2.com/stores/ (with the trailing slash) works correctly.
",dominictarr,2013-03-09 09:22:26
150,2011-11-11 04:39:20,"THE TRAILING SLASH! Hot damn! Your rock, thank you so much :) This is -wonderful-.
",jmonster,2013-03-09 09:22:26
150,2011-11-11 14:54:17,"@dominictarr, you rock! Works perfectly now
",gotwarlost,2013-03-09 09:22:26
150,2011-11-14 20:49:23,"sorry guys, I introduced a bug in another edgecase to fix this one, and in 0.7.6 you will need to pass in an option `new HttpProxy({changeOrigin: true})` in order to get this behavior.
",dominictarr,2013-03-09 09:22:26
150,2011-11-14 21:17:37,"No worries - I was going to ask for this enhancement anyway ;)

I noticed that the routing proxy still does not pass this option down to the http-proxy

<S_CODE_TOKEN>

Could you please include the changeOrigin attribute in this list as well? Thanks.
",gotwarlost,2013-03-09 09:22:26
150,2011-11-14 21:35:38,"Thanks for the update -- any other secret parameters we can pass here? It would help me immensely to be able to drop part of the client's headers. This seems like the opposite behavior you'd want from a proxy, but the problem I'm running into is that the remote url is detecting the request is coming from a mobile device and redirecting rather than just returning the expected content --- some URLs are handled explicitly by the server while anything unspecified just falls through to the proxy. Unfortunately I'm not getting back the desired content because of the mobile-client-detection.

If you can suggest an alternative middleware way that'd be fine too. I've been having a hard time using middleware due to GZIP data being returned from the remote server (again, something that I could strip out of the client's proxied-request)
",jmonster,2013-03-09 09:22:26
150,2011-12-17 23:50:13,"this is broken again on master -- I receive the following error when accessing servers as described above:

Error 324 (net::ERR_EMPTY_RESPONSE): The server closed the connection without sending any data.

It does, however, have a 200 status codes.

To recreate: use the master branch to proxy www.gnc.com and then try, for example, /home/index.jsp

I traced it back adn it's due to commit 2061c713664b044852fdf67aa5e173e5c3b6d874 by Cloud9:
Revert ""update outgoing.headers.host incase the destination does proxying""
",jmonster,2013-03-09 09:22:26
150,2012-01-02 20:00:00,"@jmonster can you test this against `http-proxy@0.8.0`?  I'm fairly certain that we fixed this while doing the 0.6.x migration stuff.
",AvianFlu,2013-03-09 09:22:26
150,2012-03-16 21:39:20,"I'm seeing this issue in version 0.8.0, and looking through the code there's no mention of `changeOrigin` outside the Web Socket section. This is a serious problem if you're trying to proxy an external site - many sites use the `host` header to direct your request on the server, and hitting them with `localhost` just gives you a 404.
",nrabinowitz,2013-03-09 09:22:26
150,2012-03-22 23:48:45,"Also seeing this in 0.8.0. Is there an update on {changeOrigin: true}?
",johnsheehan,2013-03-09 09:22:26
150,2012-03-22 23:51:05,"I added the functionality in my own fork since the main repo doesn't like it
",jmonster,2013-03-09 09:22:26
150,2012-03-23 00:13:39,"Note that in addition to reverting the lines in 2061c71, you also need to handle the `changeOrigin` option in the `RoutingProxy` if you're using it - see https://github.com/nrabinowitz/gapvis/commit/6e8431371f4e1e800a99dc68476c3ae4483ae34d#diff-3 (sorry, I've done this by changing the module I added to my project, which I suspect is bad git practice, and makes it harder to isolate my changes).
",nrabinowitz,2013-03-09 09:22:26
150,2012-04-13 22:28:37,"Yeah, so I'm not sure what happened, but the master branch currently doesn't use the changeOrigin option for proxyRequest. I guess I'll add it again!
",coderarity,2013-03-09 09:22:26
149,2011-11-08 08:53:32,"Hi,

Apologies for raising this question again, I know it has already been answered and closed.  i.e. https://github.com/nodejitsu/node-http-proxy/issues/148

Since this is not out of the box, would it be possible to provide an example for doing this using .pipe? Would this be middleware plugin?

I'm new to node and still trying to get my head around some of its capabilities. From what I can see so far I think node might well be better suited than some of the older Java HTTP proxies for this type of thing. 

I need the ability to change form data on the fly for both the HTTP request and response. Even a very simple example would be much appreciated.

Best Regards,

Carl
",carlskii,2011-11-08 16:08:59
149,2011-11-08 16:08:58,"Yes, you can do this with middlewares. [This awesome article](http://blog.nodejitsu.com/http-proxy-middlewares) by @AvianFlu should explain more.

Also, I added some hand-crafted middleware in `examples/middleware`: https://github.com/nodejitsu/node-http-proxy/blob/master/examples/middleware/modifyResponse-middleware.js
It's not perfect, in reality it would need some kind of output buffering, etc.

I'm closing this as it's not a real issue, but feel free to ask questions. You can also reach as at #nodejitsu IRC channel on Freenode.
",mmalecki,2011-11-08 16:08:59
149,2011-11-11 20:46:47,"I'm trying your modifyResponse example and getting jibberish when I expected to see ascii-ish text:

<S_CODE_TOKEN>

.ÔøΩdÔøΩÔøΩm<<$ ?j$ÔøΩ(ÔøΩ
                ÔøΩv||rsÔøΩÔøΩÔøΩÔøΩ,!,nÔøΩÔøΩ+ÔøΩ6nÔøΩÔøΩ<ÔøΩ{F=SEÔøΩ1ÔøΩ#«óÔøΩÔøΩÔøΩGÔøΩz

Ideas? Context:

else { // proxy the request

<S_CODE_TOKEN>
",jmonster,2011-11-08 16:08:59
149,2013-03-13 16:34:31,"I realise this is now closed, but was interested in how you could manipulate the response and also update the content length. Are there any more examples available?
",neilkinnish,2011-11-08 16:08:59
148,2011-11-07 13:16:36,"Hi,

Is it possible manipulate the request/response data within HTML content using nodejitsu?

For example I would like to change the content of a form field before it is sent to a server and before it is returned to the browser.

Regards,

Carl
",carlskii,2011-11-07 22:09:45
148,2011-11-07 22:09:45,"no, node-http-proxy doesn't support that out of the box, however, 
it's pretty simple to rig up something like that using streams and .pipe.

I did something just like it this weekend. 
https://github.com/dominictarr/shadow-npm/blob/master/proxy.js#L39-46

I'm just doing a l straight string replace, but you may want to parse the form first.
",dominictarr,2011-11-07 22:09:45
148,2011-11-07 22:20:22,"Hi,

Thanks very much for this. I'm very new to node so could I take the liberty of asking you for a simple working example of this?

I assume it would be added using the middleware functionality?

Best Regards,

Carl 
",carlskii,2011-11-07 22:09:45
147,2011-11-05 04:03:46,"if a server writes some response, but crashes before it sends end, node-http-proxy not send close the connection to the client.

end is always emitted in node 0.5, but as long as we are using 0.4 we need to fix this. 
",dominictarr,2011-11-14 20:45:46
147,2011-11-05 04:19:04,"also, I'm seeing my tests not exit as expected, so I think there is something not closing properly, which may be a memory leak or something.
",dominictarr,2011-11-14 20:45:46
147,2011-11-14 20:45:43,"http-proxy now always emits end. since 0.7.4
",dominictarr,2011-11-14 20:45:46
146,2011-11-04 12:06:04,"currently, there are tests for requests that should be proxied correctly, 
but I do not see any tests that check that errors are handled correctly.
- socket hangup (server proxied to dies part way)
- econn refused  (there is no server at host:port proxied to)
- sockets closing part while proxy is writing (can make req.write throw)

those are the errors that I can think of off the top of my head, can anyone else think of any more?
",dominictarr,2015-10-30 20:45:56
146,2011-11-04 12:06:52,"these need to be tested for both http and ws requests.
",dominictarr,2015-10-30 20:45:56
146,2012-03-31 02:10:25,"I think I can try to add a few test cases for errors, I'm not sure how you would test something like a socket hangup error though.
",coderarity,2015-10-30 20:45:56
146,2012-03-31 04:40:24,"it's simple, you just make a server that calls res.destroy() instead of writing a response.
",dominictarr,2015-10-30 20:45:56
146,2012-03-31 12:57:07,"Ok, cool, thanks.
",coderarity,2015-10-30 20:45:56
146,2015-10-30 20:45:56,"Closing due to old age and relevance. 
",jcrugzz,2015-10-30 20:45:56
145,2011-11-04 11:08:57,"what is the rationale behind:

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L255-257

from what I understand about streams, that just seems wrong.

how come it's like that?
",dominictarr,2011-12-14 06:25:57
145,2011-11-17 01:09:43,"If memory serves, that was added in a patch from @isaacs.  He may be able to comment.
",AvianFlu,2011-12-14 06:25:57
145,2011-11-17 02:04:13,"it was @isaacs .

https://github.com/nodejitsu/node-http-proxy/commit/84be9f2c3a244c7dbfe2c6320fa26d85cf80ec31
",dominictarr,2011-12-14 06:25:57
145,2011-11-17 02:41:52,"We saw some cases under load where a drain event would never happen.  It should be impossible, but it's not.
",isaacs,2011-12-14 06:25:57
145,2011-11-17 05:11:11,"is that possible to reproduce?
",dominictarr,2011-12-14 06:25:57
144,2011-11-03 20:12:22,"Hey folks,

Seeing an issue with socket.io 0.8.6 and http-node-proxy 0.7.3. When I run the socket.io server without proxying connections there is no issue.

I have a socket.io server listening on port 9001 and a node-http-proxy server running on port 80. When requests come in for ""ic.isogenicengine.com"" they are proxied to port 9001.

I can establish websocket connections and send some data but once the connection has been up for about 10 - 30 seconds and has done a heartbeat signal, the server states ""warn - websocket connection invalid""

The socket.io output is here:

 debug - emitting heartbeat for client 758674003956265495
    debug - websocket writing 2::
    debug - set heartbeat timeout for client 758674003956265495
    debug - got heartbeat packet
    debug - cleared heartbeat timeout for client 758674003956265495
    debug - set heartbeat interval for client 758674003956265495
    debug - setting request GET /socket.io/1/websocket/758674003956265495
    debug - set heartbeat interval for client 758674003956265495
warn - websocket connection invalid
info - transport end
    debug - set close timeout for client 758674003956265495
    debug - cleared close timeout for client 758674003956265495
    debug - cleared heartbeat interval for client 758674003956265495

I am using Chrome 15.0.874.106

As I say, if I remove the proxy and connect directly to socket.io there is no issue. I am proxying connections via my proxy project https://github.com/coolbloke1324/node-irrelon-router (which uses node-http-proxy extensively).
",Irrelon,2011-11-04 01:38:21
144,2011-11-04 01:38:19,"Hey, forget this issue, it is not http-proxy related, I've managed to see the same issue occur without the proxy in place.

Sorry!
",Irrelon,2011-11-04 01:38:21
144,2011-11-04 08:41:56,"what node version are you on? I know there has been some issues with node's websocket parsing.  
there have actually been breaking changes to the websocket protocol recently.

by the way, this is an exemplar issue post! ++
",dominictarr,2011-11-04 01:38:21
144,2011-11-04 14:51:53,"Thanks Dominic, I run support for my own project at www.isogenicengine.com so I know how frustrating badly written issue posts can be! :)

I actually managed to trace this down. Would you believe... it was my ISP's fault! Here's what was happening...

I would connect to my site and that connection was proxied to an internal port. About 30 seconds after my code had connected and successfully communicated with the server, socket.io would warn of an invalid websocket and then drop the connection.

I did a lot of digging and console logging in socket.io and actually found that around 30 seconds after I visit ANY web address (including websocket addresses) my ISP (who I traced their IP back to) would then also load the URL.

When they loaded the URL of MY websocket, socket.io would see they had no upgrade header in their request and make the request invalid, but in doing so, would also invalidate my websocket because it was using the same ID.

I altered socket.io's code to check the original websocket IP address against any incomming requests afterwards to make sure that it was the same... and drop the connection if not. That solved the problem.

You can see my code meandering in this socket.io issue post: https://github.com/LearnBoost/socket.io/issues/619
",Irrelon,2011-11-04 01:38:21
144,2011-11-04 21:53:45,"wow, that isn't really something that a ISP should be doing... you should tell them to stop.
",dominictarr,2011-11-04 01:38:21
144,2011-11-07 03:38:14,"They are not the only ISP that behaves like this either. I have also had a couple of other users complain of similar issues and when they checked like me, they were seeing their ISP loading the URL after them. Amazing!
",Irrelon,2011-11-04 01:38:21
144,2011-12-19 18:16:36,"I get this when connecting over a tethered mobile phone (on T-Mobile in the UK).

Can anyone suggest away to handle this failure gracefully? i.e. capture the event and show an error message to the user?
",annapowellsmith,2011-11-04 01:38:21
143,2011-11-03 13:04:43,"When you build your architecture that node-http-proxy is another proxy in a proxy chain it will ignore the incoming x-forward-for details and set it's own.

Architecture (all on the same server):

<S_CODE_TOKEN>

Expected x-forward-for at node application:

<S_CODE_TOKEN>

Actual x-forward-for at node application:

<S_CODE_TOKEN>

It does not only throw away the x-forward-for information, it even does not pass the proxy-ip in the x-forward-for chain.
",tpetry,2011-12-08 23:12:38
143,2011-11-04 07:51:22,"that definitely sounds more correct. 
can you link to an RFC on this or anything?

what `x-forward-for` does nginx write?
",dominictarr,2011-12-08 23:12:38
143,2011-11-04 10:02:27,"`x-forward-for` is a non rfc header, but wikipedia has a very nice [article](http://en.wikipedia.org/wiki/X-Forwarded-For) for it. Nginx complies to the description of this article.
",tpetry,2011-12-08 23:12:38
143,2011-11-04 21:55:16,"thanks. I'm gonna do some work on the tests soon, I'll stick this in after that.
",dominictarr,2011-12-08 23:12:38
143,2011-11-26 05:15:21,"+1 for this issue. 
",samyakbhuta,2011-12-08 23:12:38
143,2011-11-28 09:05:37,"Please accept the pull request https://github.com/nodejitsu/node-http-proxy/pull/163.
",samyakbhuta,2011-12-08 23:12:38
143,2011-12-08 23:12:38,"#163 has been merged; closing issue.
",AvianFlu,2011-12-08 23:12:38
142,2011-10-28 17:29:17,"xforward settings undefined. It appears the socket that contains the details is one layer deeper.
",lyondhill,2011-12-14 06:20:51
142,2011-10-28 17:39:15,"Current code works for me. Can you run `examples/http/basic-proxy.js` and go to [localhost:8000](http://localhost:8000)? You should see:

<S_CODE_TOKEN>

Also, what are your node-http-proxy and node versions?
",mmalecki,2011-12-14 06:20:51
142,2011-10-28 18:07:42,"Yes that works. Im doing a https proxy and I found the bug in there

my code looks like :

<S_CODE_TOKEN>

then i just have phpinfo.php listening on port 80. 

It appears that on an https request it nests but on http it does not.

can you verify?
",lyondhill,2011-12-14 06:20:51
142,2011-11-17 00:28:49,"When I try to run the tests with your fix merged in, I get a TypeError.  `req.connection.socket` comes up as undefined on L#133 of `lib/http-proxy/http-proxy.js`.  I'm on node v0.4.12.  Can either of you confirm?
",AvianFlu,2011-12-14 06:20:51
142,2011-12-14 06:20:51,"Adding an additional header is not the solution
",indexzero,2011-12-14 06:20:51
141,2011-10-27 13:47:29,"Hey, 

I'm having this sporadic message, I haven't dig too much into it, but it started to show up once I Implemented a file uploading feature using connect-form.

Any ideas?
",c4milo,2012-06-05 22:46:48
141,2011-10-27 15:45:39,"Too little details. What shows this error? `node-http-proxy` or your app? Where does it come from? Please provide a stack trace (bonus points for example code which causes this). 
",mmalecki,2012-06-05 22:46:48
141,2011-10-27 17:44:31,"yeah, sorry I know, it's node-http-proxy that is showing that message. There is not stack trace nor more clues

this is all the code https://gist.github.com/102edfc4136edce001c0
",c4milo,2012-06-05 22:46:48
141,2011-10-27 18:03:45,"Sorry, I'm confused. Can you gist node-http-proxy output? If it's an error, there should be a stack trace.
",mmalecki,2012-06-05 22:46:48
141,2011-10-27 18:05:11,"camilo@buggersillo:~/Dropbox/Development/buglabs/bugswarm-http-proxy> sudo node server.js  
development: Proxy listening in port 80...
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.
req.resume error: Cannot resume() closed Socket.

that's all what I'm getting
",c4milo,2012-06-05 22:46:48
141,2011-10-27 18:11:34,"And again, my apologies, It's a sporadic error, I don't have identified the exact steps to reproduce it. What I was doing was uploading binary files with curl to the server, which uses connect-form.
",c4milo,2012-06-05 22:46:48
141,2011-10-27 18:37:29,"Which version of the proxy are you using? Tagged version, or HEAD?
",Marak,2012-06-05 22:46:48
141,2011-10-27 19:11:04,"tagged 0.7.3
",c4milo,2012-06-05 22:46:48
141,2011-10-27 19:11:39,"any reason why you closed it? is it an invalid issue, is it valid and you fixed it?
",c4milo,2012-06-05 22:46:48
141,2011-10-27 19:12:39,"Sorry, that was a misclick.
",Marak,2012-06-05 22:46:48
141,2011-10-27 19:40:51,"this is a regression since we went to an implementation based on .pipe

pipe doesn't put a try ... catch around resume, or write, for performance reasons, 
Although, they can throw if the socket is closed. the nodejs core team intends to 
fix this, to that the http streams etc will not throw in that situation.

what we need to do for now, is monkey patch HttpResponse so that there is a try...catch
and then we can remove that when it's fixed in core.
",dominictarr,2012-06-05 22:46:48
141,2011-10-27 19:41:43,"also see this discussion:

https://github.com/nodejitsu/node-http-proxy/issues/115
",dominictarr,2012-06-05 22:46:48
141,2011-11-04 11:11:07,"@c4milo is this still an issue?
",dominictarr,2012-06-05 22:46:48
141,2011-11-04 14:29:57,"yes
",c4milo,2012-06-05 22:46:48
141,2011-11-04 14:33:06,"I can reproduce it on current `HEAD` by stress testing it with `ab`.
",mmalecki,2012-06-05 22:46:48
141,2011-11-04 17:44:49,"when are you planing to release a new version?
",c4milo,2012-06-05 22:46:48
141,2011-11-04 21:49:59,"this is where that error message comes from:

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L242-257

here is my theory: sometimes there is a pause event on the last packet. which soon emits 'drain' on it's own, 
however, because, for some reason, node-http-proxy forces 'drain' after 100 milliseconds, some times it emits a drain after the socket is closed.

see this issue: https://github.com/nodejitsu/node-http-proxy/issues/145
",dominictarr,2012-06-05 22:46:48
141,2011-12-14 22:06:37,"I'm running into this issue, is there a way to suppress this without modifying the node-http-proxy code?

*edit: I'm running 0.4.11 currently, I'll upgrade soon, but for the time being I'd just like to keep my server logs a little cleaner...
",jesseditson,2012-06-05 22:46:48
141,2012-01-02 21:54:53,"Please test this with `http-proxy@0.8.0` on node 0.6.x - I believe this was primarily an 0.4.x problem.
",AvianFlu,2012-06-05 22:46:48
141,2012-03-31 02:11:10,"@c4milo have you tested this yet (see AvianFlu's comment)? is it still an issue?
",coderarity,2012-06-05 22:46:48
141,2012-03-31 02:19:06,"Oh, not really. I ended up using haproxy.
On Mar 30, 2012 10:11 PM, ""Christian Howe"" <
reply@reply.github.com>
wrote:

> @c4milo have you tested this yet? is it still an issue?
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> 
> https://github.com/nodejitsu/node-http-proxy/issues/141#issuecomment-4854153
",c4milo,2012-06-05 22:46:48
141,2012-06-05 22:30:36,"@c4milo 0.8.1 is out, please test it for reproduce this issue or close it. Thanks!
",cronopio,2012-06-05 22:46:48
140,2011-10-25 09:44:56,"http://en.wikipedia.org/wiki/Edge_Side_Includes

These are a very powerful feature in Varnish (and other reverse proxy load balancers), and I suspect that if done right could be really performant in node, if you can process them all in parallel etc.

You would need middleware that parses a response, and then replaces the ESI tags (as the ESI tags are provided by the back end server you are proxying) on the way through back to the user.

Will dig into how to do this as middleware, but wanted to add a feature request as this would be useful for me.
",cliftonc,2011-10-25 15:04:22
140,2011-10-25 09:46:10,"Note that this needs to be coupled with caching middleware to be really useful.
",cliftonc,2011-10-25 15:04:22
140,2011-10-25 14:51:47,"I don't think it should be in core. I like this feature, but I think we should keep core as small as possible in order to make it maintainable and fast.

Writing it as a middleware should be easy, though.
",mmalecki,2011-10-25 15:04:22
140,2011-10-25 14:54:30,"Definitely, had always thought of it as middleware but wanted to list it as a feature and this seemed like the best place - I'll give it a crack, and shout if I get stuck.
",cliftonc,2011-10-25 15:04:22
140,2011-10-25 15:04:21,"OK. I'm closing this issue. If you have any problems with implementing this middleware, feel free to harass us on IRC (#nodejitsu @ irc.freenode.net) or comment here.

We may create a wiki page with listing of all interesting middlewares later.
",mmalecki,2011-10-25 15:04:22
140,2011-10-25 15:07:18,"Cool - will do.
",cliftonc,2011-10-25 15:04:22
139,2011-10-25 08:59:44,"I wanted to handle the 'start' event from http-proxy with some code like this one:

<S_CODE_TOKEN>

To make this work, I had to add to routing-proxy.js line 93:

<S_CODE_TOKEN>

I guess that the same should be done with other events (forward)
",gonzaloruizdevilla,2012-06-08 17:12:35
139,2011-11-28 16:34:57,"Doesn't it work using http.createServer, like in the websocket example?
",desaintmartin,2012-06-08 17:12:35
139,2012-03-28 03:33:25,"Hey, I just made a pull request that fixes this. See nodejitsu/node-http-proxy#216.
",coderarity,2012-06-08 17:12:35
139,2012-06-05 22:32:39,"@gonzaloruizdevilla @desaintmartin can you test it again against the 0.8.1 version just released today. Should works now.
",cronopio,2012-06-08 17:12:35
139,2012-06-08 17:12:44,"I've just seen it. Thank you!
",gonzaloruizdevilla,2012-06-08 17:12:35
138,2011-10-24 15:22:29,"When I hit this proxy with multiple requests it always fails to return a reponse for the last one, the previous ones return the correct data but the final one's always empty. If I increase or decrease the number of requests it's always the last one that fails.  It was working with the old API. Could it be a buffer issue caused by express? 
Thanks.

<S_CODE_TOKEN>
",sirganya,2011-10-25 18:21:25
138,2011-10-25 18:21:25,"setting a content length on the reply from the proxy server seemed to do the trick.

<S_CODE_TOKEN>
",sirganya,2011-10-25 18:21:25
137,2011-10-23 21:11:50,"Is there still an active changelog anywhere? I'm upgrading from 0.6.x and would like to know everything that changed in 0.7.x.
",mrchess,2012-05-31 20:13:08
137,2012-02-11 23:50:40,"You can look in the list of commits: https://github.com/nodejitsu/node-http-proxy/commits/master 

(though I agree it's an unhealthy habit to not keep a list of ""user visible changes"" in a changes file, like this project used to).
",abh,2012-05-31 20:13:08
136,2011-10-22 18:16:14,"Right now multiple .once calls can be done on paused streams, only one should be set.
",bmeck,2011-10-22 18:24:36
135,2011-10-20 23:13:39,"Hi there,

I just jumped to version 0.7.3 with the new API. I'm finding that my responses are being truncated. I was hoping someone could have a glance at this

https://gist.github.com/1302672

and tell me if I have the correct set up for the new API.

Thanks,
Greg
",sirganya,2012-01-04 23:35:34
135,2011-10-21 00:07:58,"please post a complete test example that reproduces this problem, with your server, and the proxy.
",dominictarr,2012-01-04 23:35:34
135,2011-10-21 00:09:37,"oh, and you should create the HttpProxy object outside of the request handler.
",dominictarr,2012-01-04 23:35:34
135,2011-10-21 16:05:26,"Hi,

Thanks for getting back. Here's the current code

https://gist.github.com/1304211

I still have to move the creation of the HttpProxy objects out of the req, but I'm not sure what the correct use of the API is now. I had moved them inside as I was hunting a memory leak. Should I use your URL middleware. I can use regexp correct? 

Thanks again.
",sirganya,2012-01-04 23:35:34
135,2012-01-04 23:35:34,"If you're still having issues, please try this with `http-proxy@0.8.0`.

I also notice you're using the express bodyParser, which you'll need to account for to proxy properly.  An explanation and example exists here: https://github.com/nodejitsu/node-http-proxy/issues/168#issuecomment-3289492

You should look specifically at the `buffer` method.
",AvianFlu,2012-01-04 23:35:34
134,2011-10-20 20:30:36,,quackingduck,2011-10-20 20:33:18
134,2011-10-20 20:33:30,"Thanks!
",Marak,2011-10-20 20:33:18
133,2011-10-18 19:15:00,"""pizza.com/taco/muffins"": ""127.0.0.1:8099' -> 127.0.0.1:8099
""pizza.com/taco/muffins"": ""127.0.0.1:8099/pasta/tomato' -> 127.0.0.1:8099/pasta/tomato
",manast,2012-07-22 06:30:04
133,2011-10-18 19:16:56,"It passes current unit tests but I could not write new unit tests for testing my specifics since I get an error if I do so which I have not yet figured out how to fix: 

Error: EADDRINUSE, Address already in use
",manast,2012-07-22 06:30:04
133,2011-10-18 20:41:03,"@manast the test harness starts a separate single-use proxy for each entry in the proxytable and each proxy must have a unique port as per the way the test harness is implemented
",maxogden,2012-07-22 06:30:04
133,2011-10-19 07:16:22,"@maxogden well, that was what I thought, but it seems as I never manage to find any port that is not already busy, because it keeps failing :/
",manast,2012-07-22 06:30:04
133,2011-10-19 07:21:26,"well, for me it is insane, I can not manage to make it working and unfortunately I have to move on to other things... in order to make this unit tests scalable (right now I think there is far too few tests to say that this is production ready), it is needed a better approach than trying to figure out which ports are free by hand, maybe we could use a function that returns a unique port every time it is called or something, then we need to match that port in the tests later on...
",manast,2012-07-22 06:30:04
133,2012-03-28 22:03:19,"Oops, seems like I did this again at nodejitsu/node-http-proxy#218. Not sure why there's so many more changes in your version though.
",coderarity,2012-07-22 06:30:04
133,2012-07-22 06:30:04,"There have been a bunch of changes to this in `master`. If you're still having the same issue when we release the new version feel free to reopen. 
",indexzero,2012-07-22 06:30:04
132,2011-10-17 17:41:52,"Has Team Nodejitsu ever put node-http-proxy in front of static content servers--like Apache? If so, how do you set it up to proxy more than one request at a time for static files?

I've got it running as a reverse proxy on Windows in front of Apache (for static content) and Node, allowing my browser JS to avoid cross-domain requests. My concern is that http-proxy is a bottleneck when it comes to static content. For example, if a browser hits my site and opens multiple simultaneous connections for static files but http-proxy only proxies one conn at a time to Apache (because it's single-threaded).

How would you handle something like that? Multiple http-proxy instances, perhaps?

Thanks for any advice/tips.
",clintharris,2011-10-17 20:00:28
132,2011-10-17 17:54:24,"We put `http-proxy` in front of a lot of static sites, haven't seen issues yet. Currently we are not using apache for anything.

I'm a bit confused by your issue, node can stream out multiple files at the same time over multiple connections. Perhaps there is a setting in apache you need to change?

`http-proxy` also has a lot of API entry points. Can you provide the code you are using? How are you testing this? The browser isn't really an adequate tool for testing this sort of thing.
",Marak,2011-10-17 20:00:28
132,2011-10-17 19:48:52,"Hey Marak, here's the gist of how we're using it:

<S_CODE_TOKEN>

I assumed that since Node is single-threaded it would only handle (i.e., proxy) one connection at a time to Apache, resulting in only one file be transferred at a time. Is that incorrect?

Thanks!
",clintharris,2011-10-17 20:00:28
132,2011-10-17 19:54:16,"> I assumed that since Node is single-threaded it would only handle (i.e., proxy) one connection at a time to Apache, resulting in only one file be transferred at a time. Is that incorrect?

That is not correct. Node's network i/o is non-blocking.
",Marak,2011-10-17 20:00:28
132,2011-10-17 20:00:28,"Great, thanks for clarifying (and the patience--this is probably something anyone working with Node should already know).
",clintharris,2011-10-17 20:00:28
132,2011-10-17 20:07:47,"I'd like to help you figure out why this is happening so if someone else brings it up we can help them.

It's possible there is a misconfiguration on either side of the equation ( node or apache ). 

Please let me know what additional information you can find out.
",Marak,2011-10-17 20:00:28
132,2011-10-18 00:54:20,"I finally had the sense to do a quick test with Chrome's network trace/timeline graph and confirmed that the static files are **definitely** being delivered concurrently (and hitting Chrome's 6 simultaneous network conn limit). Sorry--totally should have done that before taking up your time.

![Screenshot of Chrome network trace/timeline graph](https://img.skitch.com/20111018-m1snuwthq96qfqp74d75f758it.jpg)
",clintharris,2011-10-17 20:00:28
131,2011-10-17 11:59:28,"Hi, when i tr to launch a websocket proxy, i've an error :

<S_CODE_TOKEN>

I just launch the example websocket proxy, l'm totaly lost, i found lot issues but nothing :( Please help me :)

The line error : 

<S_CODE_TOKEN>

Thank you !
",zelkin,2011-10-17 15:29:08
131,2011-10-17 15:29:08,"@zelkin. Looks like the port you have there (port `7`) is wrong. In the example (https://github.com/nodejitsu/node-http-proxy/blob/master/examples/websocket/websocket-proxy.js#L76), we are listening on 8081.
",indexzero,2011-10-17 15:29:08
131,2011-10-18 07:47:18,"noway, if i want to make port 7, i change on all script, it's not a response...
",zelkin,2011-10-17 15:29:08
131,2011-10-18 15:01:32,"Port 7 is reserved; I'm not quite sure if it is possible to use for websocket traffic. Maybe @avianflu or @jesusabdullah would know.
",indexzero,2011-10-17 15:29:08
131,2011-10-18 16:58:23,"What @indexzero says. Trying to listen on port 7 makes no sense anyway. Try to set up a web server on this port. Browsers refuse to connect to it (at least so do FF and Chrome on Linux).
",mmalecki,2011-10-17 15:29:08
130,2011-10-16 01:50:16,"I slightly over-engineered (see: needlessly used `new RegExp` :P) https://github.com/nodejitsu/node-http-proxy/pull/129 so this simplifies the re-routing logic
",maxogden,2011-11-17 03:20:49
130,2011-10-18 19:19:02,"check my changes, I think I have a better behavior now, and also the routing should be faster:

https://github.com/nodejitsu/node-http-proxy/pull/133
",manast,2011-11-17 03:20:49
130,2011-10-25 20:01:32,"would it be possible to merge this? my patch fixes a bug that was introduced in my earlier patch.

I agree that more time should be spent on improving the test suite for the routing stuff but getting this patch in would at least provide a stable API for now
",maxogden,2011-11-17 03:20:49
130,2011-10-26 07:19:42,"Why dont you test my patch? I also optimized the routing mechanism, it should be much faster than in your version :).
",manast,2011-11-17 03:20:49
130,2011-11-17 03:20:49,"This has been merged.  Thanks!
",AvianFlu,2011-11-17 03:20:49
129,2011-10-15 21:35:36,"given a proxyTable router like this:

<S_CODE_TOKEN>

requests from `baz.com/taco` will get proxied to `127.0.0.1:8098` and requests from `pizza.com/taco/muffins` will get proxied to `127.0.0.1:8099/taco`

the old behavior was `baz.com/taco` to `127.0.0.1:8098/taco` and `pizza.com/taco/muffins` to `127.0.0.1:8099/taco/muffins`
",maxogden,2011-10-15 23:00:37
129,2011-10-15 22:52:10,"looks good, reviewing.
",dominictarr,2011-10-15 23:00:37
129,2011-10-17 11:27:01,"well guys I think the documentation is wrong in this regard. According to the documentation in the main page, it does not imply that a route like this 'foo.com/baz': '127.0.0.1:8001', means that requests will be forwarded to 127.0.0.1:8001/baz, in fact it says: incoming requests to 'foo.com/baz' and forward them to '127.0.0.1:8001'.
This behaviour is in fact giving me huge amounts of frustration. I cannot see the point of forwarding to 127.0.0.1:8001/baz. It doesn't seem to fullfil any useful usecase. I had solved this problem with a custom middleware, but unfortunately, bugs in the handling of websockets make this approach impracticable now... help please! :).

From the Readme:
A Proxy Table is a simple lookup table that maps incoming requests to proxy target locations. Take a look at an example of the options you need to pass to httpProxy.createServer:

var options = {
  router: {
    'foo.com/baz': '127.0.0.1:8001',
    'foo.com/buz': '127.0.0.1:8002',
    'bar.com/buz': '127.0.0.1:8003'
  }
};
The above route table will take incoming requests to 'foo.com/baz' and forward them to '127.0.0.1:8001'. Likewise it will take incoming requests to 'foo.com/buz' and forward them to '127.0.0.1:8002'. 
",manast,2011-10-15 23:00:37
129,2011-10-17 11:29:37,"btw, the issue I am referring to is #112
",manast,2011-10-15 23:00:37
129,2011-10-17 12:27:13,"@manast if you use node-http-proxy at 4d50915373b6afaafc7857a3e9366e8e77315683 then that is the behavior that you will get, is that what you want?

the first type of proxying could be useful for sharding your app, but foo.com/db: host:port could be useful for sidestepping the single origin policy... which is probably much more useful.
",dominictarr,2011-10-15 23:00:37
129,2011-10-17 14:05:21,"@dominictarr

The reporter is complaining that pizza.com/taco/muffins is proxied to 127.0.0.1:8099/taco instead of to 127.0.0.1:8099/muffins/taco, which according to the documentation are both wrong behaviors, or at least thats my interpretation of what I read. But besides that I think that proxying just to  127.0.0.1:8099 should be the most common use case, i.e., you have several servers and you want to place them under different sub routes (to avoid for instance cross-browser scripting problems, etc). If we keep the subroutes in the proxied request, then we are creating a coupling between the proxy and the servers, both need to be always in sync, which I dont think is a good idea. Every server should be agnostic of where the proxy configurator has placed it...
Wouldnt it be better to support this kind of routes if we really want to keep subroutes:

<S_CODE_TOKEN>

?
",manast,2011-10-15 23:00:37
129,2011-10-17 14:26:05,"On top of everything I am also a bit confused about how to use the proxy in conjunction with socket.io+express. Before, everything worked without any hassle, but now I am not sure If I need to do something else or not :/
",manast,2011-10-15 23:00:37
129,2011-10-17 18:58:08,"@manast I like the subroutes API you defined, it seems more robust than my solution, which is more robust than what used to be in node-http-proxy. If you make a pull request to support your suggestion then I'd be happy to use it.
",maxogden,2011-10-15 23:00:37
129,2011-10-17 20:55:15,"@manast, your description is better. it would probably only be a small change from what @maxogden has done to get that behavior.
",dominictarr,2011-10-15 23:00:37
129,2011-10-18 10:37:12,"guys, it may be me, but what is now on the repo is not working at all. For example, If I defined a route like this:

""pizza.com/taco/muffins"": ""127.0.0.1:8099""

and I get the following incoming request: pizza.com/taco/muffins/tomato I should expect (according to the latest merge):
127.0.0.1:8099/taco/muffins/tomato  while I am getting (if I have run the tests correctly): 127.0.0.1:8099/taco

Of course I would have preferred 127.0.0.1:8099/tomato
I am btw hacking on the code as we speak, but I have problems when adding new test cases, I always get this error: Error: EADDRINUSE, Address already in use

Strange that I just can't add a new case :/

regards.
",manast,2011-10-15 23:00:37
128,2011-10-13 01:28:10,"When I run the proxy directly, it seems to work fine as long as the session remains open.

I'm having a hard time getting my proxy server to stay alive when its being started with Upstart or as a background process. Basically I can see the process start and then after a few seconds it dies. Upstart then continues to restart the proxy but it continues to bounce.

The other way to background a process is:

<S_CODE_TOKEN>

I run multiple node.js services on the same server and start them up using Upstart with no issues.

First, here is my proxy server:

var http = require('http'),
    httpProxy = require('http-proxy'),
    fs = require('fs');

fs.readFile(__dirname + '/routes.json', function (err, data) {

 if (err) throw err;

<S_CODE_TOKEN>

});

Next, my routes.json file (domain changed, but localhost and port are the same):

{
    ""mysite.com"": ""127.0.0.1:9999""
}

The routes.json file is loaded and parsed as json and this is used for the router options.

Finally, this is my Upstart conf which is identical except for the app.js paths to several other conf files I have that work as expected.

description ""nodeproxy node.js server""

start on started
stop on shutdown

respawn

script
    # We found $HOME is needed. Without it, we ran into problems
    export HOME=""/usr/local/apps/nodeproxy/""

<S_CODE_TOKEN>

end script

I have done extensive checking including:
Error logging
File permissions on app.js and nodeproxy.conf
File owners
Running app.js with Upstart and as a background process using &

I'm really at a loss as to why this is running fine when I have the session open but refuses to be backgrounded.

Thanks!
",geuis,2011-10-13 06:37:18
128,2011-10-13 02:29:50,"Are you using `nohup`?

While I haven't used upstart myself, I know that a process backgrounded with `&` will still receive a hangup signal if the user that started it logs out.  `nohup` prevents this hangup signal from killing the process.  (Note that you'll have to redirect `stdio` for this to work properly.)

I'm going to read up on upstart a little, let me know if `nohup` has been of any use to you.  You may also want to check out [forever](http://github.com/indexzero/forever) - it's the process monitor that we use in production.
",AvianFlu,2011-10-13 06:37:18
128,2011-10-13 03:28:52,"This might also be useful: http://upstart.ubuntu.com/cookbook/#jobs-that-run-forever
",AvianFlu,2011-10-13 06:37:18
128,2011-10-13 05:48:49,"Thanks AF. I don't use nohup because upstart works very well in auto starting and restarting processes. So far my nodeproxy script is the only one I'm having a problem with. Is there perhaps a problem with my code that I'm missing?
",geuis,2011-10-13 06:37:18
128,2011-10-13 06:37:18,"Hey, turns out it was completely a different issue. Non-root users can't bind to ports under 1024. By running as root, i.e. removing -u www-data it now works as expected.
",geuis,2011-10-13 06:37:18
127,2011-10-10 20:40:06,"It look's like @substack implemented a first pass at doing the tcp/net based http proxying ( which calls ry's http parser directly).

We should pull this in or use it as a reference for implementing the fast proxying scenarios we were discussing ( not needing the whole request, but just enough to route it ).

https://github.com/substack/bouncy/blob/master/index.js
",Marak,2011-10-11 19:46:48
127,2011-10-10 20:53:06,"+1 If you need some more hooks to make using bouncy as a library easier I can oblige.
",substack,2011-10-11 19:46:48
127,2011-10-10 20:56:09,"I think it's probably just going to be put into the core proxy logic. We've been talking about this for a while, we just haven't been that motivated since the performance we already are getting is still really good.
",Marak,2011-10-11 19:46:48
127,2011-10-10 21:01:34,"+1 for @substack's being a lib
",tj,2011-10-11 19:46:48
127,2011-10-10 21:49:48,"+1 for substack lib, its a kernel, and at a glance looks easy to maintain. (this is just my immediate reaction, need to look at the code in more depth)
",0x00A,2011-10-11 19:46:48
127,2011-10-11 04:47:57,"Do you have a benchmark for `bouncy`. While codebase is much cleaner than http-proxy's - it's still using the same parser and headers generator.
",indutny,2011-10-11 19:46:48
127,2011-10-11 04:50:31,"I would remove the hasOwnProperty calls, unnecessary penalty IMO, if you augment Object.prototype with x-forwarded-for you deserve for things to break :D
",tj,2011-10-11 19:46:48
127,2011-10-11 05:14:25,"@visionmedia agreed, there is a time and place for hasOwnProperty
",0x00A,2011-10-11 19:46:48
127,2011-10-11 05:30:18,"The `.hasOwnProperty()` is just to see whether `opts` has those fields since if you set them to falsey values they aren't sent.

@indutny: https://gist.github.com/1275259 and https://github.com/substack/bouncy/tree/master/bench
",substack,2011-10-11 19:46:48
127,2011-10-11 05:34:11,"Well , that's much more argumented :)
",indutny,2011-10-11 19:46:48
127,2011-10-11 06:34:49,"@substack `.hasOwnProperty()` might not be the best way to do that http://jsperf.com/hasownpropvsbool #maxPerf! >=)
",0x00A,2011-10-11 19:46:48
127,2011-10-11 19:46:45,"We will not be taking `bouncy` as a dependency. The approach of using a TCP proxy has its merits, which I have discussed with @mikeal at length. 

There is an experimental branch of node-http-proxy which exposes a transparent balancing proxy that uses this approach. I started work on this back in April I think: https://github.com/nodejitsu/node-http-proxy/blob/experimental/lib/balancing-proxy.js

Doing things on a TCP level breaks many of the existing HTTP-level APIs which users rely on in connect and/or express, so this won't be an all or nothing change. 

I would welcome pull requests on the experimental branch which also allow for `x-forwarded-*` headers and `sec-websocket-*` header rewriting.
",indexzero,2011-10-11 19:46:48
127,2011-10-12 21:57:24,"> Doing things on a TCP level breaks many of the existing HTTP-level APIs which users rely on in connect and/or express

Sorry for being late to the party, but there isn't any way to get http req/res objects from a tcp connection? No way to ""upgrade""?
",jfhbrook,2011-10-11 19:46:48
127,2011-10-12 23:46:25,"is this ticket for a ""TCP based proxy"" or specifically for pulling in bouncy as a dep?

because I think all the issue you have with bouncy could still be dealt with if you just implemented it a little differently.

_some_ of your features might not be doable, but _some_ of your features are, to put it frankly, kind of retarded. i know some people want to buffer every response in to memory and mutate it but, well, that's dumb :)
",mikeal,2011-10-11 19:46:48
126,2011-10-08 11:17:03,"I wish to use a proxy-table, but I need too add more route properties while the proxy-server is running, how do I do this?
",AndreasMadsen,2013-03-09 09:23:26
126,2012-02-02 02:14:54,"+1  I feel like this shouldn't be too hard to hack together but I suppose exposing a few methods to add and remove routes might be the best option?
",tglines,2013-03-09 09:23:26
126,2012-02-02 03:40:34,"Do note that it looks like if you pass the routing as a file path string that it watches the file for changes and updates the routing table.
",tglines,2013-03-09 09:23:26
126,2012-02-14 01:37:58,"This pull request should make this possible

https://github.com/nodejitsu/node-http-proxy/pull/195
",tglines,2013-03-09 09:23:26
126,2013-03-09 09:23:26,"#195 was manually merged.
",indexzero,2013-03-09 09:23:26
125,2011-10-07 11:53:29,"Refer to issue #59 and joyent/node#1234.

Simple test is [here](https://gist.github.com/1270121).
before:

<S_CODE_TOKEN>

after:

<S_CODE_TOKEN>
",koichik,2011-11-17 00:15:31
125,2011-10-07 17:33:20,"@koichik This does not seem to completely fix issue #59 because the `HTTP/1.1` status line is still returned. Not `HTTP/1.0`
",indexzero,2011-11-17 00:15:31
125,2011-10-07 17:58:40,"It is right behavior.

[RFC2145](http://www.ietf.org/rfc/rfc2145.txt) - 2.3 Which version number to send in a message

>   An HTTP server SHOULD send a response version equal to the highest
>   version for which the server is at least conditionally compliant, and
>   whose major version is less than or equal to the one received in the
>   request.  

Also, please refer to [the comment](https://github.com/joyent/node/issues/1234#issuecomment-1537745) from @mnot.
",koichik,2011-11-17 00:15:31
125,2011-10-07 18:00:09,"Great! Thanks for citing the RFC. I will get this merged in ASAP.
",indexzero,2011-11-17 00:15:31
125,2011-11-17 00:15:31,"Thanks!  Merged in 152d258 .  Sorry for the delay!
",AvianFlu,2011-11-17 00:15:31
124,2011-10-04 16:10:45,"added 'targetHeaders' and targetResponse' events for handling the response header, or the whole response, using the target response.

It ables to make some smart error pages for all the (v)hosts a reverse-proxy handles
",temsa,2012-07-22 06:53:51
124,2011-12-14 06:19:43,"This API needs some work. Passing a function to invoke to the listener of `targetResponse` it too fragile. My thoughts here are that if you listen to the `targetResponse` event then it's all or nothing
",indexzero,2012-07-22 06:53:51
124,2012-07-22 06:53:51,"Closing. No activity. 
",indexzero,2012-07-22 06:53:51
123,2011-10-04 00:05:31,"Something I try to do with node-http-proxy for some days now, is chaining proxies in case of error : I have multiple middle server. During a delivery, at least one server will be down for a while, so I'd like, if I get an ECONNREFUSED (or a hangup, but it happens for now in about 240s, I guess 2x 120s timeout, and I didn't get how to change this), I'd like my proxy to try another host instead of returning an error I could avoid<

I've created a first proxy, I listen to the ""proxyError"" event, which is fired, then I ask a second proxy to handle that request and try another equivalent host), it tries to handle the request then I have a ""start"" event as well for it, but it never writes to my response. My response is writable because I can write to it then call res.end().

I didn't get why for now. Is it possible to do?
",temsa,2013-03-09 08:30:44
123,2011-10-04 00:09:14,"Are you buffering the request? You need to be doing buffering because you will need to re-emit the `data` and `end` events so that it gets written to the second response.

Can you provide a code sample? I can probably help you quickly; if you're not familiar with event buffering it can be tricky to get right.
",indexzero,2013-03-09 08:30:44
123,2011-10-04 00:20:19,"I haven't the code with me and my implementation is pretty naive with no buffering, just chaining 2 RoutingProxy (tried also with RoutingProxy + create a HttpProxy in case of error).

I'm not familiar with event buffering yet (or maybe; but I didn't know it is called like this), so I'll just post here an example tomorrow (it's >2:00am here) and hope for help ;) 
",temsa,2013-03-09 08:30:44
123,2011-10-06 19:12:45,"I'm also looking into getting this working, would buffering the request cause significant performance issues?

Charlie, If you have some pointers on where to start re the event buffering that would be great.
",bearnard,2013-03-09 08:30:44
123,2011-11-06 09:09:42,"Hi, I'm trying to do something like this:

<S_CODE_TOKEN>

while this works for the 1st fe hundred requests, after about 300 or so I see a whole bunch of these errors:

response.resume error: Cannot resume() closed Socket. 

Clearly I'm doing something wrong.

I wonder if it would be a nice feature to have proxyRequest accept multiple backends to try.

<S_CODE_TOKEN>

or something along those lines?

So to get back to my problem, what is the correct way to go about achieving this desired ""failover""?.

Bearn.
",bearnard,2013-03-09 08:30:44
123,2012-01-02 18:26:14,"any suggestions on this?
",bearnard,2013-03-09 08:30:44
123,2012-02-12 00:07:34,"@bearnard I'm not sure there is a workable solution here. The `proxyError` event may be raised after the `response` has been partially written to or closed. 

Consider the scenario when the first backend fails midway through the response. It is impossible for the proxy to know at what point of the response the reverse proxy request errored.

My suggestion would be to pass a mock response object to `proxy.proxyRequest` which buffers the response into memory and when it ends then writes it back to the actualy `res`. This way you can discard the entirety of the data returned from the backend that failed and try all over again.
",indexzero,2013-03-09 08:30:44
123,2013-03-09 08:30:44,"This should be fixed by #374 since the `proxyError` event is only raised once now.
",indexzero,2013-03-09 08:30:44
123,2015-07-17 22:43:54,"Is there any workaround for this problem after 2 years?
",ntdunglc,2013-03-09 08:30:44
122,2011-10-03 12:47:05,"Fixes #120
",temsa,2011-10-03 23:59:53
122,2011-10-03 21:51:42,"Looks good. This will go in tonight
",indexzero,2011-10-03 23:59:53
122,2011-10-03 23:55:34,"@temsa Thanks. Cherry-picked in b7adf866b595f0d64a3ef6bde19271276450e723 and published in `node-http-proxy@0.7.3`
",indexzero,2011-10-03 23:59:53
122,2011-10-04 00:06:17,"great !
",temsa,2011-10-03 23:59:53
122,2011-10-04 12:47:52,"could you publish it ?
",temsa,2011-10-03 23:59:53
122,2011-10-04 19:18:27,"Done
",indexzero,2011-10-03 23:59:53
121,2011-09-30 16:28:41,"It makes me a bit nervous that mis-configuring my proxy by pointing it at a non-existent target caused it to send the following message to my browser:

An error has occurred: {""stack"":""Error: ENOTFOUND, Domain name not found\n    at IOWatcher.callback (dns.js:74:15)"",""message"":""ENOTFOUND, Domain name not found"",""errno"":4,""code"":""ENOTFOUND""}

I couldn't find a straight-forward way to avoid sending diagnostics to the client. It seems like the default behaviour should be to send a vague 500 error message to the client.
",aarong,2011-10-03 15:48:09
121,2011-10-03 09:27:24,"<S_CODE_TOKEN>

It doesn't work in RouterProxy mode (see #120)
",temsa,2011-10-03 15:48:09
121,2011-10-03 15:49:19,"Solved my problem - thank you. It still might be worthwhile to change the default behaviour to send a more vague error, in my opinion.
",aarong,2011-10-03 15:48:09
121,2011-10-03 16:09:36,"I can see your point of view, but others could argue that obfuscating the error message by default is worse ( since it's hiding information that most people will want to see ).

It's probably better to just show everything by default and just let people hide it if they want. 
",Marak,2011-10-03 15:48:09
121,2011-10-03 23:44:02,"IMHO :

User is mostly interested in functional error reporting rather than technical one. Even, if you can, thanks to some work, avoid those errors (like trying to call another server when getting ECONNREFUSED), or at least try to, it's better. BTW it takes some time to wrap all of those technical errors for user, and even not to forget all protocols you use (e.g. don""t forget json for your ajax application, and handle those errors gracefully in your app using something like a flash message)

Developers are interested in what happened, why, and how often, so they would like to store those errors with as much details as possible or even send them by email/xmpp/irc to the team, so error hooks are important here)
",temsa,2011-10-03 15:48:09
120,2011-09-30 13:00:42,"I have multiple host possible for my target, as I can have several stateless servers behind (for the moment, just 2).

I'd like, if ever the proxy request encounters an error (like ECONNREFUSED), to be able to redirect to another host.
I couldn't make it work because I would need both:
- Router based proxy
- connect middlewares
- 'proxyError' event to be thrown by my server.proxy.on('proxyError')

The latter is never emitted in this configuration.

(I'd also need for hang up errors a target connection timeout to be sent so I can dispatch the request to another server in this case).

Try this script (adapted from 2 examples), proxyError is never emitted :

<S_CODE_TOKEN>
",temsa,2011-10-03 23:59:47
120,2011-10-01 08:00:16,"Thanks for pointing this out. Events from the HttpProxy instances managed by the RoutingProxy are not correctly bubbled up. 

I will try to fix this ASAP.
",indexzero,2011-10-03 23:59:47
120,2011-10-03 11:03:08,"Can be easily fixed by adding at [routing-proxy.js line 93](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/routing-proxy.js#L93) this :

<S_CODE_TOKEN>

Works like a charm here :)
",temsa,2011-10-03 23:59:47
120,2011-10-03 12:48:24,"See #122
",temsa,2011-10-03 23:59:47
120,2011-10-03 23:59:45,"Fixed in #122
",indexzero,2011-10-03 23:59:47
119,2011-09-29 22:44:39,"Should fix #97
",indutny,2011-09-30 01:29:15
119,2011-09-29 22:44:57,"@indexzero - please review this.
",indutny,2011-09-30 01:29:15
119,2011-09-29 23:15:51,"+1, The testing that @mmalecki and I have been doing confirms that this works.  We tried a similar version of this fix this morning, but it was in Node's `lib/http.js` and we didn't quite get it right.  

The problem lies in an extremely convoluted message-sending bug in Node's `http.Agent`.  Issue #97 Has more info.
",AvianFlu,2011-09-30 01:29:15
119,2011-09-30 01:29:15,"Cherry-picked in 45ef87e71bc9cccefe5fb6afc3121fb09b8efbc3
",indexzero,2011-09-30 01:29:15
118,2011-09-29 20:06:26,"Refer to issue #117 . This doesn't fix the issue, but it takes care of the low-hanging fruit.
",jfhbrook,2011-09-29 20:16:54
118,2011-09-29 20:16:50,"Looks good. Merging.
",indexzero,2011-09-29 20:16:54
117,2011-09-29 20:04:06,"A few of the examples are broken due to changes in the routing table api:
- [fixed] /examples/http/standalone-proxy.js
- [fixed] /examples/websocket/latent-websocket-proxy.js
- [fixed] /examples/websocket/standalone-websocket-proxy.js

Also, the last example from the readme quietly terminates immediately.

[fixed] Many of the examples also have broken require paths, but I should have a fix for those bugs in a few minutes.

Edit: Refer to pull request #118 .

Edit2: While the require-based and api-related issues have been resolved, there are still a few breaking examples for me:
- Everything in `/examples/websocket/` crashes for me with the following output:

<S_CODE_TOKEN>
- The last example from the readme still terminates immediately without saying anything first. See: https://gist.github.com/1252041
",jfhbrook,2011-09-29 21:43:27
117,2011-09-29 21:43:27,"Fixed in 6c6fec094eb1aaa8a2b87475dcb7bdbf17813b30
",indexzero,2011-09-29 21:43:27
117,2011-09-29 21:55:33,"I don't believe all of the broken examples have been fixed by that commit! I'm going to make sure the problems I'm having aren't because of my machine before reopening, though.
",jfhbrook,2011-09-29 21:43:27
116,2011-09-22 08:18:01,"this would be way simpler if we used pipe

something like this:

<S_CODE_TOKEN>

the code we currently have just duplicates functionality in pipe
",dominictarr,2012-07-22 06:38:30
116,2011-09-22 14:05:50,"Pipe is not ready for this kind of operation. @mikeal could probably speak to why that is
",indexzero,2012-07-22 06:38:30
116,2011-09-22 14:27:46,"by ""this"" do you mean the whole project?

i don't see why you couldn't use pipe(). 

in the case where you want to mutate the data you can just pipe() to a stream that handles your mutation api.

in the case where you need to buffer you can use BufferedStream until streams2 gets merged (which includes the .buffer()) method.

but yes, i doubt it would be a trivial patch.
",mikeal,2012-07-22 06:38:30
116,2011-09-22 14:49:45,"The problem is really with the optimism of the current pipe implementation:

https://github.com/joyent/node/blob/master/lib/stream.js

There are no guards (i.e. `try/catch`) around calls to `.write()` (which can throw). Also the `source.readable` around `stream.resume()` are apparently not enough:
https://github.com/joyent/node/blob/master/lib/stream.js#L127
https://github.com/joyent/node/blob/master/lib/stream.js#L34-38

Recent commits have been added by @isaacs to fix problems regarding calls to those two methods throwing `uncaughtException` events:

https://github.com/nodejitsu/node-http-proxy/commit/7bda25b1c60d082f0f2fd12fc61b45a33b74f13d
https://github.com/nodejitsu/node-http-proxy/commit/558a8a4f79716496dbdee13759c8641606458c05

If we can solve these problems within the existing `.pipe()` implementation then it is probably fine, but I suspect it won't work because there are a couple of special cases for HTTP streams that we handle in `node-http-proxy`:

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L214-218

In short, I think `.pipe()` is awesome and when you have a little information around the HTTP stream you are trying to pipe, it works like a charm. As a generic silver bullet though, it still has a little way to go.
",indexzero,2012-07-22 06:38:30
116,2011-09-22 14:56:04,"When does write() throw? I believe you that it does but in what case?

I mean, this is really slow. This many guards is just really slow.

And when does resume() throw? jesus!

These sound like core bugs that we're catching and I just want to make sure they are fixed in core. 
",mikeal,2012-07-22 06:38:30
116,2011-09-22 14:56:42,"Also, core pipe() will never have this many guards cause it'll totally fuck our benchmarks.
",mikeal,2012-07-22 06:38:30
116,2011-09-22 14:57:27,"Also, I really really really can't wait for domains, which would make this all a lot simpler to catch.
",mikeal,2012-07-22 06:38:30
116,2011-09-22 15:10:19,"When I spoke with @isaacs about finding these throwing cases he said they were very difficult to reproduce which makes sense to me given the brow-beating both Nodejitsu and Joyent put node-http-proxy thru in production. 

I agree with you that the `.pipe()` method in core shouldn't have this many guards for performance reasons, and that misalignment of goals is probably why `.pipe()` isn't appropriate here. Keeping the process alive is paramount to avoid dropped WebSocket connections.
",indexzero,2012-07-22 06:38:30
116,2011-09-22 16:32:28,"There are bugs in core where .write() or .resume() on an http response stream will throw if the socket is closed.

I would like to solve this by 0.6.  If for some reason it turns out it's not possible to fix by 0.6 because it requires too much API change, then we need to know why, lay the appropriate deprecations, and fix it asap in 0.7.  But the first step is figure out what that API needs to be, and how far we are from it.
",isaacs,2012-07-22 06:38:30
116,2011-09-23 01:17:41,"https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L214-218

sounds like a core issue too, I mean, it should a bodyless response should still emit 'end'
",dominictarr,2012-07-22 06:38:30
116,2011-09-27 12:44:08,"so, the write() and end() throwing issues, insuring ""end"" is emitted, and removing close() in favor of destroy() have all made it in to the spec in streams2 and are part of the discussion in that pull request. i also have buffering in there as well. we can back burner this discussion until 0.6.0 is released.
",mikeal,2012-07-22 06:38:30
116,2011-09-29 02:35:21,"In some work I was recently doing with streams, I was getting this error, (was piping tar -c to tar -xz, which crashes tar), however I was able to keep the process up by listening on 'uncaughtException'.

I was piping from an incoming tar file to disk via http, and though the write to disk socket was breaking, since I was managing to catch it, I was still able to respond to the http request with an error message.

I don't see uncaughtException anywhere in node-http-proxy, maybe we could use that and then we might not need the guards?
",dominictarr,2012-07-22 06:38:30
116,2012-04-02 14:42:07,"@isaacs with 0.6.0 out would it make sense to look at this again?
",coderarity,2012-07-22 06:38:30
116,2012-07-22 06:38:30,"From what I've heard from @isaacs this doesn't make sense until `node@0.10.0` has a stable domains API
",indexzero,2012-07-22 06:38:30
116,2012-07-31 13:49:04,"How are domains involved here? I'm down with maintaining our code to make it match current API.

Also, looks like `.write()` shouldn't throw anymore. @isaacs, is that correct?
",mmalecki,2012-07-22 06:38:30
116,2013-04-24 08:19:29,"Since 0.10 is released, can we consider this refactoring again?

I see that @mmalecki has prepared a branch https://github.com/nodejitsu/node-http-proxy/tree/refactor with the pipe implementation a few month ago.

The code would be far easier to maintain and also it would simplify a lot the modification of the HTML response going back to the user.
",abarre,2012-07-22 06:38:30
116,2013-05-02 07:39:03,"There is work on this to rewrite most of this as a stream, if you'd like to contribute it would be greatly appreciated. See: https://github.com/nodejitsu/node-http-proxy/tree/streams2
",indexzero,2012-07-22 06:38:30
116,2013-05-02 09:57:22,"ok, thank you for the reply, I will definitely have a look at this branch. Is there already an issue tracking the changes ?
",abarre,2012-07-22 06:38:30
115,2011-09-22 08:17:59,"this would be way simpler if we used pipe

something like this:

<S_CODE_TOKEN>

the code we currently have just duplicates functionality in pipe
",dominictarr,2011-09-30 08:23:26
115,2011-09-22 08:30:36,"this also opens up a great avenue for response altering middleware. basically, the middlewares aren't middlewares, they are a pipe of streams.

so just pipe `_res` to the 'middleware' stream, then the 'middleware' stream to `res`.

using something like https://github.com/dominictarr/event-stream makes writing streams pretty easy.
",dominictarr,2011-09-30 08:23:26
115,2011-09-22 13:49:21,"+1

On Sep 22, 2011, at September 22, 201110:18 AM, Dominic Tarr wrote:

> this would be way simpler if we used pipe
> 
> something like this:
> 
> <S_CODE_TOKEN>
> 
> the code we currently have just duplicates functionality in pipe
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/115
",mikeal,2011-09-30 08:23:26
115,2011-09-23 01:13:55,"I think github has gotten really confused somewhere here, I blame RoR.

more discussion here:

https://github.com/nodejitsu/node-http-proxy/issues/116
",dominictarr,2011-09-30 08:23:26
115,2011-09-30 08:23:25,"Duplicate of #116. Closing.
",indexzero,2011-09-30 08:23:26
114,2011-09-21 21:26:15,"This adjusts a number of the examples so that they are in compliance with the 0.7.x API.
",AvianFlu,2011-09-21 22:30:18
113,2011-09-21 21:00:54,"I'm not creating a proxyserver (I need to proxy only some requests), and I proxy certain urls by using an instance of http proxy (by calling proxyrequest). I need to use a middleware for this function, but I'm not sure how I can do this. Any ideas?
",inev,2011-09-30 08:24:39
113,2011-09-21 21:22:24,"Are you asking about using a middleware in the node-http-proxy, or using the node-http-proxy inside of a middleware?

For an example of using `node-http-proxy` inside a middleware, please see https://github.com/nodejitsu/node-http-proxy/issues/112#issuecomment-2159418 . 

For examples of using middlewares in the `node-http-proxy`, please see http://blog.nodejitsu.com/http-proxy-middlewares .

Let us know if you have any other questions. 
",AvianFlu,2011-09-30 08:24:39
113,2011-09-21 22:45:11,"i want to use a middleware in the node-http-proxy. I read http://blog.nodejitsu.com/http-proxy-middlewares, and it was very helpful but I want to use the middleware in the proxyrequest function. Currently middleware are instantiate when you create the server using createServer, but what if you don't create the server, and instead just use an instance of http-proxy.proxyRequest? How would I use a middleware in this case?

Thanks
",inev,2011-09-30 08:24:39
113,2011-09-21 22:53:05,"What are you trying to do?  There isn't a way to put middlewares into an instance of `HttpProxy` or `RoutingProxy`, but there's probably a way to do what you want to do without having to do that.  Which middleware did you need to use?
",AvianFlu,2011-09-30 08:24:39
113,2011-09-22 00:06:02,"A custom built one. All it needs to do it check the req.url for a string, and if present, it needs to change the response content type to text/plain. 
",inev,2011-09-30 08:24:39
113,2011-09-22 00:18:50,"Couldn't you just add a function to your request handler that checked that and changed the content-type (if necessary) before passing `req` and `res` to `proxy.proxyRequest`?
",AvianFlu,2011-09-30 08:24:39
113,2011-09-22 01:05:48,"The response I get from the remote server has its own content type, and overwrites the res content type. I need the change to happen after I get the response, which is why I wanted to use a middleware. Am I not understanding something here?
",inev,2011-09-30 08:24:39
113,2011-09-22 08:11:22,"most middleware that do this kind of thing do it by monkeypatching the response object.

part of the problem here is that the response headers are not set until the response in returned. so, you can't set them when you call proxyRequest. 

basically, you'll need to monkeypatch setHeaders. thats a bit messy though, so we can't take responsibility for what goes wrong...
",dominictarr,2011-09-30 08:24:39
113,2011-12-17 02:53:56,"can you give a simple example of how to do said monkey patching? I need to do something like this -- suppose I'm at localhost and the current request is notlocal.com. When I POST something to localhost, which proxies to notlocal, the response is a 302 direct to http://notlocal.com/somewhere. I'd like to change this to http://localhost.com/somewhere otherwise the client is no longer using my proxy.

suggestions? greatly appreciate advice on a best practices way to solve this, if any
",jmonster,2011-09-30 08:24:39
112,2011-09-21 15:00:55,"The **Proxy requests within another http server** example (from README.md) raises the following error:

<S_CODE_TOKEN>
",twobitfool,2013-03-09 09:23:10
112,2011-09-21 15:36:00,"There has been an API change, and the examples do not yet reflect it.  Passing  a `target` object in the form of `{ host: host, port: port }` to the constructor will solve this issue.

Sorry about the confusion - I'll try to get the docs updated ASAP.
",AvianFlu,2013-03-09 09:23:10
112,2011-09-21 15:36:02,"Same here.

Example:

<S_CODE_TOKEN>
",coolaj86,2013-03-09 09:23:10
112,2011-09-21 15:37:03,"See my above comment - `target` has `host` and `port` within it, they are not parallel arguments.  
",AvianFlu,2013-03-09 09:23:10
112,2011-09-21 15:43:47,"This is still a no-go for me.

<S_CODE_TOKEN>

server.js:

<S_CODE_TOKEN>
",coolaj86,2013-03-09 09:23:10
112,2011-09-21 15:54:59,"`Connect` is probably buffering the request, in which case it isn't a stream anymore, and no longer has a `resume` method.  Here is an example without `Connect`.  https://gist.github.com/1232446

Does that help you at all?
",AvianFlu,2013-03-09 09:23:10
112,2011-09-21 18:43:27,"There indeed has been an API change which is more significant: if you were using the `HttpProxy` before that is now a `RoutingProxy`:

<S_CODE_TOKEN>

Conversely, if you want to use the old `HttpProxy` object, you do not pass anything to `.proxyRequest()`:

<S_CODE_TOKEN>

What examples are broken? We can update them accordingly.
",indexzero,2013-03-09 09:23:10
112,2011-09-21 20:54:50,"Charlie, I think the READMe is out of date IIRC.
",strmpnk,2013-03-09 09:23:10
112,2011-09-21 20:57:32,"I'm fixing the README and all the examples now.  I'll publish the changes as soon as I'm sure all the examples work.
",AvianFlu,2013-03-09 09:23:10
112,2011-09-29 11:07:48,"Hmm, This is still not working for me. Documents are outdated or there is in fact a bug when using middleware. I get the following error: 

<S_CODE_TOKEN>
",manast,2013-03-09 09:23:10
112,2011-09-29 11:44:41,"well, forget about the previous error. It was created by me when trying to fix the real problem I found. Namely that socket.io related requests do seem to use the new API while normal http request do not. For instance, I have a simple proxy created using:

var proxyServer =  httpProxy.createServer(myMiddleware)
proxyServer.listen(config.proxyPort)

Now, inside my middleware I do this call: 
proxy.proxyRequest(req,res, dest);

where dest is in the form {port:8081, host:'myhost'}

This works well until socket.io tries to make a request, in that case I get the following error:
node_modules/http-proxy/lib/node-http-proxy/routing-proxy.js:239
    throw new Error('options.host and options.port or options.target are requi
          ^
Error: options.host and options.port or options.target are required.
    at [object Object]._getKey (/Users/manuel/dev/clouddisplay/node_modules/http-proxy/lib/node-http-proxy/routing-proxy.js:239:11)
    at [object Object].add (/Users/manuel/dev/clouddisplay/node_modules/http-proxy/lib/node-http-proxy/routing-proxy.js:70:18)
    at [object Object].proxyWebSocketRequest (/Users/manuel/dev/clouddisplay/node_modules/http-proxy/lib/node-http-proxy/routing-proxy.js:222:10)
    at Server.<anonymous> (/Users/manuel/dev/clouddisplay/node_modules/http-proxy/lib/node-http-proxy.js:190:13)
    at Server.emit (events.js:81:20)
    at Socket.<anonymous> (http.js:1042:14)
    at Socket._onReadable (net.js:683:27)
    at IOWatcher.onReadable [as callback](net.js:177:10)

Seems to me like there is some inconsistence with the APIs right now :/
",manast,2013-03-09 09:23:10
112,2011-09-29 20:22:01,"@manast I need a bigger code sample to understand what you are referring to. If you are trying to proxy WebSockets, why are you not calling `.proxyWebSocketRequest()`?
",indexzero,2013-03-09 09:23:10
112,2011-09-30 07:55:00,"Hello,

I will update with more code. But the reason I am not using proxyWebsocketRequest is because I did not need to do it before, and it worked well. Its after the API change that this has stop working.

regards.

On Sep 29, 2011, at 10:22 PM, Charlie Robbins wrote:

> @manast I need a bigger code sample to understand what you are referring to. If you are trying to proxy WebSockets, why are you not calling `.proxyWebSocketRequest()`?
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/112#issuecomment-2242780
",manast,2013-03-09 09:23:10
112,2011-09-30 08:20:40,"@manast I need a full code sample to give you any help.
",indexzero,2013-03-09 09:23:10
112,2011-09-30 08:31:40,"Ok, here it comes :)

<S_CODE_TOKEN>
",manast,2013-03-09 09:23:10
112,2011-10-11 14:49:11,"@indexzero

any news on this issue? :)
",manast,2013-03-09 09:23:10
112,2012-06-05 23:14:13,"New version of `node-http-proxy` was released. 0.8.1
",cronopio,2013-03-09 09:23:10
111,2011-09-21 10:31:02,"Is it possible to update the proxyTable without restarting http-proxy? Needed to do this to prevent requests dying to each of the routed domains. Is this something I can write some custom logic for?
",bradleyg,2011-09-21 10:49:52
110,2011-09-20 20:36:25,"These commits should fix the bug where the x-forwarded family of http headers are not being added to proxied requests.
",jfhbrook,2011-09-21 20:09:24
110,2011-09-20 21:09:25,"This looks good, but shouldn't:

<S_CODE_TOKEN>

be

<S_CODE_TOKEN>
",indexzero,2011-09-21 20:09:24
110,2011-09-20 21:32:38,"Yes. I thought I fixed that. >_<

**edit:** Fixed it.
",jfhbrook,2011-09-21 20:09:24
109,2011-09-17 12:42:56,"This fixes a bug that caused cli to fail when --target was specified with both hostname and port
",jnordberg,2011-09-19 01:49:39
108,2011-09-15 08:53:28,"Folks,

I've been trying for a couple of hours to configure node-http-proxy. I would like to forward any request  at www.website.com/blog to a tumblr url. Here's what I have so far ...

<S_CODE_TOKEN>

So far it redirects to tumblr but I'm getting their 404 page.

I realise it probably me and nothing to do with the code - if I'm in the wrong place to post this, forgive me.

Cheers,
Gordon
",gogza,2011-09-15 15:40:34
108,2011-09-15 14:54:27,"You probably have to rewrite the headers somehow before sending it off to tumblr
",indexzero,2011-09-15 15:40:34
108,2011-09-15 15:34:00,"In order to send the request to a remote host, you need to do something like the following:

<S_CODE_TOKEN>

Otherwise, the remote server sees a request with your server's hostname on it, and doesn't know what to do with it.  

You can also use a middleware for this - see https://github.com/dominictarr/proxy-by-url .  This middleware allows forward and reverse proxying in the same code block, and was developed specifically as an easy solution for what you want to do.  

Let us know if any of this helps.
",AvianFlu,2011-09-15 15:40:34
107,2011-09-12 19:30:27,"## Via Assistly:

Re: [nodejs] Express logger, output the client ip while using a proxy
Fabryz -

This would probably be best sent to support@nodejitsu.com or just drop into
the #nodejitsu IRC room.

x-forwarded-for should be set by node-http-proxy, maybe it's not getting
set? I've forwarded this email to our support team and we'll have someone
look into it.

Thanks!
- Marak

On Sun, Sep 11, 2011 at 4:19 AM, Fabryz  wrote:

> Hello,
> I tried asking in #node.js and #express but no one answered, so let's
> try here:
> 
> At the moment I'm using this format on express.logger:
> app.use(express.logger(':remote-addr - :method :url HTTP/:http-
> version :status :res[content-length] - :response-time ms'));
> 
> But on the logs on my hosted app in nodejitsu it actually shows their
> proxy IP on every request. How to show the real connected client's IP?
> 
> Tried with :req[x-forwarded-for] but didn't work.
",jfhbrook,2011-09-21 22:34:40
107,2011-09-12 20:10:28,"@dominictarr Can you create a sample app which attempts to reproduce this issue? 
",indexzero,2011-09-21 22:34:40
106,2011-09-09 09:34:47,"I've been trying to implement something like this but I'm still a newbie when it comes to node and node-http-proxy. Basically, what I'd like to see in node-http-proxy is support for a more nginx-like x-accel-redirect. Nginx can not only send files from the local disk but also send them from another backend server. So you could in, say Rails, do:

headers['X-Accel-Redirect'] = '/some/file.mp4'
or even
headers['X-Accel-Redirect'] = 'http://myotherbackend.example.com:1234/some/file.mp4'

I guess node-http-proxy would have to support checking the headers returned from backend and if it contains X-Accel-Redirect (or perhaps X-Sendfile - or even something else) it would send that out instead. Something like that.

At first I thought perhaps a middleware could accomplish this but well, I'm a newbie, and couldn't figure out how. Then I cloned the source and started hacking on it... haven't got very far yet though.

We need this since we'd like to offload this stuff from Rails onto the frontends. We currently use nginx as our frontend but nginx has problems with http 1.1 to backends and we must absolutely have 1.1 to our backends(these are not rails backends). We also use node which we'd actually like to use as our frontend going forward.
",johnae,2015-10-30 20:45:39
106,2011-09-09 15:28:30,"you could do this with middlewares, but the trick is that since the middleware system was copied from connect it delt mainly with modifying the request. what you are talking about here is modifying the response.

you proxy to your server (rails) which writes the X-Accel-Redirect header, then responds to the proxy, the proxy reads the header, sees x-accel-redirect and makes another request, to the redirect url.

currently, middlewares that modify the response work by monkeypatching the response object, have a look at https://github.com/nateps/connect-gzip

you would intercept the calls to write and end like here: https://github.com/nateps/connect-gzip/blob/master/lib/gzip.js#L40-49 but instead of piping it through the gzip command, you would make a whole new request. 

we currently don't have a middleware system for responses... 

you won't be a newbie once you have this licked. welcome to the bleeding edge.
",dominictarr,2015-10-30 20:45:39
106,2013-03-09 06:29:45,"This is blocked by nodejs core since it does not have `sendfile`.
",indexzero,2015-10-30 20:45:39
106,2015-10-30 20:45:39,"Closing, node core still does not have `sendFile`
",jcrugzz,2015-10-30 20:45:39
105,2011-09-08 16:24:15,"(no default value)
you can specify the target (hostnameOnly must be true) as an array of
this sort:
`[<port:integer>, <host:string>]`

this pull request is my attempt at the solution proposed by @jimisaacs in [this issue](https://github.com/nodejitsu/node-http-proxy/issues/104)

this is not a definitive work, I still need some advice on how to do things in node-http-proxy.
",Floby,2012-07-22 06:51:33
105,2011-09-09 08:44:21,"just wanted to add that the whole point of this is to support unix sockets so `port` can also be a string.
",Floby,2012-07-22 06:51:33
105,2012-07-22 06:51:33,"The implementation here has changed significantly since this was originally implemented. Still open to the feature, but you will need to pull and re-implment.
",indexzero,2012-07-22 06:51:33
104,2011-09-08 02:19:30,"So I wanted to use node-http-proxy to serve content from multiple apps running locally on unix sockets.
I found out quick that this was not going to work:

<S_CODE_TOKEN>

I spent the next 5 hours or so trying to figure out why.
It turns out the problem was in this method:

<S_CODE_TOKEN>

That method is always looking for a host and a port, because it does a split on the string. It could easily be modified to use a unix socket path, which is the first argument for the net.Server.listen method, the same as a port. The core lib simply checks if this value is a number or a string.

So anyway, rather than modifying the code because I didn't want to monkey around in there just yet. The simple solution after 5 hours of trying to make this reverse proxy unix sockets was this:

<S_CODE_TOKEN>

That my friends, is one magical colon.

Thanks again for this great and extremely useful module. Let me know what you think about all this, I can try to contribute.

Jim
",jimisaacs,2013-03-09 06:28:57
104,2011-09-08 13:02:56,"I had the same problem. I was expecting this to work since it works seamlessly in node core. Anyway, @jimisaacs solution is working right now.
",Floby,2013-03-09 06:28:57
104,2011-09-08 15:24:25,"Here is a suggestion for a possible change:

<S_CODE_TOKEN>

Whether this is actually proxying other node servers or not, this setup still simply looks like arguments for other servers' listen methods.
",jimisaacs,2013-03-09 06:28:57
104,2011-09-08 15:41:24,"@jimisaacs +1, just ports too, defaulting the host would be nice & a very common use-case for people just wanting cheap vhost-like behaviour

<S_CODE_TOKEN>

etc
",tj,2013-03-09 06:28:57
104,2011-09-08 16:25:13,"I gave this solution a try and started a [pull request thread](https://github.com/nodejitsu/node-http-proxy/pull/105)
",Floby,2013-03-09 06:28:57
104,2011-09-08 16:30:00,"By the way I +1 @visionmedia proposal too.
",Floby,2013-03-09 06:28:57
104,2011-09-08 21:01:40,"@Floby How does your [pull request](https://github.com/nodejitsu/node-http-proxy/pull/105) support UNIX sockets? 
",indexzero,2013-03-09 06:28:57
104,2011-09-08 21:02:44,"This is a duplicate of #79. I'm closing #79 because I think your description is more astute.
",indexzero,2013-03-09 06:28:57
104,2011-09-08 21:55:59,"errr, I inverted host and port. I updated the pull request.
You should be able to use unix sockets by doing things like this:

<S_CODE_TOKEN>

String targets still work. I haven't found a simple way to add the proper testing though since it seems that you can't use UNIX sockets with Mickeal's `request` module.
",Floby,2013-03-09 06:28:57
104,2011-09-08 22:58:56,"+1 Floby's pull request.
",jimisaacs,2013-03-09 06:28:57
104,2011-09-08 22:59:50,"Sorry, I think you can tell I don't actually comment very much on github.
I'm not a noob I swear ;)
",jimisaacs,2013-03-09 06:28:57
104,2011-09-08 23:13:31,"added testing. Some testing helpers were acting funny but it works now.
",Floby,2013-03-09 06:28:57
104,2011-09-09 00:04:48,"@Floby I want to accept your pull request, but there is a big set of changes coming down the pipeline for `v0.7.x` which optimizes the hot-paths by ~10%. I will most likely do sometime similar once that refactor is done.

I will leave this open as a reminder to do so.
",indexzero,2013-03-09 06:28:57
104,2011-09-09 08:43:27,"no problem. The magic colon is working for me for now.
",Floby,2013-03-09 06:28:57
104,2012-01-04 13:57:11,"Error while using magic colon for
- node 0.6.6
- node-http-proxy 0.8.0

I think there is new checking for host and port exists

<S_CODE_TOKEN>
",reekoheek,2013-03-09 06:28:57
104,2012-03-21 10:20:37,"Any update on this?
",epeli,2013-03-09 06:28:57
104,2012-05-10 15:14:04,"I would also like this.
",brianloveswords,2013-03-09 06:28:57
104,2012-05-11 08:23:27,"@brianloveswords I would like you to implement it ;)
",indexzero,2013-03-09 06:28:57
104,2012-05-11 12:26:31,"@indexzero I'll see if I can start throwing together a patch today!
",brianloveswords,2013-03-09 06:28:57
104,2012-05-29 11:32:53,"@indexzero @brianloveswords Hey, guys. I don't want to be a party-crasher but this neat bug still isn't fixed yet.If you don't want to or can't fix it could you please point me to the lines of codes, that probably cause the problem? I'd then try to fix it myself and make a pull request.

Thanks!
",buschtoens,2013-03-09 06:28:57
104,2012-05-29 13:49:56,"Fixed it myself.
If you can't wait you can use this script which fixes the module: https://gist.github.com/2828473

Pull Request: https://github.com/nodejitsu/node-http-proxy/pull/254
Thread on Stackoverflow: http://stackoverflow.com/a/10800727/420747
",buschtoens,2013-03-09 06:28:57
104,2013-03-09 06:28:57,"Fixed in #294 
",indexzero,2013-03-09 06:28:57
104,2013-03-09 08:45:15,"You can't imagine, how much I love you.
",buschtoens,2013-03-09 06:28:57
103,2011-09-03 21:00:09,"added postFlightMethod option to proxyRequest so that I can postprocess response/squash access-control-allow-origin.
",phillro,2011-09-03 21:19:13
103,2011-09-03 21:19:13,"Did you change all of the indentation to four spaces? I cannot accept this pull request. It does not conform to our style guidelines of two-space indentation.
",indexzero,2011-09-03 21:19:13
103,2011-09-04 14:52:54,"Oops, my defaults. Ill clean it up. Thx!

On Sat, Sep 3, 2011 at 5:19 PM, indexzero
reply@reply.github.com
wrote:

> Did you change all of the indentation to four spaces? I cannot accept this pull request. It does not conform to our style guidelines of two-space indentation.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/pull/103#issuecomment-1988692
",phillro,2011-09-03 21:19:13
102,2011-09-01 23:37:21,"Trying to do a request against a server that is down:

<S_CODE_TOKEN>

However the same request against against an http proxy:

<S_CODE_TOKEN>

Funny thing I found the error in the third parameter of the callback as a string:

<S_CODE_TOKEN>

Is this expected?
",expensecat,2011-09-08 23:11:40
102,2011-09-08 23:11:40,"This looks expected. The proxy responds with an error in the body because it is, in fact, actually accepting connections.
",indexzero,2011-09-08 23:11:40
101,2011-09-01 20:49:49,"it's pretty trivial to trigger a `next(err)` for almost any middleware, by-design they should be handled in some unified fashion, however the one in this lib just throws. You could also emit an error event with the req/res to conditionally allow users to customize the handling if necessary
",tj,2011-09-08 23:09:56
101,2011-09-01 20:53:17,"+1
",mikeal,2011-09-08 23:09:56
101,2011-09-01 20:56:37,"one concern i have is that this 500 is indistinguishable from a 500 returned by the applications behind the proxy. 

we could add a header 'x-node-proxy-error', or change the status code to one that is proxy specific, the problem is that there isn't one that fits perfectly.

<S_CODE_TOKEN>
",mikeal,2011-09-08 23:09:56
101,2011-09-01 21:08:22,"true true, not sure what convention is there
",tj,2011-09-08 23:09:56
101,2011-09-01 21:12:41,"bah, fuck it, let's just change the text body to ""Internal Proxy Server Error"" :)
",mikeal,2011-09-08 23:09:56
101,2011-09-01 21:15:25,"beats nothing. looks like squid adds custom 6xx range status codes

<S_CODE_TOKEN>
",tj,2011-09-08 23:09:56
101,2011-09-01 21:18:31,"node.js should define all kinds of new status codes that all begin with 31337 ;)
",mikeal,2011-09-08 23:09:56
101,2011-09-02 15:17:02,"Thanks. I'll push this in tonight.
",indexzero,2011-09-08 23:09:56
101,2011-09-08 18:20:21,"Sorry, been busy with NodeConf SummerCamp. Will push this out when I'm back in NYC tonight. 
",indexzero,2011-09-08 23:09:56
101,2011-09-08 19:22:41,"sounds good thanks man! 
",tj,2011-09-08 23:09:56
101,2011-09-08 23:09:56,"Cherry-picked in 07c8d2ee6017264c3d4deac9f42ca264a3740b48. Will be published in `0.6.7` 
",indexzero,2011-09-08 23:09:56
100,2011-09-01 04:52:59,"Not in the ""async/fibers/coro"" sense of flow control, but in the TCP
backpressure sense.

Pause the stream when a write isn't flushed, and then resume it once the
writable stream drains.
",isaacs,2011-09-08 21:26:21
100,2011-09-01 20:41:02,"would a better route be to refactor this to actually use pipes?

you could use my BufferedStream to handle the buffering that is in there.
",mikeal,2011-09-08 21:26:21
100,2011-09-01 20:57:27,"I agree, a refactor to use BufferedStream and Stream.pipe would be ideal here.

For my purposes, though, this change makes things a lot nicer.  Since the proxy is on the same physical hardware as the origin server, it has virtually 0 latency.  If someone streams a large file through it, it effectively buffers the entire file in memory.  With the flow-control addition, that effect is much smaller.
",isaacs,2011-09-08 21:26:21
100,2011-09-02 15:16:24,"I'll merge and push this out tonight.

+1 to refactoring this with BufferedStream and Stream.pipe. The big changes are in the `v0.7.x` branch which I hope on finishing sometime in the next few weeks. @isaacs I'm porting over your changes as they come in to this branch. 
",indexzero,2011-09-08 21:26:21
100,2011-09-08 21:26:21,"This is cherry-picked in now in 558a8a4f79716496dbdee13759c8641606458c05, 2b9e09b00ac40e6c6de2b68754df7b8e8c1e3878, and 84be9f2c3a244c7dbfe2c6320fa26d85cf80ec31. Will be published at `node-http-proxy@0.6.7` and cross-ported to the `v0.7.x` branch for forwards compatibility.
",indexzero,2011-09-08 21:26:21
99,2011-08-31 01:45:51,"good stuff! plan on using this for some personal stuff, all I really wanted was the routing capabilities, so feel free to ignore the request but I thought it might be nice to simplify the api a little for what I would at least consider one of the most common use-cases for regular vhost-style stuff.

<S_CODE_TOKEN>
",tj,2011-08-31 15:43:35
99,2011-08-31 07:35:42,"hey, we won't pull this, as we want to keep this focused primarily on performance,

but you can release this as a middleware (it's mostly the same as connect) and we'll link to it from the readme.
",dominictarr,2011-08-31 15:43:35
99,2011-08-31 15:24:40,"what does it have to do with performance?
",tj,2011-08-31 15:43:35
99,2011-08-31 15:38:44,"A couple of things: 
1. We don't use makefiles. Just use `npm test`
2. No need for `index.js` since our package.json has a `main` property.
3. No need for `module.exports` to be a function. I find `.createServer()` is a more explicit API entry-point.
4. Dominic is right about the performance implications. We chose to duplicate code because of the expense of the extra function invocation. It may seem minor, but when you're running a block of code thousands of times a second it adds up to a small fraction of performance (usually 1-2% in optimization benchmarks).
",indexzero,2011-08-31 15:43:35
99,2011-08-31 15:43:27,"if anything v8 is more likely to optimize the util.. but alright
",tj,2011-08-31 15:43:35
99,2011-08-31 16:03:17,"looks like v8 will bail regardless in this case

Bailout in HGraphBuilder: @""ProxyTable.getProxyLocation"": ForInStatement
[disabled optimization for: ProxyTable.getProxyLocation / 125a39951]
",tj,2011-08-31 15:43:35
99,2011-08-31 16:35:21,"Not quite sure how to interpret that output, can you describe what's happening in  more detail?
",indexzero,2011-08-31 15:43:35
99,2011-08-31 16:47:01,"v8 builds a graph that crankshaft uses but it's bailing out of that function all together so it's not being optimized, granted I ran it with a flag to force optimization, without that flag v8 didn't even seem to touch it so it's not such a hot function
",tj,2011-08-31 15:43:35
99,2011-08-31 16:53:08,"I should mention it bailed on mine too due to the switch statement, so neither are optimal 
",tj,2011-08-31 15:43:35
98,2011-08-30 22:37:25,"We saw the memory usage of the http proxy servers in no.de climb way up past normal levels after fixing the crash-inducing socket termination throws.  (Incidentally, that error was preventing this one from occurring.)

The attached patch makes sure to destroy the buffered request, and unhook event listeners, when there is an error.  So far today, the memory usage on the proxy with this patch has been stable.  The others continue to rise, occasionally hitting the point where they get forcibly HUP'ed.
",isaacs,2011-08-31 15:48:04
98,2011-08-30 22:43:58,"Thanks for all the patches @isaacs! 

I had a feeling we might run into issues like this once we patched those last errors. We'll get someone to review and merge shortly.
",Marak,2011-08-31 15:48:04
98,2011-08-31 15:48:04,"Cherry-picked in 0941123d8710443ec123ddbba948bfdf0df94320
",indexzero,2011-08-31 15:48:04
97,2011-08-30 18:54:45,"Howdy,

A few days ago, we added FF6 and Chrome 14 websocket support to Socket.IO. But http-proxy doesn't seem to be able to proxy these upgrade events.

If I run a plain Socket.IO 0.8.2 chat example it works fine in FF6 and latest chrome, but if I add node-http-proxy infront of it only the Draft 76 specification receives a upgrade event.

After a bit digging I found out that https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L862 doesn't get fired for the new websocket specifications (it does work for older websocket specifications like draft 76)
",3rd-Eden,2011-09-30 08:22:58
97,2011-08-30 19:18:25,"@3rd-eden. The `agent` object on the line that you've cited is an instance of the `http.Agent` from node.js core. So if the `upgrade` event is not firing on it this seems like a node.js core bug. 

The new version of the websocket draft is on our list of priorities, but we probably won't implement it until the 0.6.x timeframe. 
",indexzero,2011-09-30 08:22:58
97,2011-08-30 19:37:56,"@indexzero I don't know if it's a core bug, I don't know enough of the node-http-proxy module to debug it further. I might have missed something obvious.
",3rd-Eden,2011-09-30 08:22:58
97,2011-08-30 19:41:49,"@3rd-eden I'll try to take a stab at it if I get some cycles this week. NodeConf SummerCamp is next week so I'm kinda strapped for time.
",indexzero,2011-09-30 08:22:58
97,2011-08-30 19:55:40,"+1

This issue makes me T_T
Having my no.de work faster will make me :D

Thanks guys!
",DTrejo,2011-09-30 08:22:58
97,2011-09-09 22:59:28,"Any news on this? I'd love to use node-http-proxy, but I need WebSocket (including newer drafts) support...
",nicokaiser,2011-09-30 08:22:58
97,2011-09-09 23:12:36,"No. This is a difficult problem. 
",indexzero,2011-09-30 08:22:58
97,2011-09-10 09:24:48,"@3rd-Eden I can confirm this. I can also confirm that Firefox 6 is not working either apparently. I did some digging and here's what I'm seeing

## Firefox 7

<S_CODE_TOKEN>

## Chrome 13

<S_CODE_TOKEN>
",indexzero,2011-09-30 08:22:58
97,2011-09-10 09:31:41,"Clearly this isn't working in Firefox 6 because Firefox 6 implements WebSockets draft-07 (source: http://en.wikipedia.org/wiki/WebSocket) 
",indexzero,2011-09-30 08:22:58
97,2011-09-10 10:08:19,"@3rd-Eden Did further investigation here. This may be a bug in node.js core (or more specifically the response parsing in [http-parser](https://github.com/ry/http-parser) so I'm going to attempt to summon @ry. 

I can confirm deep in the tendrils of node (https://github.com/joyent/node/blob/v0.4.11/lib/http.js#L1230-1265), the `upgrade` event is not being fired for outgoing HTTP requests in the `draft-07` protocol.

I'm no expert of the HttpParser used by node.js here, but it seems like the `request` and `response` parsing may be different code paths. Clearly the parser is in a different state:

""Request"" mode (working): https://github.com/joyent/node/blob/v0.4.11/lib/http.js#L1020
""Response"" mode (no working): https://github.com/joyent/node/blob/v0.4.11/lib/http.js#L1203

I'm building `v0.5.5` now to see if this is fixed in HEAD.
",indexzero,2011-09-30 08:22:58
97,2011-09-10 10:17:20,"But the odd thing is that If we attach socket.io to a normal HTTP server it does work. So it's not a fundamental flaw on the node core, it might just be related to http client

On 10 sep. 2011, at 12:08, Charlie Robbins wrote:

> @3rd-Eden Did further investigation here. This may be a bug in node.js core (or more specifically the response parsing in [http-parser](https://github.com/ry/http-parser) so I'm going to attempt to summon @ry. 
> 
> I can confirm deep in the tendrils of node (https://github.com/joyent/node/blob/v0.4.11/lib/http.js#L1230-1265), the `upgrade` event is not being fired for outgoing HTTP requests in the `draft-07` protocol.
> 
> I'm no expert of the HttpParser used by node.js here, but it seems like the `request` and `response` parsing may be different code paths. Clearly the parser is in a different state:
> 
> ""Request"" mode (working): https://github.com/joyent/node/blob/v0.4.11/lib/http.js#L1020
> ""Response"" mode (no working): https://github.com/joyent/node/blob/v0.4.11/lib/http.js#L1203
> 
> I'm building `v0.5.5` now to see if this is fixed in HEAD.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/97#issuecomment-2058794
",3rd-Eden,2011-09-30 08:22:58
97,2011-09-10 10:40:25,"@3rd-eden @ry I can confirm that this still isn't working in Firefox 6 and Chrome 14 upon upgrading to `http2` from @mikeal in `v0.5.5`. 

I would like to make note for @mikeal that `http2` is going to simplify the implementation quite a bit because the `upgrade` event is fired on the `ClientRequest` object and not the `Agent`. 

However, the `upgrade` event is still not firing and I'm starting to think that this is a problem with `http-parser` since it seems to hold the necessary and sufficient state for the event to be fired: https://github.com/joyent/node/blob/v0.5.5/lib/http2.js#L1107

@ry @mikeal Any thoughts here? I'm stumped.
",indexzero,2011-09-30 08:22:58
97,2011-09-10 10:41:21,"The http2 compatible of `node-http-proxy` is here: https://github.com/nodejitsu/node-http-proxy/tree/http2
",indexzero,2011-09-30 08:22:58
97,2011-09-10 11:16:11,"@3rd-eden

> But the odd thing is that If we attach socket.io to a normal HTTP server it does work. So it's not a fundamental flaw on 
> the node core, it might just be related to http client

Exactly. When you attach socket.io to a normal HTTP server the `http-parser` is in the ""Request"" state. When `node-http-proxy` is attempting to make an outgoing WebSocket connection it is in the ""Response"" state. I noticed that the only current implementation of the later spec(s) in node is actually using the deprecated `http.createClient` method because they claim ""Node's new Agent-based API is buggy."" 

I'm not sure if these bugs are in the `http-parser` or the `Agent` but as I tried this out with both `http.js` and `http2.js` only to get the same result I'm suspicious of it being at the http-level. No evidence to support that claim though. 

https://github.com/Worlize/WebSocket-Node/blob/master/lib/WebSocketClient.js#L149-150
",indexzero,2011-09-30 08:22:58
97,2011-09-10 11:25:35,"So if http-proxy starts using the old interface this would be resolved i guess?

On 10 sep. 2011, at 13:16, Charlie Robbins wrote:

> @3rd-eden
> 
> > But the odd thing is that If we attach socket.io to a normal HTTP server it does work. So it's not a fundamental flaw on 
> > the node core, it might just be related to http client
> 
> Exactly. When you attach socket.io to a normal HTTP server the `http-parser` is in the ""Request"" state. When `node-http-proxy` is attempting to make an outgoing WebSocket connection it is in the ""Response"" state. I noticed that the only current implementation of the later spec(s) in node is actually using the deprecated `http.createClient` method because they claim ""Node's new Agent-based API is buggy."" 
> 
> https://github.com/Worlize/WebSocket-Node/blob/master/lib/WebSocketClient.js#L149-150
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/97#issuecomment-2058986
",3rd-Eden,2011-09-30 08:22:58
97,2011-09-10 12:34:59,"Thats not a viable solution
",indexzero,2011-09-30 08:22:58
97,2011-09-11 01:58:29,"@3rd-eden Wanted to give more info on my last comment. It was like 8am here; so I was pretty spent after pushing out `0.7.0`. 

From what I can see in `http2` using the deprecated `http.Client` interface will not work because it is using the new `ClientRequest` object which is not raising the `upgrade` event. I'll try to do some more digging, but this seems like a very small header parsing issue.
",indexzero,2011-09-30 08:22:58
97,2011-09-11 03:42:24,"@3rd-eden @ry 

I spent some time reading the `http-parser` code with help from @bmeck and it seems that this is indeed a problem with the `connection` header parsing not detecting the ""Upgrade"" state because in Firefox 7 it sends

<S_CODE_TOKEN>

where as in Chrome 13 and older versions of the spec the header is:

<S_CODE_TOKEN>

Based on our first pass it seems like the parser enters the `h_connection_keep_alive` greedily (https://github.com/ry/http-parser/blob/master/http_parser.c#L1367-1377) and does not continue to check the contents of the header. 

Not sure how simple a fix this is, but @bmeck will be putting together a low-level parser repro next week.
",indexzero,2011-09-30 08:22:58
97,2011-09-11 05:12:32,"please provide an example request that youve seen in the wild with `connection: keep-alive, Upgrade` and i'll fix the parser
",ry,2011-09-30 08:22:58
97,2011-09-11 05:16:35,"@ry Firefox 7 Websocket Requests. Seems to be consistent across Firefox 6 (draft7), Firefox 7 (draft10) and (reportedly) Chrome 14 (draft10).

More info in this comment: https://github.com/nodejitsu/node-http-proxy/issues/97#issuecomment-2058654
",indexzero,2011-09-30 08:22:58
97,2011-09-11 05:28:11,"Best way to repoduce this is in the wild is to open the simple chat example for socket.io that @3rd-eden suggested in Firefox 6 or 7. I'm using a different socket.io sample app: http://github.com/fat/space-tweet. To run this just

<S_CODE_TOKEN>

Then you can throw a proxy server in front of it

<S_CODE_TOKEN>

I found an interesting discussion on the ietf mailing list about a bug in the draft11 spec which confirms that comma-separated `connection` headers are in-fact supported by HTTP and used in builds of Firefox: http://www.ietf.org/mail-archive/web/hybi/current/msg08519.html

> ""Connection"" header allows a list of tokens separated by comma. So the
> following is valid (in fact Firefox 8 uses it):
> 
> Connection: keep-alive, upgrade
",indexzero,2011-09-30 08:22:58
97,2011-09-11 12:17:14,"Well there seems to be 2 seperate issues then. Because Chrome beta and Chromium are sending the following headers:

<S_CODE_TOKEN>

And they are not answered correctly by the proxy either. So it seems to me that the 

<S_CODE_TOKEN>

Isn't the only reason why node-http-proxy fails to proxy requests.
",3rd-Eden,2011-09-30 08:22:58
97,2011-09-11 14:27:57,"Interesting. Again, in this case as you pointed out @3rd-eden it is just that the `upgrade` event is not being emitted. This leads me to believe that this is _not_ a bug in `node-http-proxy`, but perhaps a combination of small issues elsewhere in node.js core or it's dependencies.
",indexzero,2011-09-30 08:22:58
97,2011-09-17 23:57:28,"I wonder where is (Key3):00:00:00:00:00:00:00:00 coming from, I am trying to implement draft-ietf-hybi-thewebsocketprotocol-15 in jwebsocket.org. But keep getting disconnected. I am using chrome 14.0.835.163
",narup,2011-09-30 08:22:58
97,2011-09-21 19:02:48,"I think I might know what causes this bug.

[Websockets are messed up a bit in Chrome 14](http://groups.google.com/a/chromium.org/group/chromium-discuss/browse_thread/thread/97f3cb623c581395) (I remember that this was a real issue during node knockout), and [Firefox's support for them is limited](https://bugzilla.mozilla.org/show_bug.cgi?id=666349). As you can see, neither browser supports binary frames, while socket.io [_seems_ to be using it](https://github.com/LearnBoost/socket.io/blob/master/lib/transports/websocket/hybi-07-12.js#L130).

In fact, I was able to run socket.io chat demo with node-http-proxy and Chrome 15.0.874.15 dev (and yes, it was using Websockets transport - verified by `socket.socket.transport` in inspector and by looking at `chrome://net-internals/#events`).
Firefox 8.0a works _partially_. Connection breaks quite randomly, but that happens both with and without proxy, so I guess it isn't our problem.
Also, Chromium 13 works without any problems.

For me, it seems that the source of problem is that browsers are _trying_ to use newest hybi specification, but don't actually implement it fully.

However, please note that I may be _terribly_ wrong and YMMV.
",mmalecki,2011-09-30 08:22:58
97,2011-09-21 19:27:42,"@mmalecki Thanks for the information, but @3rdeden has confirmed that `socket.io@latest` works on node stand-alone, but not behind node-http-proxy. 

So the binary frames may be a red herring, but I will look into it.
",indexzero,2011-09-30 08:22:58
97,2011-09-29 02:11:28,"After some further investigation with @AvianFlu:

Parser doesn't seem to be a problem. It detects upgrades just fine (and fires [this callback](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L189)). Proxy receives http requests like:

<S_CODE_TOKEN>

But fails to pass them further. [This callback doesn't get executed at all](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L591).

[Comparison between direct and proxied request](https://gist.github.com/44c77df7f64cda18e664) - forwarded requests have their headers all in lower case. No forwarded request has an `Upgrade` header.

I'll investigate it further, but it's 4 AM and it's basically a brain dump.
",mmalecki,2011-09-30 08:22:58
97,2011-09-29 11:29:56,"After some further further investigation:

In [this line](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L537) we [append a message to a queue](https://github.com/joyent/node/blob/v0.4.12/lib/http.js#L1162) and we hope that _eventually_ (when socket is assigned) it'll be send to a server. In fact, socket gets assigned in the very first [`_cycle`](https://github.com/joyent/node/blob/v0.4.12/lib/http.js#L1377) call. This calls a [`_flush`](https://github.com/joyent/node/blob/v0.4.12/lib/http.js#L728) method on this message, but flushing fails [here](https://github.com/joyent/node/blob/v0.4.12/lib/http.js#L753), because of empty `output` and this request gets stuck.

Weirdest thing is: after some time [`proxyError`](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L544) gets called with `'socket hung up'` message. And _then_ this `OutgoingMessage`, which got stuck is send to a server (to be precise: [`OutgoingMessage._writeRaw`](https://github.com/joyent/node/blob/v0.4.12/lib/http.js#L376) is called - of course, server never receives it because of this socket error).

In fact, I can force this flush by inserting `first.end()` right after [this line](https://github.com/joyent/node/blob/v0.4.12/lib/http.js#L1399) or `reverseProxy.end()` [here](https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy/http-proxy.js#L537), but it results in a following error from socket.io:

<S_CODE_TOKEN>
",mmalecki,2011-09-30 08:22:58
97,2011-09-29 23:18:10,"The request gets stuck, as @mmalecki said, and then, since there's no error status, eventually https://github.com/joyent/node/blob/v0.4.12/lib/http.js#L1284-1293 is reached and the ""socket hang up"" message is received.  The real key to fixing this lies in figuring out how to make it past https://github.com/joyent/node/blob/v0.4.12/lib/http.js#L753 to the socket.write() call at the end of that method.
",AvianFlu,2011-09-30 08:22:58
97,2011-09-29 23:39:37,"Do you guys have a simple test case yet? Put one together send it to me and I'll just fix it. You guys are thinking too hard.

A simple test case would be: tcpdump the req/res in question, set up a http server, have a tcp client connect to it - send the request as you got it from the tcpdump - assert what you expect to happen. See `test/simple/test-http-*` in the node tree for examples of test cases.
",ry,2011-09-30 08:22:58
97,2011-09-29 23:55:40,"@ry There really isn't a fully programmatic test case. Is that what you mean by a ""simple test case"". No node.js library (node-websocket-client, websocket-node, etc) correctly emulates how browsers have implemented WebSockets.

The easiest way to reproduce this right now is to 
1. Write anything that uses socket.io (we have some simple test cases if you'd like to talk offline)
2. Put node-http-proxy in front of them
3. Open it in Firefox 7+ or Chrome 14+
",indexzero,2011-09-30 08:22:58
97,2011-09-30 00:48:54,"I can confirm that the fix from @indutny resolves this issue in his pull request. In both Firefox 7 and Chrome 14. I'm merging this into master.
",indexzero,2011-09-30 08:22:58
97,2011-09-30 08:22:57,"This should be fixed in `0.7.2`. @3rd-eden can you confirm?
",indexzero,2011-09-30 08:22:58
97,2011-10-01 16:52:08,"@indexzero fix confirmed
",3rd-Eden,2011-09-30 08:22:58
96,2011-08-28 20:51:04,"<S_CODE_TOKEN>

In the version of http-proxy we've got deployed, that line is this:

<S_CODE_TOKEN>

this seems to fix it:

<S_CODE_TOKEN>

Patch coming.
",isaacs,2011-08-28 23:33:25
96,2011-08-28 23:33:25,"Thanks. I've merged this into head and I'll publish as 0.6.4 in a few minutes. I won't forget this time
",indexzero,2011-08-28 23:33:25
95,2011-08-28 20:38:52,"<S_CODE_TOKEN>
",isaacs,2011-08-28 23:32:36
94,2011-08-28 06:12:20,"Now that we have a middle-ware system, does it make sense to remove the `proxy-table.js` file from the core repo and add it back as a proper middle-ware? 
",Marak,2011-08-28 09:15:00
94,2011-08-28 09:14:59,"Yes and no. Basically routing has become a more complex operation in the `0.7.x` API:
1. `HttpProxy` object will only be valid for a single `host:port` combination.
2. `RoutingProxy` will encapsulate any logic that existed around `ProxyTable` integration. The `RoutingProxy` will thus have to create multiple instances of `HttpProxy` objects.

The `.createServer()` API will be 100% backwards compatible creating a `RoutingProxy` instance if `options.router` is set. The reasoning here is that it will remove a **lot** of core application logic that we don't use in production and should therefore speed things up.

Basic tests (w/o routing table) are passing in the `v0.7.x` branch with optimizations for **every request** in the non-routing case which remove a non-trivial amount of branching statements and function invocations.
",indexzero,2011-08-28 09:15:00
93,2011-08-27 18:52:30,,isaacs,2011-08-28 05:51:57
93,2011-08-27 19:20:42,"Looks good. Need to do a little triage before merging. Quick question: is res.write() throwing frequently generally resolved in node@0.6.0?
",indexzero,2011-08-28 05:51:57
93,2011-08-28 05:51:57,"@isaacs Merged and published as `http-proxy@0.6.3`. Point of question about testability: do you know a good way to reproduce `res.write()` throwing? 

Would like to add this to the test suite.
",indexzero,2011-08-28 05:51:57
93,2011-08-28 22:23:22,"@indexzero I can't figure out how to reproduce it, either.  It shouldn't be possible.
",isaacs,2011-08-28 05:51:57
93,2011-08-28 22:23:53,"There are a few other areas where res.end can throw.

<S_CODE_TOKEN>
",isaacs,2011-08-28 05:51:57
92,2011-08-17 00:42:29,"The following would not work, assuming a websocket request is sent, and local.host and sub.local.host can receive socket.io websocket requests:

<S_CODE_TOKEN>

Even though there is a passing test for websocket proxying when using a routing table in your vows tests, that test does not provide complete coverage, since the test helper it uses passes a callback to httpProxy.createServer(...). When a callback is passed to createServer, then proxyWebSocketRequest is never called because the 'upgrade' event callback is only set up if a callback is passed into createServer. As a result, it does not end up catching this particular issue.
",bnoguchi,2011-08-28 05:44:07
92,2011-08-28 05:44:07,"@bnoguchi I think you are mistaken about how the tests are setup:
1. `web-socket-proxy-test.js` calls `TestRunner.prototype.webSocketTestWithTable` https://github.com/nodejitsu/node-http-proxy/blob/master/test/web-socket-proxy-test.js#L58
2. `TestRunner.prototype.webSocketTestWithTable` calls `TestRunner.prototype.startProxyServerWithTable` https://github.com/nodejitsu/node-http-proxy/blob/master/test/helpers.js#L175-194
3. `TestRunner.prototype.startProxyServerWithTable` calls `httpProxy.createServer` with a merged object literal (no callback) https://github.com/nodejitsu/node-http-proxy/blob/master/test/helpers.js#L238

In addition: 
1. This pull request uses the logic from `.proxyRequest()` with works with `http.Response` instances, not `net.Socket` instances. 
2. There is support for `ProxyTable` instances in `.proxyWebSocketRequest()` already: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L641-650

Happy to discuss whatever problems you're running into, but won't be merging this in as it seems like a false-positive.
",indexzero,2011-08-28 05:44:07
91,2011-08-13 02:17:34,"line 34 in the websockets example points to:

var utils = require('socket.io/lib/socket.io/utils'),

when it should point to:

var utils = require('socket.io/lib/socket.io/util'),

There's no ""s"" at the end of ""utils""
",newshorts,2011-08-13 02:19:36
91,2011-08-13 02:19:35,"@newshorts Actually no, it is not. You are probably confused because we are using `socket.io@0.6.18`, not `socket.io@0.7.x` which has significant refactoring to various paths:

https://github.com/nodejitsu/node-http-proxy/blob/master/test/web-socket-proxy-test.js#L41-42
",indexzero,2011-08-13 02:19:36
91,2011-08-13 02:20:14,"Also, see: https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/utils.js
",indexzero,2011-08-13 02:19:36
91,2011-08-14 00:53:27,"My apologies, I should have done a bit more research first.
",newshorts,2011-08-13 02:19:36
90,2011-08-12 05:11:02,"proxy.createServer({
    router:{
        'myserver.com':'localhost:81', //works
                'mail.myserver.com':'localhost:8080', //works
        'google.myserver.com':'www.google.com', //doesn't work
    }
}).listen(80);

//WHY??
",tianshuo,2011-08-13 03:59:47
90,2011-08-12 05:27:12,"Note that changing `www.google.com` to its ip and/or adding `:80` doesn't work.
",tianshuo,2011-08-13 03:59:47
90,2011-08-12 18:58:42,"You're trying to do forward and reverse proxying at the same time - the 'router' option doesn't really do that by itself.  In order to proxy a request to another domain like that, you also need to change the hostname in the request headers, or else `google.com` won't have any idea what to do with the request once it gets there.  I've drawn up a basic example for you:  let me know if this helps.  https://gist.github.com/1142699

That code runs, although it's likely not production-grade.
",AvianFlu,2011-08-13 03:59:47
89,2011-08-11 19:15:44,"Hi,

   I am trying to create an express application that uses node-http-proxy and I have a few questions that the documentation and examples don;t address. I want to listen on a proxy port -- that is a port that I configure browsers to use and have all requests that don;t match a route using a regex be answered. It would also be useful if the proxy protocol for authentication was supported. Is this configuration possible with node-http-proxy and express. I am trying to find a worked out example but everything I have found so far doesn't seem to address the web proxy issue. There is another node.js library that does what one could reasonable say a proxy does but it may not support the connect next() approach. Thanks for all this great work.

Rinaldo
",digitalrinaldo,2011-09-10 08:05:19
89,2011-08-28 05:59:22,"@dominictarr Can you help @digialrinaldo with his question?
",indexzero,2011-09-10 08:05:19
89,2011-08-28 19:04:28,"let me see if I understand, you want to use http-proxy to proxy outgoing requests?

browsers on you network will access the internet through the proxy, but if the request matches a regexp they will get express instead?

is that correct?
",dominictarr,2011-09-10 08:05:19
89,2011-09-05 10:31:23,"@digitalrinaldo can you answer my questions so that we can move forward with this issue?
",dominictarr,2011-09-10 08:05:19
89,2011-09-08 15:54:41,"@digitalrinaldo I think I see where you are going with this.

I think it's something that would allow this module to wrap itself around an express application.
All the logic is in place in the this module, it would just have to be reworked a little to be able to use that logic as express middleware.
",jimisaacs,2011-09-10 08:05:19
89,2011-09-10 08:05:19,"No response in > 2 weeks. Closing issue.
",indexzero,2011-09-10 08:05:19
88,2011-08-10 07:33:37,"At the moment, if the number of maxSockets is reached, nothing happens.

If the number is reached, there should be an event thrown by the proxy, so a developer can log an error, close some connections and so on.
",KimSchneider,2015-10-30 20:45:04
88,2011-08-10 07:40:55,"that is a good idea. seems that node doesn't have anyway to directly access
this. you would probably have to poll agent.requests.length

It might be worth it to post this as an issue on node core.

I'm really busy at the moment, but i'd accept a pull request (with tests)
for this.

On Wed, Aug 10, 2011 at 5:33 PM, KimSchneider <
reply@reply.github.com>wrote:

> At the moment, if the number of maxSockets is reached, nothing happens.
> 
> If the number is reached, there should be an event thrown by the proxy, so
> a developer can log an error, close some connections and so on.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/88
",dominictarr,2015-10-30 20:45:04
88,2011-08-10 07:44:52,"That's right, I'll post it as an node issue, too.

If I got some time this week, I will implement it. But as I said, we are overhauling our product, that's prio one at the moment :)
",KimSchneider,2015-10-30 20:45:04
88,2015-10-30 20:45:04,"We currently use `agent = false` by default. Pass in an agent with your own defined `maxSockets` to handle this. In general it is node core's job to manage sockets
",jcrugzz,2015-10-30 20:45:04
87,2011-08-09 17:56:26,"node url-middleware.js

http proxy server started on port 8000
http server started on port 9000 

/usr/local/lib/node/.npm/proxy-by-url/0.0.1/package/index.js:56
    next() //if there wasno matching rule, fall back to next middleware.
    ^
TypeError: object is not a function
    at [object Object].CALL_NON_FUNCTION (native)
    at /usr/local/lib/node/.npm/proxy-by-url/0.0.1/package/index.js:56:5
    at Server.<anonymous> (/usr/local/lib/node/.npm/http-proxy/0.6.2/package/lib/node-http-proxy.js:237:47)
    at Server.emit (events.js:67:17)
    at HTTPParser.onIncoming (http.js:1135:12)
    at HTTPParser.onHeadersComplete (http.js:108:31)
    at Socket.ondata (http.js:1030:22)
    at Socket._onReadable (net.js:683:27)
    at IOWatcher.onReadable [as callback](net.js:177:10)
",digitalrinaldo,2011-08-09 19:04:29
87,2011-08-09 18:31:42,"THis may be a version issue it is unfortunate that node doesn't include api versioning.  I am looking into it.
",digitalrinaldo,2011-08-09 19:04:29
87,2011-08-09 19:04:28,"Can't repeat it.
",digitalrinaldo,2011-08-09 19:04:29
86,2011-08-08 22:20:57,"Hi,

url-middleware.js
url-middleware2.js

and the example at the proxy-by-url workspace

/private/tmp/http-proxy/1.js:18
  });
    ^

node.js:134
        throw e; // process.nextTick error, or 'error' event on first tick
        ^
SyntaxError: Unexpected token ;
    at Module._compile (module.js:397:25)
    at Object..js (module.js:408:10)
    at Module.load (module.js:334:31)
    at Function._load (module.js:293:12)
    at Array.<anonymous> (module.js:421:10)
    at EventEmitter._tickCallback (node.js:126:26)

I can't seem to get this example

require('http-proxy').createServer(
require('proxy-by-url')({
  '/database': { port: 5984, host: 'localhost' },
})
).listen(8000)

or the url-middleware.js example to work with node I am getting a
unexpected token

m1:node rinaldo$ node url-middleware.js

/opt/node/url-middleware.js:44
});
  ^

m1:node rinaldo$ npm info proxy-by-url
{ name: 'proxy-by-url',
description: 'custom logic for node-http-proxy to proxy basedon incoming
url',
'dist-tags': { latest: '0.0.0' },
versions: '0.0.0',
maintainers: 'dominictarr dominic.tarr@gmail.com',
time: { '0.0.0': '2011-07-30T09:55:29.217Z' },
author: 'Dominic Tarr dominic.tarr@gmail.com (
http://bit.ly/dominictarr)',
repository:
 { type: 'git',
   url: 'git://github.com/dominictarr/proxy-by-url.git' },
version: '0.0.0',
homepage: 'http://github.com/dominictarr/proxy-by-url',
dependencies: {},
devDependencies: {},
scripts: { test: 'meta-test test/_.js' },
engines: { node: '_' },
dist:
 { shasum: 'ee8c04d31d20996e7d4a4ce888379890119a73ea',
   tarball: '
http://registry.npmjs.org/proxy-by-url/-/proxy-by-url-0.0.0.tgz' },
directories: {} }
## 

Reply to this email directly or view it on GitHub:
http://github.com/inbox/11305033#reply
",digitalrinaldo,2011-08-10 00:02:26
86,2011-08-09 04:34:14,"uh, this is a syntax error in /private/tmp/http-proxy/1.js

this looks like a missing { or ( 
or possibly a comment //
on the last line, or an unclosed block comment. /*

it looks like the way you have your enviroment setup is very odd.

have a look in /private/tmp/http-proxy/1.js

also, there was a mistake in proxy-by-url please install the new version. (then your pasted code will work)
",dominictarr,2011-08-10 00:02:26
86,2011-08-09 10:38:03,"sorry, I just realized that you had already emailed me about this.

please install/pull the new version and also `cd examples && npm install`

also fixed a small mistake in `proxy-by-url`, now it's at 0.0.1

this should work now, please confirm.
",dominictarr,2011-08-10 00:02:26
86,2011-08-09 18:33:49,"Works on my mac with 0.4.9 fails on 4.11-pre on centos
",digitalrinaldo,2011-08-10 00:02:26
86,2011-08-10 00:02:26,"cool, thanks.

will check this again when 0.4.11 is offically released.
",dominictarr,2011-08-10 00:02:26
85,2011-08-03 05:18:37,"This example is not working:

https://github.com/nodejitsu/node-http-proxy/blob/master/examples/body-decoder.js

Is not calling ""data"" callback.
",raphaelcosta,2011-08-03 06:13:16
85,2011-08-03 06:05:32,"That example wasn't meant to be used - try `examples/bodyDecoder-middleware.js` instead.  You'll have to install a few dependencies for it, like `connect` and `connect-restreamer`.

Thanks for pointing it out, by the way - miscommunication led to a bad merge.
",AvianFlu,2011-08-03 06:13:16
85,2011-08-03 16:20:10,"@AvianFlu i am implementing a proxy that simulate a ipad request, and iam trying to remove flash element in response body, how can i do that? thanks
",raphaelcosta,2011-08-03 06:13:16
84,2011-08-01 10:22:46,"The number of maxSockets has to be set after the agent is created. Setting the property in the constructor does not work.
",KimSchneider,2011-08-02 14:07:46
84,2011-08-01 19:04:52,"this is actually is a feature of node.js core.

https://github.com/joyent/node/blob/v0.4.10/lib/http.js#L1139-1147

unless this is something that would be useful? @dominictarr
",jamesonjlee,2011-08-02 14:07:46
84,2011-08-02 04:30:35,"am yet to confirm the bug this commit fixes. see discussion here: https://github.com/nodejitsu/node-http-proxy/issues/80
",dominictarr,2011-08-02 14:07:46
84,2011-08-02 11:32:52,"Just ran into this issue
I used setMaxSockets, but all agents report their default (5) instead.
Indeed, it appears the Agent constructor doesn't look at the maxConnections option, but rather uses the global Agent.defaultMaxSockets
So if http-proxy wants to set this, it has to occur after calling the Agent constructor.
",bluescreen303,2011-08-02 14:07:46
84,2011-08-02 14:09:06,"you where right, 

thanks!
",dominictarr,2011-08-02 14:07:46
84,2011-08-02 18:27:58,"@drjackal @KimSchneider is actually correct here. @dominictarr +1 to merge this
",indexzero,2011-08-02 14:07:46
83,2011-07-29 13:53:58,"My machine has a pool of IPs. Is it possible to choose the outgoing IP the proxy will use to make the requests? Would it be possible to randomly use more than one IP?

Thanks
",barbolo,2011-07-29 13:55:04
82,2011-07-29 13:33:20,"My machine has a pool of IPs. Is it possible to choose the outgoing IP the proxy will use to make the requests? Would it be possible to randomly use more than one IP?

Thanks
",barbolo,2011-08-02 17:10:40
82,2011-07-29 18:15:51,"I might be misunderstanding you, but have a look at this: http://blog.nodejitsu.com/http-proxy-intro/roundrobin.js
",AvianFlu,2011-08-02 17:10:40
82,2011-07-29 18:30:56,"@AvianFlu, thanks for the reply!

The example you posted shows how to connect to a target server/website that has multiple IPs/domains. So each request is routed to a different address of the target server.

I have a different need. I have a machine with multiple IPs attached to its network interface. I want to use a different IP for each request I do to a website. This will avoid the target server to track the users who make the requests.

I believe this is achievable by programming the net.Socket connection and would like to know if this project already support it in any way.

Thanks
",barbolo,2011-08-02 17:10:40
82,2011-07-29 20:40:39,"You need to `bind` the socket before calling connect() or listen(), you can't do that using node.js.
",tralamazza,2011-08-02 17:10:40
82,2011-07-29 20:44:42,"If net.Socket had an event before connect/listen you could manually bind it using something like:

<S_CODE_TOKEN>
",tralamazza,2011-08-02 17:10:40
82,2011-07-29 20:46:52,"Quickly looking the source code seems the socket `FD` is not initialized until `connect`, so apparently you can't intercept it anywhere.
",tralamazza,2011-08-02 17:10:40
82,2011-07-31 20:02:20,"Thanks, @tralamazza.

I'm looking for the Ruby EventMachine as well. It seems that its implementation allows to bind the address before making the requests.

I'll still be looking for a solution with node.js.
",barbolo,2011-08-02 17:10:40
82,2011-07-31 23:29:55,"This might actually work https://gist.github.com/1117341
I wrote looking at the net.js code.

_Edit:_ Tested myself and it works :-)
",tralamazza,2011-08-02 17:10:40
82,2011-08-02 17:10:40,"Since this seems to be more of a `net` issue, I'm closing this for now.
",AvianFlu,2011-08-02 17:10:40
82,2011-08-03 13:27:40,"Thanks so much, @tralamazza!
",barbolo,2011-08-02 17:10:40
81,2011-07-29 06:18:24,"nt

see https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L112 and http://nodejs.org/docs/v0.4.10/api/all.html#agent.maxSockets
",dominictarr,2011-09-10 08:58:39
80,2011-07-28 13:53:04,"Hi,

we want to use the node-http-proxy in combination with express.

Our setup ist the following:

Main server:
- express listening on port 443
- node-http-proxy listening on port 84 and forwards to 443

Proxy server
- node-http-proxy listeing on port 443 and forwards to main server port 84 or another tomcat server

Clients
- clients connect to proxy server
- depending on the url, they are routed to main server or tomcat server
- if routet to main server the connection is kept open for about 30 seconds (long-polling)

Everything works fine if our clients connect directly to the main server. If they connect over the proxy server we can have 5 request and nothing else happens until those requests are closed.

We have to be able to connect a minimum of 500 clients by long polling. Any way we can manage this?

Thanks for your help.
",KimSchneider,2011-08-02 14:07:46
80,2011-07-29 05:58:19,"are you sure that this is caused by node-http-proxy?

there was recently a discussion on the mailing list about this topic: http://groups.google.com/group/nodejs/browse_thread/thread/bbc049d7d320c5ab?hl=en%3Fhl%3Den
",dominictarr,2011-08-02 14:07:46
80,2011-07-29 06:06:39,"oh sorry, it might besomething to do with this: http://nodejs.org/docs/v0.4.10/api/all.html#agent.maxSockets
",dominictarr,2011-08-02 14:07:46
80,2011-07-29 06:14:52,"okay, read through the code in node-http-proxy: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L32 default connections is set to 100. 

you'll want to include:

`require('http-proxy').setMaxSockets(500)`

how are you generating the requests? 
",dominictarr,2011-08-02 14:07:46
80,2011-08-01 07:27:38,"Thanks for your reply. I am not really sure, if it has to do with express. I already modified the http-proxy and hard coded  the defaults to 10000 connections.

After some checks it realy seems to be limited to 5 connections. So, the max connections have no effect or express accepts only 5 connections, too. To be honest, I don't know how to set the max connections on express and did not find any solution, yet.

To answer your question, we have a c# client that talks to our online servers via https requests.
",KimSchneider,2011-08-02 14:07:46
80,2011-08-01 10:23:24,"Found a solution, here you go: https://github.com/nodejitsu/node-http-proxy/pull/84
:-)
",KimSchneider,2011-08-02 14:07:46
80,2011-08-02 04:29:31,"hi, how are you testing this?

I have not yet seen http-proxy limiting it self to 5 concurrent connections. 

here in a test I am using, it does not respond until it has 10 connections, so if some thing is limiting connections to 5 then it would timeout.

but that is not the behavior that I am seeing.

can you run the test and tell me what happens?
",dominictarr,2011-08-02 14:07:46
80,2011-08-02 07:20:33,"I testet this using an basic node webserver that counts incoming connections, but does not close them. I started a proxy that forwards every request to the webserver.

Run jMeter or any other http stresstool with more than 5 concurrent threads. In my testcases everytime I used the proxy the counter stopped at 5 and if I did not use the proxy I have been able to open as many connections as I wanted.

My fix changed it to the behaviour we need :)
",KimSchneider,2011-08-02 14:07:46
80,2011-08-02 12:23:12,"oops, I forgot to link my test. https://gist.github.com/1119591

can you post your test as a gist so that I can reproduce the issue here?
",dominictarr,2011-08-02 14:07:46
80,2011-08-02 13:22:28,"https://gist.github.com/1120162

That's my testcase. Open it 10 times in your browser or run a http stress tool against it.
",KimSchneider,2011-08-02 14:07:46
80,2011-08-02 13:49:27,"thanks. I've reproduced your issue.
",dominictarr,2011-08-02 14:07:46
79,2011-07-27 12:09:54,"I really love this module, but one thing that bars me from using it is the lack of domain socket support. I know that this is a limitation of the < 0.5.0 node http agents, but since most production servers probably will be on 0.4.x until the next stable release, I suggest using [httpu](https://github.com/mcavage/node-httpu).
",coverslide,2011-09-08 21:02:57
79,2011-07-27 12:53:08,"very interesting. we will accept a pull request for this.
",dominictarr,2011-09-08 21:02:57
79,2011-09-08 21:02:57,"This is a duplicate of #104. Closing
",indexzero,2011-09-08 21:02:57
78,2011-07-26 04:54:07,"If a server omits Content-Length and Transfer-Encoding the client waits until timeout. I am not sure if this needs a ""fix"" to be honest, nor where this fix should be implemented (http-proxy or http.js).
According to [RFC 2616 section 4.4](http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4) the server can simply disconnect. I hacked a small [patch](https://github.com/tralamazza/node-http-proxy/commit/b24452a00a1ca256bb3ae734a7706eaab194cfe9#lib/node-http-proxy.js) to fix my particular problem.
",tralamazza,2013-03-09 07:26:23
78,2011-07-26 06:20:34,"you linked to an RFC. that makes me highly inclined to pull your code, however I don't think that you've put the call to res.end() in the right place, as long responses may end up as two chunks...

can you gist a script that will reproduce this?

does res.on('end',... not get called?

res.connection.on('close',.. may be the correct place, but this warrants more investigation.
",dominictarr,2013-03-09 07:26:23
78,2011-07-26 06:37:58,"I am assuming (and hoping) that if a server does not send the Transfer-Encoding, it won't chunk the body.
The res.on('end') wasn't called, I fixed my ""patch"" a [couple of minutes ago](https://github.com/tralamazza/node-http-proxy/commit/ba126bb3c54bdb3a6c052cbf66d17d037c98bc41).
This problem is actually happening on a production server running a json REST API. I will code a small server to emulate this behavior and gist it.
",tralamazza,2013-03-09 07:26:23
78,2011-07-26 07:22:38,"Gist is up https://gist.github.com/1106179
",tralamazza,2013-03-09 07:26:23
78,2011-07-26 09:28:10,"hmm, okay. from what I can see the proxy is working correctly.

I think the problem is that your nc script doesn't close the connection.

If it did, it would emit 'end'.

from my reading of that RFC if the server doesn't send a Content-Length or a transfer encoding the end of a message is determined from a closing connection.

my understanding is that the chunk in the on 'data' events is an actual packet, and can be split up however tcp wants, so there is no guarantee the whole message will always be one chunk. (particularly for longer messages)

what is your use-case?
",dominictarr,2013-03-09 07:26:23
78,2011-07-26 15:56:11,"Hmm yeah you are right, I thought the nc trick would emulate it correctly, but it didn't (I blame sleep deprivation =P).

Like I said, I am assuming the server won't send anything else. The server could be experiencing network problems yada yada yada...  the usual network problem solved by timeouts >.<

I've put together a new gist with my user-case https://gist.github.com/1107045
",tralamazza,2013-03-09 07:26:23
78,2012-04-02 14:28:49,"@tralamazza is this still a problem from you? I tried your user-case and I did get a `content-length` header back. (I guess that's an old API key, but you should probably keep that to yourself.)
",coderarity,2013-03-09 07:26:23
78,2012-04-02 14:33:52,"@CodeRarity not sure this key still works, I haven't touched the src code in months. I just want to forget rapleaf honestly. Anyway thanks for testing/answering.
",tralamazza,2013-03-09 07:26:23
77,2011-07-26 02:41:28,"See the following example:

<S_CODE_TOKEN>

If we make a request to the route server.domain.com/helloworld works as expected. Also, if we request server.domain.com/helloworldZZDXC also successful and calls 127.0.0.1:3000. That is not expected. Is this the intended behavior? How can we make a route an exact match and not a wildcard at the end?
",nodesocket,2011-07-26 03:27:32
77,2011-07-26 03:27:32,"If you bothered to read the source code for http-proxy, you'd clearly see that the routes in the routing table are Regex strings, which means the behavior is very much expected.

see: 

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/proxy-table.js#L93
https://github.com/nodejitsu/node-http-proxy/blob/master/lib/proxy-table.js#L131

<S_CODE_TOKEN>
",Marak,2011-07-26 03:27:32
76,2011-07-25 19:19:21,"Hello,

since I am totally new to proxying I was expecting that a table like this:

options = {
    router: {
    'foo.com/':'127.0.0.1:8081',
    'foo.com/dev':'127.0.0.1:8082',
    }
  }

is going to route all routes that start with foo.com/dev to 127.0.0.1:8082 by removing the /dev part. So for example:
foo.com/dev/users is going to be proxyed to 127.0.0.1:8082/users, but instead it seems like it is routing it to 127.0.0.1:8082/dev/users

The reason I wish it did remove the /dev part is that the server located in port 8082 should not even need to know that the content sent to him is being proxyed, now instead I have to take into consideration that all urls will start with /dev which I dont think is a very elegant solution...

I am probably missing something basic here, I appreciate if you could point me out what it is.

thanks in advance.
",manast,2011-07-26 06:22:15
76,2011-07-26 01:05:01,"no, you have not missed anything.

this feature has been requested before 
https://github.com/nodejitsu/node-http-proxy/issues/69

basically, the focus of node-http-proxy is high performance proxying.

we're adding a middleware system, so things like this, can be maintained seperately.

here is an example: https://github.com/nodejitsu/node-http-proxy/blob/middleware/examples/url-middleware.js

that is only an example. It is not ready for production use, but does give yau a starting point if you want to develop this feature.
",dominictarr,2011-07-26 06:22:15
76,2011-07-26 01:06:39,"(note, the middleware is bleeding edge, but should be pulled into the master following a review)
",dominictarr,2011-07-26 06:22:15
76,2011-07-26 06:22:15,"Thanks for the quick answer. Even if it is not production quality yet I will try this today. My system is not going into production yet so it is ok for me to test this kind of features.

thanks once again.
",manast,2011-07-26 06:22:15
76,2012-08-01 12:26:53,"Hi, 

I've found that with http-proxy 0.8.1, for this routing rule ( to an express 3.0.0 app ) :

<S_CODE_TOKEN>

the call of 'foo.com/dev/users'  route to 127.0.0.1:8082 with this request _""GET //users HTTP/1.1""_ ( express.logger() ) 
Note the double slash : so _app.get(""/users"")_ didn't work ... 

To have a clean route like _""GET /users HTTP/1.1""_ , you have to write

<S_CODE_TOKEN>

Note the trailing slash in the source.

hope that helps.
",aurel-appsthru,2011-07-26 06:22:15
75,2011-07-21 23:11:12,"The following code reproduces the problem:

<S_CODE_TOKEN>

So after 10 seconds, requesting /first should not resolve, yet it continues to resolve and respond with 'Hello From First' until you close the browser, then requests stop being routed. Confirmed in both Firefox 5 and Chrome.
",nodesocket,2011-07-22 01:36:30
75,2011-07-22 01:36:29,"@nodesocket This is actually by design in node.js core and has nothing to do with `node-http-proxy`. Here's a quick sample repro'ing the problem with the `http` module:

<S_CODE_TOKEN>

It's actually good that the server does this because you want to keep serving all of your connections and not abruptly cut them off. What would be nice is if the `close` event didn't fire on the `http.Server` instance until all of the connections had closed gracefully. I've talked to @ry and opened an issue on node.js core: https://github.com/joyent/node/issues/1383
",indexzero,2011-07-22 01:36:30
74,2011-07-21 14:05:04,"presumable they should be though.

I will address this in forth coming refactor.
",dominictarr,2011-09-10 10:57:58
74,2011-07-21 15:45:09,"@dominictarr Can we push forward on all of these refactor issues in a `v0.6.x` branch?
",indexzero,2011-09-10 10:57:58
73,2011-07-19 08:33:29,"When using multiple layers of proxies one needs the ability not to re-set x-forwarded-[for|port|proto] on every layer; as the first proxy sets these headers on further layers the headers should not be clobbered so the final destination sees the correct address.
",DanBUK,2011-07-21 13:38:49
73,2011-07-19 08:37:15,"`camelCase` options are preferred over `camel_case` options (it's Javascript, not Ruby afterall). Can you please rename this to `enableXForwarded` and I will accept it.
",indexzero,2011-07-21 13:38:49
73,2011-07-19 08:58:28,"Updated!
",DanBUK,2011-07-21 13:38:49
73,2011-07-19 19:17:58,"This should be `true` by default:

<S_CODE_TOKEN>
",indexzero,2011-07-21 13:38:49
73,2011-07-21 13:57:30,"defaults to true in https://github.com/nodejitsu/node-http-proxy/commit/e3d95ecab24700535184df32f3a97e8699099b7f
",dominictarr,2011-07-21 13:38:49
72,2011-07-18 06:24:23,"While exploring node-http-proxy, among other things (such as the rather depressing documentation), I noticed that this function doesn't utilize routing preferences set when calling HttpProxy(options).

https://gist.github.com/1088665
",ghost,2011-07-21 13:14:17
72,2011-07-18 06:32:22,"I'll have someone look into this, looks like it could be a bug.

You should understand that the routing table stuff is all for convenience. If you read the ""rather depressing documentation"" you'll understand that building a custom routing scenario is trivial.  
",Marak,2011-07-21 13:14:17
72,2011-07-18 07:03:24,"This is easy enough to fix. For optimization purposes (i.e. less function invocations on each request), this code (https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L344-372) should basically just be duplicated inside of `proxyWebSocketRequest`.

@dominctarr thoughts? Have you had a chance to really dig through the code base yet?
",indexzero,2011-07-21 13:14:17
72,2011-07-19 02:56:30,"The gist does not have enough code to reproduce the problem, and the websocket examples are broken, but looks fairly simple, will reproduce first. the websocket examples are broken, then fix.
",dominictarr,2011-07-21 13:14:17
72,2011-07-21 13:14:17,"fixed in https://github.com/nodejitsu/node-http-proxy/commit/efa17ef6cf614b763fc3b76570a24e750e2ddd31

duplicating the code is a problem, will refactor when I'm more familiar with the code base.
",dominictarr,2011-07-21 13:14:17
71,2011-07-13 17:44:51,"TypeError: Cannot read property 'pair' of undefined
at [object Object].proxyRequest (/pathtonode/node_modules/http-proxy/lib/node-http-proxy.js:384:52)
at Server.<anonymous> (/pathtonode/node_modules/http-proxy/lib/node-http-proxy.js:160:13)
at Server.emit (events.js:81:20)
at HTTPParser.onIncoming (http.js:1124:12)
at HTTPParser.onHeadersComplete (http.js:108:31)
at CleartextStream.ondata (http.js:1019:22)
at CleartextStream._push (tls.js:303:27)
at SecurePair.cycle (tls.js:574:20)
at EncryptedStream.write (tls.js:96:13)
at Socket.ondata (stream.js:36:26)

I use the node proxy for https -> http
node 0.4.9
",gernotger,2011-07-13 17:47:44
71,2011-07-13 17:47:44,"Duplicate of #62: https://github.com/nodejitsu/node-http-proxy/issues/62 ... wont fix.
",indexzero,2011-07-13 17:47:44
70,2011-07-08 13:58:19,"I'm, trying to use socket.io's xhr-multipart transport but the connection is always closed after the first chunk of data. Looks like there is a problem with transfer encoding chunked.
",fjakobs,2015-10-30 20:41:55
70,2011-07-08 17:08:16,"Could you provide a test case that reproduces this? 
",Marak,2015-10-30 20:41:55
70,2011-07-11 09:18:25,"Sure. This is a very basic test with socket.io. https://gist.github.com/1075579

You need to have socket.io 0.6.x and http-proxy in path. Then open the app in Firefox. If you navigate to the socket.io server at http://localhost:6666 you will see the connect message in the console.

If you navigate to the proxied request at http://localhost:6060 the multipart-xhr connection is opened and immediately closed again. 
",fjakobs,2015-10-30 20:41:55
70,2011-07-17 14:08:27,"hmm, I am unable to reproduce this. It loads okay. but never logs `connect`

If I point chrome at localhost:6666 

I get `Error 312 (net::ERR_UNSAFE_PORT): Unknown error.`

okay, i'm reproducing this in firefox with socket.io@0.6.0

Can you make a simpler test that does not require a browser or socket.io?

I know some things socket.io does will not work behind a proxy. (like using multiple ports) prehaps this should be posted as a socket.io issue?
",dominictarr,2015-10-30 20:41:55
70,2011-07-18 00:09:30,"The tests currently use: https://github.com/nodejitsu/node-http-proxy/blob/master/vendor/websocket.js as the websocket client.
",Marak,2015-10-30 20:41:55
70,2011-07-18 02:27:04,"@marak in @jakobs script he sets socket.io to use xhr-multipart, so socket.io falls back to that instead of websockets.

https://gist.github.com/1075579#L7
",dominictarr,2015-10-30 20:41:55
70,2011-07-18 08:29:11,"I was able to reduce the bug and remove the socket.io dependency https://gist.github.com/1088883.
Note that you have to test this with Firefox because other browsers don't support multipart xhr. I think this exposes some problems with chunked encoding and connection keep-alive.
",fjakobs,2015-10-30 20:41:55
70,2011-07-18 09:07:47,"good work.

I can see it work in firefox (note, firebug must be installed - to get console.log) 
If you request localhost:6666/xhr (bypass proxy) it works correctly.
If you request localhost:6060/xhr (through proxy) it does not work.

the same behaviour occurs with curl. 

I will tag this as confirmed bug, migrate this test to vows, then fix.

thanks @fjakobs, good hunting! 
",dominictarr,2015-10-30 20:41:55
70,2011-07-19 09:56:33,"Thanks. Good luck fixing
",fjakobs,2015-10-30 20:41:55
70,2011-07-29 08:50:00,"I think this might be a bug in core's handling of keep-alive. 

I expanded your gist to request to your keep-alive server. by passing the proxy it still doesn't work. it does not get the response body. However, if you comment out `headers['Connection'] = 'keep-alive';` it does work.

here is my gist: https://gist.github.com/1113432

there are lots of issues for keep-alive in node: https://github.com/joyent/node/issues/search?q=keep-alive 
",dominictarr,2015-10-30 20:41:55
70,2012-09-08 00:21:23,"Any update on this?
",thefosk,2015-10-30 20:41:55
70,2015-10-30 20:41:55,"Closing due to old age, this should no longer be an issue
",jcrugzz,2015-10-30 20:41:55
69,2011-07-07 08:55:26,"I would like to redirect different urls to different servers

Something like:

<pre>
var defaultOptions = {
  router: {
    ""foo.com/someurl"": ""127.0.0.1:8091/someurl"",
    ""foo.com"": ""127.0.0.1:8092""
  }
};
</pre>


This would result in

<pre>
foo.com/ -> 127.0.0.1:8092/
foo.com/bla -> 127.0.0.1:8092/bla
foo.com/someurl -> 127.0.0.1:8091/someurl
foo.com/someurl/more -> 127.0.0.1:8091/someurl/more
</pre>

note that this would also require some kind of 'order' on the router rules.
",japj,2013-03-09 09:21:06
69,2011-07-17 12:29:01,"this could be fixed nicely with a middleware system
",dominictarr,2013-03-09 09:21:06
69,2011-07-29 01:21:13,"Is this possible with the current version? I'm looking for this exact functionality to be able to do things like:

<S_CODE_TOKEN>

because I have a node app that serves static files from different directories for each users but all API endpoints are the same. I don't know right now how to accomplish this.
",diversario,2013-03-09 09:21:06
69,2011-07-29 05:42:40,"yes, you will need to write your custom logic though.
",dominictarr,2013-03-09 09:21:06
69,2012-01-31 21:03:29,"I am needing this feature as well. I actually wasn't expecting http-proxy to get rid of the current URI after proxying it.

For instance: 

<S_CODE_TOKEN>

reaches the service 127.0.0.1:8005 with no URI at all. I was expecting to receive the same request URI at the other end. Anyways, I can come up with a middleware to do that in the mean time.
",c4milo,2013-03-09 09:21:06
69,2013-03-09 09:21:06,"I think this is fixed in #380.
",indexzero,2013-03-09 09:21:06
68,2011-07-05 10:14:08,"Can somebody give me a clue? Thanks!

[~]$ npm install http-proxy
npm info it worked if it ends with ok
npm info using npm@0.2.10-1
npm info using node@v0.4.7
npm WARN not a valid range.  Please see `npm help json` 0.4.x || 0.5.x
npm WARN not a valid range.  Please see `npm help json` 0.4.x || 0.5.x
npm WARN not a valid range.  Please see `npm help json` 0.4.x || 0.5.x
npm WARN Not supported on node@v0.4.7 http-proxy
npm WARN not a valid range.  Please see `npm help json` 0.4.x || 0.5.x
npm ERR! http-proxy@0.5.11 not compatible with your version of node
npm ERR! Requires: node@0.4.x || 0.5.x
npm ERR! You have: node@v0.4.7
npm not ok
",dio,2011-07-05 19:27:36
68,2011-07-05 10:16:27,"NPM version is too old. Latest is 1.0.15.
Probably that is a problem.
",indutny,2011-07-05 19:27:36
68,2011-07-05 16:30:48,"I agree with @indutny.  This will most likely go away if you upgrade npm.  
",AvianFlu,2011-07-05 19:27:36
68,2011-07-05 19:27:41,"Thanks fixed!
",dio,2011-07-05 19:27:36
67,2011-06-30 07:59:32,"I've been trying in vain to modify the request body (adding parameters to the query string) before proxying it along. Any suggestions/examples on how to do this? 
",ryonlife,2011-07-14 21:47:26
67,2011-07-14 21:47:26,"You currently cannot since modifying the request body would involve buffering the entire request into memory ( non-performant ). 

There are a few open issues about this ( such as : https://github.com/nodejitsu/node-http-proxy/issues/58 ) , we'll be pushing something soon I hope.
",Marak,2011-07-14 21:47:26
66,2011-06-27 13:54:36,"Greetings,

This might be a stupid question, but I'll continue. I'm very new to node-http-proxy. I have the following code:

<S_CODE_TOKEN>

But how to set it up so that content is actually served from the proxy server? I want to analyse the traffic before sending it through.

I've tried res.write(res) but it doesn't work. I'm really stuck as to what to do next.

Many thanks in advance,
",hynese,2011-08-28 06:02:41
66,2011-06-27 14:30:27,"I am unable to reproduce, I changed it to be a loopback address of
'127.0.0.1' and it seemed to be fine. After that I tried off an
external address and it worked as well, are you sure '172.16.1.224' is
the address of the server?

On Mon, Jun 27, 2011 at 8:54 AM, hynese
reply@reply.github.com
wrote:

> Greetings,
> 
> I'm very new to node-http-proxy. I have the following code:
> 
> <S_CODE_TOKEN>
> 
> But how to set it up so that content is actually served from the proxy server? I've tried res.write(res) but it doesn't work. I'm really stuck as to what to do next.
> 
> Many thanks in advance,
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/66
",bmeck,2011-08-28 06:02:41
66,2011-07-17 14:21:26,"code should be:

<S_CODE_TOKEN>
",dominictarr,2011-08-28 06:02:41
66,2011-07-18 00:06:33,"@dominictarr @bmeck - Read what he is asking. He's not having an issue with basic proxying. 

_But how to set it up so that content is actually served from the proxy server? I want to analyse the traffic before sending it through._

@hynese - Can you be more clear as to what your issue is? Are you trying to do custom proxy logic? Check out the examples folder and this file: https://github.com/nodejitsu/node-http-proxy/blob/master/examples/standalone-proxy.js
",Marak,2011-08-28 06:02:41
66,2011-07-18 06:58:46,"Propose: close. Seems to be a duplicate of: https://github.com/nodejitsu/node-http-proxy/issues/58
",indexzero,2011-08-28 06:02:41
66,2011-07-18 07:42:47,"yeah it does look like @hynese is trying to log the response, which is issue #58
",dominictarr,2011-08-28 06:02:41
66,2011-08-28 06:02:41,"@hynese @marak @dominictarr @bmeck This is now resolve in the latest version of `node-http-proxy`. Check out some of the examples around ""middleware"" in: https://github.com/nodejitsu/node-http-proxy/tree/master/examples
",indexzero,2011-08-28 06:02:41
65,2011-06-27 09:28:55,"Here is the test that breaks: https://gist.github.com/1048553

Needs express as it uses express/lib/router/methods for the test.

Tested with v0.4.8
",stagas,2013-06-23 13:29:13
65,2011-07-17 13:07:44,"There is a problem with your test. You did not wait for the server to become ready before making requests. 

...so you got `ECONNREFUSED`

I've fixed this here: https://gist.github.com/1087546

Then I get `socket hang up` 

However, requesting on port 9000 (bypassing the proxy) gives the same error - so it looks like a problem with node's http, not http proxy.

It breaks on `connect`, I'm not sure what this method is for, but possibly there is a good reason for this?
",dominictarr,2013-06-23 13:29:13
64,2011-06-26 13:00:39,"following I found in my error log from the Proxy

AssertionError: true == false
    at IncomingMessage.<anonymous> (http.js:1338:9)
    at IncomingMessage.emit (events.js:81:20)
    at HTTPParser.onMessageComplete (http.js:133:23)
    at Socket.ondata (http.js:1228:22)
    at Socket._onReadable (net.js:684:27)
    at IOWatcher.onReadable [as callback](net.js:177:10)

I use the node proxy for https -> http
",gernotger,2011-06-26 13:06:05
64,2011-06-26 13:06:05,"This looks like a node.js core issue: https://github.com/joyent/node/blob/v0.4.8/lib/http.js#L1338

What version of node are you running?
",indexzero,2011-06-26 13:06:05
63,2011-06-21 14:26:37,"Hi, I'm trying to write a quick web server to sit in front of varnish to limit the number of times a user can access the website. I've pretty much got everything working but I have one problem stopping me. http://pastebin.com/YZUDUGa1 If you arrive on the server and found to be in the white list you get proxied onto our site straight away on line 201. This works fine. If however it goes into the memcache call back and then proxies you on then the server just hangs forever. The browser gets no response nore does node throw an error. Any help would be useful at this point. I'm using the 0.5 version of proxy.
",daemon-byte,2011-06-21 22:42:40
63,2011-06-21 17:38:24,"There are a couple of strange/wrong things going on with the code you pasted. 

The biggest issue I can see is that you are attempting to process the req/res object after you have proxied the request. This won't work, the request has already been proxied somewhere else for processing. You need to perform whatever custom proxy logic you are going to do BEFORE you proxy the request off somewhere.

Aside from that on line 23 I see a setTimeout around your proxy call, which is illogical. Why is this timer there? I also see you are setting req and res on the function prototype of proxyUser on lines 17 and 18, which is also illogical. 

It looks like you need to restructure your entire block of code.
",Marak,2011-06-21 22:42:40
63,2011-06-21 17:49:18,"I know about the timeout and I'm not sure how that got into my code. I already removed that. Setting the res and req the way I did is illogical but I was getting desperate and was wondering if perhaps they were outside of scope or something. So I tried passing them in first so I knew they were right. But that didn't work. 

The first bit you said however I am not aware off nore am I sure what you are saying. Where am I sending the request off for processing? Is that because the memcache call back goes off after the server is done? If so how can I alter the code so that won't happen?
",daemon-byte,2011-06-21 22:42:40
63,2011-06-21 18:41:56,"You are calling proxyUser on line 85, which in turns call httpProxy.proxyRequest on line 24. 

At this point the request and response have been proxied to another awaiting server, any further calculations you perform on the request / response objects are invalid. The request and response are gone at this point, they have been proxied to another server.

Your code also does a lot of strange things, like calling proxyUser() without arguments sometimes, and with arguments other times. You've got too many problems happening at once here.

You should write a clear specification of the logic you wish to perform and I can attempt to write a new script to help you. Attempting to fix the current code you pasted seems futile. 
",Marak,2011-06-21 22:42:40
63,2011-06-21 19:24:40,"ok to get away from the confusion I have undone the random stuff I put in to try and make it work. 

http://pastebin.com/6weBJy9L

Basically what I was trying to do was this:

user hits the server:
if they are on the blacklist print a blocked page
if they are on the whitelist proxy them
if neither list then go to memcache and see how many times they have entered the website. 
              If less than 200 then proxy
              If more than 200 then show captcha form. On completion of captcha reset timer and proxy user.

Now the first proxy works as it is supposed to. The white list users have no problem and they proxy perfectly. It is when I descend into the memcache callback that the proxy just hangs. Once I call that proxy user function I don't intend to do any more process. At that point I have decided the outcome.
",daemon-byte,2011-06-21 22:42:40
63,2011-06-21 19:25:59,"Give me a few hours and I'll see what I can respond with. :-)
",Marak,2011-06-21 22:42:40
63,2011-06-21 20:34:24,"@daemon-byte -

For the most part, you should be able to fix your code to achieve the functionality you want. Your code is just not structured correctly at all, see my previous comments. I can't help you fix it without rewriting it, you've coupled too many things too closely together. Is your coding background in C or PHP? You should think about trying to write more modular code, especially when dealing with Node.js

I've read through your requirements a little bit. I think there would be utility in having generic whitelist / blacklist functionality. We've opened up a ticket for this @ https://github.com/nodejitsu/node-http-proxy/issues/2 last year. I'm going to circle around and see if we can get this functionality built this week.
",Marak,2011-06-21 22:42:40
63,2011-06-21 22:22:16,"It's PHP. I think I ended up in a pickle by trying to mash to many 3rd party modules together. Do you know why the proxyuser function doesn't work inside the memcache call back? Is there perhaps a better way to query memcache? I was just following the example in that module's example code so I am not sure if that is the correct way to do it. My javascript skills have become some what lacking thanks to jquery :(
",daemon-byte,2011-06-21 22:42:40
63,2011-06-21 22:42:40,"1. Use http://gist.github.com instead of pastebin, your pastebin is impossible to read.
2. You CANNOT, repeat CANNOT attempt to perform ANY logic on the request or response objects AFTER you have proxied them somewhere. Your code attempts to buffer the req and response objects into memory, but you are doing it incorrectly.
3. You should be using a static file server or rendering engine to render html strings. If you insist of writing 10,000 lines of res.write, at least remove them from the same file that in responsible for your proxying logic. What you have now is insanity.
4. Don't make gigantic switch cases statements where it's clear you want to use an object or array lookup. DO NOT use switch / case like this.
5. You've got the scoping all wrong in this for request / response, it's simply not going to work. This isn't PHP, many requests are going to hit your httpServer handler concurrently. Requests DO NOT wait for previous requests to complete....

We are going to implement some middle-wares to help make performing arbitrary actions on request and response objects a little more friendly by helping buffer them into memory, but until then I'd suggest you give up on using http-proxy. If you are dealing with a single host target and are going to actually try and intercept / modify all your http requests, you should just use the raw http.client.

Closing issue for now. I'll comment when midde-wares are ready.
",Marak,2011-06-21 22:42:40
62,2011-06-14 04:30:43,"Hi,

I am using the latest http-proxy in hostNameOnly mode and it kept crashing in 
https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L372

I dont' have the stack trace right now, but it said something like res.connection was undefined. 
. I just changed res to req in that line and everything started to work. I am very new to nodejs, so not sure what may be happening, but is this just a typo? I would think you would use the request object to set the header on the proxied request, so it does seem like one.

Regards
Qasim
",qzaidi,2011-06-26 17:03:03
62,2011-06-14 04:38:11,"@qzaidi The hostNameOnly was a contributed feature, so additional information about this issue (such as a stack trace or some sample code that reproduces the issue) would be quite helpful. 

What version of node, npm, and node-http-proxy are you currently using?
",indexzero,2011-06-26 17:03:03
62,2011-06-14 04:39:41,"Also, a confirmation of running the unit tests would be good. Thanks!
",Marak,2011-06-26 17:03:03
62,2011-06-14 09:20:05,"Here's a stack trace

/usr/local/lib/node_modules/http-proxy/lib/node-http-proxy.js:357
  req.headers['x-forwarded-proto'] = res.connection.pair ? 'https' : 'http';
                                                   ^
TypeError: Cannot read property 'pair' of undefined
    at [object Object].proxyRequest (/usr/local/lib/node_modules/http-proxy/lib/node-http-proxy.js:357:52)
    at Server.<anonymous> (/usr/local/lib/node_modules/http-proxy/lib/node-http-proxy.js:155:13)
    at Server.emit (events.js:67:17)
    at HTTPParser.onIncoming (http.js:1123:12)
    at HTTPParser.onHeadersComplete (http.js:108:31)
    at Socket.ondata (http.js:1018:22)
    at Socket._onReadable (net.js:683:27)
    at IOWatcher.onReadable [as callback](net.js:177:10)

I am using node 0.4.8, npm 1.0.10
",qzaidi,2011-06-26 17:03:03
62,2011-06-15 13:49:49,"Can you provide some sample code? I am unable to reproduce this.
",indexzero,2011-06-26 17:03:03
62,2011-06-24 08:06:30,"I can confirm this error occurs however it is very random in nature. My program can be running for 10 seconds or 10 minutes without hitting this problem and I can't seem to find any reliable way of replicating it during testing. It's only when under live load it falls.
",daemon-byte,2011-06-26 17:03:03
62,2011-06-24 10:12:44,"I hard coded that line so it always used http as we don't accept https traffic just to see what happened and of course it no longer erred there but it did further down at 

<S_CODE_TOKEN>

I got a socket can't be written to error. So I'm guessing in my case at least in some rare instances node is losing the connection to the user. Is this normal?
",daemon-byte,2011-06-26 17:03:03
62,2011-06-26 15:20:18,"@daemon-byte, are you using HTTPS? I do think that there are some cases in which HTTPS can cause a socket wake up and become unwriteable.
",indexzero,2011-06-26 17:03:03
62,2011-06-26 16:01:06,"No, as I said we only accept http on our nodejs server. It's just there to sit in front of varnish on our public facing site.
",daemon-byte,2011-06-26 17:03:03
62,2011-06-26 17:03:03,"@daemon-byte So I'm going to close this as `wont fix`. I made a fix (which you can see here: https://gist.github.com/1047764), but after running the benchmarks with this applied the additional overhead of the `try/catch` logic seems to be degrading performance by `10-15%`.

My suggestion would be to use a standalone instance of the `HttpProxy` object and wrap the entire call to `.proxyRequest()` in a `try/catch`.
",indexzero,2011-06-26 17:03:03
62,2011-07-16 16:24:34,"Same here.

I do not understand what exactly triggers the crash, and the `wont fix`. Could you give more details? 

There is a performance issue, sure, but a crash does not look like a viable alternative to me :-)
",bpierre,2011-06-26 17:03:03
62,2011-07-16 17:26:49,"To be honest bpierre I haven't figured out the exact trigger and it's proving to be a nightmare. Best I can do currently is throw a 500 error out to the client but I can't put a system live like that. When I divert live traffic through it then there are just to many instances of it happening for us to accept. It's only a few percent but frequent enough to be a problem.
",daemon-byte,2011-06-26 17:03:03
62,2011-07-25 19:02:08,"I have found a trigger for it. Whenever a client using Firefox 4 or 5 connects the error occurs. It also occurs _sometimes_ when connecting with Opera. It is triggered without fail when FF 4 or 5 connects though.

At the other end of my proxy is a node.js instance that serves files to the client. On each occasion it will serve: index.htm, then main.css and as soon as it tries to serve the first .png file, the proxy crashes.

Is anyone else serving a .png file when this occurs?
",Irrelon,2011-06-26 17:03:03
62,2011-07-25 20:45:19,"Mine tends to be the css sheets but it has happened with images. So far I haven't seen it trigger on FF but there was 2 versions of opera (although I used one of those versions and it didn't crash) and a couple of mobile phone browsers. All I can think off is that at some point the browser is making subsequent connections for extra files and losing the connection somewhere. Maybe it has to do with modern browsers making multiple connections at the same time.
",daemon-byte,2011-06-26 17:03:03
62,2011-07-25 20:54:49,"@daemon-byte @bpierre  - To my understanding this issue only affects hostNameOnly mode. If you want a more robust proxy, you should be using the lower level APIs we expose ( like @indexzero has suggested ). 
",Marak,2011-06-26 17:03:03
62,2011-07-25 21:25:44,"It's been a while since I looked at the code so I am not exactly sure what you mean by hostnameonly mode and thus if that is the only thing. However it does not bother me where the try catch statement is put, what bothers me is there is no way to recover it once you reach that point. The best you can do is throw an error code out to the user which is far from ideal. I can't have 5% of our traffic generating 500 errors thus I need to understand what is happening and address the problem rather than just put a bodge around it.
",daemon-byte,2011-06-26 17:03:03
62,2011-07-25 21:30:47,"Well, unless you can reproduce the error, there isn't much that can be done, sorry. 
",Marak,2011-06-26 17:03:03
62,2011-07-25 21:34:50,"I wasn't expecting that. I was just discussing the problem with similar sufferers with the hope we could track down the issue in details.
",daemon-byte,2011-06-26 17:03:03
62,2011-07-25 21:53:26,"@daemon-byte @bpierre @coolbloke1324 This issue is marked `wont-fix` because there is nothing we can do to fix it in the node-http-proxy project itself; it is blocked by a core node.js bug which is not scheduled for fix until `0.6.x`. 

In the meantime, a recent feature has been added which may allow you work around this issue if you don't use the `x-forwarded-*` headers. You can now pass in `enableXForwarded: false` in the options to `HttpProxy` instances and `.createServer()` and this will bypass the check which is throwing the exception: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L385

You will of course not get the `x-forwarded-*` headers in your target application, but if that's not a concern for you this do the trick.
",indexzero,2011-06-26 17:03:03
62,2011-07-25 21:54:35,"@dominictarr can shed some light on whether this is pushed in the latest version of `node-http-proxy` on npm
",indexzero,2011-06-26 17:03:03
62,2011-07-25 21:57:24,"@dominictarr FYI:

<S_CODE_TOKEN>
",indexzero,2011-06-26 17:03:03
62,2011-07-25 23:05:56,"@indexzero thanks for the details. Don't suppose you know the node.js bug tracker url do you? Interested to know what is going on under the hood with this one!
",Irrelon,2011-06-26 17:03:03
62,2011-07-25 23:11:28,"@coolbloke1324 Very busy preparing for upcoming releases, don't have the time to dig around to find it. Try searching for HTTPS releated bugs in the nodejs issues: http://github.com/joyent/node/issues
",indexzero,2011-06-26 17:03:03
62,2011-07-26 01:29:46,"@daemon-byte @bpierre @coolbloke1324 @indexzero

the feature indexzero refers to in

> In the meantime, a recent feature has been added which may allow you work around this issue if you don't use the x-forwarded-\* headers. You can now pass in enableXForwarded: false in the options to HttpProxy instances and .createServer() and this will bypass the check which is throwing the exception: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L385
> 
> You will of course not get the x-forwarded-\* headers in your target application, but if that's not a concern for you this do the trick.

is now available on npm in http-proxy@0.6.0
",dominictarr,2011-06-26 17:03:03
62,2011-07-26 10:37:43,"I guessed it might have an underlying bug which was causing an issue. It's a shame that the bug is not scheduled for the next big release. Is there any sort of time line for that? Also judging from your comment does that mean the issue only triggers off when someone tries to use ssl traffic because we don't use https.
",daemon-byte,2011-06-26 17:03:03
62,2011-07-26 11:33:47,"I tried with http-proxy@0.6.0 and `enableXForwarded: false`, it crashed too:

<S_CODE_TOKEN>

And here is the script:

<S_CODE_TOKEN>
",bpierre,2011-06-26 17:03:03
62,2011-07-26 12:01:51,"that looks normal. what about the backend? can you reduce that to a minimal failing example?

that error message sounds like maybe one of the sockets (client-proxy or proxy-server) is closing at a diffirent time to the other.
",dominictarr,2011-06-26 17:03:03
62,2011-07-26 12:08:54,"I reduced it to:

<S_CODE_TOKEN>

I‚Äôm waiting for the next crash now, I keep you informed.
",bpierre,2011-06-26 17:03:03
62,2011-07-26 19:06:35,"sorry, by `backend` I meant what is the server like which is being proxied?
",dominictarr,2011-06-26 17:03:03
62,2011-07-26 19:18:53,"It‚Äôs a Nginx server, with various fcgi (php-fpm) and uwsgi (Django) apps.

But since the above update (I removed the Node / Socket.IO server), the proxy has not crashed‚Ä¶ It seems to be related to my Node / Socket.IO app.

I will try to launch another node-http-proxy for the Node app to confirm that.
",bpierre,2011-06-26 17:03:03
61,2011-06-13 06:47:04,"I'm getting the following error with a very simple app.  I'm running a normal web server on port 8000.

app.js

<S_CODE_TOKEN>

console

<S_CODE_TOKEN>
",mattinsler,2011-06-13 06:56:09
61,2011-06-13 06:49:19,"Would you mind running the http-proxy tests on your system to confirm it's in a valid state? Thanks!
",Marak,2011-06-13 06:56:09
61,2011-06-13 06:53:50,"I get the same error on the tests.  I am using node v0.5.0-pre for some odd reason...  I'm going to try 0.4.8.
",mattinsler,2011-06-13 06:56:09
61,2011-06-13 06:56:08,"**SO TIRED OF THIS ERROR. WHY IS NODE STILL BROKEN!?!** >.<

I was so tired of it that I changed the way we manage agents internally in `node-http-proxy` in 887c5808c90b7128c040e510e237ddb4d034fe3e, but I had not yet published it. Now I have, this is fixed in `v0.5.10` which is now on npm. 

Please confirm that this is not an issue with this version.
",indexzero,2011-06-13 06:56:09
61,2011-06-13 06:59:01,"Well that worked like a charm (0.4.8 and Charlie's fix).  So glad to see we're all coding at 3am.
",mattinsler,2011-06-13 06:56:09
61,2011-06-13 07:00:25,"Disregard sleep, support open-source. :-)
",Marak,2011-06-13 06:56:09
61,2011-06-13 07:02:06,"Must not sleep. Must warn others. Trust blocks creep where the dust storm hovers

http://www.youtube.com/watch?v=ENbtvGEwnPo
",indexzero,2011-06-13 06:56:09
61,2011-06-13 07:05:48,"Haha nice.  Never heard of them.
",mattinsler,2011-06-13 06:56:09
61,2011-06-13 20:13:41,"_yawn_ screw open source, gonna support it tomorrow ... zZzzZz ...
",aggsol,2011-06-13 06:56:09
61,2011-06-16 04:13:29,"^ hah
@indexzero - that sounds like an old aesop song, but i haven't heard that one...but he has that quote tattooed on his forearm(s?)
",dtan,2011-06-13 06:56:09
61,2011-06-16 17:54:10,"@dtan Yup It is an old aesop song, It's also what he has tattooed on his forearms: http://lightsleepers.net/wakeup/wp-content/uploads/2009/01/aesoprocktat.jpg
",indexzero,2011-06-13 06:56:09
60,2011-06-10 18:45:21,"Say I have a server at example.com and each time a user signs up I want to spin up a new node process that maps to username.example.com, is there an easy way to add this to the route list if I'm using hostname routing, or will I need to just use the custom logic mode?

I'm thinking it'd be handy to be able to do something like this;

var proxy = httpProxy.createServer(options);
proxy.addHost('username.example.com', '127.0.0.1:9000');
",Qard,2013-03-09 09:20:10
60,2011-06-10 19:33:13,"@qard I think it might make the most sense to use the custom logic mode for now. 

If you do really like this sugar sytnax, I think we would accept a pull request for it. You want to try a few commits to get it started?
",Marak,2013-03-09 09:20:10
60,2011-06-10 20:00:38,"No problem, that'll work for now. I might take a crack at it on the weekend, if I can find the time.
",Qard,2013-03-09 09:20:10
60,2011-06-10 20:02:02,"Cool! Even if you can post an attempt, I'm sure it would help guide the next person who wants to implement this :-)
",Marak,2013-03-09 09:20:10
60,2011-07-18 09:49:07,"Yeah I would also be interested by such a feature, actualy having both addHost and removeHost would make it really easier to adapt this proxy to a changing server environment... Some news about it??
",ghost,2013-03-09 09:20:10
60,2011-07-19 21:15:55,"Agreed, that would rock. I'm gonna see if I can code this now...
",Irrelon,2013-03-09 09:20:10
60,2011-07-25 23:15:02,"I've created a system that allows you to do this now. It uses node-http-proxy and allows on-the-fly updates to the routing table without having to shutdown and restart the service: http://www.isogenicengine.com/2011/07/25/node-js-domain-to-hostport-router/
",Irrelon,2013-03-09 09:20:10
60,2012-02-14 01:39:47,"I submitted a pull request for an attempt following the style you guys were looking for here:

https://github.com/nodejitsu/node-http-proxy/pull/195
",tglines,2013-03-09 09:20:10
59,2011-06-09 15:06:24,"Sample code:

<S_CODE_TOKEN>

Sample request:

<S_CODE_TOKEN>

Request that goes to the server:

<S_CODE_TOKEN>

The server's response for this page looks like this:

<S_CODE_TOKEN>

The response to the client looks identical.  This, unfortunately, breaks the HTTP/1.0 response since now we are both sending an HTTP/1.1 status and we are doing chunked encoding.  The HTTP/1.0 client can't understand this.

The fix:  Make the request to the server an HTTP/1.0 request to mirror the client's desires perfectly.
",fidian,2011-11-17 00:10:27
59,2011-06-11 21:35:00,"@fidian Can you provide a complete repro including the PHP script that I should use to reproduce the issue? 
",indexzero,2011-11-17 00:10:27
59,2011-06-13 14:12:16,"PHP code to make the request:

<S_CODE_TOKEN>

PHP code to handle the request

<S_CODE_TOKEN>

You need to not write out gzipped data and write a large enough amount of data so that PHP will automatically chunk the reply.  The above should do it.
",fidian,2011-11-17 00:10:27
59,2011-06-26 15:16:59,"@fidian here is the simplest repro for this issue:

<S_CODE_TOKEN>

Unfortunately, it seems that this is by design in node.js core. This is the status line written to **every** `ServerResponse` object in core: https://github.com/joyent/node/blob/v0.4.8/lib/http.js#L833-834, which doesn't seem to be configurable anywhere. 

Maybe @ry or @felixge can comment on if outgoing `HTTP/1.0` requests are going to be supported in core.
",indexzero,2011-11-17 00:10:27
59,2011-06-26 19:38:42,"As far as I know node only supports http 1.1, not sure if that is going to change.
",felixge,2011-11-17 00:10:27
59,2011-06-26 19:43:19,"@felixge Thank you for clarifying. I am going to close this as `wont-fix`.
",indexzero,2011-11-17 00:10:27
59,2011-06-26 19:58:55,"You shouldn't send chunked responses to http 1.0 clients - Node should know this. HTTP 1.1 servers are backwards compatible. It certainly _is_ a bug....
",ry,2011-11-17 00:10:27
59,2011-06-26 20:00:20,"> You shouldn't send chunked responses to http 1.0 clients - Node should know this.

That would mean we have to buffer the whole response data for http 1.0 clients, right?
",felixge,2011-11-17 00:10:27
59,2011-06-26 20:07:14,"@ry Thanks. I'll reopen this. I've opened an associated bug on node here: https://github.com/joyent/node/issues/1234
",indexzero,2011-11-17 00:10:27
59,2011-06-26 21:07:33,"@felixge the response can be terminated by closing the connection
",ry,2011-11-17 00:10:27
59,2011-09-15 13:11:29,"I'm sure you're aware of the severity of this bug, but let me emphasize it again. Sending 'Transfer-encoding: chunked' response to clients that are speaking http1.0 effectively means that `node-http-proxy` will not work from behind http1.0 proxies, like squid 2.5.

[Squid website](http://www.squid-cache.org/Intro/) says: 
""Squid is a fully-featured HTTP/1.0 proxy which is almost (but not quite - we're getting there!) HTTP/1.1 compliant.""
",majek,2011-11-17 00:10:27
58,2011-06-08 21:33:43,"as discussed on twitter, it would be very interesting to be able to hack proxied ressources before sending them back to the client.

something like ressource filtering where we'll be able to change the response body/headers

wonder how to integrate this into node http proxy
",vvo,2011-08-03 07:46:04
58,2011-06-08 21:39:57,"I think this may be a related ticket: https://github.com/nodejitsu/node-http-proxy/issues/18

I remember investigating this option a while back, I think one of the main problems is that by introducing the ability to modify the response, you are going to decrease performance for all regular proxy scenarios. I'm sure it could be implemented intelligently, but I'm not sure how. 
",Marak,2011-08-03 07:46:04
58,2011-06-08 21:57:55,"The performance problems would be present of course but they are inevitable
when we want to alter the request. Any thoughts on how to do it without
modifying node http proxy? Buffering the response pethaps ?

Do you think node http proxy is a suitable solution for an app that require
ressource download and alteration ?
",vvo,2011-08-03 07:46:04
58,2011-06-08 22:03:17,"@vvo @marak It depends on the level of introspection into the data stream that you're looking to get. For example, gzip works because afaik it's a binary encoding algorithm and can process the raw stream. Rewriting HTTP headers requires a good HTTPParser like the one ryan wrote. It's really a question of exactly what you're trying to hack in there.

A generic stream rewriter could be possible, but everything would have to be capable of parsing streams.
",indexzero,2011-08-03 07:46:04
58,2011-06-08 22:27:26,"Example filters/tasks :
- adding an external javascript file to the end of the response body
- changing logo.jpg to logo-other.jpg
- modifying cache control header
- ...

There's a reverse http proxy for node with filters : http://www.steve.org.uk/Software/node-reverse-proxy/
",vvo,2011-08-03 07:46:04
58,2011-06-08 22:31:17,"I've looked through that codebase before. It's buffering the entire response into memory before sending it. You shouldn't be doing this unless you really plan on modifying the response object. 

What I'm thinking is that we have an API option for enabling ""middle-wares"" that will cause the proxy to buffer the response in memory. The default API option would be to pipe responses like we do now, which I believe to be much more performant. 
",Marak,2011-08-03 07:46:04
58,2011-06-08 22:42:12,"This option of having middlewares would trully.be awesome. I do understand
that it will kill the performance when used but this would help in some
cases. Like mines :-)
",vvo,2011-08-03 07:46:04
58,2011-06-08 23:25:26,"I will accept a patch for this, but we need to stay focused on performance here. Taking any notable hit on requests / second cannot be allowed.

From an implementation standpoint it would be relatively inexpensive to replace these lines: 

<S_CODE_TOKEN>

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L451-457

And perform a simple check to see if there are any middlewares, and if so write the mutated chunk. Something like:

<S_CODE_TOKEN>
",indexzero,2011-08-03 07:46:04
58,2011-06-28 09:47:58,"Hi, I forked node http proxy and added two events + one option

The readme explains how to use, tell me what do you think :
https://github.com/fasterize/node-http-proxy/blob/master/README.md (bottom of the file)

## Delegate option

The delegate option will give you full control on when is the proxied data written to the client, with this option you'll be able to modify the data before it is proxied to the client

<S_CODE_TOKEN>

This should only work with classic http proxy, didn't test any other cases (https, websockets, forward proxy).
This example is not complete, it will not write non-html content type responses to the client !
",vvo,2011-08-03 07:46:04
58,2011-06-29 17:35:49,"I updated my fork, now I do not construct any buffer into node http proxy, only using custom ""req"" object events.

Constructing a buffer into node http proxy was slowing down the proxy for regular users, now its not

See an example at the bottom of my updated readme : https://github.com/fasterize/node-http-proxy
",vvo,2011-08-03 07:46:04
58,2011-07-18 12:47:25,"Updated the fork, you now have 3 new events on the req object :
- proxiedHeaders -> when proxied request headers are received
- proxiedData -> every time proxied request data is received
- proxiedRequestEnd -> when the proxied request has ended

Theses 3 new events can help you saving the proxied request data.

Also, with the delegate option of the proxy, you'll be able to save the proxied data AND modify it before sending it back to the client.
",vvo,2011-08-03 07:46:04
58,2011-07-25 04:43:49,"Can't wait to try this, right now I am monkey patching _res.write()_

<S_CODE_TOKEN>
",tralamazza,2011-08-03 07:46:04
58,2011-07-25 04:46:33,"I think @dominictarr is close to getting proper middle-wares enabled. Will be reviewing all this in the upcoming weeks.

Thanks!
",Marak,2011-08-03 07:46:04
58,2011-07-25 12:12:28,"see node-http-proxy with connect middle ware support in the middleware branch. In particular see https://github.com/nodejitsu/node-http-proxy/blob/middleware/lib/node-http-proxy.js#L115-235
",dominictarr,2011-08-03 07:46:04
58,2011-07-25 12:14:44,"it supports connect middlewares, and is also backwards compatible with node-http-proxy < 0.6.0
",dominictarr,2011-08-03 07:46:04
58,2011-07-25 12:20:26,"Hello, I've read the code it looks very nice.

Could you provide us an example on how to use ?
In particular, providing a callback AND middleware**s** to createServer. Those seems very close in your branch.

Thank you.
",vvo,2011-08-03 07:46:04
58,2011-07-25 13:06:35,"here:

https://github.com/nodejitsu/node-http-proxy/blob/middleware/examples/gzip-middleware.js

callback works the same as before. put it after the middlewares.

also, creating the proxy with {router: {...}} or port, host will still work, even when using middlewares.
",dominictarr,2011-08-03 07:46:04
58,2011-08-03 05:35:16,"there is a example of modify response using middlewares?
",raphaelcosta,2011-08-03 07:46:04
58,2011-08-03 07:45:43,"yes -- https://github.com/nodejitsu/node-http-proxy/blob/master/examples/jsonp-middleware.js is an example of that.

you will be wanting to have a read through the code of https://github.com/steelThread/connect-jsonp
",dominictarr,2011-08-03 07:46:04
57,2011-05-20 15:21:30,"I am trying to install node http-proxy with the following:

`npm install http-proxy`

But I get the following error:

<S_CODE_TOKEN>

It says that it is unsupported with my version of Node. But I have v0.5.0 installed which is above the necessary v0.4.7.

Please advise.
",ghost,2011-05-20 15:36:49
57,2011-05-20 15:34:14,"http-proxy 0.5.7 is ONLY compatible with node 0.4.7. If you look at the changelog you can see this in the commit messages. https://github.com/nodejitsu/node-http-proxy/commits/master

I'm not the best person to comment on the why it is this way. There is an issue on this here:
https://github.com/nodejitsu/node-http-proxy/issues/48
",johnae,2011-05-20 15:36:49
57,2011-05-20 15:36:48,"It has to do with inconsistencies introduced in the agent APIs. This will stabilize in the next `0.4` release and it can go back to being `>= 0.4.7`
",indexzero,2011-05-20 15:36:49
56,2011-05-19 18:13:02,"I'm not sure if this is the best place, but I wanted to get a dialog going regarding the new branch of http-proxy which is intended to use the net module.

I know that @ry and @mikeal both have a lot of thoughts about this, so if either of you guys feel like bike shedding, please post whatever information you can that could help direct @indexzero and @olauzon 

:-)
",Marak,2011-05-19 18:15:43
56,2011-05-19 18:15:43,"Yes. This is not the correct venue for this. Closing this issue

I have been discussing this in-depth with @mikeal, should have something worth looking at soon.
",indexzero,2011-05-19 18:15:43
55,2011-05-19 11:49:07,"Just a minor nitpick
It seems xhr-multipart (keep-alive chunked) socket.io requests get dropped/killed by node-http-proxy.
Since there are enough other ways to connect, this is not a big issue, but I'm interested into why this happens.

I assume this piece of code is to ""blame"", but I couldn't find much info about keep-alive not being supported by node's http client.

  // Force the `connection` header to be 'close' until
  // node.js core re-implements 'keep-alive'.
  outgoing.headers['connection'] = 'close';

So as stated, not a big issue, just would like to track this so I know when I can enable this transport again.
",bluescreen303,2011-05-23 06:22:09
55,2011-05-19 17:27:44,"I suppose this is a dirty little secret of node.js: https://github.com/joyent/node/blob/v0.4.7/lib/http.js#L1315

The keep-alive support in core written by @mikeal was temporarily disabled when @ry introduced the http.Agent API in 0.3.6+. Hopefully we'll see this back in sometime soon, but until then I don't think that this issue can be resolved. 
",indexzero,2011-05-23 06:22:09
55,2011-05-19 17:30:54,"keep-alive works - set `connection: keep-alive` header - the comment is confusing and regards the default operation.
",ry,2011-05-23 06:22:09
55,2011-05-23 06:22:09,"@bluescreen303 This should be fixed in a86d18bc7f93d013df715d1f4d88e651846f645d and published in `v0.5.9`. Can you confirm?
",indexzero,2011-05-23 06:22:09
55,2011-05-23 09:16:21,"the http proxy process terminates with an exception:

> node.js:134  
>         throw e; // process.nextTick error, or 'error' event on first tick  
>         ^
> TypeError: Cannot call method 'emit' of undefined
>     at Socket.<anonymous> (http.js:1202:9)
>     at Socket.emit (events.js:64:17)
>     at Array.<anonymous> (net.js:828:27)
>     at EventEmitter._tickCallback (node.js:126:26)

I ran a sniffer to find out what happens.
The client requests http-proxy for /socket.io/xhr-multipart/ with connection: keep-alive
The http proxy requests this at the backend (connection:keep-alive)
The backend responds Content-Type: multipart/x-mixed-replace;boundary=""socketio"", Connection: keep-alive
http proxy responds to the client with: content-type: multipart/x-mixed-replace;boundary=""socketio"", connection: keep-alive, Transfer-Encoding: chunked and the first chunk (0 bytes)

So http-proxy switches to chunked encoding, while the backend doesn't.
However, the backend doesn't supply a content length as well.
I was under the impression that http mandates either chunked encoding or a length, but I suppose xhr-multipart is somewhat different, so probably the http client chokes when it receives additional data.

Let me know if I can check anything else for you.
",bluescreen303,2011-05-23 06:22:09
54,2011-05-19 11:17:33,"I would like the proxy headers that are set for normal proxyd requests to appear on websocket requests as well.
- x-forwarded-for
- x-forwarded-port
- x-forwarded-proto

Thanks a lot,
Mathijs
",bluescreen303,2011-06-08 21:46:07
54,2011-06-08 18:24:18,"I believe this issue has been resolved? @bluescreen303 can you confirm? If not, let's get @olauzon on it!

:-)
",Marak,2011-06-08 21:46:07
54,2011-06-08 21:46:07,"fully working, thanks
",bluescreen303,2011-06-08 21:46:07
54,2011-06-08 21:47:35,"Thank you for your feedback! 
",Marak,2011-06-08 21:46:07
53,2011-05-19 06:29:54,"**(Reported by @bluescreen303)**

While you are at it, can you please add the 'x-forwarded-proto' header as well (http, https).
In my case, I let the proxy do ssl, and use plain http backend servers.
This works very well, but my backend servers need to know what urls to generate for internal links.
This header does the trick. I'm not sure if it's standard in any way, but at least rails uses it.

Also, see https://forums.aws.amazon.com/ann.jspa?annID=805 for more information about these headers.
",indexzero,2011-05-19 06:46:46
53,2011-05-19 06:46:46,"Fixed in `v0.5.7`. See 421895fa308d49628bbbb546d542efa96769c3f4 
",indexzero,2011-05-19 06:46:46
52,2011-05-17 19:30:14,"I noticed two things:
- A small syntax error
- Code blocks in the README have two spaces of indentation before them, that gets copied/pasted

I fixed the syntax error in the first commit. For the code blocks, I converted them to the new GitHub format with syntax highlighting. It's not as compatible with other markdown renderers, but I think by far the most common experience will be reading the README on github. It can also be rendered [using open source](https://github.com/tanoku/redcarpet) and I expect that there will be other implementations that support the new syntax.
",benatkin,2011-05-17 20:14:26
51,2011-05-16 03:18:39,"**(Reported by @bluescreen303)**

I noticed x-forwarded-for was set to 'undefined' when proxying https.
It seems someone else was hit by this too.
http://stackoverflow.com/questions/5999379/how-to-find-out-the-remote-address-in-node-js-if-it-is-https-request

I'm not sure if this is a node bug, but as a workaround, would you please change

req.headers['x-forwarded-for'] = req.connection.remoteAddress;

into

req.headers['x-forwarded-for'] = req.connection.remoteAddress || req.connection.socket.remoteAddress;

Or maybe there's some other way around this problem.
",indexzero,2011-05-19 06:28:22
51,2011-05-19 06:28:11,"Fixed in e9b3ec9b1d0ebf427e138176b28af44f0f973670. Will be released in `v0.5.7`
",indexzero,2011-05-19 06:28:22
50,2011-05-12 05:24:06,"I'm not really sure how to explain so
I whipped up some code to demonstrate. 

https://gist.github.com/967964

please run that, then open 3 (console-supporting) browsers at http://localhost:8000
(i hope to find something to simulate in the future)
hit send in each
(you may need to modify node-http-proxy to not change headers)
console will log msgs rcvd from server.

then open 3 more browsers at http://localhost:9000 (no proxy)
hit send in each

notice the output is different.
also, the server output is different.

when proxied, messages are duplicated for client X depending on the number of clients connected after X.
also, connections disconnect after some time when proxied while they remain open indefinitely when not proxied.

<S_CODE_TOKEN>
",jfis,2011-05-18 01:39:02
50,2011-05-12 19:38:58,"The disconnects happen on the heartbeat timeout. Not sure what isn't passed through node-http-proxy yet.

The duplicate messages happen because onUpgrade() gets called every time any client connects which adds duplicate listeners. It seems agent (of _getAgent) is the same object for all connections. onUpgrade is invoked in a listener for the agent 'upgrade' event.
",jfis,2011-05-18 01:39:02
50,2011-05-12 21:04:19,"preventing duplicates by checking whether it already has listeners first seems to fix the disconnects as well. I guess heartbeats were being duplicated but only unique heartbeat numbers get processed. I'm not convinced what I've implemented is the proper solution though.
",jfis,2011-05-18 01:39:02
50,2011-05-13 15:31:48,"Not exactly sure what's going on here, but I'll investigate over the weekend. Thanks.
",indexzero,2011-05-18 01:39:02
50,2011-05-13 17:22:52,"Hi Charlie,

i've tried to reproduce this issue, i got in the console ""Error during WebSocket handshake: origin mismatch: http://localhost:8000 != http://localhost"" 

I guess you need to attach the port in both cases, at line 589 and 590, on your Lib: node-http-proxy.js
or use the remoteHost variable created at line 586.

line 586: remoteHost = options.host + (options.port - 80 === 0 ? '' : ':' + options.port);

line 589:  req.headers.host   = remoteHost;
line 590:  req.headers.origin = 'http://' + options.host; 

line 589:  req.headers.host   = remoteHost;
new line 590: req.headers.origin = 'http://' + remoteHost ; 

i tried this with chrome, it diplays the headers like this bellow
Host: localhost:1800
Origin:http://localhost:1800

i've looked into the code from socket.io, i'm convinced, that this should work after these changes.

regards
",dazagrohovaz,2011-05-18 01:39:02
50,2011-05-13 17:52:34,"Hi, again,

sorry about my stupid anwser, i tried it, and don't work.  :(

but this problem was open at issue https://github.com/nodejitsu/node-http-proxy/issues/34

andyichr commented:
https://github.com/nodejitsu/node-http-proxy/issues/34#issuecomment-1059183

i didn't kill both lines, just line 590, and then works.
- req.headers.origin = 'http://' + options.host;
- //req.headers.origin = 'http://' + options.host;

regards
",dazagrohovaz,2011-05-18 01:39:02
50,2011-05-13 18:17:13,"Feeback:

i tried this with the line 590 commented; after few clicks, i become other error at chrome, i test with both lines commeted, works too, but after few clicks i become an error in node

(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.

13 May 20:08:47 - [ERROR] Trace
Trace:
    at Socket.<anonymous> (events.js:123:17)
    at onUpgrade (/usr/local/lib/node/.npm/http-proxy/0.5.0/package/lib/node-http-proxy.js:570:18)
    at Agent.<anonymous> (/usr/local/lib/node/.npm/http-proxy/0.5.0/package/lib/node-http-proxy.js:610:5)
    at Agent.emit (events.js:81:20)
    at Socket.<anonymous> (http.js:1240:14)
    at Socket._onReadable (net.js:678:27)
    at IOWatcher.onReadable [as callback](net.js:177:10)

regards
",dazagrohovaz,2011-05-18 01:39:02
50,2011-05-13 18:26:48,"thanks for trying this. it didn't work because you got origin mismatch or data messages were not being duplicated?

in the original post i noted that ""(you may need to modify node-http-proxy to not change headers)""
that's if you get the origin mismatch error.
i should have pointed to the issue. 
what i've done is commented out the lines where the headers are changed. (589,590)

i believe this issue is unrelated.
do you have all the same versions?
after getting around the mismatch, and opening > 1 browsers to the proxied path(http://localhost:8000), hit send on the first one(the first client to connect) and the browser console and server console will show this message being duplicated (# of clients times). you should also see the connections drop after ~10secs on a heartbeatTimeout in socket.io.

if you do the same thing but go to the non-proxied path( http://localhost:9000), messages aren't duplicated and connections don't seem to close.

<S_CODE_TOKEN>

agent emits upgrade for each client connection. in onUpgrade, event listeners are added to the socket and remoteSocket. because agent is the same object across clients, this gets called multiple times per client. if there are 2 connections, connection 1 will have 2 listeners for 'data' and will send duplicates to the remoteSocket.

<S_CODE_TOKEN>
",jfis,2011-05-18 01:39:02
50,2011-05-13 18:38:53,"well then you are seeing my issue of duplicate listeners :)
i could not get the same error as you though. my maxListeners must be higher.
this suggests we have different versions.
but the same problem is illustrated nonetheless.
thanks.
",jfis,2011-05-18 01:39:02
50,2011-05-13 19:32:59,"Hi jfis,

i've taked a look again, now i really understood what you mean, ...
the http-proxy send the response to all clients, i think (i didn't tried it), it's because the http.request function preserve opened connections, and interact with the server like a one simple client, like in RFC xxxx (i cann't remenber the number now) about HTTP/1.1 described is. Now when the event onData is called it write this response back to all clients (in theory).

I had similar problems handling with the method CONNECT, with the proxyjs library, but the objective was something else,
would have to be able to add it in the browser configuration as a forward proxy, reverse functions didn't work planed.

sorry, back to the thema... i looked on the code fron http,js (from ry),

the http.request function call the function getAgent into http.js, this function build for each connection an ID (host + port) and make this Agent persistent, in this case all clients call the same host + port connection in node througth the same agent ( returned  fron the request function), if one or more clients (browser) made connections to a server througth the proxy all of them need his own connection from the proxy to the server, the standard HTTP-Server from Node.JS didn't do that, no with the request function, if we didn't create a new agent explicit with, like example ""var myAgent = new http.ClientRequest(options);"", it would never work properly.

Sorry about all that text, i hope you understand where the problem is. if not, just ask.

regards
",dazagrohovaz,2011-05-18 01:39:02
50,2011-05-13 19:42:21,"@dazagrohovaz Yes, I saw it once I realized that the agent has an eventemitter leak. The problem here is that the proper multiplexing of request-response data doesn't seem possible in the current http.Agent API design because there is no way to map the closure scoped data on the `upgrade` event to the incoming http request. 

I am going to start seriously considering looking at using a raw TCP proxy for this with my own instantiated HTTPParser.
",indexzero,2011-05-18 01:39:02
50,2011-05-13 19:55:53,"the http.Agent API implement a request object from http.ClientRequest, and i think this one it's what you need within http-proxy. You need to implement something like the Agent API, and build for each client-->proxy-connection a proxy-->server-connectoin and preserve it into your app. there is a map for the http.ClientRequest API.

http://nodejs.org/docs/v0.4.7/api/http.html#http.ClientRequest

regards
",dazagrohovaz,2011-05-18 01:39:02
50,2011-05-13 19:58:14,"`http.ClientRequest` is deprecated as is `http.Client`. They will be removed in future versions of node.js so we shouldn't rely on them.
",indexzero,2011-05-18 01:39:02
50,2011-05-13 21:56:32,"@dazagrohovaz @jfis Can you take a look at these repros again after my latest commit? I think I've fixed the event emitter leak by managing the containing the request used to the closure scope of the `upgrade` event. It's a little tricky, but I think it will solve some of these problems.

Will still have to look into the origin mismatch problem
",indexzero,2011-05-18 01:39:02
50,2011-05-13 22:36:16,"@indexzero looks good and works for me after getting around the origin mismatch.
very nice.
",jfis,2011-05-18 01:39:02
50,2011-05-13 23:02:47,"w000!!!! Ok, I'm going to make the origin mismatch thing an option and write some more robust tests here. @dazagrohovaz is that map application on your personal site open source? Seems like a great websocket demo to help benchmark / test against node-http-proxy.
",indexzero,2011-05-18 01:39:02
50,2011-05-14 00:37:21,"yes, it is. with some mods, https://github.com/dazagrohovaz/maptail, i don't have commited the changes, but i would do it.
in my version works as module, can be integrated to a http or express server, but require express.
",dazagrohovaz,2011-05-18 01:39:02
50,2011-05-14 00:55:52,"ready... now , you can clone it.

if you want to show the really filename, the line 165 need to be fixed at the index.js file
",dazagrohovaz,2011-05-18 01:39:02
50,2011-05-14 01:30:39,"@dazagrohovaz Thanks! I will try this out later tonight to see if I've fully resolved the issue
",indexzero,2011-05-18 01:39:02
50,2011-05-18 01:39:02,"This should be resolved as of v0.5.3. Let me know if you run into any issues. @dazagrohovaz I couldn't get your maptail working ... if you want to try running your site with node-http-proxy instead of squid that would be appreciated.
",indexzero,2011-05-18 01:39:02
49,2011-05-10 19:09:27,"var httpProxy = require('http-proxy');
var options = {  
        router: {  
                'domain.com/path: '127.0.0.1:3000'
        }  
var proxyServer = httpProxy.createServer(options); 
proxyServer.listen(80);

When now requesting domain.com/path in the browser, the answer is 127.0.0.1:3000/path but should be 127.0.0.1:3000/ instead
",PaulFreund,2011-05-11 18:49:06
49,2011-05-10 19:10:34,"I think this issue _might_ be related to https://github.com/nodejitsu/node-http-proxy/issues/34
",Marak,2011-05-11 18:49:06
49,2011-05-10 21:22:12,"I'm not sure these two things are related. @BigWookie can you elaborate a little more on what you mean by _""the answer is 127.0.0.1:3000/path""_. Do you mean the URL bar in the browser reflects this? Or that the HTTP Host header reflects this? 
",indexzero,2011-05-11 18:49:06
49,2011-05-11 07:47:53,"http-proxy requests host and port from the destination in the table but the path from the request, but it shouldn't.

I tried to fix this, but I didn't had the time to dive into it.
What I found out:
In /lib/node-http-proxy.js in line 315 you get the location from the routing table,
in /lib/proxy-table.js from line 127 to line 145 you check the request against the routing table and return host and port,
but the path (for example path = match['input'].substring(match[0].length, match['input'].length) ) is important too.
In node-http-proxy.js in line 379 you use req.url, and that includes the path from the original request from the browser, the path extracted in proxy-table would be more convenient for me.

Thats how I understand the problem, maybe I'm wrong, from here I didn't get further because just using the path instead of the req.url produced several other issues, and I don't have more time to spend on this.

Hope it helps :)
",PaulFreund,2011-05-11 18:49:06
49,2011-05-11 18:14:52,"I can confirm that it does preserve what the original req.url is. 
ie 'foo.com/baz' -> '127.0.0.1:8001/baz' in the example on the readme (not '127.0.0.1:8001')
also 'foo.com/baz/whatever/else/there/is' -> '127.0.0.1:8001/baz/whatever/else/there/is' (not '127.0.0.1:8001/whatever/else/there/is)

I think this is intentional.

From the readme

<S_CODE_TOKEN>

I can see how one might interpret that in different ways. 
",jfis,2011-05-11 18:49:06
49,2011-05-11 18:49:06,"Okay, thought this would proxy the whole path, readme was a bit missleading. :) Sorry for bothering
",PaulFreund,2011-05-11 18:49:06
49,2011-05-11 18:57:00,"You could redirect/rewrite the url on the destination/target server to whatever you want. If '/path' is not unique for whatever reason, I think you could check x-forwarded-for header to distinguish.
",jfis,2011-05-11 18:49:06
48,2011-05-10 17:46:56,"I'm running into issues that seem like a problem with just my system but I was hoping to find some assistance.

<S_CODE_TOKEN>

When I run 

<S_CODE_TOKEN>

all tests fail that are not expecting a 404 or 500.

The errors look like this:

<S_CODE_TOKEN>

Anyone seen this before? Seems like I'm missing something important. There is very little information on ECONNREFUSED. I do know that the error happens on making the request from proxy to target using the 'request' module (which is expected given the error) but I can't determine why. I'm hoping there's something simple I missed.
",jfis,2011-05-10 22:31:36
48,2011-05-10 18:08:02,"ECONNREFUSED is a generic node.js error message when a socket cannot make a connection. It usually indicates that the listening server isn't infact listening, or the outgoing request you made to the server could not find its target. 

With that being said, I'm not entirely sure what your issue is. Could it be possible you are already running services on the port http-proxy is trying to use for it's tests? Maybe you could change the port number in the test files?

@indexzero - Do you have any ideas why this could be happening? 
",Marak,2011-05-10 22:31:36
48,2011-05-10 18:27:16,"Thanks for the response. The ports are already varied so every test shouldn't fail if it had to do with port. I took a shot anyway and I did mix them up but no change.

To add to this mystery... I get the exact same results on my ubuntu 10.10 vps with the same node, npm, and module versions.
",jfis,2011-05-10 22:31:36
48,2011-05-10 18:58:36,"What versions of node and npm are you running? 
",indexzero,2011-05-10 22:31:36
48,2011-05-10 19:00:27,"I just ran the test suite locally on my machine, and I can confirm I am seeing the same errors in the test suite. Right now I'm going to assume that it's a regression from an update to node.js core. 

I'm in SF until the weekend, so I may not have time to properly address this until Monday. 
",indexzero,2011-05-10 22:31:36
48,2011-05-10 19:05:44,"No worries on time table.
I'm just glad someone else can replicate.

I see I forgot npm in the original.

<S_CODE_TOKEN>
",jfis,2011-05-10 22:31:36
48,2011-05-10 21:24:40,"I tried to reverting back to node `v0.4.6` and I got the same results. I'm on HEAD right now though, so I'm going to revert back to individual commits until this is passing. I always ensure the entire test suite passes before any release so it's strange that this regression popped up here on a stable tag
",indexzero,2011-05-10 22:31:36
48,2011-05-10 21:29:40,"I can confirm that on `v0.4.6` the following commit passes all HTTP tests: ddf31b22ec71ef9dacca9c178ee26b6314d9fdf4. I'm upgrading back to `v0.4.7` to test this as well now. This may be a bad rebase in node.js core because the only difference here is the underlying agent API change from this pull request: https://github.com/nodejitsu/node-http-proxy/pull/39
",indexzero,2011-05-10 22:31:36
48,2011-05-10 21:40:39,"{protocol}.getAgent() method signature
http://nodejs.org/docs/v0.4.7/api/http.html#http.getAgent
(I don't see getAgent for https in the docs?)

If I change these lines in node-http-proxy.js:

<S_CODE_TOKEN>

Everything seems to work then.

Then I found this haha 
https://github.com/joyent/node/issues/943
",jfis,2011-05-10 22:31:36
48,2011-05-10 21:52:48,"And there's already a pull request

https://github.com/nodejitsu/node-http-proxy/pull/45
",jfis,2011-05-10 22:31:36
48,2011-05-10 22:05:58,"Something is wrong in core. The method signature you suggest is not the correct method signature. This may be the result of a bad rebase on behalf of @ry. 

In `master` both `https.js` and `http.js` indicate that both `.getAgent()` methods take an options hash, not a `host, port` pair, but in `v0.4.7` it is still inconsistent. However, there is a commit from @mikeal rebased into _February_ that actually fixes this. 

_Old commit that fixes this_
https://github.com/joyent/node/commit/2b03ba59177fee8ad28b5be0bebd149b06f3c2a2#lib/http.js

_v0.4.7_
`https.js`: https://github.com/joyent/node/blob/v0.4.7/lib/https.js#L70
`http.js`: https://github.com/joyent/node/blob/v0.4.7/lib/http.js#L1408

_master_
`http.js`: https://github.com/joyent/node/blob/master/lib/http.js#L1418
`https.js`: https://github.com/joyent/node/blob/master/lib/https.js#L80

I would like to suggest a hotfix release for nodejs as `v0.4.7-1` or `v0.4.8` to resolve this inconsistency. If that's not a good plan I can always just revert node-http-proxy to the original code under v0.5.0 that works around this inconsistency.

This issue should also be closed: https://github.com/joyent/node/issues/943 and is discussed more: https://github.com/nodejitsu/node-http-proxy/issues/38
",indexzero,2011-05-10 22:31:36
48,2011-05-10 22:31:36,"Yea I meant that signature only for comparison. It's what will work with 0.4.7.
Options hash makes more sense.

I agree that node-http-proxy should not be modified.

It's just good to know about this incompatibility if others have issues.

Thanks all.
",jfis,2011-05-10 22:31:36
48,2011-05-10 22:32:56,"I reverted 642e15805dbd572835bb4fee9527e4f2da658833 in 40dc9dee2d1e617af7f85a056d281b4f220f2802 and rolled this up into 0.5.1. Confirmed all tests passing on node `v0.4.7`. I will address the above discussion when the next version of node is released.
",indexzero,2011-05-10 22:31:36
48,2011-05-10 22:33:11,"the fix only went in to master, not in to 0.4.x, because while this is a ""bug"" the fix for the bug makes 0.4.future not forward compatible.
",mikeal,2011-05-10 22:31:36
48,2011-05-10 22:35:01,"@mikeal Thanks for clarifying. In master now there is a backwards compatible change that checks the type of the arguments passed to `.getAgent()`. Would love to see a hotfix version pushed out from @ry, but now that I've reverted it's not a big deal. 
",indexzero,2011-05-10 22:31:36
47,2011-05-05 11:42:09,"error in chrome:
Error during WebSocket handshake: origin mismatch : http://outside.host != http://localhost
the websocket reverse proxy doesn't seem to do its job completely.
It does proxy the handshake to the desired port and host (localhost), but the answer comes back with the back-end host instead of the origin.
In case of an extra proxy outside.host in front of the http-proxy, this makes the websocket connections fail
(unless a trick is applied with /etc/hosts to make to map outside.host to localhost).
http-proxy version 0.5.0, node version 0.4.6
Tested in chrome.
",elisehuard,2011-05-18 01:41:02
47,2011-05-05 15:49:54,"Perhaps related to this thread: https://github.com/nodejitsu/node-http-proxy/issues/34
I'd be interested to hear if it works after commenting out the 'change header' lines described.
",jfis,2011-05-18 01:41:02
47,2011-05-18 01:40:23,"This should be resolved in v0.5.3.
",indexzero,2011-05-18 01:41:02
46,2011-05-01 04:25:52,"Hi,

Right now, if the proxy request produces and error, a JSON stack trace is written out. 

This patch adds the ability to completely customize this behavior by listening for a `proxyError` event. Otherwise, if `NODE_ENV=production`, the string ""Internal Server Error"" is written instead of a stack trace. This in-production default behavior mimics Express/Connect. Otherwise, the stack trace is still printed out.

If this implementation isn't suitable, some way to prevent a stack trace in production would be nice.

Best wishes,

-Ben
",weaver,2011-05-19 05:38:26
46,2011-05-01 04:29:57,"I'm in Portland this week at JSConf / NodeConf, but I will try to take get this merged in. They look good.
",indexzero,2011-05-19 05:38:26
46,2011-05-01 04:31:51,"OK, I just realized this pull request included the other one. I just separated them, but would you prefer them together? Thanks!
",weaver,2011-05-19 05:38:26
46,2011-05-19 05:38:50,"Had to merge this manually because of conflicts with the http.Agent APIs covered in issue #48. Thanks!
",indexzero,2011-05-19 05:38:26
46,2011-06-15 13:05:47,"Hi, can you provide an example of the proxyError listener? My simple listener does not seem to get fired. If i proxy to an unreachable target, I get the following:

<S_CODE_TOKEN>

my code snippet:

<S_CODE_TOKEN>

Best regards, Janne
",xulfus,2011-05-19 05:38:26
46,2011-06-15 13:43:17,"Sure, just added a sample to illustrate this: https://github.com/nodejitsu/node-http-proxy/commit/4cdbf0e8729a0665904b577376240c00e56ad876
",indexzero,2011-05-19 05:38:26
46,2011-06-15 13:59:58,"ahh, of course, server.proxy.on(). Thanks a lot!
",xulfus,2011-05-19 05:38:26
45,2011-05-01 04:08:21,"Hi,

The `_getAgent()` method is currently passing an options object to `getAgent`, but the signature of that function is `function (host, port)`. This causes some strange behavior for me. This small patch fixes the problem. Tested against Node 0.4.4 and 0.4.7.

Thanks!
",weaver,2011-05-10 22:23:05
45,2011-05-10 22:23:05,"I'm going to drop this request. See the discussion here: https://github.com/nodejitsu/node-http-proxy/issues/48#issuecomment-1133833

Has to do with inconsistencies in node.js core currently. When v0.4.8 drops, the code as it stands now will work. 

I'm going to push a revert commit now and push out v0.5.1
",indexzero,2011-05-10 22:23:05
44,2011-04-29 20:11:05,"But can you load balance the same hostheader name to different ports on different machines.
The Tables feature does not support this i think from reading of example.

Also would be create to support sticky and round robin patterns as default ones.
Round robin can use pinging to the web servers to determine the load and they can return a number between 1 and 100 to tell the load balancer their load indication.
",ghost,2011-04-29 20:21:07
44,2011-04-29 20:21:07,"`node-http-proxy` is not intended to be a load balancing library. This issue has come up before and my stance remains the same: if you would like to startup a load-balancer library which uses `node-http-proxy` I would be happy to contribute, but right now that does not align with the goals of the project which is to implement a fast RFC2616 compliant reverse proxy in node.js

Setting up a simple round-robin proxy is quite easy. Here's an example I made a while back: https://gist.github.com/869781
",indexzero,2011-04-29 20:21:07
44,2011-04-29 20:25:49,"fair enough.

I think i will use your script for now, and if i need more than look
into another project on top of yours.

You have made a ton of nodejs projects. Looks like everything i need
is there. thanks :)

ged

On 29 April 2011 22:21, indexzero
reply@reply.github.com
wrote:

> `node-http-proxy` is not intended to be a load balancing library. This issue has come up before and my stance remains the same: if you would like to startup a load-balancer library which uses `node-http-proxy` I would be happy to contribute, but right now that does not align with the goals of the project which is to implement a fast RFC2616 compliant reverse proxy in node.js
> 
> Setting up a simple round-robin proxy is quite easy. Here's an example I made a while back: https://gist.github.com/869781
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/44#comment_1077081
",ghost,2011-04-29 20:21:07
44,2011-04-30 01:37:35,":-D
",Marak,2011-04-29 20:21:07
43,2011-04-27 18:33:32,"Hi, I come across this error when stress test node-http-proxy, using basic-proxy-https script.js

The test is based on a simple python script that use wget:
# !/usr/local/bin/python

import os,signal,sys

count = 0
while(count < 1000):
    os.system(""wget --no-check-certificate --secure-protocol=SSLv3 --spider 'https://172.168.1\
.19:8081/'"");

node proxy will run for a while then will shutdown with error:

net.js:825
    close(this.fd);
    ^
Error: ECONNRESET, Connection reset by peer
    at Socket.destroy (net.js:825:5)
    at Socket._onReadable (net.js:652:30)
    at IOWatcher.onReadable [as callback](net.js:177:10)
",leebhm,2011-05-19 06:04:57
43,2011-04-27 20:53:08,"I believe this to be a separate (but related) issue around HTTPS in node.js core. See: https://github.com/nodejitsu/node-http-proxy/issues/36
",indexzero,2011-05-19 06:04:57
43,2011-05-19 06:04:57,"This is resolved as of `v0.5.6`. Check the updated documentation for how to proxy HTTPS --> HTTP vs. HTTPS --> HTTPS. I have tried the following python script (a modified version of what you supplied) with these two target example scripts:

<S_CODE_TOKEN>

<S_CODE_TOKEN>

<S_CODE_TOKEN>

In both cases the node process never ends. We've been making a lot of improvements to HTTPS support (both standard HTTP and WebSockets) to node-http-proxy in the last several patch releases. Can you try updating to `v0.5.6` and confirm? Thanks!
",indexzero,2011-05-19 06:04:57
42,2011-04-27 14:32:34,"Hi, I'm using faye to broadcast realtime messages, but using node-http-proxy I receive this error:

<S_CODE_TOKEN>

And in chrome console I see `POST http://nodelytics.strx.int/faye undefined`

My proxy configuration in simple

<S_CODE_TOKEN>

I'm not sure, but seams to happen when client side code tries to connect to websocket

<S_CODE_TOKEN>

Can you help me? Thanks
",straps,2011-05-17 22:34:09
42,2011-04-27 14:38:10,"Would it be possible for you to upgrade to v0.5.0?

There have been some major changes since the v0.4.0 branch. 

http://blog.nodejitsu.com/updating-node-http-proxy 
",Marak,2011-05-17 22:34:09
42,2011-04-27 19:30:30,"Updated, now the error is:

<S_CODE_TOKEN>
",straps,2011-05-17 22:34:09
42,2011-04-27 20:59:41,"I will investigate soon. Quite busy leading up to JSConf / NodeConf next week though, might not have time to get to this until after that.
",indexzero,2011-05-17 22:34:09
42,2011-04-28 02:16:49,"@straps isn't that a warning and not an error?

Either way, now that you have updated, can you try running http-proxy's unit tests?
",Marak,2011-05-17 22:34:09
42,2011-04-28 06:05:42,"`vows test/*-test.js --spec` returns (entire output omitted):

<S_CODE_TOKEN>

`vows test/*-test.js --spec --https` returns:

<S_CODE_TOKEN>
",straps,2011-05-17 22:34:09
42,2011-05-17 22:34:09,"This was actually not related to node.js core, but a typo in my test code. Thanks to @olauzon for finding this problem and fixing it in 1ee6beff6aa3087e332701fd3cfda70b4e968ce8. Will be pushed out in `v0.5.2`
",indexzero,2011-05-17 22:34:09
42,2011-05-18 15:00:53,"Thanks, I will try
",straps,2011-05-17 22:34:09
41,2011-04-27 00:06:15,"**Remark: Extrapolated from the nodejs-dev mailing list _(thanks fidian)_**

I have updated the proxy code.  Here's the newer invocation:

`require('http-proxy').createServer(8002, 'localhost').listen(8001);`

I have tried the following scenarios:
- GET without Connection: close = success
- GET with Connection: close = success
- POST without Connection: close = success
- POST with Connection: close = FAIL

I have a logging TCP proxy both on the incoming and outgoing sides of
this proxy to see what's sent and received.  It is identical to what I
saw when my older code was using sys.puts().  I see that the server is
indeed sending a response and that the JS proxy is not relaying that
information to the client.  The time stamps indicate that the
connection is actually closed before the connection to the destination
server is made.  Incoming:

-------- CLIENT TO PROXY START --------
[00:00.000 - client 127.0.0.1:35062 forwarded to :8001]
POST /test.php?postclosed HTTP/1.1
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 47
Connection: close
Host: censored.com

AUTHTOKEN=FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF

[00:00.001 - server connected]
[00:00.002 - server closed]
-------- CLIENT TO PROXY END --------

And here's what's logged on the other side:

-------- PROXY TO SERVER START --------
[00:00.000 - client 127.0.0.1:33945 forwarded to devweb1:81]
POST /test.php?postclosed HTTP/1.1
content-type: application/x-www-form-urlencoded; charset=utf-8
content-length: 47
connection: close
host: censored.com
x-forwarded-for: 127.0.0.1

AUTHTOKEN=FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF
[00:00.036 - server connected]
HTTP/1.1 200 OK
Date: Tue, 26 Apr 2011 16:35:00 GMT
Server: Apache/2.2.14 (Fedora)
X-Powered-By: PHP/5.3.3
Content-Length: 503
Connection: close
Content-Type: text/html; charset=UTF-8

{ ... hundreds of bytes of JSON data removed ... }
[00:00.079 - server closed]
-------- PROXY TO SERVER END --------
",indexzero,2013-03-09 06:28:06
41,2011-06-08 18:24:53,"@indexzero is this ticket still relevant? If so, should we get @olauzon to investigate? 
",Marak,2013-03-09 06:28:06
41,2011-06-08 18:57:18,"@marak I have not investigated it at all, so it would be good to at least confirm it is no longer an issue.
",indexzero,2013-03-09 06:28:06
41,2011-06-09 15:02:14,"It is still an issue, but not related to the proxy.  See https://github.com/joyent/node/issues/1165
",fidian,2013-03-09 06:28:06
41,2011-06-11 21:34:13,"@fidian Do you know if there is a workaround for the node core issue that we could use in `node-http-proxy`? 
",indexzero,2013-03-09 06:28:06
41,2011-06-13 14:06:58,"Please see the bug report for node for all that I have figured out.  https://github.com/joyent/node/issues/1165
",fidian,2013-03-09 06:28:06
41,2012-04-07 01:28:24,"It looks like this has been fixed. See https://github.com/joyent/http-parser/pull/83.
",coderarity,2013-03-09 06:28:06
41,2012-04-14 14:08:03,"I wrote an entirely node-based sample script to illustrate the problem and posted it on the node-http issue that was already opened.  Unfortunately, that issue has already been marked as closed and I can't reopen it.

https://github.com/joyent/http-parser/issues/47
",fidian,2013-03-09 06:28:06
41,2012-04-14 21:23:38,"This will be fixed in v0.6.16. Node v0.7.4 and newer already contain the fix from joyent/http-parser#83.
",bnoordhuis,2013-03-09 06:28:06
41,2013-03-09 06:28:06,"This is fixed in node core.
",indexzero,2013-03-09 06:28:06
40,2011-04-26 21:34:00,"I am working with a system that is very sensitive, against the standards, to the case of headers that are passed back to it.  The current code in node-http-proxy takes all of the headers (ie. ""Content-Type"") and converts them to lower case.  I know that the client is behaving badly here but it would be nice to have this configurable.  I will see if I can code this up and send a pull request.

In the meantime, is there a way to disable this behavior?
",timmattison,2011-04-26 22:03:24
40,2011-04-26 21:35:26,"I believe that this is the behavior of node.js core itself, so probably not. 
",indexzero,2011-04-26 22:03:24
40,2011-04-26 21:54:17,"Bummer.  Can I intercept the responses before the client sees them and ""fix"" them by hand or are you saying that even if I do that that node.js will do what it wants?
",timmattison,2011-04-26 22:03:24
40,2011-04-26 22:03:24,"I would post to the node.js list about this. I'm not entirely sure. I've never encountered a case-sensitive HTTP parser.
",indexzero,2011-04-26 22:03:24
40,2012-08-15 04:30:56,"I did this to make the headers more aesthetically pleasing.  I agree it's unnecessary though.

<S_CODE_TOKEN>

Then I just apply the monkey patch inline:

<S_CODE_TOKEN>

I'm pretty sure the original header names are available in the response though, to do this without the gsub.  I'll have a look.
",d11wtq,2011-04-26 22:03:24
40,2016-06-13 19:54:59,"Is there a way to 'fix' headers on a proxyReq event? I have the same problem where the server I am connecting to cares about the case sensitivity of the headers so need to correct node's tampering.

@d11wtq did you ever find out where the original header names were store? It would be good if I could get node-http-proxy to forward the original case-preserved headers rather than it using the lower-cased versions from node.
",djskinner,2011-04-26 22:03:24
40,2016-06-13 22:09:11,"For anyone who comes across this thread as I did, I created a fork that forwards on the raw headers to the target rather than the ones that node has modified.

https://github.com/djskinner/node-http-proxy/commit/8a7b44b5e8cbb9f11e0c773fb069d3ab53b82cd6
",djskinner,2011-04-26 22:03:24
40,2016-12-13 08:40:47,djskinners modification should be applied when <S_CODE_TOKEN> is set to <S_CODE_TOKEN>,mixxen,2011-04-26 22:03:24
39,2011-04-26 16:33:46,"My installation doesn't like the parameters passed as ""http, port"" to getAgent.  I think instanceof may want these variables to be instantiated with the String constructor according to some JavaScript documentation found online but I'm not sure.

In this patch all I did was create an options object and used it in both the HTTP and HTTPS constructors.  After that the examples work again.
",timmattison,2011-04-26 21:20:54
38,2011-04-26 15:11:06,"I'm new to http-proxy but after running the example here:

https://github.com/nodejitsu/node-http-proxy/blob/v0.5.0/examples/basic-proxy.js

With some modifications (changed path of http-proxy to work in my environment) it starts but immediately throws an exception when the first client tries to connect.  Is there additional setup I need to do to get it running?  I am running node v0.5.0-pre according to ""node --version"" and just pulled http-agent from npm today (2011, April 26th).

Here is the full exception:

<pre>http.js:1446
    throw new TypeError('Invalid argument to getAgent');
          ^
TypeError: Invalid argument to getAgent
    at Object.getAgent (http.js:1446:11)
    at _getAgent (/home/tim/local/node/lib/node/.npm/http-proxy/0.5.0/package/lib/node-http-proxy.js:48:30)
    at [object Object].proxyRequest (/home/tim/local/node/lib/node/.npm/http-proxy/0.5.0/package/lib/node-http-proxy.js:377:12)
    at Server.<anonymous> (/home/tim/local/node/lib/node/.npm/http-proxy/0.5.0/package/lib/node-http-proxy.js:146:13)
    at Server.emit (events.js:67:17)
    at HTTPParser.onIncoming (http.js:1109:12)
    at HTTPParser.onHeadersComplete (http.js:108:31)
    at Socket.ondata (http.js:1008:22)
    at Socket._onReadable (net.js:682:27)
    at IOWatcher.onReadable [as callback] (net.js:177:10)</pre>
",timmattison,2011-04-26 16:34:09
38,2011-04-26 15:37:49,"My testing shows this example does work in version 0.3.1 but not 0.4.1, 0.4.2, or 0.5.0.
",timmattison,2011-04-26 16:34:09
38,2011-04-26 16:34:09,"See https://github.com/nodejitsu/node-http-proxy/pull/39 for potential resolution
",timmattison,2011-04-26 16:34:09
38,2011-04-26 21:20:13,"I will roll this into `v0.5.1`. This code was a workaround for a small bug in node.js core that @mikeal fixed this here https://github.com/joyent/node/commit/2b03ba59177fee8ad28b5be0bebd149b06f3c2a2#lib/http.js 

Although this commit claims it was made in February, when I released `0.5.0` it was not in the node.js source. Rebased perhaps? 
",indexzero,2011-04-26 16:34:09
38,2011-04-26 21:21:28,"Uh oh, looks like the clock on my VM may be off.  This could be bad...

Thanks for letting me know!

Tim

On 4/26/2011 5:20 PM, indexzero wrote:

> I will roll this into `v0.5.1`. This code was a workaround for a small bug in node.js core that @mikeal fixed this here https://github.com/joyent/node/commit/2b03ba59177fee8ad28b5be0bebd149b06f3c2a2#lib/http.js
> 
> Although this commit claims it was made in February, when I released `0.5.0` it was not in the node.js source. Rebased perhaps?
",timmattison,2011-04-26 16:34:09
38,2011-04-26 21:22:26,"yeah, this was just a few weeks ago, i don't know why it has that date on it.
",mikeal,2011-04-26 16:34:09
38,2011-04-26 21:23:44,"Oh, I thought you meant my commit.

Mine should be:
Date:   Tue Apr 26 12:27:24 2011 -0400

Not sure why that other one would have a strange date.

Tim

On 4/26/2011 5:22 PM, mikeal wrote:

> yeah, this was just a few weeks ago, i don't know why it has that date on it.
",timmattison,2011-04-26 16:34:09
38,2011-04-26 21:24:54,"THEN THE KILLER INTERACTIVELY REBASED THE COMMIT HISTORY
",indexzero,2011-04-26 16:34:09
38,2011-04-26 21:25:13,"i think i know what happened.
i wrote this patch for v0.4.x, but it's not forward compatible with earlier 0.4.x releases so Ryan rolled it in to master, it probably conflicted and so he rebased.
",mikeal,2011-04-26 16:34:09
38,2011-04-26 21:26:30,"I figured something like that. Not a problem. I'll make sure to put `>= node 0.4.7` on the requirements for `node-http-proxy >= 0.5.1`
",indexzero,2011-04-26 16:34:09
38,2011-05-22 17:21:30,"I just made a clean npm install node-http-proxy, and I am using node0.5.0pre. I get the same error, I thought this was resolved long time ago?

http.js:1455
    throw new TypeError('Invalid argument to getAgent');
          ^
TypeError: Invalid argument to getAgent
    at Object.getAgent (http.js:1455:11)
    at _getAgent (/home/ubuntu/server/js/server/node_modules/http-proxy/lib/node-http-proxy.js:48:30)
    at [object Object].proxyRequest (/home/ubuntu/server/js/server/node_modules/http-proxy/lib/node-http-proxy.js:410:12)
    at Server.<anonymous> (/home/ubuntu/server/js/server/node_modules/http-proxy/lib/node-http-proxy.js:155:13)
    at Server.emit (events.js:67:17)
    at HTTPParser.onIncoming (http.js:1119:12)
    at HTTPParser.onHeadersComplete (http.js:108:31)
    at Socket.ondata (http.js:1018:22)
    at Socket._onReadable (net.js:684:27)
    at IOWatcher.onReadable [as callback](net.js:177:10)
",manast,2011-04-26 16:34:09
38,2011-05-22 18:55:53,"This seems to be something (still) going on in Node.js core. The code in questions claims that it is backwards compatible: https://github.com/joyent/node/blob/master/lib/http.js#L1427

Perhaps @ry or @mikeal could shed some light on why this is popping up again. Host is still being passed as a string in node-http-proxy (i.e. ""legacy"" arguments) https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L48

I think that this may be a bug in core related to `options instanceof String`. This syntax doesn't seem to be the correct way to identify the type of the argument. Here's a quick sample from the REPL:

<S_CODE_TOKEN>

Should be a quick fix. Reasonbly sure this has nothing to do with node-http-proxy.
",indexzero,2011-04-26 16:34:09
37,2011-04-24 19:36:51,"I'm trying to remove the www. requests to point them to the canonical non www. urls. This is the make sure copy pasted urls point to one domain and thus not divide up my Google Page Rank juice across the two domains.
",emotely,2015-10-30 20:41:06
37,2011-04-24 19:43:50,"node-http-proxy doesn't support 301 redirects yet, but I will leave this issue as this is something we want to address in future versions.
",indexzero,2015-10-30 20:41:06
37,2011-04-24 19:47:29,"Thanks for the quick answer. I guess I could put the redirect logic into the actual server that the domain is served on. I'll post my solution to that when I get it working. It will help those that have the same issue.
",emotely,2015-10-30 20:41:06
37,2011-04-28 04:59:00,"For reference here's the solution I ended up using. Note: I'm using express so it's express specific code:

<S_CODE_TOKEN>
",francoislaberge,2015-10-30 20:41:06
37,2012-01-17 16:14:07,"But what happens if i don't know the URL redirect? thanks
",yesidiaz,2015-10-30 20:41:06
37,2012-02-07 22:42:05,"Now http-proxy supports connect middleware you can use no-www

var http = require('http'),
    httpProxy = require('http-proxy');

var options = {
    hostnameOnly: true,
    router: {
        'example.com': '127.0.0.1:8001'
    }
}

var proxyServer = httpProxy.createServer(
    require('connect-no-www')(false),
    options
);

proxyServer.listen(80);
",DaleJefferson,2015-10-30 20:41:06
37,2013-02-21 17:50:47,"I got this working, here's my code, inserted in the middle of the boilerplate http+websockets example:
https://gist.github.com/konklone/5006662
",konklone,2015-10-30 20:41:06
37,2014-06-18 21:47:40,"here's a generic one - modified from @francoislaberge example - I use as the first piece of middleware in my express app:

<S_CODE_TOKEN>

You could reverse it just as easily making sure that host always starts with `www.`
",pajtai,2015-10-30 20:41:06
37,2014-08-18 19:54:38,"Http-proxy doesn't still support 301 Redirects??
So...this code won't redirect to Google, really??

var url = require(""url"")
var http = require(""http"")
var httpProxy = require(""http-proxy"")
var proxy = httpProxy.createProxyServer()
http.createServer(function(req, res) {
    proxy.web(req, res, { target: ""http://www.google.com"", headers: { host: ""www.google.com""} })
}).listen(4000) 

I don't find very useful a proxy like this, sincerely.
But thanks for your work
",q2dg,2015-10-30 20:41:06
37,2014-08-18 20:31:11,"@q2dg i think you are mistaking terminology. Your code correctly proxies any request to the server to google.com. This is not the same as redirecting to google as the traffic is still going through your server.
",jcrugzz,2015-10-30 20:41:06
37,2014-08-18 23:49:16,"Well, maybe I haven't stated the problem incorrectly, sorry.

If you try my above code (having configured proxy settings in a browser pointing to it) you will see it doesn't work: browser shows a ""restarted connection"" error. But if you change ""www.google.com"" by another URL which doesn't suffer from redirection (for instance, ""www.linux.com""), it does work (withouth changing browser's direction bar, but it doesn't matter). At least, this is what happens in Spain, where ""www.google.com"" is automatically redirected to ""www.google.es"". 

It's the only explanation I have: http-proxy doesn't handle 3xx responses, like official http.get() method either. But, of course, I can be wrong.
",q2dg,2015-10-30 20:41:06
37,2014-08-19 02:49:29,"@q2dg ok well this does seem plausible. This is something that should be handled in some manner. If you can come up with a good failing test case (integrated into the actual tests) I can take a stab at implementing it
",jcrugzz,2015-10-30 20:41:06
37,2014-08-21 23:53:31,"Ok, I will try. Thanks!!
",q2dg,2015-10-30 20:41:06
37,2014-10-30 05:51:34,"+1 to add redirection support. We could have the following simple format to indicate whether the request should be redirected to proxies.

<S_CODE_TOKEN>

If the http-proxy notices the `redirect_host` property, then it will redirect instead of proxying.
",kadishmal,2015-10-30 20:41:06
37,2014-10-30 06:55:46,"I think this is scope of a different project. In fact `http-master` is a module which tries to do intelligent things around the `http-proxy`, including redirects and serving a static file directory.
",Rush,2015-10-30 20:41:06
37,2014-10-30 07:17:57,"I have just implemented the redirection as follows without changing a code in http-proxy.

<S_CODE_TOKEN>

Then in the `app.js` code I have the following:

<S_CODE_TOKEN>

Comments are welcome.
",kadishmal,2015-10-30 20:41:06
37,2015-10-30 20:41:06,"This should technically be supported with https://github.com/nodejitsu/node-http-proxy/blob/master/lib/http-proxy/passes/web-outgoing.js#L49-L70. If not please open a new issue.
",jcrugzz,2015-10-30 20:41:06
36,2011-04-23 14:14:17,"I'm getting this error when using https:

An error has occurred: {""stack"":""Error: socket hang up\n    at CleartextStream.<anonymous> (http.js:1272:45)\n    at CleartextStream.emit (events.js:61:17)\n    at Array.0 (tls.js:617:22)\n    at EventEmitter._tickCallback (node.js:126:26)"",""message"":""socket hang up""}

When running http it all works just fine.

Someone else has recently had a similar problem and was able to solve it (not sure if this would apply here though):

http://stackoverflow.com/questions/5680543/nodejs-https-request-for-oauth2-token-google-facebook-produce-error-socket-ha
",johnae,2011-05-19 01:14:21
36,2011-04-23 14:16:49,"Would you mine letting me know which version of node you are running? Also, could you run the test suite and confirm all tests are passing?
",Marak,2011-05-19 01:14:21
36,2011-04-23 14:22:47,"Yep I'm running latest nodejs (0.4.7). Running vows test/*-test.js --spec --https fails. 8 specs are broken. Those are:

‚ô¢ node-http-proxy/https

  When using server created by httpProxy.createServer() with latency and without a valid target server
    ‚úó should receive 500 responseCode
      ¬ª expected null, got {
    stack: 'Error: socket hang up\n    at Socket.<anonymous> (http.js:1272:45)\n    at Socket.emit (events.js:64:17)\n    at Array.2 (net.js:829:12)\n    at EventEmitter._tickCallback (node.js:126:26)',
    arguments: undefined,
    type: undefined,
    message: 'socket hang up'
}

  When using server created by httpProxy.createServer() with no latency and a valid target server
    ‚úó should receive 'hello localhost'
      ¬ª expected null, got {
    stack: 'Error: socket hang up\n    at CleartextStream.<anonymous> (http.js:1272:45)\n    at CleartextStream.emit (events.js:61:17)\n    at Array.3 (tls.js:617:22)\n    at EventEmitter._tickCallback (node.js:126:26)',
    arguments: undefined,
    type: undefined,
    message: 'socket hang up'
}

‚ô¢ node-http-proxy/proxy-table/https

  When using server created by httpProxy.createServer() when passed a routing table and routing by Hostname an incoming request to unknown.com
    ‚úó should receive 404 responseCode
      ¬ª expected null, got {
    stack: 'Error: socket hang up\n    at Socket.<anonymous> (http.js:1272:45)\n    at Socket.emit (events.js:64:17)\n    at Array.0 (net.js:829:12)\n    at EventEmitter._tickCallback (node.js:126:26)',
    arguments: undefined,
    type: undefined,
    message: 'socket hang up'
} // helpers.js:107
  When using server created by httpProxy.createServer() when passed a routing table and routing by RegExp an incoming request to unknown.com
    ‚úó should receive 404 responseCode
      ¬ª expected null, got {
    stack: 'Error: socket hang up\n    at Socket.<anonymous> (http.js:1272:45)\n    at Socket.emit (events.js:64:17)\n    at Array.1 (net.js:829:12)\n    at EventEmitter._tickCallback (node.js:126:26)',
    arguments: undefined,
    type: undefined,
    message: 'socket hang up'
} // helpers.js:107
  When using server created by httpProxy.createServer() when passed a routing file an incoming request to unknown.com
    ‚úó should receive 404 responseCode
      ¬ª expected null, got {
    stack: 'Error: socket hang up\n    at Socket.<anonymous> (http.js:1272:45)\n    at Socket.emit (events.js:64:17)\n    at Array.2 (net.js:829:12)\n    at EventEmitter._tickCallback (node.js:126:26)',
    arguments: undefined,
    type: undefined,
    message: 'socket hang up'
} // helpers.js:107

  When using server created by httpProxy.createServer() when passed a routing file an incoming request to dynamic.com after the file has been modified
      ‚úó should receive 'hello dynamic.com'
        ¬ª expected 'hello dynamic.com',
    got  undefined (==) // proxy-table-test.js:99
    When using an instance of ProxyTable combined with HttpProxy directly an incoming request to foo.com
      ‚úó should receive 'hello foo.com'
        ¬ª expected null, got {
      stack: 'Error: socket hang up\n    at CleartextStream.<anonymous> (http.js:1272:45)\n    at CleartextStream.emit (events.js:61:17)\n    at Array.1 (tls.js:617:22)\n    at EventEmitter._tickCallback (node.js:126:26)',
      arguments: undefined,
      type: undefined,
      message: 'socket hang up'
  } // helpers.js:76
    When using an instance of ProxyTable combined with HttpProxy directly an incoming request to bar.com
      ‚úó should receive 'hello bar.com'
        ¬ª expected null, got {
      stack: 'Error: socket hang up\n    at CleartextStream.<anonymous> (http.js:1272:45)\n    at CleartextStream.emit (events.js:61:17)\n    at Array.1 (tls.js:617:22)\n    at EventEmitter._tickCallback (node.js:126:26)',
      arguments: undefined,
      type: undefined,
      message: 'socket hang up'
  }
",johnae,2011-05-19 01:14:21
36,2011-04-23 14:25:56,"What version of Node.js are you running on? This looks like https://github.com/joyent/node/issues/849, but ry said the issue is resolved. TLS / SSL stability has been one of the focal points of the node.js core team for the last several months, I will try to triage this issue with them. 

Any tcpdump or other low-level network output would help us greatly.
",indexzero,2011-05-19 01:14:21
36,2011-04-23 14:27:44,"He's running 4.7. I'm actually seeing the same errors on my machine when running the https tests. I'm on v0.5.0-pre.
",Marak,2011-05-19 01:14:21
36,2011-04-23 14:36:12,"Looks like issues `849/670` rearing their ugly head. HTTPS is by no means perfect in node.js core yet. I will re-escalate and try to get some dev time on it. HTTPS >>> Windows support (imo), but who knows if I'll get anyones attention.
",indexzero,2011-05-19 01:14:21
36,2011-05-17 22:32:04,"This was actually not related to node.js core, but a typo in my test code. Thanks to @olauzon for finding this problem and fixing it in 1ee6beff6aa3087e332701fd3cfda70b4e968ce8. Will be pushed out in `v0.5.2`
",indexzero,2011-05-19 01:14:21
36,2011-05-17 22:41:01,"Ok but I got the actual original error when doing real proxying NOT when running the tests. I'll try out 0.5.2 and see if that works.
",johnae,2011-05-19 01:14:21
36,2011-05-17 22:52:06,"Just tried it with 0.5.2 and I'm still getting the same error.
",johnae,2011-05-19 01:14:21
36,2011-05-17 22:52:52,"@johnae please let us know how it goes.
",olauzon,2011-05-19 01:14:21
36,2011-05-17 23:05:47,"@johnae Can you please supply some sample code? Now that we've established that this is not a node.js core issue (since all of the HTTPS tests are passing) we need to try to reproduce it locally to fix it.
",indexzero,2011-05-19 01:14:21
36,2011-05-18 08:17:48,"Sure. I put together something that fails in the same way. This doesn't use the certificates I actually use (they are real signed certs). I chose to use certificate_authority - a ruby gem for cert generation. I think I've used it correctly, anyway - the error is the same as what I get. I proxy to a locally running rails app but here I chose to proxy to http://kernel.org instead and I get the same error. If you need better tests, please don't hesitate to ask, though I suspect this is sufficient since it results in the same error:

<S_CODE_TOKEN>
",johnae,2011-05-19 01:14:21
36,2011-05-18 08:19:57,"Ohh, above code assumes you're on a Mac which may have been stupid. Just change all refs to ENV['HOME']/.Trash to something that works for you (/tmp perhaps?).
",johnae,2011-05-19 01:14:21
36,2011-05-18 23:16:42,"Can you try this with a manually generated certificate or with the certificates in `/test/fixtures` (https://github.com/nodejitsu/node-http-proxy/tree/master/test/fixtures) in the node-http-proxy repo? I want to try to reduce the surface area of this bug and remove any external dependencies (like Ruby or this certificate_authority gem).
",indexzero,2011-05-19 01:14:21
36,2011-05-18 23:22:05,"@johnae in addition to what @indexzero said, could you try with v0.5.3?
",olauzon,2011-05-19 01:14:21
36,2011-05-19 01:14:21,"@johnae Thanks for bearing with us on this! This was actually a nuance in the API that @olauzon picked up on. You are trying to proxy HTTPS to HTTP which before the version we just released, `v0.5.4`, was not possible from the `httpProxy.createServer()` API. 

No changes need to be made to your code, but if you're interested in how to proxy HTTPS to HTTPS (as opposed to HTTPS to HTTP) checkout our examples:

https://github.com/nodejitsu/node-http-proxy/blob/master/examples/proxy-https-to-https.js
https://github.com/nodejitsu/node-http-proxy/blob/master/examples/proxy-https-to-http.js
",indexzero,2011-05-19 01:14:21
36,2011-05-19 11:42:17,"I see, I just assumed it would work. Just tried 0.5.7 and now it seems to work fine. Thanks!
",johnae,2011-05-19 01:14:21
35,2011-04-20 09:16:41,"I have a problem with proxying messages from the client to the websocket server.
The messages do not reach the websocket server at all. When I connect to the server directly, it works.

However, all other things work. I can conenct & send messages to the client.

I¬¥m using the following websocket server: https://github.com/miksago/node-websocket-server

Has anyone the same problem?
",VanCoding,2011-05-18 01:40:43
35,2011-04-20 09:29:22,"Hrmm, the current test suite has coverage for socket.io and it appears to be passing.

Can you please confirm the results of this test first?

<S_CODE_TOKEN>

If those tests all pass, then there might be an issue with http-proxy and node-websocket-server.
",Marak,2011-05-18 01:40:43
35,2011-04-20 09:45:59,"I found the problem:
When proxying messages, the incoming data is a bit different:

WITHOUT proxying
Buffer 00 68 65 6c 6c 6f 20 77 6f 72 6c 64 ff
Buffer 00 68 65 6c 6c 6f 20 77 6f 72 6c 64 ff

WITH proxying
Buffer 00 68 65 6c 6c 6f 20 77 6f 72 6c 64 ef bf bd
Buffer 00 68 65 6c 6c 6f 20 77 6f 72 6c 64 ef bf bd

The messages are not well cut anymore. Hope this helps.
",VanCoding,2011-05-18 01:40:43
35,2011-04-20 11:01:59,"I fixed the problem for me by always doing ""socket.setKeepAlive(true, 0);"" in the _socket function and never set the encoding to utf8.

It seems that was the only problem. Now I get the same data from both ways.
",VanCoding,2011-05-18 01:40:43
35,2011-04-20 11:06:09,"Would you be willing to put a pull request together? 
",Marak,2011-05-18 01:40:43
35,2011-04-20 11:14:04,"I¬¥m not sure if my changes are good for all users of this library. I know it works for me like a charm now, but maybe the deleted lines of code were good for someone else.
",VanCoding,2011-05-18 01:40:43
35,2011-05-18 01:40:43,"This should be resolved in v0.5.3
",indexzero,2011-05-18 01:40:43
35,2011-07-08 02:46:59,"Hi, I'm running with v0.5.11 and this issue still exists there.
It seems that the problem is that the client socket has utf-8 encoding set. Once removed, everything works perfectly:

<S_CODE_TOKEN>

Let me know if you want me to set up a pull request.
",eladb,2011-05-18 01:40:43
35,2011-07-08 12:53:20,"@eladb What messages are you trying to proxy that are not getting through? We have extensive test coverage for websockets that are all passing

I think the correct approach here would be to make the encoding of the data being sent across the websocket configurable. 

Can you please provide a full code sample that reproduces the issue?
",indexzero,2011-05-18 01:40:43
35,2011-07-08 18:56:51,"Yes. I will get a repro.

--Elad.

On Fri, Jul 8, 2011 at 5:53 AM, indexzero
reply@reply.github.com
wrote:

> @eladb What messages are you trying to proxy that are not getting through? We have extensive test coverage for websockets that are all passing
> 
> I think the correct approach here would be to make the encoding of the data being sent across the websocket configurable.
> 
> Can you please provide a full code sample that reproduces the issue?
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/35#issuecomment-1532178

## 

Elad.
",eladb,2011-05-18 01:40:43
35,2011-07-09 15:44:06,"see attached.

1) run ""node test.js"" and open a browser on http://localhost:8000.
then show the console and you will see echo only from the direct
connection.

2) run ""node test-patched.js"" and you will be able to see echo from
both proxied and direct connections.

could be:
1) socket.io that you are using in your test.
2) the websocket library you refer under 'vendor'.

let me know if you want me to try and repro via unit test.

thanks
elad.

On Fri, Jul 8, 2011 at 11:56 AM, Elad Ben-Israel
elad.benisrael@gmail.com wrote:

> Yes. I will get a repro.
> 
> --Elad.
> 
> On Fri, Jul 8, 2011 at 5:53 AM, indexzero
> reply@reply.github.com
> wrote:
> 
> > @eladb What messages are you trying to proxy that are not getting through? We have extensive test coverage for websockets that are all passing
> > 
> > I think the correct approach here would be to make the encoding of the data being sent across the websocket configurable.
> > 
> > Can you please provide a full code sample that reproduces the issue?
> > 
> > ## 
> > 
> > Reply to this email directly or view it on GitHub:
> > https://github.com/nodejitsu/node-http-proxy/issues/35#issuecomment-1532178
> 
> ## 
> 
> Elad.

## 

Elad.
",eladb,2011-05-18 01:40:43
35,2011-07-09 19:36:39,"@eladb I might be missing something but where can I find `test.js` and `test-patched.js`?? Will try later this evening.
",indexzero,2011-05-18 01:40:43
35,2011-07-09 20:51:25,"extract the zip file and you will see both files under 'node-proxy-repro'.
10x,
elad.

On Sat, Jul 9, 2011 at 12:36 PM, indexzero
reply@reply.github.com
wrote:

> @eladb I might be missing something but where can I find `test.js` and `test-patched.js`?? Will try later this evening.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/nodejitsu/node-http-proxy/issues/35#issuecomment-1539625

## 

Elad.
",eladb,2011-05-18 01:40:43
35,2011-07-09 21:05:30,"@eladb Can you provide a link to the zip file?
",ironchefpython,2011-05-18 01:40:43
35,2011-07-09 21:31:14,"sure, sorry--
http://dl.dropbox.com/u/12586927/temp/node-proxy-repro.zip
",eladb,2011-05-18 01:40:43
34,2011-04-19 15:53:06,"changing the headers ""location"" & ""origin"" when proxying websocket request should be an option, because this is important to make the proxying behave like ""not happened"".
",VanCoding,2011-06-26 16:57:57
34,2011-04-19 16:21:51,"What happens if you modify request.headers directly before they get proxied out?
",Marak,2011-06-26 16:57:57
34,2011-04-19 16:37:35,"I think you understood me wrong.
I mean the code in the file ""node-http-proxy.js"" at line 599 and 600. The headers are going to be changed there. It doesn¬¥t matter what headers are incoming. They are changed. That¬¥s the problem.

It would be better if i could specify if I want to keep the original headers or change them.
",VanCoding,2011-06-26 16:57:57
34,2011-04-19 17:16:10,"Here? https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L589

I'm not sure if this is by design due to the websocket protocol or not. I will reread that part of the spec and follow-up on this.
",indexzero,2011-06-26 16:57:57
34,2011-04-22 02:43:29,"@indexzero - I think I'm running into a related issue here without websockets. 

I think the disconnect is in the fact that http-proxy acts as a proxy server by default. This means that the receiving server can tell the request has been proxied. In other words, it's not transparent. The proxy should act in this mode by default, but we should probably expose an API option to enable ""transparent"" proxying. I'm not sure if there is a better name for that.

Here is a more clear illustration of the problem:

<S_CODE_TOKEN>

Does that make any sense?
",Marak,2011-06-26 16:57:57
34,2011-04-26 16:33:41,"I ran into an issue with this recently. In my client (Google Chrome 10), I was getting this while attempting to make a connection to a websocket server behind node-http-proxy:

Error during WebSocket handshake: origin mismatch: http://127.0.0.1:8071 != http://127.0.0.1

It turns out this was due to the issue mentioned here of changing the request headers. After this patch:

--- /tmp/orig
+++ lib/node-http-proxy.js 
@@ -586,8 +586,8 @@
       remoteHost = options.host + (options.port - 80 === 0 ? '' : ':' + options.port);

   // Change headers
-  req.headers.host   = remoteHost;
-  req.headers.origin = 'http://' + options.host;
-  //req.headers.host   = remoteHost;
-  //req.headers.origin = 'http://' + options.host;
  
  outgoing = {
   host: options.host,

the error stops and the websocket connections work fine.
",andyichr,2011-06-26 16:57:57
34,2011-04-26 18:13:50,"This is why I posted this issue. I had the same problem.
",VanCoding,2011-06-26 16:57:57
34,2011-04-26 21:24:02,"The websocket support was originally written by @donnerjack13589 and later updated by @davglass. Maybe they can chime in on the reasoning behind changing the outgoing headers.

I will kill those lines in `v0.5.1` (coming this week) if there are no objections since both @flashfan and @andyichr have seen this fix their problems.
",indexzero,2011-06-26 16:57:57
34,2011-05-05 07:57:43,"If you're going to kill those lines, please have a look a little further down. There is code to replace the host and origin which wouldn't need to happen. Also, this section currently does not support ports other than 80.
",jfis,2011-06-26 16:57:57
34,2011-05-11 19:03:40,"Updates on this? I'm getting an origin mismatch when proxying https => http
",frank06,2011-06-26 16:57:57
34,2011-05-11 20:24:32,"@olauzon can you take a look at this ticket? I'd like to get this resolved this week if possible. 
",Marak,2011-06-26 16:57:57
34,2011-05-11 20:34:07,"@Marak definitely, will investigate.
",olauzon,2011-06-26 16:57:57
34,2011-05-11 20:36:31,"Thanks @olauzon! Feel free to post your status in this thread.
",Marak,2011-06-26 16:57:57
34,2011-05-11 21:23:55,"Great! Should be a pretty simple fix in there. Maybe we can summon @miksago or @donnerjack13589 to help shed some light on the underlying websocket spec and why these headers need to be changed (or don't)

@donnerjack13589 wrote the original implementation here, it's like 4am in Russia tho so he might not be around
",indexzero,2011-06-26 16:57:57
34,2011-05-11 21:40:54,"So what's the issue? Most websocket implementations will be reading the headers of origin and host, as well as the various sec- ones. If you're proxying websockets and adding, say, a ""x-"" to the front of these headers, then the websocket implementations will break. I think it's probably best not to modify headers on websocket requests. 

As for the specification, I don't think it defines as to how proxies should interact with headers, @donnerjack13589 may know otherwise. I might also ask the guys I work with as to whether they can shed light, but they're in BST / GMT timezone.
",ThisIsMissEm,2011-06-26 16:57:57
34,2011-05-11 21:44:25,"@miksago Thanks. The problem is that currently `node-http-proxy` rewrites the `origin` and `host` headers for WebSocket requests. This is causing some unexpected behavior for users over HTTPS and in other cross-domain proxying scenarios. 

Based on what you said, I guess we should just not be rewriting these headers at all? 
Code: https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L589
",indexzero,2011-06-26 16:57:57
34,2011-05-13 07:15:18,"I still think it would be best, if ther was an option.
In some cases, it is necessary to rewrite them.

For example when someone tries to forward wss:// to an internal ws:// server. Then we would have an origin mismatch.
",VanCoding,2011-06-26 16:57:57
34,2011-05-13 20:26:56,"how would wss to ws work? 
is that common for a proxy to handle all the encoding/decoding?

that isn't to say changing headers is never necessary

 the code to change headers and replace host and origin in the handshake is very deliberate
the coder(s) must have thought it was necessary
would be nice to hear why

code i'm referring to:

<S_CODE_TOKEN>

...

<S_CODE_TOKEN>
",jfis,2011-06-26 16:57:57
34,2011-05-13 20:49:31,"@jfis Again, this is a symptom of a larger problem. I am working on something in the experimental branch, but I'm not sure if we can actually write a websocket proxy on top of the existing http.Agent APIs without event emitter leaks.
",indexzero,2011-06-26 16:57:57
34,2011-05-13 20:55:11,"@indexzero i don't see how changing the headers and replacing host and origin in the handshake relates to http.Agent but I'll take your word for it. 

I do see the problem with http.Agent in the other thread (#50) though.
",jfis,2011-06-26 16:57:57
34,2011-05-13 21:00:31,"@jfis They are only related in that they both have to do with websockets. If this gets fixed, that is still a problem and websockets is still broken.
",indexzero,2011-06-26 16:57:57
34,2011-05-13 21:02:21,"@indexzero :) ok gotcha.
",jfis,2011-06-26 16:57:57
34,2011-05-18 01:40:09,"This is fixed in 9c6c4b908b7d6ce67144ba9d41702b5694254099. WebSockets (ws://) and Secure WebSockets (wss://) should be 100% now. Added new functional tests, but if anyone wants to do a benchmark that would be **awesome**.
",indexzero,2011-06-26 16:57:57
34,2011-05-21 19:03:49,"just double-checking: it's currently not possible to proxy `wss => ws` and `ws => wss`, correct?

could we add this to the docs?
",frank06,2011-06-26 16:57:57
34,2011-05-21 19:10:02,"This is actually possible. See the docs under ""Proxying HTTPS to HTTP"" ... this also works for websockets
",indexzero,2011-06-26 16:57:57
34,2011-05-22 00:02:06,"In a `wss => ws` scenario. In order for the non-secure websocket backend to accept the origin, we'd need to declare `ws` as the protocol. Failing to do so results in an ""Origin mismatch"" (that's what I get, `wss != ws`)

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L632

All possible values for the protocol in `req.headers.origin` become: `http` or `https` (when `changeOrigin` == `true`), or `wss` (passed along from the secure proxy server, when `changeOrigin` == `false`). Never `ws`.  Or am I missing something?
",frank06,2011-06-26 16:57:57
34,2011-05-22 00:09:09,"Hmm maybe not Origin, but location. This is what I get in the console: `Error during WebSocket handshake: location mismatch: wss://localhost/socket.io/websocket != ws://localhost/socket.io/websocket`
",frank06,2011-06-26 16:57:57
34,2011-05-22 01:20:08,"also, as noted somewhere above,
remoteHost is replaced by options.host during the handshake
options.host does not have a port
remoteHost includes the port for ports != 80
https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L710
",jfis,2011-06-26 16:57:57
34,2011-05-23 05:26:25,"@frank06 Can you provide sample code to reproduce the problem? 
",indexzero,2011-06-26 16:57:57
34,2011-05-23 06:20:58,"@frank06 @jfis This is fixed in 028d2044e71d70b7bc21d339de29e2275c3be5c2 and published in `v0.5.9`. Let me know if you run into any issues with this. 
",indexzero,2011-06-26 16:57:57
34,2011-05-23 08:06:33,"1) websocket tests point to home.devjitsu.com :)

2) The section I mentioned before, the handshake, has 2 issues. 

<S_CODE_TOKEN>

It tries to replace remoteHost with options.host during the handshake. 
remoteHost contains the port but options.host does not.

<S_CODE_TOKEN>

This replacement only needs to happen when the newly introduced changeOrigin parameter is true.
Also, since options.host does not contain the port, an origin mismatch will occur for ports != 80.

fail conditions:
1) changeOrigin == true + options.port != 80

wasteful conditions:
1) changeOrigin == false //remoteHost is never found in sdata so the 4 lines in question are a waste.

to demonstrate
run this gist:
https://gist.github.com/986377
then open in chrome:
http://otherlocalhost:8000
http://otherlocalhost:8001 
",jfis,2011-06-26 16:57:57
34,2011-05-23 20:27:16,"`0.5.9` _does_ seem to work for me in localhost! I want to fully test it tomorrow.  Traffic is being smoothly proxyed from https/443 to http/4431 (including a successful websocket handshake)
",frank06,2011-06-26 16:57:57
34,2011-05-25 06:56:00,"@olauzon ... Any progress on this issue today? Ping me if you're blocked.
",indexzero,2011-06-26 16:57:57
34,2011-06-08 18:26:13,"Ping. Is this still an issue?
",Marak,2011-06-26 16:57:57
34,2011-06-08 18:56:41,"Yes. @olauzon do you want to take a look? 
",indexzero,2011-06-26 16:57:57
34,2011-06-23 19:20:11,"I wanted to tack on this issue I had that's possibly related:
http://stackoverflow.com/questions/6444280/heroku-no-such-app-error-with-node-js-node-http-proxy-module

The host wasn't being modified by http-proxy, the repercussion being that Heroku couldn't redirect you to the correct app. I had to set the `req.headers.host = appHost` manually to get it to correctly route. I'm running http-proxy 0.5.10.

Would be useful to note in the readme that transparent proxies aren't enabled by default.
",leisms,2011-06-26 16:57:57
34,2011-06-23 19:46:07,"I looked into the source a little and there -is- an option to change the host header by setting  the option `changeOrigin: true` when you create the proxy server. However, I tried setting it during instantiation and there doesn't seem to be any effect.

`var proxy = new httpProxy.HttpProxy({changeOrigin: true});`

This could definitely be an error somewhere on my part though.
",leisms,2011-06-26 16:57:57
34,2011-06-26 15:23:55,"@lezhang If that code sample fixed your issue, this is not related to `node-http-proxy`, but how you were using it. That is, the fix was to manually set the header on the incoming request (i.e. the `IncomingRequest` was missing the `Host` header to begin with, and then`node-http-proxy` correctly proxied the request).
",indexzero,2011-06-26 16:57:57
33,2011-04-19 12:37:18,"When I install http-proxy with npm, with node 0.4.2, and I run the example in the README doing a routing using server.on('upgrade', I get:
node.js:116
        throw e; // process.nextTick error, or 'error' event on first tick
        ^
TypeError: Cannot read property 'headers' of undefined
    at Object.<anonymous> (/usr/local/lib/node/.npm/http-proxy/0.3.1/package/lib/node-http-proxy.js:133:11)
    at Object.<anonymous> (/Users/elise/Rails/MediaSquare/proxy.js:7:15)
    at Module._compile (module.js:383:26)
    at Object..js (module.js:389:10)
    at Module.load (module.js:315:31)
    at Function._load (module.js:276:12)
    at Array.<anonymous> (module.js:402:10)
    at EventEmitter._tickCallback (node.js:108:26)

It looks like using new httpProxy.HttpProxy() without parameters fails ...
",elisehuard,2011-04-19 15:59:42
33,2011-04-19 15:59:38,"oops sorry, needed to upgrade to more recent version of node of course. my apologies.
",elisehuard,2011-04-19 15:59:42
32,2011-04-13 21:20:24,,weaver,2011-04-13 21:25:30
32,2011-04-13 21:25:30,"I should have removed the eyes dependency before published. I use eyes for debugging. Fixed in a5d88aaacc209bdceaf0799e99ff82bdce1bdc10
",indexzero,2011-04-13 21:25:30
32,2011-04-13 21:35:39,"Thanks!
",weaver,2011-04-13 21:25:30
31,2011-03-27 14:55:03,"Node 0.4.3
npm 1.0rc8
Ubuntu Server 10.04

When I try to run the binary, I get the following error:

~$ sudo ./node_modules/http-proxy/bin/node-http-proxy --config=~/node-proxy-conf.json --port=80

node.js:134
        throw e; // process.nextTick error, or 'error' event on first tick
        ^
Error: Cannot find module './lib/index'
    at Function._resolveFilename (module.js:320:11)
    at Function._load (module.js:266:25)
    at require (module.js:348:19)
    at Object.<anonymous> (/home/mcurtis/node_modules/http-proxy/node_modules/winston/node_modules/riak-js/index.js:1:80)
    at Module._compile (module.js:404:26)
    at Object..js (module.js:410:10)
    at Module.load (module.js:336:31)
    at Function._load (module.js:297:12)
    at require (module.js:348:19)
    at Object.<anonymous> (/home/mcurtis/node_modules/http-proxy/node_modules/winston/lib/winston/transports/riak.js:10:14)

Any ideas? according to the riakjs issues list, there isn't an officially-compatible node 0.4 version of riakjs. I'm guessing that plus the new architecture of npm has something to do with this.
",baggachipz,2011-03-27 21:28:52
31,2011-03-27 21:28:52,"I've seen this same issue come up across all of my projects that use winston. As a result, I've released a new version of winston (0.2.6) that removes the riakjs dependency.

Installing the new version should fix this. 
",indexzero,2011-03-27 21:28:52
31,2011-03-27 21:37:46,"I tried updating it but it looks like there is still a riakjs dependency:

$ sudo npm install winston
colors@0.5.0 ./node_modules/winston/node_modules/colors
eyes@0.1.6 ./node_modules/winston/node_modules/eyes
request@1.9.3 ./node_modules/winston/node_modules/loggly/node_modules/request
loggly@0.3.2 ./node_modules/winston/node_modules/loggly
eyes@0.1.6 ./node_modules/winston/node_modules/vows/node_modules/eyes
vows@0.5.8 ./node_modules/winston/node_modules/vows
winston@0.2.6 ./node_modules/winston

$ sudo ./node_modules/http-proxy/bin/node-http-proxy --config=~/node-proxy-conf.json --port=80

node.js:134
        throw e; // process.nextTick error, or 'error' event on first tick
        ^
Error: Cannot find module './lib/index'
    at Function._resolveFilename (module.js:320:11)
    at Function._load (module.js:266:25)
    at require (module.js:348:19)
    at Object.<anonymous> (/home/mcurtis/node_modules/http-proxy/node_modules/winston/node_modules/riak-js/index.js:1:80)
    at Module._compile (module.js:404:26)
    at Object..js (module.js:410:10)
    at Module.load (module.js:336:31)
    at Function._load (module.js:297:12)
    at require (module.js:348:19)
    at Object.<anonymous> (/home/mcurtis/node_modules/http-proxy/node_modules/winston/lib/winston/transports/riak.js:10:14)

Thanks for looking into this.
",baggachipz,2011-03-27 21:28:52
31,2011-03-27 22:45:56,"No. I tested winston with riak-js removed from my system entirely. This may be an NPM cache issue. I'm not running npm 1.0, so perhaps also take this up with isaacs. 

Maybe `npm cache clean` will do the trick? 
",indexzero,2011-03-27 21:28:52
31,2011-03-27 22:47:01,"And seriously, the riak-js dependency is gone. it was only one line of code:

https://github.com/indexzero/winston/blob/master/lib/winston/transports/riak.js#L10

(Clearly commented out)
",indexzero,2011-03-27 21:28:52
31,2011-03-28 11:55:48,"npm cache clean took care of it. Did not know that was needed, thank you for your help.
",baggachipz,2011-03-27 21:28:52
30,2011-03-23 17:08:50,,mscdex,2011-04-17 03:10:00
30,2011-04-17 03:10:00,"Fixed in cfddd12e821bd6b07ff2dbf0aa543ddfc3664dca. Need more tests before pushing v0.5.0 live. Should be in the next 24 hours or so
",indexzero,2011-04-17 03:10:00
29,2011-03-20 21:38:36,"winston is now used for logging, but the dependencies in package.json were not updated.
",jhillacre,2011-03-20 21:43:40
29,2011-03-20 21:43:40,"Thanks. Landed in 0d1a3fe99511dda1ac949536a9eb4a045db39979
",indexzero,2011-03-20 21:43:40
28,2011-03-13 17:30:17,"Hi Charlie,
I'm new to node.js (I learned of it... today), and your http-proxy is one of the first apps I found. The approach is new and very interesting.
However, from your explanation, it seems it can also be used as a kind of load balancer (I have 2 web servers, ws1 and ws2, and the http-proxy at hp1 could connect to both).

Is there an example about that? Maybe it's trivial and a I'm missing something. Or this use-case has to be developed from scratch?

Thank you 
Paolo
",paoloskater,2011-03-14 02:04:54
28,2011-03-13 19:04:53,"If you're balancing across servers with multiple hosts (i.e. ws1 runs www.foo.com and ws2 runs www.bar.com) then you can use the ProxyTable features. Just pass in a routes object when you create the HttpProxy instance:

<pre>
  var httpProxy = require('http-proxy');

  var proxy = httpProxy.createServer({
    router: {
      'foo.com': 'ws1.ws1.ws1.ws1:8000',
      'bar.com': 'ws2.ws2.ws2.ws2:8000'
    }
  });
</pre>


Hope that helps.
",indexzero,2011-03-14 02:04:54
28,2011-03-14 10:10:20,"Thank you for the quick feedback!
I've only one service (e.g. www.myservice.com at ws0.ws0.ws0.ws0) and I'd like the load is distributed to 2 ""worker"" servers (ws1.ws1.ws1.ws1 and ws2.ws2.ws2.ws2). So if a user accesses www.myservice.com and, e.g, ws1 fails or is broken, the balancer sends requests to ws2, and viceversa.
Is it possible with http-proxy?
",paoloskater,2011-03-14 02:04:54
28,2011-03-14 20:16:13,"Yes, it is possible. I think this is what you want:

https://gist.github.com/869781

Let me know if that works for you.
",indexzero,2011-03-14 02:04:54
28,2011-03-21 14:36:49,"That was precisely what I was looking for. I'm putting it in the stack and I'll be back with a report.
Thank you!
Paolo
",paoloskater,2011-03-14 02:04:54
27,2011-03-10 18:05:22,"One of the common issues these days is making requests to third part domains that don't support json and/or jsonp.  Please provide an example of this in your demo.

I wrote one that kind of sucks here: https://gist.github.com/864549. 75% of the code is to prevent errors that would crash NodeJS.

For example,
/?url=http://www.google.com/calendar/feeds/developer-calendar@google.com/public/full?alt=json
Or for XML, User needs to convert this to JSON
/?url=http://www.google.com/calendar/feeds/developer-calendar@google.com/public/full

This sort of works, obviously its broken b/c I don't rebuild absolute URLs:
?url=http://google.com/

However, this one seriously breaks and I don't know why
?url=http://woot.com/
",drewwells,2011-03-11 11:56:52
27,2011-03-11 03:56:52,"Seems like this would be best implemented as a standalone library that uses node-http-proxy. 
",indexzero,2011-03-11 11:56:52
27,2011-03-11 04:36:36,"Seriously?  I would think this is very important use case.  It seems that the major pain for Web Dev's have shifted from IE6 to the horrendous state of same-domain policies.  Every JS application needs one a proxy now, and that isn't going to change for some time.
",drewwells,2011-03-11 11:56:52
27,2011-03-11 20:18:47,"Yes, seriously. The goal of node-http-proxy is to write a pure javascript HTTP proxy as compliant as possible with RFC2616 (HTTP/1.1 Specification): http://www.ietf.org/rfc/rfc2616.txt

Although I agree with you that this would be a valuable feature, it clearly does not align with this goal. Be happy to contribute / collaborate on the standalone library, but it does not belong in node-http-proxy.
",indexzero,2011-03-11 11:56:52
27,2011-03-13 01:11:42,"I gotta agree with indexzero on this. A generalized json-p proxy should be a standalone project. If you make a separate module that wraps this functionality up nicely, I'd be glad to link it to the ReadMe for http-proxy.
",Marak,2011-03-11 11:56:52
27,2011-03-13 02:45:53,"You guys are making a browser-style 'web proxy' if I understand correctly, I'll be using Node directly rather than building ontop of this http-proxy
",drewwells,2011-03-11 11:56:52
27,2011-03-13 02:57:04,"Huh? It's a proxy for http requests, not sure how else to explain that.

Either way, best of luck.
",Marak,2011-03-11 11:56:52
27,2011-03-13 18:21:43,"node-http-proxy is not designed to run in the browser. It is designed to run on the server using node.js. 

It is also designed to compete with things like nginx, and HAProxy. Very heavy C/C++ libraries that are difficult to contribute to or improve without a large upfront effort in learning the codebase and low-level networking approaches. 

You really should use node-http-proxy rather than just node.js directly. We do a lot of things that aren't immediately obvious if you're just doing http.request().
",indexzero,2011-03-11 11:56:52
26,2011-03-06 11:54:44,"calling proxy.close() does not work like it node's httpServer.close() does.

here is a gist to reproduce: https://gist.github.com/857228 
",dominictarr,2011-03-11 03:47:29
26,2011-03-06 20:13:29,"Thanks. I'll add this to the list for 0.4.0
",indexzero,2011-03-11 03:47:29
26,2011-03-11 03:47:29,"Fixed in v0.4.0 branch. 
",indexzero,2011-03-11 03:47:29
25,2011-03-04 07:23:28,"Hmm,

This is a bit of an lousy bug report, more of an notion. I had the http-proxy module fail with the following error message:

<S_CODE_TOKEN>

Was not able to identify what caused it.... trying reproduce. Any idea?
",muhmi,2011-03-04 15:42:43
25,2011-03-04 07:31:54,"Hmm ... definitely an edge case but something I should be checking for to prevent crashed from malformed requests. Here's the scenario
1. You're using the ProxyTable.
2. You're proxying by Host (i.e. proxy based on the value of the HTTP ""Host"" header 
3. Some careless user decided not to include a Host header
4. Crash because proxy.req.headers.host (i.e. the value of the HTTP Host header) is undefined

I'll put in a check in 0.4.0. Going to get pushed out in the next 10 days or so
",indexzero,2011-03-04 15:42:43
25,2011-03-04 07:42:43,"I tried to telnet and do a request by hand without the Host header. Does not crash the server =)
",muhmi,2011-03-04 15:42:43
25,2011-03-04 07:44:34,"hmm ... odd. Well no host header is the only reason I can think of that req.headers.host would be undefined.
",indexzero,2011-03-04 15:42:43
24,2011-02-11 17:54:59,"This allows the lookup within ProxyTable to be a O(1) lookup on the routers object without RegExp. Instead of the O(n) RegExp based lookup that is currently in place.

This can be toggled by a boolean that can be passed to HttpProxy and ProxyTable.

Therefore for scenarios where you want a purely Host: header lookup this will be faster and will scale better when the proxy is infront of X'00 backends.
",DanBUK,2011-03-10 13:24:18
24,2011-02-11 17:58:19,"Interesting. Will review more this weekend and give you some feedback. Speed improvements always welcome.
",indexzero,2011-03-10 13:24:18
24,2011-02-11 18:01:32,"Sorry about the setMaxListeners foo, I was trying to get EventEmitter to not alert on that warning.
",DanBUK,2011-03-10 13:24:18
24,2011-02-11 18:16:04,"Looked over it at lunch. I like the feature, but I'll tweak it a bit before pulling it. This coincides nicely with the work I was doing to make some changes for node 0.4.0 now that https is stable.

Do you need this in a release that's backwards compatible to 0.2.x? Otherwise I'll just roll it into the version targeting 0.4.x. 
",indexzero,2011-03-10 13:24:18
24,2011-02-11 18:30:16,"I don't think there is much worry about 0.2.x compatibilty; 'we' should all be moving forwards? No?

I'de be interested in your tweaks.

Cheers,
DanBUK.
",DanBUK,2011-03-10 13:24:18
24,2011-03-10 13:24:18,"Added this to v0.4.0. The rewrite for node 0.4.0 was substantial enough that merging your pull request didn't make sense. In the future though there are two things I really need before I could accept this:
1. Updates to documentation.
2. Additional tests.
",indexzero,2011-03-10 13:24:18
23,2011-01-31 21:31:07,"Forgive me if this post is slightly uninformed - I am new to Proxying in general. Today I tried to start a proxy to get around some cross domain issues I was having. Apparently the urls I need to proxy to depend on the Host header being the same as the actual domain. When I was hitting it with node-http-proxy, I got some 403s, since it was sending Host : localhost (or whatever). It turns out my service doesn't honor the x-forwarded-for header and I have to fake it, but I'm surprised that this library doesn't automatically append the x-forwarded-for header to the request. From my general understanding it seems like most proxy systems do inject this header, so why doesn't node-http-proxy?
",c2c533c4f237,2011-04-16 07:21:44
23,2011-01-31 21:47:04,"That's a good question. Right now node-http-proxy isn't 100% compliant with rfc2616, but I'll leave this issue open as a reminder that we should be doing that. 

There are going to be a lot of changes coming once 0.4.0 is stablized.
",indexzero,2011-04-16 07:21:44
23,2011-04-16 07:21:44,"Fixed in a3cb527be5e42d5192400933bf32a361b8c707c4. Will be released in v0.5.0 in the next couple of days.
",indexzero,2011-04-16 07:21:44
22,2011-01-21 22:43:25,"There is a max redirects bug in the request module. We should pull in this fix as soon as the package is available on npm.

https://github.com/mikeal/node-utils/issues/issue/9/#comment_697521
",Marak,2011-03-11 03:45:14
22,2011-03-11 03:45:14,"Fixed in v0.4.0 branch
",indexzero,2011-03-11 03:45:14
21,2011-01-21 20:26:17,"I created a very simple http-proxy instance for some testing: https://gist.github.com/790342

Running on node v0.3.5, this immediately returns the warning: 

<S_CODE_TOKEN>

when an http request is made.  Under load, it appears this is indeed leaking memory.  After about 5 minutes with Siege hitting the proxy with 400 concurrent requests, it dies with: 
     FATAL ERROR: CALL_AND_RETRY_2 Allocation failed - process out of memory

However, removing the (empty?) pool error handler on line 184 of node-http-proxy.js appears to fix this. Should this be set once upon pool creation, rather than when the pool is retrieved for each request?
",thegreatape,2011-03-11 11:49:04
21,2011-01-21 20:30:57,"We've been seeing this memory leak in production but hadn't been able to track it down yet. 

We're running node 0.3.1 (for at least minimal https support), so that would explain where we don't see it.

Thanks for the heads up and I'll investigate and get back to you.
",indexzero,2011-03-11 11:49:04
21,2011-01-21 20:55:32,"Interesting. I ran the same tests using node v0.3.1, with the same results - with the pool error handler in place, memory leaks occur. Without the error handler, it runs like champ under load. :-)
",thegreatape,2011-03-11 11:49:04
21,2011-01-21 20:58:00,"Nice. Will try siege myself, I'd only been using ab up till now, but this looks wayyy better. 

Thanks again.
",indexzero,2011-03-11 11:49:04
21,2011-02-01 05:38:02,"I'm having the same issue on 0.3.7, did anyone solve this?
",joelklabo,2011-03-11 11:49:04
21,2011-02-01 07:18:14,"All,

We will be dropping pool when we upgrade to 0.4.x in the next month or so because node.js > 0.3.6 does connection pooling for us. 

In the meantime, let me know how the removal of the pool error handler works in prod. I don't think it's the cause and not handling it can cause uncaught exceptions under high load.
",indexzero,2011-03-11 11:49:04
21,2011-03-04 03:46:18,"Hi, what's the status of this bug?.

I'm getting this error, on node 0.4:

(node) warning: possible EventEmitter memory leak detected. 11 listeners added. Use emitter.setMaxListeners() to increase limit.
Trace: 
    at Pool.<anonymous> (events.js:101:17)
    at Object.proxyRequest (/usr/local/lib/node/.npm/http-proxy/0.3.1/package/lib/node-http-proxy.js:185:7)
    at Server.<anonymous> (/Users/davem/Petromatch/repository/eclipse/petromatch-java/node/faye-server.js:12:3)
    at Server.<anonymous> (/usr/local/lib/node/.npm/faye/0.5.5/package/faye-node.js:1952:22)
    at Server.emit (events.js:45:17)
    at HTTPParser.onIncoming (http.js:1078:12)
    at HTTPParser.onHeadersComplete (http.js:87:31)
    at Socket.ondata (http.js:977:22)
    at Socket._onReadable (net.js:654:27)
    at IOWatcher.onReadable [as callback](net.js:156:10)
",davidmoshal,2011-03-11 11:49:04
21,2011-03-04 03:46:53,"oh, and node is definitely leaking.
",davidmoshal,2011-03-11 11:49:04
21,2011-03-04 04:54:32,"Working on a update for node 0.4.0. A lot of this has to do with the pool dependency which we can remove using the http.Agent API in 0.4.0
",indexzero,2011-03-11 11:49:04
21,2011-03-04 08:50:02,"thanks, rough eta? 
node now at 760 Mb after 6 hours of very light dev testing (couple of connections)
ie: I wouldn't feel comfortable moving to production.
",davidmoshal,2011-03-11 11:49:04
21,2011-03-04 09:03:40,"ps: I also posted this on the node.js google group, and had some interesting replies:

https://groups.google.com/d/topic/nodejs/TbHMjwMdRRY/discussion
",davidmoshal,2011-03-11 11:49:04
21,2011-03-04 17:44:48,"note the following comment regarding the code I posted, which is based on the example in the node.js readme:

https://groups.google.com/d/msg/nodejs/TbHMjwMdRRY/eoDRenX0UCEJ

is it true that every request creates a new proxy which isn't garbage collected?
",davidmoshal,2011-03-11 11:49:04
21,2011-03-04 19:41:37,"It is true that every request creates a new proxy. It is false that it is not garbage collected.
",indexzero,2011-03-11 11:49:04
21,2011-03-04 19:56:40,"I replied to the thread here: https://groups.google.com/forum/#!msg/nodejs/TbHMjwMdRRY/eoDRenX0UCEJ

Will try to bang this out in the next week or so. 
",indexzero,2011-03-11 11:49:04
21,2011-03-04 20:23:58,"I replaced this (which I found on your site):

var server = http.createServer (function (req, res) {

<S_CODE_TOKEN>

})

with: 

var server = httpProxy.createServer (8080, 'localhost')

Functionality is the same, and the leak does seem to be less, but will know later today.
",davidmoshal,2011-03-11 11:49:04
21,2011-03-04 20:27:25,"Have you been following this:

https://groups.google.com/d/msg/nodejs/TbHMjwMdRRY/6YIi6ktiuOEJ
",davidmoshal,2011-03-11 11:49:04
21,2011-03-05 12:54:03,"I ran node-inspector on my code, with v8-profiling.
As far as I can tell, HttpProxy is not being GC'd 

 Every request increments HttpProxy, ClientRequest and ServerResponse counts.
These counts never decrease, even if the system is left alone for some time. 

I have a screen shot of the profiler, though I don't see a way to attached files here, so email me if you want to see the screenshot: dmoshal at gmail dot com.
",davidmoshal,2011-03-11 11:49:04
21,2011-03-11 03:49:04,"I have fixed this issue in the v0.4.0 branch. Unfortunately, it is not stable due to a few bugs in the node.js http.Agent APIs that I am working to resolve. 

We will push v0.4.0 when we can get these issues resolved in core; hopefully the aforementioned fixes will make it into 0.4.3
",indexzero,2011-03-11 11:49:04
21,2011-03-11 04:01:20,"Thanks, I'm using nginx for now (without websockets)

Dave

On Thu, Mar 10, 2011 at 7:49 PM, indexzero <
reply@reply.github.com>wrote:

> I have fixed this issue in the v0.4.0 branch. Unfortunately, it is not
> stable due to a few bugs in the node.js http.Agent APIs that I am working to
> resolve.
> 
> We will push v0.4.0 when we can get these issues resolved in core;
> hopefully the aforementioned fixes will make it into 0.4.3
> 
> https://github.com/nodejitsu/node-http-proxy/issues/21#comment_859330
",davidmoshal,2011-03-11 11:49:04
20,2011-01-12 14:57:46,"Hi there,

I've come across what I think is a bug (or at least an incompatibility) within http-proxy.

What I expect to happen:  when I make a proxied POST request to the backend, it should process the request normally.

What happens instead:  when I make a proxied POST request with the Connect.bodyDecoder() middleware installed, the request hangs forever in the proxy.

I created a very simple test case here:  http://vivoh.com/node-proxy.zip

If you unzip this (and have ruby and the sinatra gem installed), you can see what I mean.

Run as is using the run.sh script, and then hit http://localhost:4568.  Then, hit the ""Submit Query"" button.  You'll see the http-proxy module successfully proxies the POST request request to the backend sinatra ruby server.

If you then edit ""app.js"" and uncomment the Connect.bodyDecoder() line, and then kill the node and ruby servers, and then restart using run.sh, if you try the POST request again, you'll see it hangs forever.  I speculate there is something happening inside the bodyDecoder() middleware which is incompatible with the http-proxy module.  I've looked around, but have not figured it out myself.

Chris
",xrd,2011-01-13 16:37:23
20,2011-01-12 15:29:06,"I think this makes a lot of sense actually. 

If you look at the bodyDecoder middleware you can see it's processing the request object and adding an event listener to the completion of the request. https://github.com/senchalabs/connect/blob/master/lib/connect/middleware/bodyDecoder.js#L40

To my understanding, since the request has already had it's end event fire, it's already been processed and cannot be proxied. http-proxy is hanging because the end and data event of the incoming request have already fired. 

I'm sure there is a way around this, it's just a matter of figuring out which library needs to get patched. Wrapping http-proxy up as a proper connect middleware might also be a solution.

Let me talk to the Connect guys and I'll see what we can figure out. 
",Marak,2011-01-13 16:37:23
20,2011-01-12 15:52:57,"Sounds great.  I really appreciate this module, it makes it so easy to do what I need to do and proxy out to other servers within node.  Please let me know if there is anything I can do to help troubleshoot any solutions you come across.
",xrd,2011-01-13 16:37:23
20,2011-01-12 15:58:04,"And, really what I want to do with the bodyDecoder middleware is pull out certain parameters from the post request.  I need to do this for my connect-rpx module.  If there were a better way to do this than use bodyDecoder() I would be OK with this too.  If I understand you correctly, it seems like the problem is that if you want access to the body of the incoming request (like I need) then it is a bit too late to proxy it.    
",xrd,2011-01-13 16:37:23
20,2011-01-13 08:37:23,"I got things working.  My solution was to remove the bodyDecoder from the filter chain, and then call it only when I need it inside my connect-rpx module.

https://github.com/xrd/connect-rpx/commit/eaffd02a02ec5fd22734338b0602be6ddba1335c

Thanks for your help, your explanation was very helpful in having my understand where the issue was happening.

Chris
",xrd,2011-01-13 16:37:23
20,2011-01-14 02:28:39,"Cool! You are very welcome. Let me know if you run into any additional issues. Closed. 
",Marak,2011-01-13 16:37:23
20,2011-05-18 00:13:39,"FYI I have this issue as well, both with one node.js web app proxying AJAX POST requests via http-proxy to another one as well as just a single node.js web app handling AJAX POSTs straight from the browser independently.  I found depending on where in the filter chain express.bodyParser() is, I can get this hang.  I can work around it by emitting a duplicate 'end' event from the request, but I'd like to understand exactly what I'm doing wrong that is causing this.
",focusaurus,2011-01-13 16:37:23
20,2011-05-18 00:23:41,"@focusaurus If you buffer and parse the incoming request of the body before you proxy the request, you can't proxy the original request anymore. 
",Marak,2011-01-13 16:37:23
20,2011-05-18 00:28:15,"Yes that makes sense.  I have removed the bodyParser middleware from my front end web server, but I'm still hitting some variant of this issue on my back end web server, which is using bodyParser but is NOT proxying the request.  Still digging through code to try to understand what other code in my back end web server is waiting for but not seeing the ""end"" event on the request.
",focusaurus,2011-01-13 16:37:23
19,2010-12-05 07:32:35,"I just had this happen, dunno what to do. This could be a problem with optimist?

<pre>$ node-http-proxy --port 8000 --target localhost:8000 --target test.localhost:1234
The 'sys' module is now called 'util'. It should have a similar interface.

node.js:50
    throw e; // process.nextTick error, or 'error' event on first tick
    ^
TypeError: Object true,true has no method 'split'
    at Object.<anonymous> (/Users/david/local/lib/node/.npm/http-proxy/0.3.1/package/bin/node-http-proxy:52:31)
    at Module._compile (node.js:348:23)
    at Object..js (node.js:356:12)
    at Module.load (node.js:279:25)
    at loadModule (node.js:251:12)
    at require (node.js:291:14)
    at Object.<anonymous> (/Users/david/local/bin/node-http-proxy:11:18)
    at Module._compile (node.js:348:23)
    at Object..js (node.js:356:12)
    at Module.load (node.js:279:25)</pre>
",DTrejo,2010-12-08 08:22:58
19,2010-12-08 00:22:57,"You should be passing command line arguments like so: --argument=value:

<pre>
$ node-http-proxy --port=8000 --target=test.localhost:1234
node-http-proxy server now listening on port: 8000
</pre>


I'm also not sure why you have two --target statements. By specifying --port=8000 the proxy server will run at http://localhost:8000, so adding '--target=localhost:8000' is not necessary.
",indexzero,2010-12-08 08:22:58
19,2010-12-08 00:28:42,"Update to CLI parsing in 34cba38c297d6dcb845e95b9e1ce0271da1631d2 so that when --argument=value is not used, the help will be printed:

<pre>
usage: node-http-proxy [options] 

All options should be set with the syntax --option=value
</pre>
",indexzero,2010-12-08 08:22:58
19,2010-12-08 01:12:02,"Thanks for correcting me :)

(I wasn't thinking clearly at that time, and was thinking I could just specify the routing table from the command line, which was wrong of me to think. I did figure everything out though.)
",DTrejo,2010-12-08 08:22:58
18,2010-12-04 10:26:20,"It would be awesome if node-http-proxy could gzip the responses so I could use it to add gzip capability do an ""not-so-modern"" backend server.
",mdornseif,2011-08-28 06:08:36
18,2011-04-29 20:06:31,"+1
",ghost,2011-08-28 06:08:36
18,2011-05-13 05:58:29,"+1
",bluescreen303,2011-08-28 06:08:36
18,2011-06-08 18:27:24,"Is this functionality best suited to be in the proxy code itself? Shouldn't gzip be implemented as a middle-ware? Do other proxy projects suppor this?

Any additional insight would be great @mdornsei
",Marak,2011-08-28 06:08:36
18,2011-06-08 21:53:24,"I've been gzipping in apache and nginx for years.
I count gzipping in the same league as ssl. You don't want your backends to bother with it.
Replacing nginx with node-http-proxy now for websocket support (among other things).
As a frontend proxy/load balancer replacement, I think it's a good feature to have.

But of course a middleware sounds like an OK place too. Depends a bit on the situation I guess.
In my case, I have multiple languages and stacks sitting behind http-proxy. Finding a middleware for all the frameworks in use sounds like a harder task than keeping it in 1 place.
",bluescreen303,2011-08-28 06:08:36
18,2011-06-08 21:58:17,"gzip is something that ryan has recently expressed a desire to have in core, so a streaming gzip parser for node is a top priority!
",indexzero,2011-08-28 06:08:36
18,2011-07-25 04:36:33,"You could use **connect-gzip** to do the dirty work:

<S_CODE_TOKEN>
",tralamazza,2011-08-28 06:08:36
18,2011-08-28 06:08:36,"Closing this since gzip is supported now with `http-proxy` middlewares: https://github.com/nodejitsu/node-http-proxy/blob/master/examples/gzip-middleware.js
",indexzero,2011-08-28 06:08:36
17,2010-11-16 09:14:36,"I got the proxy working with high numbered ports. When using port 80 I (think I) have to use sudo and I then get the error mentioned in the title.
",metamindxx,2010-11-16 17:44:28
17,2010-11-16 09:29:17,"Did you install pool via npm? Are you doing installations via npm with sudo? Not that you have to, but I know there are some issues around doing that. 

I currently sudo my npm installations, so that might be the problem 
",indexzero,2010-11-16 17:44:28
17,2010-11-16 09:37:11,"npm. I installed npm using the ""30 second method"" (top one at https://gist.github.com/579814).

I just tried, and got (i'm a bit of a unix newbe):

:~/node-latest-install$ sudo npm install http-proxy

sudo: npm: command not found

While

:~/node-latest-install$ npm install http-proxy

works fine
",metamindxx,2010-11-16 17:44:28
17,2010-11-16 09:44:28,"Right. That means that npm isn't installed for the root user, so the packages aren't getting loaded from the correct paths when you run a script using http-proxy with sudo. I'm not sure the right approach here honestly. 

Maybe try this: 

<pre>
  curl http://npmjs.org/install.sh | sudo sh
</pre>
",indexzero,2010-11-16 17:44:28
17,2010-11-16 09:54:24,"OK. That seems to have done the trick. I did get a bit of this sort of stuff though:

npm ERR! sudon't! Running npm as root is not recommended!

npm ERR! sudon't! Seriously, don't do this!

npm ERR! sudon't!
",metamindxx,2010-11-16 17:44:28
17,2010-11-16 10:00:40,"Yeah, it's true that it's not recommended, but that's just because isaacs hasn't gotten around to improving safe execution under sudo. He will eventually.
",indexzero,2010-11-16 17:44:28
17,2011-01-13 08:39:13,"I think a good way to do this is run node with an absolute path:

sudo `which node` ./connect -p 80

This allows you to use port 80, but does not require you to hardcode the path.  And, it will use whatever version of node you are currently using under nvm.

Chris
",xrd,2010-11-16 17:44:28
17,2011-01-13 08:40:14,"Hmm, did not come through in markdown.  Here is a better version.

sudo `which node` app.js -p 80
",xrd,2010-11-16 17:44:28
17,2011-01-13 14:20:29,"Nice. I'll try that out. Although it shouldn't it never be run as root and really be an IP Tables setup?
",indexzero,2010-11-16 17:44:28
16,2010-11-03 07:35:11,,indutny,2010-11-10 13:38:53
15,2010-09-28 03:56:32,"Tests, Object cloning improved
",indutny,2010-11-03 01:01:17
14,2010-09-26 03:12:05,"Hi, I download node-http-proxy source package and put the node-http-proxy.js under $Node_Lib path. But I can't find the pool that required in node-http-proxy. So it throw the error. I also can't find this module in github.
Could u help me? Thanks in advanced.
",joson,2010-09-26 15:19:37
14,2010-09-26 07:37:45,"You need to follow the installation instructions and install http-proxy via NPM. pool is a dependency listed in the package.json (http://github.com/nodejitsu/node-http-proxy/blob/master/package.json#L17) that will automatically get installed. 

<S_CODE_TOKEN>

If you want to actually look at the pool project, it's here: http://github.com/mikeal/node-utils/tree/master/pool/
",Marak,2010-09-26 15:19:37
14,2010-09-26 15:06:41,"Thanks a lot.
",joson,2010-09-26 15:19:37
14,2010-09-26 15:19:36,"closed
",Marak,2010-09-26 15:19:37
13,2010-09-17 01:24:27,,indexzero,2010-11-16 17:26:31
13,2010-11-16 09:10:52,"Yup, I get this as well. Is there a way of handling errors due to the proxy targets failing without them crashing the proxy server?
",metamindxx,2010-11-16 17:26:31
13,2010-11-16 09:26:31,"This is fixed in the 0.3.1 branch. I haven't merged it into 'master' yet because there are other changes pending some testing / battle hardening
",indexzero,2010-11-16 17:26:31
13,2010-11-17 08:36:16,"Do you know when this is likely to be?
",metamindxx,2010-11-16 17:26:31
13,2010-11-17 18:08:54,"Not sure, but you can use 0.3.1 whenever you want:

<pre>
  cd /path/to/node-http-proxy
  git checkout 0.3.1
</pre>
",indexzero,2010-11-16 17:26:31
12,2010-09-15 04:40:55,"Hi!
",indutny,2010-11-03 01:01:11
11,2010-09-09 15:07:45,"Is node-http-proxy supposed to support websockets? It seems that websocket are not passed through (according to my testing), is that correct or do I have to configure something differently?
",zefhemel,2011-04-16 07:23:17
11,2010-09-09 15:50:05,"From what I've seen it _should_ work, although we probably should have some tests for proof
",tmpvar,2011-04-16 07:23:17
11,2010-09-09 22:57:39,"i would think it should work as well, but we have no tests in place for websockets.

we are working out cranking out the new version, does anyone want to step up and do a simple vows websocket test?
",Marak,2011-04-16 07:23:17
11,2010-09-10 08:38:41,"Maybe it _should_ work, but according to my testing it does not (I just upgraded to 0.3.0, same result). The server behind the proxy never gets the websocket connection (I'm using socket.io here).
",zefhemel,2011-04-16 07:23:17
11,2010-09-10 08:59:03,"i've been talking to the socket.io author and i think he's gonna help getting some vows tests for websockets / socket.io

if you can create the tests for websockets we can make them pass. if not, rauchg should have something posted soon.
",Marak,2011-04-16 07:23:17
11,2010-09-15 08:20:32,"looks like the fork @ http://github.com/donnerjack13589/node-http-proxy might be a fix for this. has unit tests as well.
",Marak,2011-04-16 07:23:17
11,2010-12-01 11:29:17,"Is this merged yet? If so why not?
",Marak,2011-04-16 07:23:17
11,2010-12-01 11:31:31,"looks like there has been some work on this, going to try to get these tests to pass

https://github.com/nodejitsu/node-http-proxy/blob/master/test/node-http-proxy-test.js#L61

https://github.com/nodejitsu/node-http-proxy/blob/master/lib/node-http-proxy.js#L106
",Marak,2011-04-16 07:23:17
11,2011-04-16 07:23:17,"Fixed in b0b0183c2b54fa63bd2a6f9c92475c7f56d811a3. Needs some more tests before I release v0.5.0, but in the meantime checkout the working demo here: https://github.com/nodejitsu/node-http-proxy/blob/v0.5.0/examples/web-socket-proxy.js
",indexzero,2011-04-16 07:23:17
10,2010-09-09 03:29:13,"was getting a couple of people in the IRC having issues with v0.2.0 of the proxy.

it seems when using the proxy inside of a Connect app, you really need the third API usage.

here is a gist with one of the example usages:
http://gist.github.com/571216

current workaround is to run:

<S_CODE_TOKEN>

this will install http-proxy version 0.1.5, which has support proxying requests inside of an http.Server
",Marak,2010-09-10 03:31:19
10,2010-09-10 03:31:19,"This has been fixed in 0.3.0, there are also large performance boosts so I would strongly urge you to upgrade. 
",indexzero,2010-09-10 03:31:19
9,2010-08-27 13:24:05,"I want to proxy out multiple web servers running on a single ip address with different host names.  I need to be able to listen to port 80 and, depending on the domain name, serve up the respective website.
",dcinzona,2010-11-22 13:22:16
9,2010-08-28 23:33:52,"So, you can achieve this relatively simply by using a router. We could add some basic functionality for making this easier, but in production we use a router to handle this.

We are a bit tied up with node knockout this weekend, but I'll make sure to revisit this request.
",Marak,2010-11-22 13:22:16
9,2010-08-29 19:22:03,"Awesome, good luck guys.  I would love to revisit this...
",dcinzona,2010-11-22 13:22:16
9,2010-11-22 05:22:16,"Fixed in 0.3.1

<pre>
npm install http-proxy@0.3.1
</pre>
",indexzero,2010-11-22 13:22:16
9,2010-11-22 13:02:14,"siiiiiick
",dcinzona,2010-11-22 13:22:16
8,2010-08-15 23:23:13,,Marak,2010-08-16 07:47:06
8,2010-08-16 00:47:06,"I think that this would be best accomplished by an intermediate http-cache like varnish. 
",indexzero,2010-08-16 07:47:06
7,2010-08-02 20:38:32,,Marak,2010-08-03 02:34:41
7,2010-08-03 02:34:40,"done
",Marak,2010-08-03 02:34:41
6,2010-08-02 20:38:11,,Marak,2010-09-09 03:24:33
6,2010-09-06 08:24:59,"this is actually critical. by creating a new http.Client every time and using the default 2 minute timeout for http.Client requests, we run a serious risk of having too many FD handlers open at once.

we need to fix this asap, as during high traffic spikes its possible to hit default FD limits (1024 in most cases)
",Marak,2010-09-09 03:24:33
6,2010-09-09 03:24:33,"new code has been implemented, FD problem seems to have gone away.
",Marak,2010-09-09 03:24:33
5,2010-07-29 08:19:02,"http://server.com/foo reversed to http://internal-server1/foo
http://server.com/bar reversed to http://internal-server2/bar
",dready92,2010-11-22 05:21:02
5,2010-07-29 14:50:35,"Hello! I'm a little confused about this.

The current implementation should pass the original request object which will contain a ""url"" property. 

Can you explain how this implementation doesn't achieve the functionality you want? Are you talking about parking a router in-front of the reverse proxy so you can dynamically route requests?

Could you possibly write a test case or perhaps pseudo code what the api for this would look like?

Thanks!
",Marak,2010-11-22 05:21:02
5,2010-07-30 13:35:12,"You're right, certainly it wasn't a good day yesterday ! Anyway I was thinking to a sort of  a thin ""router"" layer on top of that to automate a little bit the process.

As an example : if you want to reverse proxy http://www.server.com/foo to http://server1.local/foo , instead of having to :
- modify the URL property of the request
- check for the response headers of server1.local and rewrite the ""Redirect"" header if any
- and perhaps some other things I don't think of now

just have something to predefine route, a bit of code to illustrate :

<S_CODE_TOKEN>

That way you provide features for common reverse-proxying needs, ex cookie rewriting, load-balancing, encoding ...
",dready92,2010-11-22 05:21:02
5,2010-07-30 16:59:34,"Okay, that makes a lot of sense. 

The codebase we extracted this from does have a router and (somewhat of a) load balancer. I didn't want to clutter http-proxy api, but you do have a valid point. While having the raw access to httpProxy.proxyRequest() is great, most people will want the more advanced functionality you mentioned. 

I could write a new router for this, or use a pre-existing one. I'm going to think on this for a few days and determine the best plan of attack. It's important to me that we keep the api clean, but I think there is a good solution to be had here. Hopefully I'll have a patch by next week.

In the meantime, do you think you could elaborate on the functionality you mentioned of cookie rewriting and encoding? 

Thanks a lot for your feedback, it's much appreciated.  
",Marak,2010-11-22 05:21:02
5,2010-11-22 05:21:01,"Fixed in 0.3.1:

npm install http-proxy@0.3.1
",indexzero,2010-11-22 05:21:02
4,2010-07-27 07:01:20,,indexzero,2010-07-28 05:11:09
4,2010-07-27 21:40:53,"very close now. going to take a final run over entire project and submit to charlie for release candidate. 
",nodejitsu,2010-07-28 05:11:09
4,2010-07-28 05:11:09,"done and done
",nodejitsu,2010-07-28 05:11:09
3,2010-07-27 07:01:13,,indexzero,2010-07-27 21:27:05
3,2010-07-27 21:26:34,"I started to implement this feature, but the API for it didnt really make sense, i'm gonna close this ticket for now.

// create regular http proxy server
     httpProxy.createServer('localhost', 9000, function (req, res){
          sys.puts('any requests going to 8002 will get proxied to 9000');
     }).listen('localhost', 8002);

just doesnt seem right
",nodejitsu,2010-07-27 21:27:05
3,2010-07-27 21:27:05,"closed for now
",nodejitsu,2010-07-27 21:27:05
2,2010-07-27 07:00:57,,indexzero,2015-10-30 20:34:16
2,2015-10-30 20:34:16,"This should be handled in a third party module.
",jcrugzz,2015-10-30 20:34:16
1,2010-07-27 07:00:36,,indexzero,2010-07-27 20:34:18
1,2010-07-27 20:34:18,"removed, added a depo to package.json, tested. 

had to update colors npm package as well. 
",nodejitsu,2010-07-27 20:34:18
