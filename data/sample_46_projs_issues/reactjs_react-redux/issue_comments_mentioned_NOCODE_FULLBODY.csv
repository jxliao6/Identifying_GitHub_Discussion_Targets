issue_num,datetime,body,login,mention_login
652,2017-03-20 13:35:11,"@ugogo  Yes that's what I did ... console.log(Provider) print ""undefined"" .. :(",arsenalol69,ugogo
652,2017-03-20 13:39:24,@arsenalol69 Can you provide a repo so that we can have a look?,ugogo,arsenalol69
652,2017-03-20 13:46:24,"@ugogo Thanks for your help :) Here is the git repo : https://github.com/arsenalol69/react-redux-exemple
EDIT : The code is inside ./app/containers/AppContainer.js",arsenalol69,ugogo
652,2017-03-20 13:57:34,"@arsenalol69 Hah, you're using react-native. Redux 5^ is not supported. Please refer to the [README](https://github.com/reactjs/react-redux#react-native) 😉 ",ugogo,arsenalol69
652,2017-03-20 14:09:41,"@ugogo The Readme says that 
> React Redux 5.x should work with React Native

I also try to run `npm ls react` and I only have `-- react@15.4.2`
So it should work no ?",arsenalol69,ugogo
652,2017-03-20 15:59:07,"@ugogo No problem :) Thanks for your help !
@timdorr I just tested to delete the folder, and re-install the module again but still the same problem ..",arsenalol69,timdorr
652,2017-03-20 15:59:07,"@ugogo No problem :) Thanks for your help !
@timdorr I just tested to delete the folder, and re-install the module again but still the same problem ..",arsenalol69,ugogo
652,2017-03-21 09:28:35,@jimbolla I don't understand why u want me to try a Jest test ? I has never used it and it will just try to run the project as I do myself... Maybe I just misunderstood the utility of the tool...,arsenalol69,jimbolla
650,2017-03-14 17:09:40,"Was about to write exactly what @timdorr wrote - you can pass the store as prop:

https://github.com/reactjs/react-redux/blob/master/src/components/connectAdvanced.js#L122",BTMPL,timdorr
650,2017-03-15 06:30:23,"@everdimension : yeah, there's an FAQ entry that addresses that: http://redux.js.org/docs/faq/StoreSetup.html#store-setup-multiple-stores .  Basically, accessing the store via context acts as a lightweight dependency injection mechanism, thus making it easier to test components, less hassle passing the store down, component reuse, etc.",markerikson,everdimension
648,2017-03-13 22:12:38,"As @markerikson said, you're better off doing that optimization inside `mapStateToProps`.",jimbolla,markerikson
647,2017-03-09 19:44:30,"I don't have 1 month in React/Redux, so, I'm pretty new at it.

And you're right @markerikson, I was trying to say that I want multiple components to use the same matpStateToProps function, without creating other Containers, just determining the component by using the connect(props, dispatchs)([component1, component2, component3)",DanZeuss,markerikson
647,2017-03-09 19:52:28,"Yeap, and I'm doing this. I just wish verify if would be a nice implementation by doing as I said before. Thanks anyway @markerikson ",DanZeuss,markerikson
644,2017-03-08 05:42:42,"Sorry about that @markerikson, I did check the opened Issues but I didn't checked the opened PRs. Well, I hope that PR gets merged soon. Thanks!",josepot,markerikson
640,2017-03-03 23:49:02,"Thanks for the input, @markerikson. I changed the calling of `playFile` to `playFile(sectionArray[0],sectionArray)(dispatch)` and it's working now.",natashache,markerikson
640,2017-03-04 00:23:33,@gaearon thanks! It definitely reads better that way.,natashache,gaearon
636,2017-03-18 13:29:09,I'm also able to perform the steps listed by @basilfx above to show how the ancestor connectAdvanced component's call to onStateChange() does not trigger an update to to the child component which should be updated.,jsonnull,basilfx
636,2017-03-22 15:22:01,"Damn, just having the same issue. Unfortunately with both 5.0.2 and 5.0.3. Performing the steps suggested by @basilfx forces the update and the page renders correctly.",namxam,basilfx
631,2017-03-09 11:29:34,"@data-doge 
Hi, I have same issue when I build only for production with webpack. Kindly, any update??",okmttdhr,data-doge
631,2017-03-12 18:35:56,"@okmttdhr 

ey, we just locked react-redux to `5.0.2` and moved on.

wish i could be more helpful! ",data-doge,okmttdhr
631,2017-03-13 14:37:24,"@data-doge Any chance you can reproduce that error with source maps enabled so we know what line of code is actually causing the problem? That stack trace is from a minified bundle.

@jimbolla Any idea what's up here? ",timdorr,data-doge
628,2017-02-22 15:28:19,"@jquense  For consistency, can you change the one in [Provider](https://github.com/reactjs/react-redux/blob/master/src/components/Provider.js#L54) as well?",jimbolla,jquense
628,2017-02-22 18:02:00,@jimbolla Took care of that. Put our shape definitions in one spot.,timdorr,jimbolla
627,2017-02-22 18:05:09,"@dbyzero Where is `react-dom` in your dependencies? It is possible you get this problem because you have mismatching versions of `react` and `react-dom`. Verify you have only one of each in `node_modules`, and that their versions are exactly the same.",gaearon,dbyzero
625,2017-02-17 19:40:55,@markerikson Yeah. I think https://github.com/reactjs/react-redux/issues/507#issue-179829234 explains why sCU isn't a requirement anymore.,jimbolla,markerikson
625,2017-02-18 02:44:24,"Yeah, that was really meant for @jimbolla .

Looking at that deleted couple lines, I'm pretty sure `sCU` is still necessary for preventing re-renders from parents, and that without it, the wrapper is really only able to deal with changes from `map*`-related values.

Although re-reading Jim's comment from the other thread, maybe I'm misunderstanding this?",markerikson,jimbolla
622,2017-02-16 12:58:48,@timdorr thank you!,TrevorHinesley,timdorr
620,2017-02-11 17:14:28,@jimbolla I didn't know that this was mutating the state 👍 . However the issue at hand is not resolved by implementing the suggestion. I still have the exact same behavior. Any other things that this could cause?,nealoke,jimbolla
620,2017-02-11 17:32:27,"@jimbolla Also when using the destructuring redux no longer updates the state correctly. It says the state is equal. See attachements

**Redux state**
![image](https://cloud.githubusercontent.com/assets/17417414/22855927/375eacb6-f088-11e6-81d9-17e898acf029.png)
 
**Action**
![image](https://cloud.githubusercontent.com/assets/17417414/22855936/5325649e-f088-11e6-9b8c-2cf4f528a18e.png)

**Diff**
![image](https://cloud.githubusercontent.com/assets/17417414/22855940/6b3be026-f088-11e6-8092-1005ca647446.png)
",nealoke,jimbolla
619,2017-02-28 03:15:57,"@timdorr @dsgkirkby Hi, this seems to be still broken.

Please see

https://github.com/reactjs/react-redux/issues/636

Thanks",BerndWessels,timdorr
619,2017-02-28 03:15:57,"@timdorr @dsgkirkby Hi, this seems to be still broken.

Please see

https://github.com/reactjs/react-redux/issues/636

Thanks",BerndWessels,dsgkirkby
616,2017-02-05 20:05:59,"@jimbolla no problem, test added",lukeapage,jimbolla
610,2017-01-27 20:12:22,"@timdorr _

> you would just issue actions to your redux store and each component would subscribe to the relevant bits of state.

_Could please relavent reference or  sample piece code to better understanding. 

Exact issue I am not able to reslove dispatch action  updating source component but not getting update data in other component.

![screenshot from 2017-01-28 01-30-04](https://cloud.githubusercontent.com/assets/13597781/22385980/fb79beae-e4fa-11e6-9e14-0ba3770048f2.png)
",iiitmahesh,timdorr
610,2017-01-27 21:00:22,@timdorr Thank you.,iiitmahesh,timdorr
609,2017-01-26 22:02:45,"Thanks for the solution guys, got it going with what @markerikson suggested but the option of enhanced profile seems very clean as well, thanks!",oshalygin,markerikson
606,2017-01-23 02:54:14,"@jimbolla Oh,you're right, thanks",crimsonskyrem,jimbolla
603,2017-01-19 21:11:48,"Sounds like he's saying this doesn't exist in 5.0, which is true.

@ipluser I appreciate the effort here, but 4.x is in bugfix-only mode. If you need this kind of behavior, switch to 5.0, which shouldn't involve any code changes on your end.",timdorr,ipluser
603,2017-01-20 02:20:55,"@jimbolla  @timdorr 

As you say, our framework depend on **react-redux@4.x**, we plan to upgrading **react-redux** to v5 and increment framework **MAJOR** version, not MINOR.

e.g.



I'm happy to see **react-redux@5.x**, it's nice for **compatibility**, **performance improvements** and others features.
But sometime, something isn't controlled by me, I have to think about that the framework must be stable, safe and other.

I can't promise that anything is ok if I upgrading **react-redux** to v5 and increment framework **MINOR** number.
It may bring some hidden problems, it has some risk. 

So I want to fix this issue for currently framework with **react-redux@4.x**.
And next, I will plan to upgrading **react-redux** to v5 and increment framework **MAJOR** version.",ipluser,timdorr
603,2017-01-20 02:20:55,"@jimbolla  @timdorr 

As you say, our framework depend on **react-redux@4.x**, we plan to upgrading **react-redux** to v5 and increment framework **MAJOR** version, not MINOR.

e.g.



I'm happy to see **react-redux@5.x**, it's nice for **compatibility**, **performance improvements** and others features.
But sometime, something isn't controlled by me, I have to think about that the framework must be stable, safe and other.

I can't promise that anything is ok if I upgrading **react-redux** to v5 and increment framework **MINOR** number.
It may bring some hidden problems, it has some risk. 

So I want to fix this issue for currently framework with **react-redux@4.x**.
And next, I will plan to upgrading **react-redux** to v5 and increment framework **MAJOR** version.",ipluser,jimbolla
602,2017-01-19 17:25:03,"@markerikson Well, part of the reason why I love Redux so much is that it's very minimalistic and both understanding the internal logic and writing extensions is so easy. If need be I'll make it into a package, but I really believe that basic support for HMR should be built into Redux, that's why I initially decided to open a ticket for it.
@jimbolla You're right, it should have been a ticket for the Redux repository. When I first opened the ticket I wasn't sure about that because I thought maybe the Provider can be modified to support this feature, but after some more research and writing the snippet I provided it's clear as day that this isn't the place. Furthermore, I'd really like to see your overall solution for store enhancers, it sounds like the right approach! When you're ready, of course :)",iMoses,jimbolla
602,2017-01-19 17:25:03,"@markerikson Well, part of the reason why I love Redux so much is that it's very minimalistic and both understanding the internal logic and writing extensions is so easy. If need be I'll make it into a package, but I really believe that basic support for HMR should be built into Redux, that's why I initially decided to open a ticket for it.
@jimbolla You're right, it should have been a ticket for the Redux repository. When I first opened the ticket I wasn't sure about that because I thought maybe the Provider can be modified to support this feature, but after some more research and writing the snippet I provided it's clear as day that this isn't the place. Furthermore, I'd really like to see your overall solution for store enhancers, it sounds like the right approach! When you're ready, of course :)",iMoses,markerikson
599,2017-01-08 16:23:36,@jimbolla I get the error getChildContext is not a function. Am I missing something?,MartinDawson,jimbolla
599,2017-01-08 17:41:31,"@jimbolla That worked and is exactly what I needed. Thank you so much. If you want the bounty on SO I will award it to you if you copy that answer. If not, I shall post the answer and link here.",MartinDawson,jimbolla
599,2017-03-18 21:54:43,"Thanks @jimbolla for this answer, it was exactly what I was looking for.  Question:  what kind of performance hit should we expect from always using props now in our `mapStateToProps` and `mapDispatchToProps`?",neurosnap,jimbolla
599,2017-03-18 23:36:56,"@neurosnap : erm... ""performance hit"", as compared to _what_? :)",markerikson,neurosnap
593,2017-02-17 01:55:14,"@shlajin I'm not sure this is a redux issue. I believe React TransitionGroup relies on the key internally, so `key` should be unique at all times. Try this:
 ",toddsby,shlajin
593,2017-02-17 02:39:44,@toddsby is correct. This is an issue dealing with TransitionGroup. I'd also recommend giving react-motion a look-see too.,timdorr,toddsby
592,2016-12-31 23:35:39,Also thanks for your help @markerikson. If you want I can try to come up with a gist that has a reproduction of the areMergedPropsEqual method not being called. Though all of the key info is in my snippet in the original comment. ,bdwain,markerikson
592,2016-12-31 23:50:18,@jimbolla won't shouldComponentUpdate do that? It seems to work in my specific case at least.,bdwain,jimbolla
589,2016-12-28 22:10:57,"Thanks @jimbolla  - the general idea is that this should work:



If I'm not mistaken, `<Bar>` should subscribe to its `ownStore` as if it were its own `<Provider>` (because it essentially is) instead of depending on parent subscriptions.",davidkpiano,jimbolla
589,2017-01-31 04:33:55,"@jimbolla , @timdorr : following up on this at @davidkpiano 's request.  It's Jim's code thus far, and Tim's been cutting releases (something I should go figure out for myself at some point, but don't have time to dig into atm).  Are we good to go on this?",markerikson,jimbolla
589,2017-01-31 04:33:55,"@jimbolla , @timdorr : following up on this at @davidkpiano 's request.  It's Jim's code thus far, and Tim's been cutting releases (something I should go figure out for myself at some point, but don't have time to dig into atm).  Are we good to go on this?",markerikson,davidkpiano
589,2017-02-05 17:05:17,@timdorr @markerikson It might be easier to review the 2 commits separately. The bugfix one is pretty small and the refactor one just moves a few things and adds some more comments.,jimbolla,timdorr
589,2017-02-05 17:05:17,@timdorr @markerikson It might be easier to review the 2 commits separately. The bugfix one is pretty small and the refactor one just moves a few things and adds some more comments.,jimbolla,markerikson
589,2017-02-14 14:52:55,@timdorr please release this fix,anru,timdorr
589,2017-02-28 02:17:43,"@timdorr The `react-redux 5.0.3` update breaks HMR with latest `react-hot-loader 3.0.0-beta.6`.

Basically after a hot-reload the state is somehow broken.

This worked fine in `react-redux 5.0.2` :(


repo to reproduce: https://github.com/BerndWessels/react-redux-rr4-wp2-rhl3.git

Work fine with `react-redux 5.0.2` but broken when you upgrade to  `react-redux 5.0.3`",BerndWessels,timdorr
588,2016-12-30 17:59:42,@osigum Can you provide more details? What does you store creation look like? What does your top-level component look like? Are you using the latest versions of react/redux-form/etc? There's not quite enough here to troubleshoot without making assumptions.,jimbolla,osigum
582,2016-12-21 16:53:59,"> Are you updating the first store, but expecting a component inside the second <Provider> to respond to that update?

Nop. Everything inside the ""mini app"" is self contained. So something inside send an action and update its own reducer. I only expect the mini app to be updated. The ""parent app"" has nothing to do with that.

I'm making another small project to reflect the issue. Stay tuned.

@jimbolla Maybe it's not the usual use case, but I'm having the issue because my ""mini app"" can live as a standalone application, but also embedded inside another app.
",tleunen,jimbolla
582,2016-12-21 17:44:42,"@jimbolla : I'd say that if we can fix it without much hassle, then we might as well go ahead and do so.  Sounds like it's ""just"" a matter of adding a couple more entries to context, right?",markerikson,jimbolla
578,2016-12-21 16:49:36,@fabiozaffani What is your current status with this?,jimbolla,fabiozaffani
577,2016-12-15 06:02:56,"Awww.  Why couldn't people find these _before_ we released 5.0.0 final?  :(

Thanks for the report, @ericm546 .  Appreciate it!",markerikson,ericm546
576,2016-12-17 16:44:25,I agree with @appden here. For instance `shallowEqual` in react-redux doesn't account for `NaN`. If an object contained any `NaN` value then `shallowEqual` would always return `false`.,jcready,appden
575,2016-12-14 19:11:05,"@jimbolla If you have some complex containers, that connect some components on different levels of result tree, the scenario with `<Container propName=""propB""/>` suggests passing `propName` from outer component to inner component. `Provider` component is really great thing because it passes `store` in tree context. I think that passing `propName` is a step back in this circumstances.

@markerikson Isn't it a good decision to add some component to `react-redux` (just like `Provider`) that makes this context and store manipulations?",verkholantsev,jimbolla
575,2016-12-14 19:11:05,"@jimbolla If you have some complex containers, that connect some components on different levels of result tree, the scenario with `<Container propName=""propB""/>` suggests passing `propName` from outer component to inner component. `Provider` component is really great thing because it passes `store` in tree context. I think that passing `propName` is a step back in this circumstances.

@markerikson Isn't it a good decision to add some component to `react-redux` (just like `Provider`) that makes this context and store manipulations?",verkholantsev,markerikson
575,2016-12-14 19:22:58," @verkholantsev : there's too many different potential use cases out there to try to implement things here in `react-redux`.  That's part of why there's so many different third-party libraries.  There was actually a good article just today on a related topic, entitled [""Libraries shouldn't support everything""](http://staltz.com/libraries-shouldnt-support-everything.html).

That's not to say that it's _impossible_ to implement some kind of ""isolation"" approach in `react-redux`, or that it's an ""absolute never"" that such a thing would be implemented, but I definitely don't see us adding anything like that in the near future.",markerikson,verkholantsev
574,2016-12-14 17:02:50,@jimbolla looks like just copy paste mistake. Sorry.,btd,jimbolla
574,2016-12-14 17:24:30,@timdorr thanks 👍,btd,timdorr
571,2016-12-14 04:16:05,@gaearon thank you much!,toranb,gaearon
564,2016-12-10 14:35:00,"I plan to take a loot at this today. Thanks, @pilaas.",jimbolla,pilaas
564,2016-12-10 20:23:52,Ah. The good news is this seems to be fixed if built against the head of `next` branch. @timdorr Any chance we can push an rc2?,jimbolla,timdorr
551,2016-11-27 18:43:18,"@markerikson wow, thanks, I'll try))",BjornMelgaard,markerikson
544,2016-11-16 16:52:57,"Ah ha! I was right! 😄 

Thanks for the follow up, @JoaoMosmann 
",timdorr,JoaoMosmann
541,2016-11-17 15:11:36,"@aikoven 

> But for the case when second argument is object, I think we must include another signature, because in this case TDispatchProps is constrained to object of action creators, not just any object.

We ask `mapDispatchToProps` to be a `MapDispatchToPropsObject & TDispatchProps`

Not sure I understand.

And I tried 



can' t get past



TS won't associate



with


",bbenezech,aikoven
541,2016-11-21 10:52:42,"@bbenezech I've created a PR for your PR :) https://github.com/bbenezech/react-redux/pull/1

Added tests. Some of them fail because of `MapDispatchToPropsObject`, particularly:

The first one should fail, the second one shouldn't. But we can't check it correctly because we don't know beforehand what kinds of values can be `dispatch`ed. So it seems that we have to allow `mapDispatchToProps` to be any object with function values.",aikoven,bbenezech
541,2016-12-01 14:22:31,"@aikoven I narrowed allowed Actions. I am quite satisfied with the result. It fixes your test failure (i.e. it now fails). There is a very tiny little hack for Thunks (we provide the wrong return type if TDispatchProps is not provided, covariantly compatible of course), but it is going to make everyone life's so much easier I think it is a must. I added tests around it to be sure that behavior is perfect in any cases.

Have a look and tell me what you think.",bbenezech,aikoven
541,2016-12-14 14:42:53,@timdorr Awesome thanks!,bbenezech,timdorr
541,2016-12-26 07:24:53,"@bbenezech Why don't we use Partial<T> type (introduced in Typescript 2.1) for annoying TOwnProps, TStateProps, TDispatchProps things? we can just pass two type arguments to connect: TState and  TProps.
",rokoroku,bbenezech
541,2016-12-26 08:12:41,@rokoroku What's your intended use of `Partial` here?,aikoven,rokoroku
541,2016-12-26 08:53:21,"@aikoven We can simplify things. Writing types for every TOwnProps, TStateProps, TDispatchProps is really cumbersome, and Partial\<T\> is very useful for reducing them.

For example,

##### with given redux state


##### suggested (with partial)



##### current (without partial)


(Note: above code is just an example.)",rokoroku,aikoven
541,2016-12-26 10:25:25,"@rokoroku It's not really accurate.


In this case, props of connected component (the one returned from `connect(...)(Component)`) should have type `{}`, because both `todos` and `addTodo` are provided by `connect`. By using `Partial` we'd get `{todos?: ..., addTodo?: ...}` which is not correct.

Btw, TypeScript doesn't yet work well with decorators that change the type of decorated stuff, which `connect` does indeed.

To avoid having to set all generic arguments, you can use this:

i.e. let TypeScript infer everything for you by just specifying types for `mapStateToProps`/`mapDispatchProps` arguments.",aikoven,rokoroku
541,2016-12-26 11:15:32,"@aikoven However, we already set strict type here:  
So the component will follow ``MyProps``, not ``Partial<MyProps>``.

Can't we add some abbreviated definitions while preserving existing definitions?
(And of course, I'm using the way you gave me :) )",rokoroku,aikoven
541,2017-03-17 16:25:58,"@theduke They are totally usable and include a lot of improvements over the DT ones.
If you add them to your app, simply nest them like this:

and remove the @types/react-redux package.

It may change a bit before release, but unless you have thousands of connected components, this should not be of concern.

@maclockard lack of time, sadly. I do not use this part of the API, I have no time to investigate atm.
Any help is welcome.",bbenezech,theduke
541,2017-03-17 16:25:58,"@theduke They are totally usable and include a lot of improvements over the DT ones.
If you add them to your app, simply nest them like this:

and remove the @types/react-redux package.

It may change a bit before release, but unless you have thousands of connected components, this should not be of concern.

@maclockard lack of time, sadly. I do not use this part of the API, I have no time to investigate atm.
Any help is welcome.",bbenezech,maclockard
541,2017-03-17 20:22:20,"@bbenezech thanks for the update, glad to hear.",theduke,bbenezech
540,2016-11-15 20:53:00,"@timdorr Currently swamped with other things. Will perf test when I have a large block of time. Hopefully this weekend.
",jimbolla,timdorr
540,2016-11-21 05:48:40,@timdorr why remove the provider api? I want to use this compat mode for redux-form components but want everything else in the app to use the efficient sub ordering. Having to set this on each connected component seems an unnecessary chore. have it be defaulted to true in 5.0 but why make opting into performance more difficult than it needs to be?,gnoff,timdorr
540,2016-11-21 07:19:29,This works but it also means code modding / find replacing a large number of files with the need to do so again as soon as 5.1 comes out. I'm not adamant that this get added back in but the trade offs aren't cost free for users ( I realize they aren't cost free for the lib either since it requires supporting ). I could be misguided here but I think the cost is higher on lib consumers. Just lending my annecdote to @jimbolla intuition that a configurable global default might be desired.,gnoff,jimbolla
540,2016-11-21 14:45:04,"@timdorr I'll concede taking it out of provider, but we should leave in the ability to pass the setting from props/context. Props is especially important if you want to control it through a library such as redux-form that hides the `connect` call. ",jimbolla,timdorr
540,2016-11-21 19:49:07,"@jimbolla Yeah, I think that works better. Maybe call it `connect.setDefaultReact15CompatibilityMode()` so it's clear that it's global and changes the default.",timdorr,jimbolla
540,2016-11-21 22:17:02,@jimbolla @timdorr @markerikson thanks all,gnoff,timdorr
540,2016-11-21 22:17:02,@jimbolla @timdorr @markerikson thanks all,gnoff,jimbolla
540,2016-11-21 22:17:02,@jimbolla @timdorr @markerikson thanks all,gnoff,markerikson
539,2016-11-07 23:06:59,"@markerikson oops, I meant submit this to a completely different project, I guess I had the wrong window open.  my bad
",clindsey,markerikson
538,2016-11-08 12:37:12,"@aikoven 



You are not type checking StateProps return. If you typo your hash, you won't know it. Thus you actually want:



But then why not simply



The advantage is you get an error if you forget one of the generic argument, whereas you might forget to type check return types, argument types and lose some type checking, hence my warning, that was mostly directed to newcomers.
",bbenezech,aikoven
538,2016-11-08 14:13:42,"Job's done! 🎉 
Thanks for your time @aikoven ! Your review was terrifically spot on! 🎯 
",bbenezech,aikoven
538,2016-11-09 16:55:07,"@bbenezech Can you rebase against `next` and switch out the base for this PR (hit Edit at the top of the page)? Thanks!
",timdorr,bbenezech
538,2016-11-09 20:35:30,"@bbenezech Looks like there's a conflict because the git branch isn't based on `next`. Can you rebase and force push your branch? I don't know if I can do that on my end with the collaborator permission on the PR. Thanks for working with me on this! 👍 
",timdorr,bbenezech
538,2016-11-09 21:01:48,"@timdorr I can't change my own branch in edit. I opened a new PR.
",bbenezech,timdorr
534,2017-01-10 12:43:26,@jimbolla I include only once **react-redux** at each component where **connect** is required :(,plandem,jimbolla
534,2017-01-10 13:14:18,"@jimbolla 

1) I have npm package with component that connects to redux (so it has dependency on **react-redux**). let's name it **MyProvider**

2) in my application I also connect other components, so it depends on **react-redux**

I moved **MyProvider** from npm package directly to application and there is no error anymore.

Is problem here? ",plandem,jimbolla
534,2017-01-10 14:29:36,"@plandem My problem was that I was creating two bundles: `common.js` and a page-specific js file. Because of an error in the way I was bundling, the code for react-redux ended up in both bundles.",chrisvasz,plandem
533,2016-11-01 01:27:31,"For consistency, this should be done against the `next` branch instead, where we're binding `getState`, as @taion pointed out. Plus, it would be a good stress test to try and use that new branch with a reimplementation of Redux 😄 
",timdorr,taion
530,2016-11-16 15:58:21,"Hey @sethcall . I'm trying to do the same thing and struggling to reach the solution. Would you mind posting a gist?
",stephmilovic,sethcall
528,2016-10-22 21:47:24,"<s>@timdorr Where can I find the official lodash next npm module?

Nevermind - got the repos mixed up.
",kzc,timdorr
525,2016-10-19 17:22:53,"@markerikson Indeed it is.

As another experiment, I just tried [switching React for Preact](https://preactjs.com/guide/switching-to-preact) in my own project and the bug goes away.
",jimbolla,markerikson
525,2016-10-24 16:09:13,"Hey @jimbolla Sorry didn't see your reply - I just removed my comment as I realised it was a different issue and didn't want to pollute this issue. I was still using `15.0.0` and the cursor fix was in `15.0.1`
",johnnycopperstone,jimbolla
525,2016-10-24 16:33:57,"@timdorr True, but our answer can't just be ""use Preact instead"" unfortunately. What I'm thinking...
- IMO, the new top-down ordering is the ""right"" way to do it, and much of the perf gains and many of the bug fixes are because of it. We could remove it, but that undoes a lot of the benefits of v5.
- This does seem like a bug in React that the new subscription ordering is exposing, but one that doesn't seem easy to fix, and even if it was, that fix wouldn't make it to release in a timely fashion, such that we can ignore it. I did pull and build react master, and the bug still exists.
- I'm guessing this bug might manifest itself in react-redux v4 if redux were to fire subscriptions in reverse order because of how it relates to the timing of which components receive new props first. I might try test this just for awareness of the issue.
- If we keep top-down as the default behavior, we need to make it as painless as possible to work around this issue, and make devs aware of it.
  - While it's certainly solvable in userland using the code provided above, I'd hate to force that on everyone, lest we be accused of creating javascript fatigue. 👅
  - The best solution I have right now is for `connect` (actually `connectAdvanced`) to offer an opt-in option that would allow that component to skip the subscription tree and subscribe directly to the store, making it work like v4. Devs that are using controlled text inputs would have to set this option to true. I don't know what to name this option. Libraries like redux-form would have to handle this as well. Docs would have to stress this as it's a bug that isn't discovered easily, because I doubt many devs test entering values in the middle of an input.
",jimbolla,timdorr
525,2016-10-26 09:28:17,"@gaearon 
[repro with react only](http://www.webpackbin.com/E1rDED_1f): 


",Guria,gaearon
525,2016-10-26 13:27:01,"@Guria If you _change_ the value right after input, the cursor jump is expected. React can't guess where to put the cursor. So that is not a bug.
",gaearon,Guria
525,2016-10-26 13:28:46,"@jimbolla This does not look like a bug to me. It is documented that `this.state` contains _the rendered_ value of the state. There is no guarantee that calling `setState()` will update `this.state` synchronously. Therefore, by reading from `this.state` you won't get the just-updated value.
",gaearon,jimbolla
525,2016-10-26 13:50:59,"@gaearon But It's happening as part of the callback of setState(), which _should_ have the new state. But even still, if I store the state in a global variable and read from there instead of component state, it behaves the same way. This seems more related to when React reconciles the current value of the input's value prop with what's actually in the DOM element. Basically, by the time the callback to setState fires, it's too late. I can update the code to make this more clear.
",jimbolla,gaearon
525,2016-10-26 14:13:25,"@gaearon I updated my above example to use global variable. You can toggle the `makeTheCursorJump` variable to see the 2 different behaviors. This is the core difference between react-redux master and next in its simplest form. A lot of the perf gains and the bugfix related to props/state being out of sync boiled down to this change.
",jimbolla,gaearon
525,2016-11-08 20:55:29,"@jimbolla Can you submit a PR to React with a test case for this?
",gaearon,jimbolla
525,2016-11-08 21:48:28,"I confirmed commit https://github.com/facebook/react/commit/5f49b63bde09567fb3d52a13e3e264dfcda5cac6 (PR https://github.com/facebook/react/pull/8204) is the commit that fixes the problem. Bug exists when the above demo is run against its parent, but doesn't when run against it.

I'll see what I can do about turning that code above into a complete test, but admittedly, this will be pushing the limits of my JS/testing abilities. Assuming I can turn it into a test, do I submit it as a PR to react master?

I still need to test react-redux@next against react master to confirm the fix. I'm probably like 85% sure that it will work though.

@gaearon Do you have any insight into when React v16 might launch? Are we sure 8204 will be a part of that and not a 15.x minor release?

Is our plan to not release react-redux v5 to stable until we can bump our React dependency to whatever version includes the fix? If so, do we want to offer an interim solution for the users that want to use the beta? Something like:



This would be a temporary feature that bypasses the subscription ordering.
",jimbolla,gaearon
525,2016-11-09 17:56:03,"> Yes, we can't release a stable version of React Redux that is incompatible with the stable version of React.

We'll do it within a set of 5.0 and 5.1 releases. 5.0 goes with React 15 and has this extra option for those that need it; 5.1 goes with React 16 and doesn't need the option (basically, it switches default to enabled). Hence the 5.1 milestone on this issue :)

@jimbolla Can you prep a PR to add the option to reorder the subscriptions? Maybe call it `reorderSubscriptions`? It doesn't need to be lengthy and scary. It would be ignored in 5.1. 
",timdorr,jimbolla
525,2016-11-10 00:07:18,"@jimbolla If you're able to make a simple test case depending only on React that exhibits the issue in a browser but you're struggling with jsdom, that would be very helpful and I can look at turning it into an automated test.
",spicyj,jimbolla
525,2016-11-10 00:13:53,"@spicyj https://github.com/reactjs/react-redux/issues/525#issuecomment-256181787 is basically that. I just used create-react-app and then wrote that in App.js
",jimbolla,spicyj
525,2016-11-10 16:11:32,"@jimbolla With the compat option on, does the perf regress over 4.x? What is the main benefit of 5.x for the people while it's enabled?
",gaearon,jimbolla
525,2016-12-05 16:46:42,"@spicyj I was just wondering if you were able to make an automated test from this. If so, I'd like to see it for my own education.",jimbolla,spicyj
523,2017-02-17 14:42:54,"Any update on this, @neeharv?",timdorr,neeharv
523,2017-02-18 07:24:01,@timdorr this slipped my mind completely! I'll work on the changes requested over this weekend,neeharv,timdorr
523,2017-02-18 08:19:27,@timdorr @jimbolla I've cleaned up the test and memoized the response of the factory. Also updated API docs. Do let me know if there is anything else you'd like me to do. Thanks!,neeharv,timdorr
523,2017-02-18 14:26:40,@timdorr much easier to just do it in a new branch for me. The new PR is here is #626. Closing this so you can take a look there! Thanks.,neeharv,timdorr
522,2016-10-13 21:26:44,"Ahhhhhhhh - thank you @markerikson, it never occurred to me that it had applications for HoCs as well, not just middlewares :)
",rubyruy,markerikson
522,2016-10-13 21:27:13,"Amusingly, @epeli pointed it out at the exact same time I did, just right before your ""concrete example"" comment :)
",markerikson,epeli
522,2016-10-13 21:30:08,"See #407 and #416 for the gory details, but it's basically a complete reimplementation to improve performance and fix edge cases.  Courtesy of @jimbolla .
",markerikson,jimbolla
517,2016-10-14 01:19:59,"@jimbolla I rebased and amended the commit to include a test that would fail with an exception prior to this change. It's a pretty contrived reduction of what happened in my codebase.
",appden,jimbolla
513,2016-10-07 00:35:32,"@theverything I'm not exactly sure how to reproduce this. Any chance you can provide a repo?
",jimbolla,theverything
513,2016-10-18 20:04:32,"@theverything Anything I can do to help you with this? I'd love to resolve this one to help v5 make it to release. If you can't share your code with me, what about a screen-sharing session? Maybe from that I can see enough to make a repro without it.
",jimbolla,theverything
513,2016-11-27 14:54:18,@timdorr Recently discovered the same error — [here’s the project](https://github.com/patrikholcak/hot-loader-demo/tree/81e03e19b4a22b68038431482d7cb225f5f25f90). If you try to HMR `./src/routes/counter.js` you’ll see the exact same error. Downgrading to `react-redux@^4.4.6` fixed it,patrikholcak,timdorr
513,2016-11-28 13:43:57,@restrry We'll have to make some changes to get it to merge with PR #540 but this is very helpful. Thanks.,jimbolla,restrry
513,2016-12-05 16:44:48,"Does anyone, @patrikholcak, @restrry, know how to simulate HMR in a test?",jimbolla,patrikholcak
513,2016-12-05 16:44:48,"Does anyone, @patrikholcak, @restrry, know how to simulate HMR in a test?",jimbolla,restrry
513,2016-12-10 23:12:48,I just added PR #567 which fixes this. Thanks @patrikholcak and @restrry.,jimbolla,patrikholcak
513,2016-12-10 23:12:48,I just added PR #567 which fixes this. Thanks @patrikholcak and @restrry.,jimbolla,restrry
510,2016-10-04 16:57:25,"@zhangk2000 : Are you more concerned about the _use_ of `connect`, or its implementation?

For usage, the basic approach is described in the Redux docs at http://redux.js.org/docs/basics/UsageWithReact.html , and the API docs are at https://github.com/reactjs/react-redux/blob/master/docs/api.md .  There's also numerous tutorials online that describe how to use `connect`.

For implementation, to some extent that's supposed to be something that users don't have to worry about.  In fact, the upcoming React Redux v5 version completely changes the internal implementation, without changing the public API at all.  That said, Dan wrote a gist that shows the basic idea of what `connect` does, at https://gist.github.com/gaearon/1d19088790e70ac32ea636c025ba424e .  There was also a video where Dan walked through the current (v4) version of `connect` and explains it, at https://youtu.be/VJ38wSFbM3A .The v5 implementation is described in #407 and #416.

Do you have any specific questions or concerns about the docs?
",markerikson,zhangk2000
510,2016-10-04 17:39:42,"In addition to what @markerikson said, there's also more comments in the new version, currently in the `next` git branch. I tried to add comments to the stuff that is not-obvious, but what's obvious to one person, won't be the same was what's obvious to another. If there's specific areas of the code that you feel need greater explanation, please point them out.
",jimbolla,markerikson
510,2016-10-04 18:00:43,"Thanks @markerikson & @jimbolla 

I have two questions about the wrappedcomponent generated by connect function, .
1. the state of every wrappedcomponent is the whole state tree ? 
2. trigger re-rendering of wrappedcomponent based on the state selected in mapstattoprops()?

these concepts should be clarified in the introductory, or people will get confused.
",zhangk2000,jimbolla
510,2016-10-04 18:00:43,"Thanks @markerikson & @jimbolla 

I have two questions about the wrappedcomponent generated by connect function, .
1. the state of every wrappedcomponent is the whole state tree ? 
2. trigger re-rendering of wrappedcomponent based on the state selected in mapstattoprops()?

these concepts should be clarified in the introductory, or people will get confused.
",zhangk2000,markerikson
510,2016-10-05 00:31:00,"Yeah, given that we now have some more examples in there thanks to @jimbolla , I can live with that.
",markerikson,jimbolla
509,2016-10-03 14:06:13,"Thanks @epeli this worked very well! BTW is this the way you solved it in v5?
",ynonp,epeli
507,2016-09-28 18:15:34,"@timdorr I don't think changing where the computed props are stored would unblock things. The issue is that the implementation of `shouldComponentUpdate` can't do ""the computed props have changed **or something in context has changed**"". I'm pretty sure there are some open issues in React about adding new methods for components to communicate context changes, but that doesn't help us today.
",jimbolla,timdorr
507,2016-10-24 16:04:01,"@jimbolla How about we do this as a test release (5.0.0-test.1) and see what the effects the community can find? I'd also love to have a benchmark suite available so we can have an objective analysis on our own, but that could work in a pinch until we get something built out.
",timdorr,jimbolla
507,2016-11-03 16:15:59,"@primozs I don't really understand your use case. When would you want a component that received changed props to not re-render?
",jimbolla,primozs
506,2016-09-28 13:43:37,"@timdorr done!
",roncohen,timdorr
504,2016-09-27 13:32:04,"@jimbolla Thanks a lot :+1: 
I've misunderstood the behavior of this function
",mafzst,jimbolla
503,2016-09-27 02:43:09,"@markerikson thank you for the reply.  In my example, NewCustomerContainer is the container and CustomerForm is my plain one, so I think I am already doing what you suggest.
",stevenmusumeche,markerikson
502,2016-12-19 16:51:21,"I had to struggle a bit but @timdorr is right about the `Provider`. I'm sharing my setup below with the hopes that it'll help.

**index.ios.js**


**Main.js**


**configureStore.js**
",a-koka,timdorr
498,2016-09-24 05:36:20,"@timdorr ok, but can it be in both branches? I just want to get this published sooner than later.
",btd,timdorr
496,2016-09-23 16:00:10,"You should inspect what props your underlying component receives. If `ownProps` has a key called `myProps`, then your component should have a props key called `myProps` without needing to explicitly include it in `mapStateToProps`, like @markerikson said.

It sounds like you might be mutating the nested pieces of the `myProps` object in place, which won't trigger a re-render in and of itself.  How are you actually ""updating"" `changedProp`?

When you said ""props received"", how do you know they are received? Are you investigating inside `compnentWillReceiveProps` or something?

Forgetting redux for a moment, consider this example:



Changing `window.someValue` will not cause `ChildComponent` to rerender --- `ChildComponent` won't receive the new value until `Parent` renders.  When you change values, you need a component somewhere in the ancestor chain to get the ball rolling, with something like a `setState`
",naw,markerikson
496,2016-10-05 02:25:19,"@Daniel-Baranowski-BJSS Were you able to resolve this?
",jimbolla,Daniel-Baranowski-BJSS
492,2016-09-19 20:12:24,"@braco Can you try perf testing against the v5 beta by running `npm install react-redux@next`?
",jimbolla,braco
490,2016-09-17 13:38:14,"Fair enough. I just thought I would put it out there in case there's a rollback or something.

@jimbolla it's funny you should say that about needless setState calls because I thought that was the important problem to solve when doing blackbox. But if I'm not mistaken, react made some internal changes to deal with this issue. (it's extremely possible that I'm completely missing something here, so please correct me if I am wrong.)

Here's the scenario
 lets say you have two connect components that will setState on the same store changes, and one component is inside the other. When the store changes, they both setState,  but the parent setState takes priority, and the child setState will only fire if the render propagation fails to reach it. (Because of a false shouldCompomentUpdate in between them)

Is there still a performance gain then?
",l2silver,jimbolla
490,2016-09-18 01:07:47,"@jimbolla Ah, got it! Brilliant. Now it makes sense.
",l2silver,jimbolla
488,2016-10-05 00:32:39,"@jimbolla's correct. I'd like to leave new features/APIs to the next branch for now. We can do bugfixes on 4.x, but I kind of doubt it's going to need anything major in the meantime :)
",timdorr,jimbolla
483,2016-09-06 09:42:01,"@markerikson object shorthand syntax is very handy, and I do use it. But we can still introduce errors. Imagine we have a container that the only thing it does is to dispatch an action (to fetch data for instance) when the component is mounted. I'd be very nice if I can double check that the action it dispatches is the one we want.

@jimbolla that's really interesting approach, I'm going to rethink my implementation with that in mind. Though it also needs `connect` to be executed, and it's not ideal as markerikson pointed. But I can't think of any approach to verify the action without connecting the component. 

Another thing that I'm trying to achieve with my PR is to avoid expensive operations that the actions may execute (like fetching data from an API). Using Sinon to generate test doubles of the actions is not easy.

Keep your good feedback and ideas guys, very appreciated!
",alexlbr,jimbolla
483,2016-09-06 09:42:01,"@markerikson object shorthand syntax is very handy, and I do use it. But we can still introduce errors. Imagine we have a container that the only thing it does is to dispatch an action (to fetch data for instance) when the component is mounted. I'd be very nice if I can double check that the action it dispatches is the one we want.

@jimbolla that's really interesting approach, I'm going to rethink my implementation with that in mind. Though it also needs `connect` to be executed, and it's not ideal as markerikson pointed. But I can't think of any approach to verify the action without connecting the component. 

Another thing that I'm trying to achieve with my PR is to avoid expensive operations that the actions may execute (like fetching data from an API). Using Sinon to generate test doubles of the actions is not easy.

Keep your good feedback and ideas guys, very appreciated!
",alexlbr,markerikson
483,2016-09-06 16:38:43,"@gaearon: Dan.  You're supposed to be on vacation.  STOP COMMENTING ON ISSUES AND GO DO VACATION-Y THINGS! :)

(But yeah, exposing `mapState` and `mapDispatch` seems totally reasonable, since we already do the component as well.)
",markerikson,gaearon
475,2016-08-28 14:13:12,"Your solution works perfectly.  Thanks @jimbolla !
",wookiem,jimbolla
473,2016-09-09 15:26:33,"@markerikson Can you give me an example of what to add in there for manual tags and I'll update the docs this weekend?

@timdorr Thoughts on adding the beta release to the github releases tab?
",jimbolla,timdorr
473,2016-09-09 15:26:33,"@markerikson Can you give me an example of what to add in there for manual tags and I'll update the docs this weekend?

@timdorr Thoughts on adding the beta release to the github releases tab?
",jimbolla,markerikson
473,2016-09-09 15:41:54,"@jimbolla : You can stick HTML straight into Markdown, so what I did was insert `<a>` tags right before each appropriate section header.  I gave each anchor a custom relevant shorter name, as opposed to the long auto-generated names from the slugified header text:


",markerikson,jimbolla
473,2016-09-11 00:43:38,"@markerikson I threw some a tags in PR #480
",jimbolla,markerikson
473,2016-09-12 20:22:41,"@timdorr It's all good. I appreciate that everyone has their own things going on. I just want to make sure this doesn't get lost.
",jimbolla,timdorr
473,2016-11-29 20:29:45,@timdorr Let me know if I can help.,jimbolla,timdorr
473,2016-12-07 16:04:10,"@ghigt we added a setting in rc1 to make it opt-in, but then removed it in latest. there isn't a release w/ the latest. see the [release notes for rc1](https://github.com/reactjs/react-redux/releases/tag/v5.0.0-rc.1) for details.",jimbolla,ghigt
473,2016-12-07 16:40:41,"@timdorr I think everything's good to go. Perf tests look good. The only known issue is broken HMR (#513) which I can spend some time fixing while on christmas vacation. I added a note about that to the release notes draft, which look good.",jimbolla,timdorr
473,2016-12-07 21:50:34,@timdorr Can we publish an rc2 with the expected 5.0 change?,gnoff,timdorr
473,2016-12-07 22:45:01,"@gnoff If you're eager to test it, I published the latest changes as `@jimbolla/react-redux`. You can `npm install` that and then if you're using webpack, you can alias that on top of react-redux proper: 
```js
{
  resolve: {
    alias: {
      'react-redux': '@jimbolla/react-redux',
    }
   }
}",jimbolla,gnoff
473,2016-12-07 22:45:01,"@gnoff If you're eager to test it, I published the latest changes as `@jimbolla/react-redux`. You can `npm install` that and then if you're using webpack, you can alias that on top of react-redux proper: 
```js
{
  resolve: {
    alias: {
      'react-redux': '@jimbolla/react-redux',
    }
   }
}",jimbolla,jimbolla
473,2016-12-08 08:56:16,"@jimbolla sorry, I didn't understand well the release note. As I don't have any issue with the beta3, I'll keep it until the flag is removed. Thanks for your reply.",ghigt,jimbolla
473,2016-12-10 03:06:03,"Just saw your Reddit comment at https://www.reddit.com/r/reactjs/comments/5hf4d4/an_artificial_example_where_mobx_really_shines/db09sf2/ .  Quoting for posterity:

> To be honest I'm still feeling wary about subscribing in order. This feels like a hack for something React can already do in the batched mode. But I'm not actively involved now so it's hard for me to say.

@jimbolla is way more familiar with the guts of this, and you're obviously _way_ more familiar with the guts of React, but as I understand it there's two main intended benefits:

- Ensure that we don't have children subscribing before parents, as can happen in 4.x.  The current behavior results in nasty bugs if you're using the ""connected parent passing IDs to connected children"" pattern, as a child whose item just got deleted may try to retrieve no-longer-existing data before its parent has a chance to re-render without that child.  Top-down subscriptions solve that by ensuring that the parent re-renders first, causing the child to unmount.
- By handling things top-down, it minimizes wasted effort, since a connected child won't call `setState` before its parent has.",markerikson,jimbolla
473,2016-12-11 23:17:54,"@jimbolla , side question: per your comments in https://github.com/dtinth/pixelpaint/pull/1#issuecomment-266211907 , any other tweaks you can think of that would help improve perf in that kind of scenario?  I know, I know, all programming is tradeoffs and nothing is perfect, just would be nice to say that v5 is better in every way :)",markerikson,jimbolla
472,2016-08-25 19:13:15,"@timdorr Do you think this is ready for another alpha release?
",jimbolla,timdorr
469,2016-12-29 22:05:28,"I can help out with this if nobody has dibs. Wouldn't the PR have to go to ""redux"" repo proper for this file: https://github.com/reactjs/redux/blob/master/docs/basics/ExampleTodoList.md ? @markerikson @timdorr 

Thanks guys!",mtomcal,timdorr
469,2016-12-29 22:05:28,"I can help out with this if nobody has dibs. Wouldn't the PR have to go to ""redux"" repo proper for this file: https://github.com/reactjs/redux/blob/master/docs/basics/ExampleTodoList.md ? @markerikson @timdorr 

Thanks guys!",mtomcal,markerikson
466,2016-08-19 13:21:44,"I agree with @gaearon that `mapStoreToProps` would be incorrect. I suppose `mapStoreStateToProps` would be correct and would be slightly more clear, but ugh... getting too verbose for my liking.

I will say that the method signature for `connect` has been an issue for several of my team, who I'll admit probably just need to read the docs a little more carefully. I've thought a lot about alternate signatures but so far haven't come up with anything that's clearly better.
",jimbolla,gaearon
465,2016-08-18 17:49:55,"@jimbolla will do as soon as I get back to my computer.
",vhmth,jimbolla
465,2016-08-19 21:05:18,"Sounds good @timdorr. Saw that @jimbolla already has a fix he's playing around with. Again - thanks for the work on this next release guys!
",vhmth,timdorr
465,2016-08-19 21:05:18,"Sounds good @timdorr. Saw that @jimbolla already has a fix he's playing around with. Again - thanks for the work on this next release guys!
",vhmth,jimbolla
460,2016-08-16 20:51:27,"@jimbolla Thanks your answer!! In this component , your way is worked! But the most serious problem is on `ReduxListView` component, i change this issue , the example code is the `selector` of `ReduxListView` component. 
",fengliu222,jimbolla
457,2016-08-15 18:31:09,"@max-mykhailenko do you have simple steps to repro?
",Restuta,max-mykhailenko
457,2016-08-15 18:59:44,"@Restuta Do you have a reproducible test case as well? 

Does this occur in the canonical `real-world` example? https://github.com/reactjs/redux/tree/master/examples/real-world
",timdorr,Restuta
457,2016-08-16 06:19:19,"@timdorr not it does not, I created a branch that you can use to repro it.

Branch: https://github.com/Restuta/rcn.io/tree/react-redux-connect-bug

Steps to repro:
- `git clone git@github.com:Restuta/rcn.io.git`
- cd `rcn.io`
- `npm i && npm run dev`
- open [http://localhost:8888/events/8](http://localhost:8888/events/8) in your browser
- open console
- click on MTB in the header and then back to ""Event 8""

You should see in console:

""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Connect(EventDetails) component.""

Notice that the only change from ""dev"" branch is bump of `redux-react` and you can test it yourself that issue is not happening with `4.4.5`.  @jimbolla 
",Restuta,timdorr
457,2016-08-16 06:19:19,"@timdorr not it does not, I created a branch that you can use to repro it.

Branch: https://github.com/Restuta/rcn.io/tree/react-redux-connect-bug

Steps to repro:
- `git clone git@github.com:Restuta/rcn.io.git`
- cd `rcn.io`
- `npm i && npm run dev`
- open [http://localhost:8888/events/8](http://localhost:8888/events/8) in your browser
- open console
- click on MTB in the header and then back to ""Event 8""

You should see in console:

""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Connect(EventDetails) component.""

Notice that the only change from ""dev"" branch is bump of `redux-react` and you can test it yourself that issue is not happening with `4.4.5`.  @jimbolla 
",Restuta,jimbolla
457,2016-08-16 13:25:48,"@Restuta That git repo address doesn't seem to work for me. Is it supposed to be https://github.com/Restuta/rcn.io.git?
",jimbolla,Restuta
457,2016-08-16 18:59:02,"@jimbolla that address is in SSH format, of you prefer HTTPS then yes, use that one
",Restuta,jimbolla
457,2016-08-19 21:49:56,"@jimbolla what do you think the timeline is for getting this in? This is the last thing before #465 gets in, which is causing some UI issues for our beta users so I'm more than happy to write some tests if you're feeling tied up. :-)
",vhmth,jimbolla
457,2016-08-20 04:59:35,"@vhmth Unfortunately I have commitments this weekend, so I won't be able to work on it again until Monday evening. I have off Tuesday and plan to work on it then as well.

I started writing a test but am having difficulty reproducing the behavior from scratch. I'm going to take a different approach and start with @Restuta's project and just start ripping out all the unrelated code until I'm left with the minimum code that reproduces the error. Then I'll turn that into a test.
",jimbolla,Restuta
457,2016-08-20 04:59:35,"@vhmth Unfortunately I have commitments this weekend, so I won't be able to work on it again until Monday evening. I have off Tuesday and plan to work on it then as well.

I started writing a test but am having difficulty reproducing the behavior from scratch. I'm going to take a different approach and start with @Restuta's project and just start ripping out all the unrelated code until I'm left with the minimum code that reproduces the error. Then I'll turn that into a test.
",jimbolla,vhmth
457,2016-08-20 05:07:08,"Sounds like a plan @jimbolla. If I have some time later on Sunday, I'll see if I can repro too. Maybe that will save ya some time and you could turn that into a test if I come up with that minimal example.
",vhmth,jimbolla
457,2016-08-22 06:15:06,"Hey guys I'm sorry about the push off. A lot of stuff landed on my plate (life stuff) this weekend and couldn't get to working on repro-ing that bug. I will try tomorrow afternoon. I know @jimbolla said he wouldn't be able to get to it until tomorrow too, but it may be good to have two set of eyes on trying to repro it.
",vhmth,jimbolla
455,2016-08-15 02:31:22,"I've got to agree with @jimbolla here. Redux has both an API and a guaranteed way of behaving. And that behavior can be fairly critical to this library and isn't always documented exactly. If you happen to build something that works with it, great, but a hard requirement on Redux is going to be needed. 

At the very least, if your minification process is sufficient, any bytes spent on Redux code should be eliminated by dead code removal. And if you _really_ want to get rid of it, you can use an alias in your build process to an empty module.
",timdorr,jimbolla
455,2016-08-15 06:42:21,"@timdorr Thanks for the explanation!
",adamterlson,timdorr
454,2016-08-15 02:33:05,"You can definitely access multiple parent contexts from a single component. So, something must be set up wrong. Without an example, I'm not sure what's going on, but it sounds like an error on your side, unfortunately. I'd look at @DavidBrear's example to see what you might be doing differently.
",timdorr,DavidBrear
452,2016-08-12 16:34:44,"@gaearon I kept looking into this and discovered there are two reasons why I might be missing some printWasted entries:
1) some are being filtered out by DONT_CARE_THRESHOLD which you seem to have removed from React in this https://github.com/facebook/react/pull/6647/files#diff-f5e99eb03b46b76237d2e7632d018f91L16 (we're still using v15.0.2)

2) after updating to the latest React, some entries were still missing, this (I believe) is because of the way perf tools work (not sure if it is a bug). As suggested, I will close and have opened a bug on the react project: https://github.com/facebook/react/issues/7484
",foiseworth,gaearon
451,2016-08-14 15:28:05,"Thanks @frankwallis 

I ended up including the following which seems to have resolved the issue for me. I'll look into adding the globals you listed above as well!


",michael-iglesias,frankwallis
448,2016-07-31 03:28:37,"Got it,Thanks! @markerikson 
",Mutefish0,markerikson
446,2016-07-28 06:58:12,"I got my answer here:  http://redux.js.org/docs/FAQ.html#react-rendering-too-often . That's because some state is produced by Array.map() method. And thank you so much. @markerikson 
",RubyZhuuu,markerikson
444,2016-07-27 21:14:08,"@jimbolla is there any other way? I'm sticking to the stateless components. 
",tomitrescak,jimbolla
443,2016-07-28 16:31:56,"@lourd If mapDispatchToProps doesn't depend on props (function.length === 1), I'm pretty sure it is only run once per component instance.

@alsh76 Your mapStateToProps will cause your component to rerender every time any action is fired. You should have it be more picky about what parts of state it needs.
",jimbolla,lourd
443,2016-07-28 16:31:56,"@lourd If mapDispatchToProps doesn't depend on props (function.length === 1), I'm pretty sure it is only run once per component instance.

@alsh76 Your mapStateToProps will cause your component to rerender every time any action is fired. You should have it be more picky about what parts of state it needs.
",jimbolla,alsh76
443,2016-07-28 16:50:57,"@jimbolla there is the only action in my example. and button pressing causes the only dispatching and the only rendering. the issue happens because of delay between dispatching and rendering. not because of multiple rerenderings. 
",alsh76,jimbolla
443,2016-07-29 13:20:44,"@alsh76 Have you tried you demo without any middleware (including redux-logger)? 
",foiseworth,alsh76
443,2016-07-29 13:47:15,"@foiseworth I tried to remove redux-logger and all console.log from the code. It did not help - same delays. 

Actually it was a test page from my current project that uses [redux-thunk](https://github.com/gaearon/redux-thunk) and [react-native-router-flux](https://github.com/aksonov/react-native-router-flux) as well as some other libraries. 

i am gonna create test project with minimal dependencies and put it on github 
but honestly i need thunk and router - if the issue is caused by them i will be forced using Flux. With Flux it works good enough
",alsh76,foiseworth
443,2016-08-02 19:14:00,"@lourd, @jimbolla, @foiseworth As it turned out the cause of this issue is all components from navigation chain are staying unmounted and get rerendered behind of the visible scene
See more details here [Possible navigation issue in React Native/Redux app](http://stackoverflow.com/questions/38728435/possible-navigation-issue-in-react-native-redux-app)

So it seems not a redux issue but nevertheless I would be very grateful for advices how to handle multiple unmounted components from navigation stack in the best way.  I am checking in shouldComponentUpdate if current component is visible but maybe there is the better way?
",alsh76,foiseworth
443,2016-08-02 19:14:00,"@lourd, @jimbolla, @foiseworth As it turned out the cause of this issue is all components from navigation chain are staying unmounted and get rerendered behind of the visible scene
See more details here [Possible navigation issue in React Native/Redux app](http://stackoverflow.com/questions/38728435/possible-navigation-issue-in-react-native-redux-app)

So it seems not a redux issue but nevertheless I would be very grateful for advices how to handle multiple unmounted components from navigation stack in the best way.  I am checking in shouldComponentUpdate if current component is visible but maybe there is the better way?
",alsh76,lourd
443,2016-08-02 19:14:00,"@lourd, @jimbolla, @foiseworth As it turned out the cause of this issue is all components from navigation chain are staying unmounted and get rerendered behind of the visible scene
See more details here [Possible navigation issue in React Native/Redux app](http://stackoverflow.com/questions/38728435/possible-navigation-issue-in-react-native-redux-app)

So it seems not a redux issue but nevertheless I would be very grateful for advices how to handle multiple unmounted components from navigation stack in the best way.  I am checking in shouldComponentUpdate if current component is visible but maybe there is the better way?
",alsh76,jimbolla
443,2016-08-15 06:22:43,"@alsh76 please test your example with the last `react-redux@next`. I have almost same problem and update doesn't fix it :(
",max-mykhailenko,alsh76
443,2016-08-15 14:43:57,"@max-mykhailenko as i figured out my performance issues were caused by navigation system.
when the user navigate through pages like this  Scene A => Scene B => Scene C all components A, B, C are  staying mounted. Because all reducers are combined into one any action dispatching causes passing props to every mounted component. 

For example if the user makes any changes and dispatch them in Scene C all mounted components A, B, C are receiving props and getting rendered in same order A => B => C. If components A and B are big enough (e.g. big ScrollView list) it causes visible delays between Scene C actions and Scene C rendering as in my example   

a workaround for this - do not allow rendering of not visible components in shouldComponentUpdate. it resolved my performance issue

i hope it will help you
",alsh76,max-mykhailenko
443,2016-08-16 06:46:08,"@alsh76 Thanks for response. I use NavigatorExperimental and also saw lags, but with `react-native-router-flux` I got good performance. How do you check your active screen for `shouldComponentUpdate`?
",max-mykhailenko,alsh76
443,2016-08-16 14:40:44,"@max-mykhailenko  i am using `react-native-router-flux`. as well as `RN Navigator` it keeps all components from navigation stack mounted and all of them are rendered together.  

with `react-native-router-flux` you can use your own reducer to detect start of navigation as in their example [REDUX_FLUX](https://github.com/aksonov/react-native-router-flux/blob/master/docs/REDUX_FLUX.md) `ActionConst.BACK_ACTION` for `Actions.pop()` and `ActionConst.JUMP` for tabs switching. First reducer's param contains scene key and name.

also it's important to detect end of navigation (transition between scenes).  No rendering should be allowed in transition time. When navigator animation and rendering happen simultaneously it causes freezes and delays in my app.  No event is fired at the end of transition.  I am using 
[InteractionManager](https://facebook.github.io/react-native/docs/interactionmanager.html)
to detect end of navigation. 

if you are using `NavigatorExperimental` that's even simpler you have all callbacks out of the box [https://facebook.github.io/react-native/docs/navigation.html#step-4-create-a-navigation-stack](https://facebook.github.io/react-native/docs/navigation.html#step-4-create-a-navigation-stack)

and common rule i came to - the less renderings the better.  
",alsh76,max-mykhailenko
443,2016-11-10 15:52:31,"@alsh76 How did you did you check if components were visible?
",aljux,alsh76
443,2016-11-10 16:11:36,"@aljux, I use NativationExperimental but I imagine the flux one is similar in the sense that a list of routes will be maintained with an index to indicate ""where we are"". You can easily calculate the ""distance"" between the index and the requested route

@alsh76 I have had a lot of problems with performance on NativationExperimental. Aside from the trick abovem, another trick that made a HUGE ( ;-) ) difference is the following:

render(){



in the navigationStart and End methods I set a state boolean 'navigating'. When it's true, I force the sceneComponent to not re-render through shouldComponentUpdate. 

Another issue you may or may not have is that there are many more render cycles than people  often realize. If you don't have a system to ""guard"" against fetch requests being unnecessarily re-executed with every render cycle, you will also see a big negative performance impact and even recursive loops.
",mschipperheyn,aljux
443,2016-11-10 16:11:36,"@aljux, I use NativationExperimental but I imagine the flux one is similar in the sense that a list of routes will be maintained with an index to indicate ""where we are"". You can easily calculate the ""distance"" between the index and the requested route

@alsh76 I have had a lot of problems with performance on NativationExperimental. Aside from the trick abovem, another trick that made a HUGE ( ;-) ) difference is the following:

render(){



in the navigationStart and End methods I set a state boolean 'navigating'. When it's true, I force the sceneComponent to not re-render through shouldComponentUpdate. 

Another issue you may or may not have is that there are many more render cycles than people  often realize. If you don't have a system to ""guard"" against fetch requests being unnecessarily re-executed with every render cycle, you will also see a big negative performance impact and even recursive loops.
",mschipperheyn,alsh76
443,2016-11-10 16:34:11,"@aljux just watched for navigation events and keep full navigation history and a key of visible scene. code for `react-native-router-flux` looks like 



maybe in recent versions you can get foreground scene directly.  should check that
",alsh76,aljux
443,2016-11-10 18:51:41,"@mschipperheyn yes, thank you for pointing out. I forgot to mention about blocking re-rendering during scene-to-scene transition.  If not using `NativationExperimental` then should use
`InteractionManager.runAfterInteractions`. This callback is run on the end of navigation animation - the only way to detect end of the animation in my case
",alsh76,mschipperheyn
443,2016-11-11 10:24:28,"@alsh76, @mschipperheyn  Thanks. 
Im using the regular Navigator component together with redux.
But I cant figure out how to check inside the component which index that is currently on top?
Since the navigator it self does not have that kind of property?
",aljux,alsh76
443,2016-11-11 10:24:28,"@alsh76, @mschipperheyn  Thanks. 
Im using the regular Navigator component together with redux.
But I cant figure out how to check inside the component which index that is currently on top?
Since the navigator it self does not have that kind of property?
",aljux,mschipperheyn
443,2016-11-11 23:24:35,"@aljux You can track user actions (navigation buttons and hardware back button presses).  To detect end of  scene-to-scene transition use [InteractionManager.runAfterInteractions](https://facebook.github.io/react-native/docs/interactionmanager.html)

Have you tried [onDidFocus ](https://facebook.github.io/react-native/docs/navigator.html#ondidfocus) and [onWillFocus ](https://facebook.github.io/react-native/docs/navigator.html#onwillfocus)?  As far as I understand these callbacks allow to detect end and start of navigator transitions. Maybe their arguments refer to top component
",alsh76,aljux
443,2016-11-12 15:25:51,"@mschipperheyn @alsh76 thanks for the tips and info, really appreciate it! 
I will look into it asap.
",aljux,alsh76
443,2016-11-12 15:25:51,"@mschipperheyn @alsh76 thanks for the tips and info, really appreciate it! 
I will look into it asap.
",aljux,mschipperheyn
440,2016-07-22 15:18:44,"



@jimbolla The import / export definitely works because I can render the SnippetContainer inside the <Page /> if I do it directly. The <Cta /> component also work using the dynamic way.
",bretthadley,jimbolla
439,2016-07-24 18:15:57,"Hi, @hoschi, 
Do you have any sample code for me to reproduce it ? maybe your simple reducer and action,
I try to updated my project and looks well for my project ~ 

If your state didn't change anything then not re-render anything for you, but I think that is not your problem.

version
React: 15.2.1, ReactDOM: 15.2.1
redux: 3.5.2, react-redux: 4.4.5
",madeinfree,hoschi
434,2016-09-11 12:28:57,"@timdorr Could you please reply?
",fatfisz,timdorr
433,2016-09-06 09:19:38,"@timdorr Do the Typescript definitions have to take into account that the library can be used as an UMD module? Also, can I make use of the Typescript 2.0 features for the definitions?

@bbenezech I don't see what's missing. Could you explain more in depth?
",DaanDeMeyer,timdorr
433,2016-09-06 09:19:38,"@timdorr Do the Typescript definitions have to take into account that the library can be used as an UMD module? Also, can I make use of the Typescript 2.0 features for the definitions?

@bbenezech I don't see what's missing. Could you explain more in depth?
",DaanDeMeyer,bbenezech
433,2016-09-06 09:40:24,"@DaanDeMeyer Sorry, disregard.
I overlooked `connect<TOwnProps, TStateProps, TDispatchProps>`.
I can use TDispatchProps and inform my component that it has a dispatch prop passed from its HOC.

Really sorry. Still trying to wrap my head with TS
",bbenezech,DaanDeMeyer
433,2016-10-20 15:52:08,"@codeandcats suggested I fork and re-request these additions. Before I start, I wonder what are the tasks that need to be performed? I don't mind opening a PR but I'd rather not just copy the code without adding anything myself, unless we are content with the state of this PR before it was closed.  
@DaanDeMeyer raised some questions which I'd like to get answered before I begin.
- @timdorr Do the Typescript definitions have to take into account that the library can be used as an UMD module? Also, can I make use of the Typescript 2.0 features for the definitions?
- The rest of the definitions seem to be correct. Anything missing? Probably needs to be converted to external module though.
- Do we have any typescript files that can be used to test this with typescript-definition-tester?
",Zalastax,DaanDeMeyer
433,2016-10-20 15:52:08,"@codeandcats suggested I fork and re-request these additions. Before I start, I wonder what are the tasks that need to be performed? I don't mind opening a PR but I'd rather not just copy the code without adding anything myself, unless we are content with the state of this PR before it was closed.  
@DaanDeMeyer raised some questions which I'd like to get answered before I begin.
- @timdorr Do the Typescript definitions have to take into account that the library can be used as an UMD module? Also, can I make use of the Typescript 2.0 features for the definitions?
- The rest of the definitions seem to be correct. Anything missing? Probably needs to be converted to external module though.
- Do we have any typescript files that can be used to test this with typescript-definition-tester?
",Zalastax,timdorr
433,2016-11-07 11:34:21,"@timdorr **_bump**_

Also, _imho_ it would be fine to target TypeScript 2 since it's backwards compatible with 1.x code so there's really no reason consumers shouldn't be using it now.
",codeandcats,timdorr
433,2016-11-07 13:59:07,"@timdorr
Redux typings and flow typings are successfully maintained in-house, why not react-redux?
DT is a gigantic mess, noise there is overwhelming. It makes sense to have it maintained here, with PR merged by react-redux maintainers, unless you do want to reduce the load on the library's maintenance, which is very understandable.
",bbenezech,timdorr
428,2016-07-06 11:02:41,"> #416 probably already fixes this

@jimbolla, ""probably"" is a bit wooly for my liking; please could you verify by running the new test I added in #429? Also, #416 seems more like a long-term project than a fix for the current implementation so I'd say this is still a worthwhile improvement in the short-term.
",andydavies92,jimbolla
424,2016-07-01 21:42:52,"Got it. Thanks @gaearon 
",realbugger,gaearon
416,2016-06-24 11:47:10,"@gnoff. I can probably refactor the factories/selectors relationship to be a little clearer. I may have made it too abstract for the sake of hypothetical reuse. Keep an eye out for an update.

As for tests, right now everything is indeed being tested indirectly through the original tests. It would be valuable to write tests directly against some of the lower level parts but I wasn't ready to do that until I get some kind of feedback on the likelihood of these changes being accepted. If the project maintainers say they'll accept the PR if I write some tests, then I'll def write the tests.
",jimbolla,gnoff
416,2016-06-24 18:56:13,"@gaearon I removed connectAdvanced from index.js and filtered out any extra options props to connect(). Does that adequately hide the new functionality, or do we have to worry about users importing from `react-redux/lib/something`? I'll test the repo's examples and any recommended projects this weekend.
",jimbolla,gaearon
416,2016-06-25 00:12:59,"@jimbolla : perhaps some of the repos listed at https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md might be suitable for experimentation?
",markerikson,jimbolla
416,2016-06-25 17:43:54,"@gaearon I've run all the examples in redux/examples against the rewrite and didn't find any problems. Steps were:
1. npm run build:examples
2. npm: run test:examples
   3 overwrite node_modules/react-redux/lib with rewrite in each example
3. repeat 1 & 2. all tests still passed
4. run each example manually to see if there was any unexpected behavior. I did not see any

Next I am going to look at @markerikson 's list as well as reach out to the folks on reactiflux chat for repos to test.
",jimbolla,gaearon
416,2016-06-25 17:43:54,"@gaearon I've run all the examples in redux/examples against the rewrite and didn't find any problems. Steps were:
1. npm run build:examples
2. npm: run test:examples
   3 overwrite node_modules/react-redux/lib with rewrite in each example
3. repeat 1 & 2. all tests still passed
4. run each example manually to see if there was any unexpected behavior. I did not see any

Next I am going to look at @markerikson 's list as well as reach out to the folks on reactiflux chat for repos to test.
",jimbolla,markerikson
416,2016-06-26 22:57:37,"@gaearon I haven't been able to get anything React Native running on my machine. Once I got past errors related to installing python, now it's complaining about missing c++ things.
",jimbolla,gaearon
416,2016-07-02 21:35:48,"I did a review pass through the new codebase, trying to get a feel for what's going on.  Jim was hanging around in Reactiflux, so I asked him several questions about behavior in the process.  The one vague hypothetical concern I saw would be if somehow a child unsubscription happened during `Subscription.notifyNestedSubs`, causing a callback to be removed shortly before the loop tries to call it.  Should be easily fixable with an object copy, similar to how Redux handles its own notification process.

Code quality looks very good.  Functions are generally short and readable.  The helper functions don't generally have comments, but are clear enough that that's not an issue.  The higher-level logic in `connectAdvanced()` has considerably more comments, especially around the arguments.  Very well-written overall.

I built the branch and swapped out the `react-redux` folder in my own app's `node_modules`, rebuilt my dependencies bundle with Webpack's DllPlugin, and loaded up my app.  Didn't do an exhaustive test or any specific perf benchmarks, but did run through several chunks of functionality.  Everything looked just fine.

My only concern at this point is trying to follow how all of the various levels of selectors fit together.  Even with the diagram in this PR, things are a bit hazy.  The `match` approach used for handling the various possible argument forms for `mapState` and `mapDispatch` also took me a couple minutes to grasp, although the individual case handling functions themselves are very nice and encapsulated.  Not immediately sure what would be needed to make the selector connections and interplay more understandable.

Overall, the PR is looking very solid.  I am generally :+1: on the PR at this point.  @gaearon , any thoughts?  Anyone else have a chance to play around with this?
",markerikson,gaearon
416,2016-07-03 01:44:12,"Talked with Mark on Reactiflux today after running across this and pulled it into our company project. All our tests pass and I've run through multiple workflows with the app and everything works fine. 

Just to note, our application runs with the following packages. I'll only list the ones that are relevant here:

`
    ""react"": ""15.1.0"",
    ""react-redux"": ""4.4.5"",
    ""redux"": ""3.5.2"",
    ""redux-saga"": ""0.10.5"",
    ""reselect"": ""2.5.1"",
`

We also make use of a few factory functions in some of our connect calls as we are controlling how often updates are sent to the connected component.

The chrome extension dev tool also handles this change completely fine.

Unfortunately I cannot contribute to the React-Native cases yet since we havn't gotten a chance to dig into it yet.

Edit:  @jimbolla If you can tell me where in the code to measure performance, I have a load test suite setup for my application. I can put it through some heavy strain and post the results.
",Sinistralis,jimbolla
416,2016-07-03 16:55:16,"@ellbee : just to confirm, you did use Jim's branch of `react-redux`?
",markerikson,ellbee
416,2016-07-03 17:09:11,"@markerikson Yep, used the branch. `""react-redux"": ""4.4.5""` is the version that we are running in production. Sorry if it wasn't clear!
",ellbee,markerikson
416,2016-07-04 15:10:38,"@markerikson I'll add comments to match... will explain why it goes backwards.

@Sinistralis I describe how I did perf testing under the Performance header at the top of this page. Basically just recording before/after values for stats.js. Also, just using FF/Chrome's profiler to see methods with longest times.
",jimbolla,Sinistralis
416,2016-07-04 15:10:38,"@markerikson I'll add comments to match... will explain why it goes backwards.

@Sinistralis I describe how I did perf testing under the Performance header at the top of this page. Basically just recording before/after values for stats.js. Also, just using FF/Chrome's profiler to see methods with longest times.
",jimbolla,markerikson
416,2016-07-05 16:12:50,"@jimbolla , @reactjs/redux : if no one else has any comments in the next few hours, I'll do as Dan asked and ping him to set up a beta.
",markerikson,jimbolla
416,2016-07-05 18:23:20,"@timdorr @jimbolla @markerikson depends on how many people we want using this in the wild and how soon. If we tag it as `rewrite` then we reduce the number of people who are likely to come across it and exercise it. We would still need a `alpha` or `beta` phase then to get critical mass to move to general release.

if we use more traditional prerelease vernacular then we are likely to pick up a much larger proportion of experimenters and early adopters.

since the public API does not change we can silently bail out of the rewrite with no community fallout. I'm more concerned about when we expose `connectAdvanced` api as public. This is where the extra very obvious opt-in to non-standard release makes the most sense to me.

That said, being conservative isn't generally a bad thing, I can see the argument to protect this more deliberately from accidental opt-in.
",gnoff,timdorr
416,2016-07-05 18:23:20,"@timdorr @jimbolla @markerikson depends on how many people we want using this in the wild and how soon. If we tag it as `rewrite` then we reduce the number of people who are likely to come across it and exercise it. We would still need a `alpha` or `beta` phase then to get critical mass to move to general release.

if we use more traditional prerelease vernacular then we are likely to pick up a much larger proportion of experimenters and early adopters.

since the public API does not change we can silently bail out of the rewrite with no community fallout. I'm more concerned about when we expose `connectAdvanced` api as public. This is where the extra very obvious opt-in to non-standard release makes the most sense to me.

That said, being conservative isn't generally a bad thing, I can see the argument to protect this more deliberately from accidental opt-in.
",gnoff,jimbolla
416,2016-07-05 18:23:20,"@timdorr @jimbolla @markerikson depends on how many people we want using this in the wild and how soon. If we tag it as `rewrite` then we reduce the number of people who are likely to come across it and exercise it. We would still need a `alpha` or `beta` phase then to get critical mass to move to general release.

if we use more traditional prerelease vernacular then we are likely to pick up a much larger proportion of experimenters and early adopters.

since the public API does not change we can silently bail out of the rewrite with no community fallout. I'm more concerned about when we expose `connectAdvanced` api as public. This is where the extra very obvious opt-in to non-standard release makes the most sense to me.

That said, being conservative isn't generally a bad thing, I can see the argument to protect this more deliberately from accidental opt-in.
",gnoff,markerikson
416,2016-07-16 21:14:06,"I went through a round of refactorings/optimizations based on the results @gaearon found in redux-todomvc.  The scenario is that we have a list of 10,000 todo items components, each of which is connected. The speed being measured is when a todo is marked completed. To measure the results consistently, I set up a timer to check the first 10 items in the list like this:



This gave me enough time to let the page load and start Chrome's profiler. (Also profiled in Firefox but didn't bother writing down timings, but the results were consistent.) The `connect()` call of importance is the one for TodoItem. Note that this connect uses the factory style to grab the `id` from `initialProps` so that its selector doesn't have to depend on props :

### version 1



The second test I profiled was to change the `mapStateToProps` to the following. Note that this version grabs `id` from props in the final selector:

### version 2



For the third test, I removed the extra factory wrapper that's no longer needed from version 2:

### version 3



Finally I wrote a version that used `connectAdvanced` directly, which handles its own value memoization:

### connectAdvanced



### results

Aveage time in ms per `dispatch(completeTodo(...))` for 10 samples:

| test | current | rewrite |
| --- | --- | --- |
| version 1 | 28.6 | 36.9 |
| version 2 | 223.2 | 35.8 |
| version 3 | 215.4 | 32.4 |
| advanced | N/A | 24.3 |

So where I ended up is that for the original (version 1) `makeMapStateToProps`, the rewrite performs slightly slower, but performs significantly faster for a more ""typical"" selector (version 3). I think this is related to the added code to solve #292, #368, and #398. But the `connectAdvanced` version can eek out a little bit more speed (mostly by avoiding some calls to `shallowEqual`) by handling its own memoization.
",jimbolla,gaearon
416,2016-07-22 22:09:33,"@PCreations It's roughly an order of magnitude faster for many common types of selectors. Not a huge deal for a single component, but if you have a deep tree and lots of connected components, it will start to add up. Especially for those on a hot path.

But probably more important here is the code cleanup. Things are more readable and organized now. Cruft has built up over time on the current release, so this is a good chance to refactor and level up the code style a bit.
",timdorr,PCreations
416,2016-07-25 19:09:44,"@stevewillard You may be able to install directly from @jimbolla's branch:



It _should_ work, but you might need to mess with your build setup to get the code to be transpiled. Alternatively, you can check it out locally, run the build steps, and install against that local copy.
",timdorr,stevewillard
416,2016-07-25 19:09:44,"@stevewillard You may be able to install directly from @jimbolla's branch:



It _should_ work, but you might need to mess with your build setup to get the code to be transpiled. Alternatively, you can check it out locally, run the build steps, and install against that local copy.
",timdorr,jimbolla
416,2016-07-25 19:55:52,"@stevewillard I pinged Dan about it and he said he'd take a look this week. I'm not sure if that means release a beta or do more of his own testing first. If you want to test it yourself in the meantime, what I do is build the branch (npm install && npm run build) and then copy the lib & dist folders into my node_modules/react-redux folder.
",jimbolla,stevewillard
416,2016-08-09 13:41:09,"@gaearon Is there anything else you'd like me to do/test with this?
",jimbolla,gaearon
416,2016-08-09 17:14:41,"Unfortunately, only Dan has the publish bit set on npm, so only he can push out the planned `react-redux@next` dist-tagged testing release.

@gaearon Can you package up a release for testing? Everything here looks good to me. If not, I can take care of it if you are OK with adding me to npm.
",timdorr,gaearon
416,2016-08-11 14:00:11,"In the interim, I published `@jimbolla/react-redux` to npm for anyone that's eager to experiment with this. If you're using webpack, you can add an alias to substitute this package for the official one w/o having to change any other individual files. Just add the following code to your webpack.config.js:


",jimbolla,jimbolla
416,2016-08-12 08:23:25,"@timdorr Sorry, I’ve been unexpectedly swamped by Create React App which started as a hackathon project 😄 . I’ll give you the npm ownership so you could publish it.
",gaearon,timdorr
416,2016-08-12 08:24:31,"@timdorr You should have access to `redux`, `react-redux`, `redux-thunk`.
",gaearon,timdorr
416,2016-08-13 13:40:38,"@jimbolla When do you plan to release it?
",max-mykhailenko,jimbolla
416,2016-08-14 15:07:57,"#### Publicity and such: https://twitter.com/timdorr/status/764848054528774144

This version of react-redux is now available on npm for you to install and test:



It's tentatively called 5.0.0, although technically it has no breaking API changes. semver schmemver!

Please report any bugs you find with it as a separate issue on the repo. 

As some housekeeping, I'm going to close out this PR and instead merge it into the `next` branch on the repo (since this is against `master`). @jimbolla, you (or anyone else for that matter) can open up any followup PRs with further improvements and bug fixes against that branch. I'll go through and close out any issues that this PR solves (so many!) and we can plow forward on getting this released. I'll give it a week or so and we'll promote to beta status so we can get even more people trying it out. 

Everyone please give @jimbolla a huge round of virtual applause for this PR. He's done some really great work here!
",timdorr,jimbolla
416,2016-08-14 17:13:56,"And thank _you_, @jimbolla , for your initiative and all the time and effort you've put into working on this, as well as everyone else who has participated in the discussion.  This has been a very nice example of open source collaboration at work.
",markerikson,jimbolla
416,2016-08-14 18:11:45,"Oh my gwd @jimbolla love you man for all the hard work you've done!!!
",OshotOkill,jimbolla
416,2016-08-15 09:31:13,"thanks @jimbolla . Didn't have much time to see what you have done so far but it looks great and will probably solve some of my own issues
",slorber,jimbolla
416,2016-08-15 16:40:54,"@irvinebroque Open a new issue here if you find anything. We'll want a reproducible test case (a ""repro"") to most effectively fix it, but at least notifying us would be a great start!
",timdorr,irvinebroque
416,2016-08-15 16:46:56,"@irvinebroque : Dan wrote up a gist a while back that shows what `connect()` does at a conceptual level: https://gist.github.com/gaearon/1d19088790e70ac32ea636c025ba424e .  Both the original version of `connect` and Jim's rewrite are way more complicated than that internally, but that gist demonstrates the overall intent: subscribe to the store, map state, merge props, render the wrapped component.
",markerikson,irvinebroque
416,2016-09-04 07:39:25,"@timdorr upgrading to `5.0.0-beta.1` but i cant see exported `connectAdvanced` in lib. I see file `src\components\connectAdvanced.js` but it is not exported in index so i cant use it directly by my own. Can you add that export and publish updated beta version?
",psulek,timdorr
416,2016-09-05 13:25:32,"@psulek You can still use it directly if you do `import connectAdvanced from 'react-redux/lib/components/connectAdvanced'` in the meantime. If you're trying out `connectAdvanced` would you also review and provide feedback on the related docs in PR #480?
",jimbolla,psulek
416,2016-09-28 17:33:28,"Love this! I just dropped the beta into an existing application that uses Redux to store form information. In my application, each field is connected to the store, similar to `redux-form`'s approach after the v6 upgrade. I loaded a fairly complex form and noticed with `Perf.printWasted()` that each field was performing a ""wasted"" render each time any other field changed. This quickly adds up to hundreds of wasted renders on a medium-sized form. (Imagine that each character in an `<input>` causes a state change in the store. For an average typist, that is 3-4 characters per second. Multiply that by the number of form fields and you arrive at hundreds of wasted renders _per second_ on a form with just 25 fields, which is a small number for our use case.)

With the new `react-redux`, against the exact same code, the hundreds of wasted renders have dropped to zero! Love it! Way to go @jimbolla!
",chrisvasz,jimbolla
416,2016-10-01 00:12:41,"@jimbolla can explain further, but it's a combination of several factors.  Primarily, there's a ton of custom memoization going on using selectors, which avoids the need to call `setState`.  v4, on the other hand, called `setState` and then did the real checking in the wrapper's `render` function.  It also ensures that subscriptions are handled top-down, fixing a loophole where children could get notified by the store before ancestors and causing unnecessary render checks.  See the rest of this thread, as well as #407 for discussion and details.
",markerikson,jimbolla
416,2016-10-01 01:55:39,"@slorber @markerikson The short short version... Forcing the order of components' store subscriptions to trigger top-down allows connect to avoid extra calls to setState, render, and mapStateToProps'n'friends.
",jimbolla,slorber
416,2016-10-01 01:55:39,"@slorber @markerikson The short short version... Forcing the order of components' store subscriptions to trigger top-down allows connect to avoid extra calls to setState, render, and mapStateToProps'n'friends.
",jimbolla,markerikson
416,2016-10-03 22:49:11,"That's nice! so finally it somehow breaks compatibility (not in a way that's likely to break someone's app) and the new behavior makes connect more performant, in addition to being more flexible.

However @jimbolla can you take a look at this usecase of a list of 100k connected elements? http://stackoverflow.com/a/34788570/82609
I've seen your comments pointing out that the new implementation will permit to solve this problem in an efficient way, but I'm not sure how it can be done. Any code to share?
",slorber,jimbolla
416,2016-10-04 15:31:04,"@slorber A few thoughts on that:
- Can squeeze some extra perf by using `connectAdvanced` with a custom selector instead of `connect`. It would probably be worth it at 100k connected components.
- Another option besides those you suggested would be grouping your components into pages of (let's say) 100, so instead of 100k connected components, you'd have 1000 connected pages containing 100 unconnected components. Not sure if this would be faster or not. But it's worth experimenting
- In v5, connect/connectAdvanced take an option `shouldHandleStateChanges`. (connect sets it based on whether mapStateToProps is provided, connectAdvanced defaults it to true) You could connect a component that reads from state, but doesn't subscribe to store changes. This means it would only trigger rerenders when it receives new props from above. This may be be faster or slower.
",jimbolla,slorber
416,2016-10-05 13:53:16,"@jide Looks like we're calling `warning()` incorrectly in that commit. I'll fix and push out another beta.
",timdorr,jide
413,2016-06-24 18:55:27,"@markerikson: Please, look at https://github.com/reactjs/react-redux/pull/417. I hope my english is good enough :)
",erykpiast,markerikson
407,2016-06-17 01:52:02,"@btipling I'm all for opening it up as much as possible. But I'm not sure what you're not able to access that you expect to. The Connect component has to be inside the closure function because it depends on the functions parameters. It can't be outside because each call to connect creates a unique class.
",jimbolla,btipling
407,2016-06-18 00:53:08,"@Aweary I've been working on adding comments to the code to explain as much as possible, but I can provide an executive overview:
- The API for `connect()` is exactly the same, but its internals are completely different, ultimately delegating to `connectAdvanced()`. 
- The API for `connectAdvanced()` is `connectAdvanced(selectorFactory, {connectOptions})`. `selectorFactory` is a func with the signature `({factoryOptions}) => (state, props, dispatch) => {finalProps})`
- While Reselect is utilized internally, there's no requirement for a user to use it as their memoization engine for the functions they pass to either `connect` or `connectAdvanced`, nor is memoization even a requirement.
- Exposing an advanced API will allow end users to customize the connect functionality by building their own wrappers. For example, the whole reason I started this was so that I could define a wrapper that let me define my mapping using reselect's `createStructuredSelector`. Another example would be #323. 

Looking at a diff probably won't be super useful, since it's a total rewrite. It's probably better to look at the new files as a whole.

@timdorr Can you elaborate on why you think this implementation would fall through more often? Unless I'm missing something, I expect render to NEVER execute unnecessarily.
",jimbolla,timdorr
407,2016-06-18 13:21:43,"I made a small change in `handleChange` that fixes my own performance issues. The key being to avoid excess `setState(...)` calls, which @jimbolla mentioned.



I'm not aware of the repercussions of this change, as I just start messing with the code here, well, 30 mins ago. I just started using React, Redux, etc. etc. this week, so I'm not quite up-to-speed on the performance problems here, but it didn't take long to run into them. Glad I'm not alone!

Anyway, I'm happy to see that this thread is pretty active, so I wanted to take the opportunity to post my 2 cents and see what others thought before I spend the rest of the weekend catching up on this particular issue. Thanks, all!
",jonkelling,jimbolla
407,2016-06-18 16:00:25,"@jonkelling Would you be interested in helping me test my changes? At least by trying them in your app?
",jimbolla,jonkelling
407,2016-06-18 21:50:48,"@jimbolla I'll do what I can! I was able to get it functioning, but the first go at it saw decreased performance. I may not be doing it the way you intended, so I can try it again a bit differently if this seems off.



A couple of things:
1. I had to add `children: props.children` to get things to render.
2. I think `shouldComponentUpdate` is always returning try because it's comparing all of the properties returned by the selector, including the onMouseOver and onMouseOut functions--I really only want it to update if ""active"" is different, in this case.
3. I love the intentions of reselect in general, but as I'm only after a single boolean property, caching would technically be less efficient, and would sort of defeat the purpose of what reselect does.

Let me know if I can help any other way!
",jonkelling,jimbolla
407,2016-06-18 22:41:28,"@jonkelling Ah yes, if you're going to use `connectAdvanced`, you probably want to pre-build your event handlers at least, otherwise react sees those as new every time. It also doesn't assume you want to pass alll ownProps through by default, so you either have to cherry pick them, or use spread. You could write:



Note that with the spread operator (...props) approach, all props will be considered for equality check, so if your component gets other things passed to it that it's not interested in, that would still trigger a rerender. That would be motivation to cherry pick your props so that only the ones you're interested in.
You could also use the standard connect() API as well:



And if the id param of your handlers is the same id from props, you could do this:



I could go on about how to use reselect to build your selector as well, but I don't want to go to far off tangent right here. Feel free to submit an issue on my fork if you want to go in depth there.
",jimbolla,jonkelling
407,2016-06-21 14:21:12,"@markerikson I'm still refactoring for clarity, and need to add some comments, but I'm getting close to being ready to submit as a PR. Any feedback you have is greatly welcome.
",jimbolla,markerikson
407,2016-06-21 17:07:20,"@markerikson I totally agree, and was already thinking all those things. It's just a matter of time. I'm hoping to have all that by some time this weekend, optimistically. The code is more-or-less complete, barring any renames to make things clearer. Next up is comments to clarify things at the local level, where needed. Then I'll work on the ""conceptual"" documentation. Do you think it makes sense to write that as an .md file to be included with the code?
",jimbolla,markerikson
407,2016-06-21 19:06:28,"I'm with @jimbolla on avoiding unnecessary calls to setState and render. Might I also suggest calling out the specific cases and adding unit tests for them. My own change to avoid extra calls to setState breaks one of existing tests in react-redux. When I get the time, I hope to understand the intention behind that test case and the original code so I can decide how I really want to/should handle it. I look forward to seeing what you come up with!
",jonkelling,jimbolla
407,2016-06-21 19:17:56,"@jonkelling : yeah, the snippet you commented out is to specifically handle the case where a parent component is rendering a connected child component, and passing some props in.  For example, the parent might render something like:



If the child's `mapState` indicates that it takes the second argument of `ownProps`, then the return value of `mapState` is probably dependent on the incoming parent props, usually along the lines of:



In that case, every time the parent re-renders, the connected child would need to re-run `mapState` in case the incoming props changed, even if the state itself hasn't changed.

And yes, MOAR UNIT TESTS!!!! :)
",markerikson,jonkelling
407,2016-06-21 19:30:39,"@jonkelling @markerikson I broke the same test when I removed the ""unnecessary"" setState() calls. The solution was to enforce top-down subscriptions. Then it's no longer a ""re-run"", it's just a ""run"". This also added significant perf gains because in most cases, a whole tree of connected components will re-render in a single frame. By the time the child components get their notification from the store, they've already done their work... they fire the getFinalProps selector, which sees that current ownProps and state are the same as previous, and avoids the extra setState/render cycle.
",jimbolla,jonkelling
407,2016-06-21 19:30:39,"@jonkelling @markerikson I broke the same test when I removed the ""unnecessary"" setState() calls. The solution was to enforce top-down subscriptions. Then it's no longer a ""re-run"", it's just a ""run"". This also added significant perf gains because in most cases, a whole tree of connected components will re-render in a single frame. By the time the child components get their notification from the store, they've already done their work... they fire the getFinalProps selector, which sees that current ownProps and state are the same as previous, and avoids the extra setState/render cycle.
",jimbolla,markerikson
407,2016-06-21 20:19:47,"Cool, yeah, I haven't had much time to look over all of these changes. Seems reasonable though, great work @jimbolla 
",aweary,jimbolla
407,2016-06-21 20:52:37,"@markerikson I never modify the context so no need to trigger an update. That should be a non issue. I followed the same ""props.store"" or ""context.store"" pattern like the original.
",jimbolla,markerikson
407,2016-06-23 06:29:15,"@jimbolla 

having gone through your implementation of connectAdvanced (and to some extend the connect api reimplementation) I have the following very disjointed thoughts and questions.
1. in many respects `connectAdvanced` seems simpler than `connect` to me. would you intend to ever use the original api over the advanced api. If the benefits of the new api consistently outweigh those of the existing one I wonder if this framing is the correct one long term.
2. Should connectAdvanced have sensible defaults for when say you just want dispatch? Obviously one can use the connect wrapper for advanced but this adds a lot of internal complexity (for the backwards compat sake which is great) and if users are using the advanced api already there may be some value in providing defaults
3. ~~using options to control depends on state feels clunky to me. Can the selector arity be used to modulate this behavior whereby `(state, props, dispatch) =>` depends on state and `(props, dispatch) =>` does not?~~  scratch that, babel transpilation can alter fn arity when using default values. explicit is fine if a bit clunky
4. would the perf boost from enforcing subscription updates top down make the performance parity more equal? I think as great as the new implementation is, I'm worried that the parent subscription tracking feature is doing the heavy lifting perf wise and that a similar implementation in the current form may show possibly even higher performance than your new implementation (not that I hope it does one way or the other)

I'm torn because the risk of major reimplementations is real but the simplicity of the new implementation is valuable too. Part of me feels like if the new implementation is worth adopting we ought to deprecate the existing api in a major and move over to the new api in another major. In my mind most of the complexity in the new implementation is in trying to keep backwards compatibility which is a valuable target but if the new API turns out to be genuinely better (which we would of course need plenty of time in production use to adequately gauge this) then why hide it behind a veil of 'advanced-users-only' connotations.

I don't make decisions, just been around this project for a bit. take my opinions for what little they are worth :)
",gnoff,jimbolla
407,2016-06-23 13:03:50,"@jimbolla, I've got your latest code. Kudos on making it work with connect()! My own performance problems resolved :+1: I'll work on test cases for ya this weekend. Thanks for all of your work on this!
",jonkelling,jimbolla
407,2016-06-23 20:14:57,"@markerikson Thank you for your all your help. Your participation has helped me flesh out my ideas and force me to critically think about what I'm trying to do and how to do it. I understand the potential impact of such a large change, and therefore the need to make a strong justification for it. I'm working on that ""justification"" doc now, and even as I'm writing it, I'm tweaking my design to make the explanation less awkward. I'm still hoping to get it done by this weekend.

@gnoff `connectAdvanced` appears simpler than `connect` because it does less for you. But the responsibility to memoize intermediate results is now on the caller. This is especially important for any actionCreators being bound to dispatch, for example. I don't want to make assumptions about what ""sensible defaults"" are for anyone's usage; instead I'd like an API that's flexible enough so that anyone can wrap `connectAdvanced` in their own method that makes assumptions that work for them. Using function arity is somewhat brittle and is not obvious. I'm sure if the current implementation of connect was modified to use hierarchical subscriptions, it could gain a lot of the same perf improvements. If someone else wants to take that approach, they're more than welcome to copy any of my code/ideas. But to me the performance is just a bonus, because what I really wanted was a more flexible API. Sepcifically, I'm interested in defining my selector using Reselect's `createStructuredSelector` function. I still think the `connect` API should be the official API for 99% of use cases, and then `connectAdvanced` is there when you want to get clever, eek out performance, or want to use it to integrate with another library.

@jonkelling That's great. I'm encouraged by your positive feedback. Test cases are certainly welcome.
",jimbolla,jonkelling
407,2016-06-23 20:14:57,"@markerikson Thank you for your all your help. Your participation has helped me flesh out my ideas and force me to critically think about what I'm trying to do and how to do it. I understand the potential impact of such a large change, and therefore the need to make a strong justification for it. I'm working on that ""justification"" doc now, and even as I'm writing it, I'm tweaking my design to make the explanation less awkward. I'm still hoping to get it done by this weekend.

@gnoff `connectAdvanced` appears simpler than `connect` because it does less for you. But the responsibility to memoize intermediate results is now on the caller. This is especially important for any actionCreators being bound to dispatch, for example. I don't want to make assumptions about what ""sensible defaults"" are for anyone's usage; instead I'd like an API that's flexible enough so that anyone can wrap `connectAdvanced` in their own method that makes assumptions that work for them. Using function arity is somewhat brittle and is not obvious. I'm sure if the current implementation of connect was modified to use hierarchical subscriptions, it could gain a lot of the same perf improvements. If someone else wants to take that approach, they're more than welcome to copy any of my code/ideas. But to me the performance is just a bonus, because what I really wanted was a more flexible API. Sepcifically, I'm interested in defining my selector using Reselect's `createStructuredSelector` function. I still think the `connect` API should be the official API for 99% of use cases, and then `connectAdvanced` is there when you want to get clever, eek out performance, or want to use it to integrate with another library.

@jonkelling That's great. I'm encouraged by your positive feedback. Test cases are certainly welcome.
",jimbolla,gnoff
407,2016-06-23 20:14:57,"@markerikson Thank you for your all your help. Your participation has helped me flesh out my ideas and force me to critically think about what I'm trying to do and how to do it. I understand the potential impact of such a large change, and therefore the need to make a strong justification for it. I'm working on that ""justification"" doc now, and even as I'm writing it, I'm tweaking my design to make the explanation less awkward. I'm still hoping to get it done by this weekend.

@gnoff `connectAdvanced` appears simpler than `connect` because it does less for you. But the responsibility to memoize intermediate results is now on the caller. This is especially important for any actionCreators being bound to dispatch, for example. I don't want to make assumptions about what ""sensible defaults"" are for anyone's usage; instead I'd like an API that's flexible enough so that anyone can wrap `connectAdvanced` in their own method that makes assumptions that work for them. Using function arity is somewhat brittle and is not obvious. I'm sure if the current implementation of connect was modified to use hierarchical subscriptions, it could gain a lot of the same perf improvements. If someone else wants to take that approach, they're more than welcome to copy any of my code/ideas. But to me the performance is just a bonus, because what I really wanted was a more flexible API. Sepcifically, I'm interested in defining my selector using Reselect's `createStructuredSelector` function. I still think the `connect` API should be the official API for 99% of use cases, and then `connectAdvanced` is there when you want to get clever, eek out performance, or want to use it to integrate with another library.

@jonkelling That's great. I'm encouraged by your positive feedback. Test cases are certainly welcome.
",jimbolla,markerikson
407,2016-06-26 22:18:36,"I was about to write an RFC issue to discuss rewriting `connect()` to provide more functionality. Given how healthy this discussion has been I think this is the best place to post it.

My approach was going to be a bit different than @jimbolla's. My inspiration came from wanting to write a lightweight version of [`apollo-client`](https://github.com/apollostack/apollo-client), call it `react-redux-graphql`, and to avoid having to do something like this:



Ideally it would be something like this: (inspired by redux store enhancers)



Or something similar (this doesn't have to be the final signature).

Now, I could just use another higher order component and do:



You can basically do anything you want with higher order components but I thought that maybe baking that functionality into `connect()` out of the box would leave room for anybody to write componentEnhancers, be consistent with Redux, and bend `connect()`'s functionality to do whatever you want, more so than `advancedConnect()`.

So should we leave it for other developers to create higher order components or should we bake in functionality to enhance `connect()` out of the box. Thoughts?
",migueloller,jimbolla
407,2016-06-27 00:21:37,"Sounds good. And thanks for the prompt replies @markerikson!

Here's the change https://github.com/migueloller/react-redux/commit/1c8d940b945d519f32011e1359bd65c42e5f83b1

All tests are passing. Just wanted to get some comments on what people thought.

The change now allows for enhancing connect (if you want to) in any way you want, allowing for what I mentioned above.

If this ends up being ignored in the end that's ok. Just thought that this would be a good improvement. 😁
",migueloller,markerikson
407,2016-06-27 23:26:45,"@migueloller If #416 gets accepted, then you will probably be able to create your desired API by wrapping the new `connectAdvanced` method with your own custom connect method, without needing to modify the standard `connect`. That's what I'm trying to accomplish in my own project... I have my own `connectToStore` method that calls `connectAdvanced` while providing a significantly different API than `connect`.
",jimbolla,migueloller
407,2016-06-28 04:36:05,"@jimbolla That would be an option but it's not much different from wrapping `connect` because the library would still have `react-redux` as a dependency. It would be nice to simply export a function that takes in `connect` as a parameter and outputs a new version of connect. This is how store enhancers work (Redux libraries don't normally have Redux as a dependency).

It doesn't look like there is interest to mirror store enhancer functionality for `react-redux`, though.

**EDIT**: It's probably worth mentioning that all the benefits that you get from `advancedConnect` can be achieved with my implementation simply by doing:


",migueloller,jimbolla
405,2016-06-15 15:03:33,"@markerikson In addition to what you mentioned, the other issue I started running into was when I was using createSelector in mapStateToProps, mapDispatchToProps and mergeProps, because they each have different parameters, I had to organize my selectors by which method they aligned with. (Using createSelector to memoize my functions is useful for partially applying args from state/props, so that a new function isn't created every time an unrelated prop is changed.) It also looks like mergeProps doesn't have the same ""advanced"" option like the other two, so any selectors I want to use in there have to be singletons instead of being bound to the lifetime of the component instance.

So I started looking at the source for connect() to see if it would be possible to modify it to just supply dispatch as a 3rd param to mapStateToProps, but I found the source for connect() to be very difficult to mentally parse. There's a lot of magic in there to track all the various moving parts. I don't think I could make the changes I'd like to connect() without breaking something. There's 10 ""cache"" fields on the component and another 5 temp variables in the render() method mixed inside a lot of if/else blocks.

That's why I decided to create my own implementation using reselect to track all those moving parts instead. 
",jimbolla,markerikson
405,2016-06-16 03:28:17,"@markerikson So I wrote a version of `connect()` that builds a selector from its args and passes along to `connectToStore()`. All react-redux tests pass with 1 breaking change for when `mapStateToProps` / `mapDispatchToProps` are factory methods and a couple tweaks to some spy counts because my implementation does things slightly different behind the scenes.

[Fork is here](https://github.com/jimbolla/react-redux/tree/connect-rewrite/)
",jimbolla,markerikson
403,2016-06-08 22:49:37,"@markerikson Well basically, because what action gets returned to the component needs to use state. I don't have access to dispatch in `mapStateToProps` to fully bind the method, and I don't have access to state in `mapDispatchToProps` to do so, so I have to do it after both have run, either in `mergeProps`, or using recompose's `withProps`. In an ideal case, I'd have access to state, dispatch, and ownProps in a single pass.

In this case, the state is the current user's authorization. The result is either the real action, or nothing. Our app has role based authentication (details stored in state.auth) where employees in the admin role can can perform write actions from a screen where other users can only get a readonly version. The components key off whether the event handler functions are null or not to make that determination.
",jimbolla,markerikson
403,2016-06-09 16:36:01,"@jimbolla Your use of dispatch in this way does feel a bit awkward to me but I can see why having dispatch available in the selector can be useful if you want to keep all this kind of thing in selectors exclusively.

`connect` doesn't add much overhead beyond what any HOC would if you aren't subscribing to anything so the double connect isn't really an issue per se. If you want to make your intent more clear to others I might suggest doing something like this though



this way you can swap out the implementation for `provideDispatch` in the future without finding every place you happened to do the double connect.
",gnoff,jimbolla
403,2016-06-10 22:11:50,"@gnoff That's a good idea. If I don't end up using my own implementation of `connect` I would do that.

@markerikson Partly stylistic and syntactical preference, partly being able to leverage the abilities of `reselect`. It's still in flux (no pun intended), but my current syntax looks like this for a simple use case:



Now I have both state and bound action creators available so I can build my props object in a single pass.  
",jimbolla,gnoff
403,2016-06-10 22:11:50,"@gnoff That's a good idea. If I don't end up using my own implementation of `connect` I would do that.

@markerikson Partly stylistic and syntactical preference, partly being able to leverage the abilities of `reselect`. It's still in flux (no pun intended), but my current syntax looks like this for a simple use case:



Now I have both state and bound action creators available so I can build my props object in a single pass.  
",jimbolla,markerikson
397,2016-06-02 02:11:47,"@gaearon You are right！
Last night，I solved the problem！
I was so careless... 
Thank you very much!
",kissyRui,gaearon
396,2016-05-30 06:51:47,"I get the point @gaearon.

I had been playing with the idea of exposing a way to disconnect.

I got the idea while making some tests by doing this from my connected container:



Of course the code above uses undocumented APIs and there are many things that could go wrong.

Also, there's no way to reconnect later. That's why I thought that it might be a nice addition to expose somehow a (dis/re)connect / (un/re)subscribe methods.

I guess I'll need to create my own connect wrapper or simply call (un)subscribe as you suggested.

Thanks!
",landabaso,gaearon
396,2016-05-30 15:14:06,"Thanks @gaearon!

I decided NOT TO use the approach of (un)subscribe anyway since it also makes the App slow.

I'll explain it in case some other people read this issue in the future:

I worked a bit more on the idea. I passed a prop from the parent though intermediate components to the final subscribed list Items: `pauseSubscriptions = true/false`. Then the list items unsubscribed and resubscribed when it's parent Page was hidden or shown.

The problem is that passing that prop triggers a chain of renders which would not have happened without it. I guess there are ways to directly (un)subscribe the children items not passing props but I have the feeling I was over-engineering the problem.

I'll try different approaches to avoid having thousands of connected components. Maybe connecting only from the parent and passing props to the children. This will make the program a bit verbose (lots of props-passing) but may do the trick!

Thanks again @gaeron for such great tools and support!
",landabaso,gaearon
393,2016-05-26 19:56:31,"@braco I’d like to help you but I need you to help me first. Can you please publish a complete example showing why you want it to be a static method, and how it gets used? It is not obvious.

It’s not that something “doesn’t work in Redux”, it’s that the solution is likely very simple, but since I don’t understand what you’re building, I can’t help you.
",gaearon,braco
389,2016-06-06 13:01:20,"@nmn can you maybe give an example of the annotated connected component which is compatible with these type definitions?

btw, you can probably use `type ConnectOptions = {pure?: boolean, withRef?: boolean}` to decrease duplication.
",agentcooper,nmn
389,2016-06-06 13:16:30,"@nmn One more thing: you support `ownProps` param in `mergeProps` (as `origProps`), but not in `mapStateToProps` and `mapDispatchToProps`.
",agentcooper,nmn
389,2016-06-08 02:53:41,"@agentcooper 
1. The idea is that if you type your own component you shouldn't need anything extra. So the example is to just use connect like normal!
2. I think I missed the ownProps arg in the other two args. I'll add it in.
",nmn,agentcooper
389,2016-08-30 16:07:48,"thanks @agentcooper! those are some great lib defs!
",ccorcos,agentcooper
389,2016-08-31 03:50:12,"@agentcooper Those type definitions do look interesting. They are definitely more sound theoretically. But in the past, the most correct definitions have not worked for me in practice.

I'll take these for a spin and report back, now that Flow has been updated a few times.
",nmn,agentcooper
388,2016-05-22 23:06:26,"@gaearon thanks. Upgrading to React Router `3.0.0-alpha.1` doesn't appear to have fixed the problem :(

Got this warning though: 


",olalonde,gaearon
388,2016-05-23 00:12:45,"@gaearon ah ok thanks. Any idea why `withRouter()` fixed the problem anyway?
",olalonde,gaearon
388,2016-05-23 00:36:28,"@olalonde Because both `withRouter()` and `Link` contain the necessary fix.
",gaearon,olalonde
384,2016-05-18 20:14:52,"Looks like this was actually an issue in a different part of my code (a faulty `onEnter` hook in my routes). Figured that out when other parts of the app started misbehaving in the same fashion after five route changes 😄 

Thanks anyway for the quick response and all your hard work on redux, @gaearon!
",vitosamson,gaearon
380,2016-05-16 14:02:15,"@gaearon  Thanks of your kind reply! I already got your answer in stackoverflow. maybe I should not separate partial app from the whole web app in iframe, it was not allowed in redux structure?
",sevenLee,gaearon
380,2016-05-17 18:30:19,"The package works so great! I don't need to use react-router to decide iframe source any more, I directly put the component I want to display inner < Frame > , the component will render in iframe, like so:



The most awesome feature is the state is synchronous ! the inner component works the same as outer component. Now I can dynamically change inline style in inner component. That is big present for me, @gaearon very much appreciated ! :D
",sevenLee,gaearon
376,2016-05-09 19:18:31,"@gaearon First of all thank for the impressively quick response (and overall great work).
Sorry I missed #165. 

IMHO saying pure imperative methods is not idiomatic React is incorrect. A way of communicating with components through exposing a component function is part of the React docs:
https://facebook.github.io/react/tips/expose-component-functions.html

It even states at the end, that passing props for animations might get messy, or in other words, there are some situations a component interface is a better solution. 

In our case, we have a generic wizard component, and each step in the wizard is a react component, that must implement a certain interface in order for it to work in the wizard.
",omerts,gaearon
372,2016-05-12 09:23:56,"> Context updates are notoriously broken with shouldComponentUpdate (facebook/react#2517). If a library you use relies on them, you should be using impure version of connect(). We can’t protect against random breakage in patch versions here because you are essentially relying on known buggy behavior.

@gaearon, AFAIK react-redux also relies on the context feature of React. So does that quote above also apply to react-redux itself? Say, for instance:



a) The parent's `shouldComponentUpdate` returns `false`.
b) Child is connected to some part of the `state` that changes.

Will the Child re-render when that part of the state changes? Do we need to pass `{ pure: false }`?
",landabaso,gaearon
372,2016-05-13 13:33:12,"@landabaso React Redux only uses context for dependency injection of the `store`. The future updates work because `Child` subscribes to the `store` directly via `store.subscribe()` API.

@krukid I sent a few PRs to fix this in React Router, and it won’t be an issue in 3.0 anymore.
",gaearon,krukid
372,2016-05-13 13:33:12,"@landabaso React Redux only uses context for dependency injection of the `store`. The future updates work because `Child` subscribes to the `store` directly via `store.subscribe()` API.

@krukid I sent a few PRs to fix this in React Router, and it won’t be an issue in 3.0 anymore.
",gaearon,landabaso
371,2016-04-28 11:06:00,"@akoshman It's supported https://github.com/reactjs/react-redux/blob/master/package.json#L98
How it doesn't work? Show your code and config.
",TrySound,akoshman
368,2016-04-26 01:39:55,"https://github.com/amccloud/react-redux/commit/d2a1fe3bc317e39ed49ffedb53a9835896a5015b

@gaearon  Now i'm stuck! I've gotten all but 3 test to pass:



I had to update one test now that re-rendering is now driven by setState. I think test failures 2 and 3 are similar issues. Test failure 1 is a bit different and @gaearon I was hoping you can look at it for me.

My notes: https://gist.github.com/amccloud/327a9d7b7dc97eaf6bb3f1f3da9e2d5e
",amccloud,gaearon
368,2016-05-01 00:27:11,"@gaearon is there a reason why the test `calls mapState and mapDispatch for impure components` expect 2 calls to mapState/mapDispatch on mount? For me only one should be required.
",slorber,gaearon
368,2016-05-01 01:51:22,"@gaearon it was quite hard and the code is not clean yet but I made all tests pass!

You can take a look at [#373]

At first I thought that I would never be able to make pass the last test related to the stale props when both parent/child are connected, because the transactionnal setState callback can be called multiple times in a single batch.

I had to use a trick like that:



@tgriesser I also succeeded make all the tests pass without using `checkMergedEquals`. Do you think there might be a missing test case?
",slorber,gaearon
363,2016-04-26 02:33:03,"@seanstrom I'm working on some of the convoluted code in the connect class. Would appreciate your feedback https://github.com/reactjs/react-redux/issues/368
",amccloud,seanstrom
359,2016-04-20 02:17:34,"@gaearon Thanks.

Is it a problem of `react-native` hot reloading? I found no problem in some `react-redux` hot reloading examples likes https://github.com/erikras/react-redux-universal-hot-example/blob/master/src/client.js#L46
",cpunion,gaearon
355,2016-09-29 17:18:29,"@toddgroff : the example that @anatoliyarkhipov gave should be the basic idea.  Create one store instance, then call `ReactDOM.render()` multiple times with your different component trees.
",markerikson,anatoliyarkhipov
355,2016-09-29 17:18:29,"@toddgroff : the example that @anatoliyarkhipov gave should be the basic idea.  Create one store instance, then call `ReactDOM.render()` multiple times with your different component trees.
",markerikson,toddgroff
355,2016-10-17 18:23:01,"@jaysg Looks like you're creating 2 instances of your store instead of just one.
",jimbolla,jaysg
355,2016-10-17 18:32:39,"@jimbolla thanks thats what it was. I created a variable for the store and now it works.

just in case someone one sees this and it's going through the same thing.


",jaysg,jimbolla
351,2016-06-10 06:40:46,"I don't understand what was changed but 4.4.4 and 4.4.5 breaks my current solution :)
The render function is calling and locale is fine when i dispatch **setLocale**, but **FormattedMessage** doesn't change the message. Looks like FormattedMessage doesn't get new props or something. It works on previous releases, and i did double check that issue reproduces only with react-redux 4.4.4 and 4.4.5
I will investigate the bug late, but for now here is my component



@gaearon thx
",DmitryAuine,gaearon
348,2016-04-12 23:07:55,"@gaearon this is great news that connect not using component's props get faster :)

However I'm not sure the current implementation is the best we could do:
- The factory method works but is kind of unintuitive API at first
- If a connected component do care about ownProps, and these props can change (ie can't use the factory), then the component will setState even if the props don't change often

Instead of 



I would rather have something like:



(this is probably not the best API but you get the idea)

What it permits here is to make it clear on what the mapping function has to rely on to do its job, so you can more easily detect when props needed for the mapping have changed and run the mapper only when needed

And I think, by default, not providing any ownProps to the mapping function (ie no selector provided) would actually encourage people to write more optimized code by default (unlike factories which would be opt-in optimization), but it would be a breaking change

(This is related to my proposal  for more flexible subscriptions here: https://github.com/reactjs/react-redux/issues/269#issuecomment-175904958)
",slorber,gaearon
348,2016-04-13 09:51:59,"> I’m confused: how does accepting a selector for props solve the problem of setState()? As soon as something depends on ownProps, due to #99, we are forced to delay its calls until render() at which point we have already paid the price of setState().

@gaearon sorry it's hard to think well on such code late in the night :) My proposal may not prevent the `setState` cost finally.

The problem I see with current code is that for example if this component changes from



 to 



then yes we necessarily have to do a `setState` because ownProps have changed and we must render the child. The problem is that here our `mapStateToProps` is relying on ownProps but actually does only care about the `id`, and not `className`.

This line:



it will make `mapStateToProps` be run in such a case, while it could have been avoided if we could have known that `mapStateToProps` is not interested to receive the `className` property but only the Todo id.

Also, not a big deal, but not sure `this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1` is relyable if someone writes mapStateToProps with `arguments[0]` (yes it is unlikely... :p). It would become more relyable if that wish to depend on ownProps was more explicit

---

This is only what I can say for now, I have to study the code a bit more to say anything else :) (ie #99)
",slorber,gaearon
348,2016-04-25 04:57:08,"@gaearon Here is [my use case](https://github.com/yelouafi/redux-saga/issues/241#issuecomment-207202589), in which early bailout yields significant performance boost.

With regards to @slorber's concern that props _can_ change, I encountered a similar issue, and I did this hack to get around it.

Let's say we have:



Of course, userID isn't expected to change, but there may be some cases where it does. For example, the above component may be a react-router route component, which gets its userID from the pathname: `http://example.com/userpage/cat`. When the path changes to `http://example.com/userpage/dog` the component holds on to stale userID (cat) and this causes problems. (because react router doesn't re-mount for the same route)

I _could_ revert back to `mapStateToProps (state, ownProps)`, but I would loose the performance boost gained from the early bailout. So instead, I do this:



Because of key, when userID is changed, the old component is completely unmounted, and new one is mounted instead, with the updated props. It's a bit hacky, but I think this is an acceptable trade-off. I guess for multiple props that aren't expected to change often I can stringify as a key:



but that .. is beyond ugly. It does bother me there are so many different steps within different levels involved in simply invalidating and updating a component, but was the only way I could make this work.
",joonhyublee,slorber
348,2016-04-25 04:57:08,"@gaearon Here is [my use case](https://github.com/yelouafi/redux-saga/issues/241#issuecomment-207202589), in which early bailout yields significant performance boost.

With regards to @slorber's concern that props _can_ change, I encountered a similar issue, and I did this hack to get around it.

Let's say we have:



Of course, userID isn't expected to change, but there may be some cases where it does. For example, the above component may be a react-router route component, which gets its userID from the pathname: `http://example.com/userpage/cat`. When the path changes to `http://example.com/userpage/dog` the component holds on to stale userID (cat) and this causes problems. (because react router doesn't re-mount for the same route)

I _could_ revert back to `mapStateToProps (state, ownProps)`, but I would loose the performance boost gained from the early bailout. So instead, I do this:



Because of key, when userID is changed, the old component is completely unmounted, and new one is mounted instead, with the updated props. It's a bit hacky, but I think this is an acceptable trade-off. I guess for multiple props that aren't expected to change often I can stringify as a key:



but that .. is beyond ugly. It does bother me there are so many different steps within different levels involved in simply invalidating and updating a component, but was the only way I could make this work.
",joonhyublee,gaearon
348,2016-04-26 12:06:53,"nice trick @joonhyublee :D 

Maybe this usecase will be easier to handle once the code of connect becomes much simpler, and it might with https://github.com/reactjs/react-redux/issues/368
",slorber,joonhyublee
347,2016-09-14 15:34:55,"@gaearon Does this mean that I just have to accept that I won't be able to hot-reload when working on my flow-control logic (thunks, sagas)? 
",Thorbenandresen,gaearon
345,2016-08-14 15:33:46,"lol @timdorr, no worries :)
",jisaacks,timdorr
330,2016-04-02 19:29:17,"Note that this is a Redux-specific question, and not a React-Redux concern.

@joshwcomeau's example is good.  There's also utilities out there that make that approach easier, such as https://github.com/omnidan/redux-recycle.  There are a number of Redux-related libs listed over at https://github.com/markerikson/redux-ecosystem-links , and some of them might also help with this.
",markerikson,joshwcomeau
330,2016-07-11 18:05:13,"Thank @joshwcomeau for that. It's working for me.
",gaastonsr,joshwcomeau
329,2016-04-04 17:10:59,"@lelandrichardson Thanks for chiming in!

> Nevertheless, redux could adjust the code it uses to create it's HOC to facilitate testing (and perhaps other things) by providing a static property reference to the original (unwrapped) component. This would allow people testing with enzyme to access the component directly, and find or render it directly by reference, which is the better route.

I think we do this, we provide [`WrappedComponent`](https://github.com/reactjs/react-redux/blob/2d5ee79627b6e2dc3ff2e23a395091334a64ef28/src/components/connect.js#L288).
",gaearon,lelandrichardson
329,2016-04-04 17:11:41,"@firasd Thanks for explaining. Indeed this is very fragile.
",gaearon,firasd
329,2016-06-13 18:45:46,"I disagree, `WrappedComponent` is not a perfect solution.

> @ianobermiller (FormidableLabs/radium#271 on [Jul 17, 2015](https://github.com/FormidableLabs/radium/issues/271#issuecomment-122227566))
> Can you imagine if every decorator did the same thing? `Radium(Relay(autobound(Button)))` 👎 

Or are you suggesting that `react-redux` is the king of React standards and every HOC project out there should adopt the `WrappedComponent` standard?  What if other HOCs provided `InnerComponent` or `BaseComponent` as their standard method?  What we end up with is chaos.

> @gaearon
> Display name is meant for debug purposes and tooling like React DevTools. Why do you rely on it?

No matter how you slice it, the wrapped component appears to be a change in the display name to the consuming developer(s).  So I ask, why does `react-redux` modify `displayName` in the first place?  If it's something that is expected for people not to rely on, why does `react-redux` rely on changing the `displayName` at all?  If `displayName` is truly inconsequential - then the `react-redux` team should have no problem removing their reliance on the ""change"" of the `displayName`.
",TigerC10,gaearon
329,2016-06-13 20:48:34,"@TigerC10 I think it is more important to educate React devs what HOCs are and are not rather than implement an intentionally misrepresentative behavior for `displayName` to have the library function as you might expect with a naive understanding of HOCs.

connect or any other HOC does not return a decorated component in the strictest sense (attach behavior or data to something and return it) it returns a wrapping component that proxies most component interactions to the wrappee but with some additional behavior or data. I think understanding this distinction is more important than trying to pretend decorating is happening.

I'm a strong -1 on changing displayName. the displayName of `connect(whatever...` is non-obfuscating and deterministic. if you want to instrument components for easier testing in enzyme then just make your own HOC who's sole purpose is to expose whatever method you want for getting a handle on your wrapped component.

The solution is better education and documentation here IMO not clever renaming of the HOC to hide that it is a HOC
",gnoff,TigerC10
329,2016-06-14 19:00:16,"@TigerC10 I'm sorry that you felt I meant you needed education in how HOCs work. That wasn't my intention. point noted on the difficulty of wrapping things in many HOCs.
",gnoff,TigerC10
329,2016-06-14 19:48:21,"@gnoff My apologies, the ""please don't patronize me"" remark wasn't intended to suggest that I felt like you were personally patronizing me - just expressing the fact that I don't expect that developers feel like `displayName` is truly educational.
",TigerC10,gnoff
328,2016-03-24 10:35:38,"@tgriesser  Thanks a lot, seems it is a common JavaScript gotcha, and I have to learn more about JS :100:  

Thank you a lot for your help!  ^_^.  
",Lucas-Qi,tgriesser
325,2016-03-22 01:03:49,"BOOM! :boom: :dancers: 

Thanks @gaearon!
",renanvalentin,gaearon
325,2016-10-24 20:13:34,"@gaearon How do you test that the state tree looks like you expect?

e.g. I change the structure of the state tree by changing the reducer and make sure to change the tests there. Now all my tests pass, but the connected component is broken since it's not mapping the state correctly, anymore.
",flushentitypacket,gaearon
325,2016-11-22 11:59:10,"@flushentitypacket; write selectors and use them in your `mapStateToProps`. They'll allow you to get parts of state in your components, without the component needing to know the structure of state.



Then, test your reducers, actions and selectors together - so your test starts with dispatching an action, and ends with expectations about the selector's output.",atkinchris,flushentitypacket
323,2016-03-20 22:53:13,"@tgriesser thanks for your feedback.

Yes it looks like passing props too does not cost much :)

Also I'm surprised that you comment positively on this because I've just discovered ""structured selectors"" of Reselect. I don't find the name very good but it was built after your [issue](https://github.com/reactjs/reselect/issues/42) and seems to almost do what I propose here...

What would my PR help you solve that you can't already with:
`connect(createStructuredSelector({selector1, selector2}))`

Not sure to understand your comment about using a factory. Is this the little thing added recently that almost nobody has to use but that can leverage better performances? ^^
",slorber,tgriesser
323,2016-03-23 09:20:52,"thanks for your feedback @tgriesser 

I have no strong opinion on this as the `createStructuredSelector` is already in Reselect and I already use it, but being directly inside Redux would be a bonus.

@gaearon tell me when you have decided, I may rework a little my PR with some code of @tgriesser before merge.

@tgriesser btw, now that you removed your optimisation that finally does not work (don't know why but I trust you), couldn't we just use `mapValues(mapStateToProps, val => val(state, props))` in all cases?
",slorber,gaearon
323,2016-03-23 09:20:52,"thanks for your feedback @tgriesser 

I have no strong opinion on this as the `createStructuredSelector` is already in Reselect and I already use it, but being directly inside Redux would be a bonus.

@gaearon tell me when you have decided, I may rework a little my PR with some code of @tgriesser before merge.

@tgriesser btw, now that you removed your optimisation that finally does not work (don't know why but I trust you), couldn't we just use `mapValues(mapStateToProps, val => val(state, props))` in all cases?
",slorber,tgriesser
323,2016-04-15 10:05:48,"@gaearon are you still interested by this PR? 

Tell me and I'll update my PR (because with recent optims I now understand better code suggested by @tgriesser )
",slorber,gaearon
323,2016-04-15 10:05:48,"@gaearon are you still interested by this PR? 

Tell me and I'll update my PR (because with recent optims I now understand better code suggested by @tgriesser )
",slorber,tgriesser
323,2016-04-23 13:37:34,"@gaearon I've updated my PR with @tgriesser suggestions
",slorber,gaearon
323,2016-04-23 13:37:34,"@gaearon I've updated my PR with @tgriesser suggestions
",slorber,tgriesser
323,2016-10-04 09:19:02,"@jimbolla @gaearon @timdorr I suspect this will be doable in userland with `connectAdvanced` no?
",slorber,gaearon
323,2016-10-04 12:52:29,"@slorber Yes. A couple thoughts:
1. It's certainly implementable with `connectAdvanced`, and that was my intent behind extracting that method from `connect`, so that different custom connect APIs could be achieved in userland.
2. There are extension points in `connect` that could make this achievable in userland with less work than `connectAdvanced`, but they are not part of the official API at this time. Exposing those extension points is  more about the effort of writing tests and docs than the app code.
3. I still think this feature would be nice as part of the official API, and I think the code is refactored well to implement this fairly easily. Again, not a lot of app code, but more work to write tests and documentation.
",jimbolla,slorber
323,2017-01-12 16:56:39,"@gaearon @jimbolla @tgriesser it's been a while that this PR is open and it seems I'm not the only one wanting this

Would this get merged if I port the PR to work on master, polish it a bit and add better documentation?",slorber,gaearon
323,2017-01-12 16:56:39,"@gaearon @jimbolla @tgriesser it's been a while that this PR is open and it seems I'm not the only one wanting this

Would this get merged if I port the PR to work on master, polish it a bit and add better documentation?",slorber,tgriesser
323,2017-01-12 16:56:39,"@gaearon @jimbolla @tgriesser it's been a while that this PR is open and it seems I'm not the only one wanting this

Would this get merged if I port the PR to work on master, polish it a bit and add better documentation?",slorber,jimbolla
323,2017-01-13 10:09:12,"Hi @jimbolla

For now I've not really used these factories, do you refer to [this](https://github.com/reactjs/react-redux/blob/master/docs/api.md#examples-1)? 

Because what I see as signature in doc is `(dispatch => (nextState, nextOwnProps) => stateProps` which does not really look like your example signature. Can you give me a doc reference? It seems to me only connectAdvanced takes a factory, and only one while your exemple assume we can provide as many factories as props we want. Can you give me a unit test that showcase this feature?

Also could we mix both styles?



I'm not sure it would be easy to detect weither makeGetSometThing is a normal selector or a factory as both are functions


",slorber,jimbolla
323,2017-01-13 19:22:59,"@slorber : yeah, that's what Jim is referring to.  I have an example of using the factory syntax here : https://www.reddit.com/r/reactjs/comments/5dxasp/any_deepdiveadvanced_tutorials_on_reselect/ ",markerikson,slorber
323,2017-01-13 23:39:36,"@markerikson I see your example but still it's different from what @jimbolla show in his code snipped



VS

 


Maybe I'm missing something, but can you give me the verbose version of the following snippet?

",slorber,jimbolla
323,2017-01-13 23:39:36,"@markerikson I see your example but still it's different from what @jimbolla show in his code snipped



VS

 


Maybe I'm missing something, but can you give me the verbose version of the following snippet?

",slorber,markerikson
323,2017-03-08 06:26:28,"Hi @slorber @markerikson and @jimbolla ,

I wasn't aware that this PR was here and I opened a similar PR that -obviously- got immediately closed by @markerikson. Sorry about that, I did check in the opened issues if there was a feature request for this and I saw nothing. I should have also checked in the opened PRs... my bad!

I would really like to see this enhancement shipped and I'm pretty sure that I know how to solve the ""factory style"" issue that seems to be blocking this PR. Is it cool if I solve that issue in my branch? Or should I try to add a commit to this branch?

",josepot,slorber
323,2017-03-08 06:26:28,"Hi @slorber @markerikson and @jimbolla ,

I wasn't aware that this PR was here and I opened a similar PR that -obviously- got immediately closed by @markerikson. Sorry about that, I did check in the opened issues if there was a feature request for this and I saw nothing. I should have also checked in the opened PRs... my bad!

I would really like to see this enhancement shipped and I'm pretty sure that I know how to solve the ""factory style"" issue that seems to be blocking this PR. Is it cool if I solve that issue in my branch? Or should I try to add a commit to this branch?

",josepot,jimbolla
323,2017-03-08 06:26:28,"Hi @slorber @markerikson and @jimbolla ,

I wasn't aware that this PR was here and I opened a similar PR that -obviously- got immediately closed by @markerikson. Sorry about that, I did check in the opened issues if there was a feature request for this and I saw nothing. I should have also checked in the opened PRs... my bad!

I would really like to see this enhancement shipped and I'm pretty sure that I know how to solve the ""factory style"" issue that seems to be blocking this PR. Is it cool if I solve that issue in my branch? Or should I try to add a commit to this branch?

",josepot,markerikson
323,2017-03-08 09:37:06,"Hi again @slorber @markerikson and @jimbolla !

I've added the [following commit into my branch](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758) which makes the `mapStateToProps` object argument compatible with factory selectors as [@jimbolla suggested](https://github.com/reactjs/react-redux/pull/323#issuecomment-272251764).

I've also added [the following test](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758#diff-b5fd7a42ea1b8efa382416b4a323003cR1951) to make sure that it works... and it does 😄 

Since this PR seems to be stale, would it be ok for me to suggest that I make the PR from my branch which also has no conflicts with master?",josepot,slorber
323,2017-03-08 09:37:06,"Hi again @slorber @markerikson and @jimbolla !

I've added the [following commit into my branch](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758) which makes the `mapStateToProps` object argument compatible with factory selectors as [@jimbolla suggested](https://github.com/reactjs/react-redux/pull/323#issuecomment-272251764).

I've also added [the following test](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758#diff-b5fd7a42ea1b8efa382416b4a323003cR1951) to make sure that it works... and it does 😄 

Since this PR seems to be stale, would it be ok for me to suggest that I make the PR from my branch which also has no conflicts with master?",josepot,jimbolla
323,2017-03-08 09:37:06,"Hi again @slorber @markerikson and @jimbolla !

I've added the [following commit into my branch](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758) which makes the `mapStateToProps` object argument compatible with factory selectors as [@jimbolla suggested](https://github.com/reactjs/react-redux/pull/323#issuecomment-272251764).

I've also added [the following test](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758#diff-b5fd7a42ea1b8efa382416b4a323003cR1951) to make sure that it works... and it does 😄 

Since this PR seems to be stale, would it be ok for me to suggest that I make the PR from my branch which also has no conflicts with master?",josepot,markerikson
322,2016-03-21 21:02:20,"Yes, Dan @gaearon,
This is the [repo](https://github.com/srlopez/rntest), and in the [src/pages/TestForm.js](https://github.com/srlopez/rntest/blob/master/src/pages/TetsForm.js) you can see:



Direct dispatching in point 1, does not reflect in screen (the field name remains empty), but delayed dispatching as in point 2, reflect the mutation in field URL (and in NAME  too if both lines of code are executed, without comment marks)

Talking about Redux, the 'scene' is connected in [App.js](https://github.com/srlopez/rntest/blob/master/src/App.js) lines 55-67



And the `App` is on lines 21-53 of the same file, as a typical `Navigator` component, so all the scenes are 'connected' and the connectComponent is the typical  react-redux '`connect`' function in [AppContainer.js](https://github.com/srlopez/rntest/blob/master/src/AppContainer.js), just few lines ...



There is no doubt, the component is '`connect'ed` and Redux is well working, the trace display all the actions are dispatched. 

To test the behavior we are talking about, you know, clone the repo, run it (you can run using `npm run nurse`), next on first screen, press 'Go to Form' and ... you pass throw the `componentWillMount()` above.

If you need some help, this Form is inspired by @kasprownik and his code in this [repo](https://github.com/kasprownik/react-forms-tutorial) write in ReactJS and well explained in this [http://x-team.com/2016/02/tutorial-forms-in-react-and-redux/](blog)
",srlopez,gaearon
313,2016-03-29 21:49:21,"@Robinnnnn I have similar need that I want to access `store` in `onEnter`. How did you solve your problem?
",jungejason,Robinnnnn
313,2016-03-30 03:24:39,"hey @jungejason, I just decided to pass down the store as props into the component that was generating my routes. Here is my code, in full:



And here is the parent file:


",Robinnnnn,jungejason
313,2016-03-31 00:37:15,"Thank you @Robinnnnn!!
",jungejason,Robinnnnn
313,2016-04-14 17:29:34,"Thank you @gaearon!! It's nice to be able to still have `routes` in a separated file. 

BTW, I really like your Redux training on egghead.io. I really enjoy the way you describe the idea, then do a simple implementation, and then finally add layers of abstractions at the end. It's the best training video I've seen in the last several years. Thank you!
",jungejason,gaearon
313,2016-04-14 18:17:35,"@jungejason Thank you for kind words!
",gaearon,jungejason
313,2016-04-15 13:11:06,"The ability to abstract `routes.js` is super helpful. 

On another note, I side with @jungejason -- thank you for all that you do @gaearon, your egghead videos are the reason I decided to migrate our web stack to React + Redux and away from Angular. I'm a much happier person now :)
",Robinnnnn,gaearon
313,2016-04-15 13:11:06,"The ability to abstract `routes.js` is super helpful. 

On another note, I side with @jungejason -- thank you for all that you do @gaearon, your egghead videos are the reason I decided to migrate our web stack to React + Redux and away from Angular. I'm a much happier person now :)
",Robinnnnn,jungejason
309,2016-03-22 16:58:12,"Hey @BerkeleyTrue, @gaearon, is anyone working on this currently? 
Would love to take a look and see if I can work on this if no one is. :smiley: 
Cheers!
",moaazsidat,BerkeleyTrue
309,2016-03-22 16:58:12,"Hey @BerkeleyTrue, @gaearon, is anyone working on this currently? 
Would love to take a look and see if I can work on this if no one is. :smiley: 
Cheers!
",moaazsidat,gaearon
307,2016-03-05 05:56:21,"@iamakulov  Thanks lot for your answer. I understood how to dispatch for initial loading.

> The dispatching can take place in any appropriate part of your app. If the app is small, I’d do it right where the store is created.

Now, my application wouldn't be small. I have scenario where I need to initialize a component with fresh data whenever it gets called. 

Now, I have three case where my component gets called.

1). When I simply click on link to go to ""home"". `<Link to=""/home"">Home</Link>`

2). When I do dynamic routing to ""home"". `store.dispatch(push(""/home"");`

3). When user sometimes directly change URL in brwoser and hit ""Enter"". `http://localhost:8080/myapp/home`

> The dispatching can take place in any appropriate part of your app

So, I actually don't know what is appropriate part of my app where I can handle fresh data loading in all three scenarios?

@gaearon Can you please reopen the issue? Because I still confused and my closed issue might not get any attention.

Thanks again
Manan V. Panchal
",mananvpanchal,gaearon
307,2016-03-05 05:56:21,"@iamakulov  Thanks lot for your answer. I understood how to dispatch for initial loading.

> The dispatching can take place in any appropriate part of your app. If the app is small, I’d do it right where the store is created.

Now, my application wouldn't be small. I have scenario where I need to initialize a component with fresh data whenever it gets called. 

Now, I have three case where my component gets called.

1). When I simply click on link to go to ""home"". `<Link to=""/home"">Home</Link>`

2). When I do dynamic routing to ""home"". `store.dispatch(push(""/home"");`

3). When user sometimes directly change URL in brwoser and hit ""Enter"". `http://localhost:8080/myapp/home`

> The dispatching can take place in any appropriate part of your app

So, I actually don't know what is appropriate part of my app where I can handle fresh data loading in all three scenarios?

@gaearon Can you please reopen the issue? Because I still confused and my closed issue might not get any attention.

Thanks again
Manan V. Panchal
",mananvpanchal,iamakulov
307,2016-03-05 07:31:28,"@mananvpanchal, do you have any action that is triggered when a user switches to a route? If so, I’d create a middleware that listens for such switch actions, checks if the switch is performed to `/home`, and dispatches an additional `loadText` async action if it is. This way is quite verbose (as the new middleware is created), but I don’t know the more elegant one.
",iamakulov,mananvpanchal
307,2016-03-05 09:34:49,"@iamakulov Thank you very much. I will try to implement triggering actions on route switching. Need to research on route switching. That way I can handle all three scenarios. But, need to research first that how can I know that ""route is going to switch now"".
",mananvpanchal,iamakulov
307,2016-03-05 10:41:15,"@iamakulov I found something like this.

`<Route path=""home"" component={Home} onEnter={loadHome}/>`

and I write ""loadHome"" like this

`const loadHome = () => {
    store.dispatch({type: ""LOAD_HOME""});
};`

Using this, I can handle all that three scenario.

Thanks.
",mananvpanchal,iamakulov
306,2016-03-05 08:42:31,"@gaearon sorry, maybe I said it wrong. The ""problem"" is that I don't want the store to be overridden. The point is to have **both** stores in the `contex`:



Besides those technical details, how do you see this approach? Does it make sense for you?

Thanks.
",emmenko,gaearon
304,2016-03-04 18:54:36,"^^^ these answers are correct, thanks @iamakulov for answering!
",gaearon,iamakulov
301,2016-02-24 14:51:52,"@Sunakujira1 I don't think so, you can see from my first comment how my states look and how I update its contents. It works fine in majority of cases as well, only when two neigbour contents with similar type are sorted it doesn't. I'm starting to think that this could be something to do with contentEditable as all elements that have an issue have it within them. 
",IljaDaderko,Sunakujira1
301,2016-02-24 15:35:47,"@IljaDaderko Hmm, you are right, state seems fine.
Do you have `key` specified for each `StoryBlock`? Seems to be quite important as specified [here](https://facebook.github.io/react/docs/multiple-components.html#dynamic-children).  
Also, I am not as familiar with `this.props.children`, but I'm guessing it may be the case that `StoryBlockText` are not being re-rendered due to the `StoryBlock` not having any difference in props.
",Sunakujira1,IljaDaderko
301,2016-02-24 15:43:50,"@Sunakujira1 I got it! so I was setting key of each storyBlock to index gathered from map() somehow this led to isues, changing this key to something like uniqe random id I generated for each block helps.
",IljaDaderko,Sunakujira1
301,2016-09-15 14:54:17,"Hi @gaearon , thanks for your answer. I am having a similar problem (check http://stackoverflow.com/questions/39513753/how-can-i-force-re-rendering-when-redux-state-is-changed-but-react-does-not-trig).

As far as I understand, React will re-render a component if nextProps and actual props differ. Why is it then needed to call the componentWillReceiveProps(nextProps) method, should the component do this automatically?

Thanks again!
",nicmesan,gaearon
300,2016-03-04 23:10:34,"@matianfu , @davibe : I think your concerns are based on a misunderstanding of how the Connect wrapper component actually works.  Note that there is a distinction between ""the Connect wrapper component re-renders"" and ""the wrapped original component re-renders"".

The wrapper component does not actually call your `mapStateToProps` function as part of the `shouldComponentUpdate` logic.  That call is deferred as long as possible, and actually only happens when the wrapper component re-renders.  Per https://github.com/reactjs/react-redux/blob/master/src/components/connect.js#L248-L270 , during the wrapper rendering process, it re-runs your `mapStateToProps`, and checks to see if the merged props have actually changed since last time.  If they have not (like, say, if an unrelated portion of the state store changed), then the Connect component directly returns the cached React element, _and does not even tell your component to re-render_.

So, what that means is that we DO want the Connect wrapper component to re-render if the store has changed, but that does NOT automatically mean that your own component will actually re-render as well.  It just means that things MAY be different, and now the Connect component needs to do additional checking based on the store and `mapStateToProps`.

@davibe , you may need to do some additional looking at your components.  Remember that Connect only does shallow equality checking by default - if you're returning new instances in your `mapStateToProps` (such as using `someArray.map()`), those will always be seen as different and force a re-render of your component.  It might help to use a debug tool that indicates why a component re-rendered, such as https://github.com/redsunsoft/react-render-visualizer , https://github.com/spredfast/react-transform-render-visualizer , or the ""WhyDidYouUpdateMixin"" listed at http://benchling.engineering/deep-dive-react-perf-debugging/ .
",markerikson,davibe
300,2016-03-04 23:10:34,"@matianfu , @davibe : I think your concerns are based on a misunderstanding of how the Connect wrapper component actually works.  Note that there is a distinction between ""the Connect wrapper component re-renders"" and ""the wrapped original component re-renders"".

The wrapper component does not actually call your `mapStateToProps` function as part of the `shouldComponentUpdate` logic.  That call is deferred as long as possible, and actually only happens when the wrapper component re-renders.  Per https://github.com/reactjs/react-redux/blob/master/src/components/connect.js#L248-L270 , during the wrapper rendering process, it re-runs your `mapStateToProps`, and checks to see if the merged props have actually changed since last time.  If they have not (like, say, if an unrelated portion of the state store changed), then the Connect component directly returns the cached React element, _and does not even tell your component to re-render_.

So, what that means is that we DO want the Connect wrapper component to re-render if the store has changed, but that does NOT automatically mean that your own component will actually re-render as well.  It just means that things MAY be different, and now the Connect component needs to do additional checking based on the store and `mapStateToProps`.

@davibe , you may need to do some additional looking at your components.  Remember that Connect only does shallow equality checking by default - if you're returning new instances in your `mapStateToProps` (such as using `someArray.map()`), those will always be seen as different and force a re-render of your component.  It might help to use a debug tool that indicates why a component re-rendered, such as https://github.com/redsunsoft/react-render-visualizer , https://github.com/spredfast/react-transform-render-visualizer , or the ""WhyDidYouUpdateMixin"" listed at http://benchling.engineering/deep-dive-react-perf-debugging/ .
",markerikson,matianfu
300,2016-03-04 23:33:26,"@markerikson i already made sure that my stateToProps does not do funny things. 

I discovered that my purely functional component only re-renders if i fire an action that changes the query params using redux-router `replaceState`. If i fire another action the store does change but my component does not actually rerender (which is good). There must be something that react-router does which is unrelated to redux. As you explained it the connect wrapping element should be able to prevent the normal 'react' way of updating the components, but it's not
",davibe,markerikson
300,2016-04-12 15:51:27,"@davibe 

Yes, I think this is related to the context change. In this case returning constant element is not enough to bail out of reconciliation. That’s a rare case though so I wouldn’t worry too much about it.
",gaearon,davibe
294,2016-02-23 18:19:48,"I agree with what you are saying. @gaearon `react-css-modules` is invasive and @FredyC you are correct you _can_ go very far with vanilla css modules, but dasherized css class names i.e. `my-css-class-name` is a very common use case it supports. To me it felt like the lesser of two evils. I mean what if you want to include third party css? Was thinking about writing a postcss plugin that rewrites the class names to camel case to fix this the 'easy' way, but realized that React looks for dasherized class names when adding CSS transitions :/ . cc @gajus
",kristoferjoseph,FredyC
294,2016-02-23 18:19:48,"I agree with what you are saying. @gaearon `react-css-modules` is invasive and @FredyC you are correct you _can_ go very far with vanilla css modules, but dasherized css class names i.e. `my-css-class-name` is a very common use case it supports. To me it felt like the lesser of two evils. I mean what if you want to include third party css? Was thinking about writing a postcss plugin that rewrites the class names to camel case to fix this the 'easy' way, but realized that React looks for dasherized class names when adding CSS transitions :/ . cc @gajus
",kristoferjoseph,gaearon
294,2016-02-24 21:59:32,"@FredyC Exactly. I've been using the `style['dasherized-classe-name']` approach. Thar definitely be dragons there though for brining on new devs etc. Not terrible, just a rake waiting to be stepped on in the middle of the room.
",kristoferjoseph,FredyC
292,2016-02-18 02:21:57,"@gaearon We encountered this same issue early on in development of Relay and are using `unstable_batchedUpdates` to prevent such discrepancies at the framework level. We have a `relayUnstableBatchedUpdates` module that is forked to use the appropriate version depending on web/native - see the two versions at https://github.com/facebook/relay/tree/master/src/tools.
",josephsavona,gaearon
292,2016-02-18 05:07:50,"Thanks everyone for taking a look and weighing in! I'm very interested if you find out more details about incorporating `unstable_batchedUdpates` @gaearon 
",chandlerprall,gaearon
292,2016-02-18 15:38:32,"@gaearon yup!
",josephsavona,gaearon
292,2016-02-26 13:26:28,"@gaearon 

If 

1) only root component subscribe to redux store.
2) all component passing store to all children in JSX, something like:



3) all container components do `this.setState({ store: nextprops.store, ... })` in `componentWillReceiveProps(nextprops)`

Do you think the problem will be solved?

This is basically the React way. I think react-redux should NOT `setState()` outside the React work flow (reconciliation). Store state should only be passed by props in top-down manner, and `setState()` should only be called in componentWillReceiveProps(). The root cause of the problem could be considered that redux uses a single JavaScript object, and redux emit change events too early.

Besides, the reference equality check, the gem of redux, could be done in shouldComponentUpdate(). Here, both store state and props is synchronized, and unnecessary render() can be prevented.

If this works, it looks much cleaner than current implementation in react-redux.
",matianfu,gaearon
292,2016-04-30 14:33:09,"@tappleby 

> My only idea is having each connected component being responsible for notifying its own children instead of subscribing directly to the store, this would end up with only the root connected component being subscribed to redux.

I agree with that.

It looks to me an antipattern to have `Parent > Child`, both using `connect`, and parent passing down props to child. If Child has to receive props from Parent, the parent could pass as props everything the child needs. I don't really see any advantage of the child receiving state from both props and connect at the same time and it's probably better to choose one or the other but not both at the same time.

@epeli 

> But the biggest argument for enabling it by default in my opinion is that it makes dispatch() consistent. Currently by default dispatch() can surprise you because it works differently depending on when you happen to call it. Ex. onClick vs. setTimeout.

Do you mean that dispatches from event handlers are batched automatically? If that's the case yes it's probably worth batching automatically on dispatches to have a consistent behavior, even if I still think the issue described here can be avoided in the first place.
",slorber,tappleby
292,2016-04-30 14:33:09,"@tappleby 

> My only idea is having each connected component being responsible for notifying its own children instead of subscribing directly to the store, this would end up with only the root connected component being subscribed to redux.

I agree with that.

It looks to me an antipattern to have `Parent > Child`, both using `connect`, and parent passing down props to child. If Child has to receive props from Parent, the parent could pass as props everything the child needs. I don't really see any advantage of the child receiving state from both props and connect at the same time and it's probably better to choose one or the other but not both at the same time.

@epeli 

> But the biggest argument for enabling it by default in my opinion is that it makes dispatch() consistent. Currently by default dispatch() can surprise you because it works differently depending on when you happen to call it. Ex. onClick vs. setTimeout.

Do you mean that dispatches from event handlers are batched automatically? If that's the case yes it's probably worth batching automatically on dispatches to have a consistent behavior, even if I still think the issue described here can be avoided in the first place.
",slorber,epeli
292,2016-06-17 07:28:00,"@slorber 

> Do you mean that dispatches from event handlers are batched automatically? 

Yes.
",epeli,slorber
290,2016-02-16 16:27:43,"@mohsen1 I'm using custom typings for `connect`:



They only work with stateless functional components and don't cover all cases, but types are inferred correctly:



The major drawback that kept me from submitting these to DefinitelyTyped is that TypeScript doesn't understand decorators that change type.

Before that I had to explicitly specify `props` type and make every prop optional.
",aikoven,mohsen1
290,2016-02-16 23:43:03,"@aikoven how is Angular2 solving it with their decorators?
",mikekidder,aikoven
290,2016-02-17 04:53:42,"@mikekidder I'm not aware of it, could you please point to some examples?
",aikoven,mikekidder
290,2016-02-17 05:17:08,"@aikoven can you share your full `react-redux.d.ts` file so I can try it out?
",mohsen1,aikoven
290,2016-02-17 06:59:36,"@mohsen1 https://gist.github.com/aikoven/be8a430ab2a38baaf29f
",aikoven,mohsen1
290,2016-02-17 07:28:17,"@gaearon - I also had this problem, but did not found any good solution. It's actually problem of how `.tsx` understands component class.

@mikekidder - Angular2 decorators are not useful here. Their way is binding a property of a class to input attr. If something similar was made for react it would look like this:



and now `render(…, <App/>)` would compile, because binding of `title=""…""` property to component attribute `appTitle` is done under the hood and `.tsx` compiler thinks that `App` does not have any props. And this of course will work well if we omit using of regular `props`…
",ulfryk,mikekidder
290,2016-02-17 07:28:17,"@gaearon - I also had this problem, but did not found any good solution. It's actually problem of how `.tsx` understands component class.

@mikekidder - Angular2 decorators are not useful here. Their way is binding a property of a class to input attr. If something similar was made for react it would look like this:



and now `render(…, <App/>)` would compile, because binding of `title=""…""` property to component attribute `appTitle` is done under the hood and `.tsx` compiler thinks that `App` does not have any props. And this of course will work well if we omit using of regular `props`…
",ulfryk,gaearon
290,2016-09-12 06:49:16,"@codeandcats Nope, but there are some issues in TS repo to track, e.g.: https://github.com/Microsoft/TypeScript/issues/4881
",aikoven,codeandcats
290,2016-10-20 01:18:46,"@Zalastax it looks like that PR has been closed. 😢  I don't suppose you feel like forking and re-requesting it? 🌹 
",codeandcats,Zalastax
289,2016-03-01 18:18:32,"Hi @gaearon 

Since React-Router allows you get access to the router, history, location etc.... via the context, how can you get access to the context from mapStateToProps() ?

Since its now a documented feature of React, react-redux should expose context in the public api, right ?

Best regards ?
",lauterry,gaearon
289,2017-01-18 02:08:07,"@jimbolla By only injecting it into `connectAdvanced`, we're limiting the arity problem. You don't have to worry about how many args `mapStateToProps` or `mapDispatchToProps` take because the user is now in control of that.

Whether or not the context is passed to the inner function of `selectorFactory` could be a factory option; perhaps `{contextTypes: xxx}`, same as what the React Component and `recompose` accept.

`reselect` is a separate package; `react-redux` isn't responsible for that. Regardless, I think most of us are just going to copy the relevant context into the props, and then `reselect` will be able to handle it just fine. That's exactly what I've done, and it's working great so far.

I did manage to get [`getContext`](https://github.com/acdlite/recompose/blob/master/docs/API.md#getcontext) working though, so thank you for that! This would have been a big pain without it. I suppose I'm less concerned about this now that you've posted a reasonable workaround, but it doesn't sound like it would be that difficult to add. I think the lifecycle problem can just be ignored -- context updates simply won't be propagated since React doesn't really support it anyway.",mnpenner,jimbolla
289,2017-02-10 18:18:13,"@adriancooney what solution have you implemented in the end?

My dirty way:

and in the component:
",zergione,adriancooney
289,2017-02-11 22:21:16,@zergione in the end I opted to manage the state globally. I took a bit more effort but it felt more organised with the app and not tied to the implementation.,adriancooney,zergione
287,2016-02-20 22:50:09,"Nice link by @FredyC Thanks. Some good insight into the ever evolving complexities of ES*
",topgun743,FredyC
285,2016-02-12 17:07:23,"@gaearon thanks for the quick feedback. I'm really interested in getting something that works for this, but it seems you have pretty specific ideas about how it should work. Would you mind giving a little bit more guidance on how you'd like to see this structured? Happy to put the work in to get to something useful. I'm struggling to see how to get a clean API here without inheritance when so many lifecycle methods are involved. We could double wrap the component but that seems even worse to me.
",mhodgson,gaearon
285,2016-02-13 12:53:34,"@mhodgson yes i'd also prefer to avoid inheritence but rather use composition / strategy pattern, where the default strategy remains compatible with current behavior.
",slorber,mhodgson
283,2016-02-10 15:43:15,"@salztorte This will not help. In this case you should process with babel this code. It's not fast.
",TrySound,salztorte
283,2016-02-10 15:44:15,"@salztorte See here
https://github.com/rackt/redux/pull/1369
",TrySound,salztorte
281,2016-02-05 14:55:45,"Thanks @gaearon.  This was extremely helpful. Have a nice weekend.
",TomiS,gaearon
279,2016-02-09 22:06:51,"@tgriesser I have started to update the Reselect docs to reflect this change. If you haven't started on this already, would you like me to carry on and document it?
",ellbee,tgriesser
278,2016-02-03 11:47:50,"@tomkis1 Thanks for this great overview! I'm familiar with the Elm Architecture, but the missing piece was this library https://github.com/salsita/redux-elm/ which looks like new kid on the block.

Several real-world questions aren't yet answered for me, but I'll study the examples from this repo first.
",sompylasar,tomkis1
278,2016-02-03 12:52:42,"@sompylasar Please keep in mind that it's not a framework nor library, it's just a proof of concept that we can write Elm like programs using redux. Good thing is that using this approach will solve many problems  which otherwise needs some solution while using redux.
",tomkis1,sompylasar
278,2016-02-06 14:02:11,"@tomkis1 I like the Elm architecture and it seems perfect to handle local component state, however I think it's missing something for real world apps.

Wrapping actions according to the dom tree structure means at the top your mailbox basically only receive some kind of global action like APP_STATE_CHANGED, and it's the deeply nested payload of that action that actually holds the useful action. So if you have an app with a lot of counters everywhere, at very different nested levels, it seems pretty hard for me to listen to ALL the increment actions of ALL counters, and display that value somewhere.

I've written something here and did not get any good answer but maybe you can try to solve my counter problem? https://github.com/evancz/elm-architecture-tutorial/issues/50

By the way, I'd appreciate if you wanted to contribute to this [TodoMVC-Onboarding](https://github.com/slorber/todomvc-onboarding) with an Elm architecture solution.
",slorber,tomkis1
278,2016-02-06 14:08:48,"@sompylasar maybe the DDD part of my anwser here can interest you: https://github.com/rackt/redux/issues/1315#issuecomment-179164091
",slorber,sompylasar
278,2016-02-06 14:24:57,"@slorber :+1:
",sompylasar,slorber
278,2016-02-14 00:54:27,"@sompylasar Thanks for the kind words in https://github.com/reactjs/redux/issues/419#issuecomment-183775729.  I believe everything in my article, [React, Automatic Redux Providers, and Replicators](https://medium.com/@timbur/react-automatic-redux-providers-and-replicators-c4e35a39f1), covers most of your questions and provides solutions for nearly all of them.  I'd be glad to answer any specific questions.  In advance, if you can include some background/reasoning behind your questions, it would help me answer them to the best of my ability.  :)
",timbur,sompylasar
278,2016-02-14 01:20:23,"@timbur Yes, thank you, I'm very excited with the article, that's exactly what I was looking for. I'm still reading it now, I'll ping you here if something comes into mind. One thing for now is I wonder how would redux-saga fit into the proposed architecture.
",sompylasar,timbur
273,2016-03-31 08:40:19,"@tmcw Do you have your branch somewhere on github? I am also facing problems with re-render and finding it is very hard to tell why a connected component re-renders. Currently I am hooking mergeProps(), saving the previous props and then doing shallowEquals with them. But all the props are the same so something else is going on but I have no clue what since the wrapper component does not output any debugging info.

The demo of react-transform-render-visualizer sure seems nice but in a large project with complex state I don't think it will work well. For example I have immutablejs state etc. It also requires your components to be classes but most of mine are stateless functions. In addition it requires babel. 

Some other solution to seeing why a connected component re-renders would be really nice. Maybe the wrapper component could take an option that turns logging on?
",jonaskello,tmcw
270,2016-01-27 00:02:04,"@gaearon:
Currently, `static` methods are hoisted, why not `prototype` methods? What's the difference? Current implementation just seems incomplete.
With this functionality, `@connect` can be added or removed without caring about changing how `refs` are managed from containers.
I integrated this into my app and it works flawlessly.

A. Can you think of a scenario where it wouldn't be desired?
B. If I change the code to hoist methods optionally, e.g. `{ withRef: true, hoistMethods: /* whitelist */ ['focus', 'scrollToBottom'] }` or `{ withRef: true, hoistMethods: /* all methods */ true }` 
would this be merged?
",elado,gaearon
270,2016-09-20 06:19:47,"Dan @gaearon , thanks for your great input!

I'm using your suggestions to implement my wizard. Basically what i'm doing is when clicking the next button in Parent component (the wizard container), I need to call the submit function of Child component (the wizard page).

before I wrap my child component with connect, I was able to call wizard page's submit method by wiring up Parent ->  Child thru ref, i.e   



and it worked fine.

I then found out that I need to wrap my child component to a connect component , and after that, I lost control to the Child component, as the activePage is now pointing to the wrapper component, which doesn't have submit method defined (only static function hoisted, not prototype)

Yes, I can use getWrappedInstance() which I believe will work just fine, but I really like your idea of passing callbacks to child and let child set the value that Parent is interested in, so I decided to give it a go



and this also works fine as well. great! 

my question, is that when passing a callback to child, why can't we name the prop 'ref', i.e. 



won't work and will cause exception at child component, saying this.props.ownProps.ref is undefined, but I have defined it and passed down to child.. don't really understand why I got that error

does this mean that connect component will selectively filter out some props?
",bochen2014,gaearon
269,2016-01-29 17:29:03,"@gaearon a usecase for https://github.com/rackt/react-redux/pull/208 would be to build a React.Perf middleware so that we can take measures for every dispatched action.

If subscription returned a promise resolved on setState callback, then the redux Middleware could be able to know when rendering has ended and measure wasted time that is relative to a given action.
See also this issue that can make it more complicated to build: https://github.com/facebook/react/issues/3611

There's already a not-really advanced middleware that does not take account that renderings can happen in an async way: https://github.com/AvraamMavridis/redux-perf-middleware

---

Also for my initial custom connect proposal I think another usecase is when we want to bind dom inputs to redux state. It might work well with events on a small app but I guess once the app becomes big, on a mobile device typing in an input triggering hundreds of HOC may be a problem?

---

@gaearon yes that would be great to provide full flexibility so that we can compose code in the way we want to use it without rewritting/forking the lib.

Also it can be nice to have an experimental API so that you can eventually change your mind later.

I  don't have an API in mind I'll have to digg deeper in the implementation details of connect :)
",slorber,gaearon
269,2016-02-11 18:26:27,"@gaearon @slorber I have a PR that attempts to address this here: #285. Would be interested in your thoughts. Not ready to merge, but want to know if it is directionally interesting.
",mhodgson,slorber
269,2016-02-11 18:26:27,"@gaearon @slorber I have a PR that attempts to address this here: #285. Would be interested in your thoughts. Not ready to merge, but want to know if it is directionally interesting.
",mhodgson,gaearon
269,2016-02-13 12:56:37,"@gaearon also it seems there is a community need to run multiple redux stores (https://github.com/reactjs/redux/issues/1385)

It could be nice if we could also pass to the provider a map of stores and if the connect method was flexible enough to permit to select the appropriate store from context
",slorber,gaearon
269,2016-05-02 09:50:56,"@gaearon @slorber @mhodgson 

Was playing around with one attempt at splitting the core connect features into two different HOC: connector and cacher.

https://github.com/jtadmor/react-redux/commit/b829ece0688f71b0b5acb2ed73233f075487d8d6

The basic idea is that cacher should not know at all about the store or where state comes from. It receives all of the old connect() arguments, but doesn't actually hook up to a store. Instead, it requires the following props:



Instead of a handleChange method, it will now attempt to calculate mapStateFromProps only when storeState changes or if mapStateFromProps depends on props and ownProps changes. Ditto for mapDispatchToProps.

The connector accepts a wide variety of options:



These are designed to give consumers ability to customize the behavior, while falling back to sane default behavior, e.g. `store` falls back to `context.store`, `dispatchFromStore` falls back to `(store) => store.dispatch` and so forth.

You could call `connector()(Component)` and it would work just fine.

Regarding updating the subscription on `componentWillReceiveProps`, I've tried to solve that by allowing the options to specify either `subscribeFromStore` or `subscribeFromStoreAndProps`, and optionally allow a `resubscribeIf` that would look like `(props) => props.node_id`. This forces consumers to be explicit about whether resubscriptions should ever happen while the component is mounted but also provide fine-grained control.

I based this on suggestions [here](https://github.com/reactjs/react-redux/pull/348#issuecomment-214131076).

The major thing I'm not sure on is how to avoid `setState` on Connector when Cacher is not going to end up re-rendering. Right now the `handleChange` default behavior is to do a `setState` whenever the store broadcasts. Although Connector does allow for other optimizations, I'd need to figure out how to keep that one.

What I'm not sure on is the best API for each. Right now they are separate functions, but still very coupled in that Connector passes down storeState, ownProps, dispatch, and Cacher consumes those. One possibly way to make them more re-usable is to allow, e.g. Cacher options argument to let the consumer specify something like `getOwnPropsFromProps = (props) => {}` and `getDispatchFromProps`, `getStoreStateFromProps` likewise.

Also, we now have two wrapper components instead of one to provide the same basic functionality as before. (This could be mitigated by keeping connect as is, but export the two more modular HOC as well, although that leaves future development a pain).

Let me know if this seems like a fruitful avenue.
",jtadmor,slorber
269,2016-05-02 09:50:56,"@gaearon @slorber @mhodgson 

Was playing around with one attempt at splitting the core connect features into two different HOC: connector and cacher.

https://github.com/jtadmor/react-redux/commit/b829ece0688f71b0b5acb2ed73233f075487d8d6

The basic idea is that cacher should not know at all about the store or where state comes from. It receives all of the old connect() arguments, but doesn't actually hook up to a store. Instead, it requires the following props:



Instead of a handleChange method, it will now attempt to calculate mapStateFromProps only when storeState changes or if mapStateFromProps depends on props and ownProps changes. Ditto for mapDispatchToProps.

The connector accepts a wide variety of options:



These are designed to give consumers ability to customize the behavior, while falling back to sane default behavior, e.g. `store` falls back to `context.store`, `dispatchFromStore` falls back to `(store) => store.dispatch` and so forth.

You could call `connector()(Component)` and it would work just fine.

Regarding updating the subscription on `componentWillReceiveProps`, I've tried to solve that by allowing the options to specify either `subscribeFromStore` or `subscribeFromStoreAndProps`, and optionally allow a `resubscribeIf` that would look like `(props) => props.node_id`. This forces consumers to be explicit about whether resubscriptions should ever happen while the component is mounted but also provide fine-grained control.

I based this on suggestions [here](https://github.com/reactjs/react-redux/pull/348#issuecomment-214131076).

The major thing I'm not sure on is how to avoid `setState` on Connector when Cacher is not going to end up re-rendering. Right now the `handleChange` default behavior is to do a `setState` whenever the store broadcasts. Although Connector does allow for other optimizations, I'd need to figure out how to keep that one.

What I'm not sure on is the best API for each. Right now they are separate functions, but still very coupled in that Connector passes down storeState, ownProps, dispatch, and Cacher consumes those. One possibly way to make them more re-usable is to allow, e.g. Cacher options argument to let the consumer specify something like `getOwnPropsFromProps = (props) => {}` and `getDispatchFromProps`, `getStoreStateFromProps` likewise.

Also, we now have two wrapper components instead of one to provide the same basic functionality as before. (This could be mitigated by keeping connect as is, but export the two more modular HOC as well, although that leaves future development a pain).

Let me know if this seems like a fruitful avenue.
",jtadmor,gaearon
269,2016-05-02 09:50:56,"@gaearon @slorber @mhodgson 

Was playing around with one attempt at splitting the core connect features into two different HOC: connector and cacher.

https://github.com/jtadmor/react-redux/commit/b829ece0688f71b0b5acb2ed73233f075487d8d6

The basic idea is that cacher should not know at all about the store or where state comes from. It receives all of the old connect() arguments, but doesn't actually hook up to a store. Instead, it requires the following props:



Instead of a handleChange method, it will now attempt to calculate mapStateFromProps only when storeState changes or if mapStateFromProps depends on props and ownProps changes. Ditto for mapDispatchToProps.

The connector accepts a wide variety of options:



These are designed to give consumers ability to customize the behavior, while falling back to sane default behavior, e.g. `store` falls back to `context.store`, `dispatchFromStore` falls back to `(store) => store.dispatch` and so forth.

You could call `connector()(Component)` and it would work just fine.

Regarding updating the subscription on `componentWillReceiveProps`, I've tried to solve that by allowing the options to specify either `subscribeFromStore` or `subscribeFromStoreAndProps`, and optionally allow a `resubscribeIf` that would look like `(props) => props.node_id`. This forces consumers to be explicit about whether resubscriptions should ever happen while the component is mounted but also provide fine-grained control.

I based this on suggestions [here](https://github.com/reactjs/react-redux/pull/348#issuecomment-214131076).

The major thing I'm not sure on is how to avoid `setState` on Connector when Cacher is not going to end up re-rendering. Right now the `handleChange` default behavior is to do a `setState` whenever the store broadcasts. Although Connector does allow for other optimizations, I'd need to figure out how to keep that one.

What I'm not sure on is the best API for each. Right now they are separate functions, but still very coupled in that Connector passes down storeState, ownProps, dispatch, and Cacher consumes those. One possibly way to make them more re-usable is to allow, e.g. Cacher options argument to let the consumer specify something like `getOwnPropsFromProps = (props) => {}` and `getDispatchFromProps`, `getStoreStateFromProps` likewise.

Also, we now have two wrapper components instead of one to provide the same basic functionality as before. (This could be mitigated by keeping connect as is, but export the two more modular HOC as well, although that leaves future development a pain).

Let me know if this seems like a fruitful avenue.
",jtadmor,mhodgson
269,2016-05-02 10:09:47,"At first glance I like the extensibility and decomposition of the problem but I'm not sure it would be nice for performances to have 2 wrappers instead of one, when we already focus on optimizing the single one we currently have. 

I don't know what @gaearon exactly had in mind when saying

> Basically, what if we separated the component in connect from the caching and invalidation logic.

But I guess the idea is that the caching logic would be an utility function instead of a new wrapper, to avoid degrading performances

See also work being done here: https://github.com/reactjs/react-redux/issues/368
",slorber,gaearon
265,2016-01-24 03:15:37,"Hey @gaearon,

Yeah, I guess my question is very specific. So let me generalize it a bit. :)

From your egghead.io Redux tutorial, how would you `connect()` each Todo so that only the changed Todo re-renders (instead of the entire list)?

Here's my [JSBin](https://jsbin.com/lucego/edit?js,console,output) of the Todo example. I've: 
1. set an initial state, 
2. commented out where TodoList is `connect()`-ed, 
3. and `connect()`-ed the Todo component.

In `mapStateToTodoProps`, I don't know which Todo to reference in the Todos array, so I thought `ownProps` was how to do it. If you click on a Todo, the state correctly changes (see the console) but the Todo component does not re-render.

I hope this makes better sense. Thanks!
",gojohnnygo,gaearon
263,2016-01-22 07:13:29,"@epeli not sure I understand the issue, can you please explain with code?

So far it seems that the issue of multiple unnecessary renders is gone, due to debouncing it, and store is filled correctly after every single dispatch action (it doesn't wait for the debouce time to execute a bunch of actions together).
",elado,epeli
259,2016-12-09 14:49:37,"Sorry too for being off topic but I'm having the same issue as @beebase. I want to change between stores in a login/logout logic in react-native, and I'm not sure how can that be done. Have you found a solution @beebase ? Thanks!",jpamarohorta,beebase
256,2016-01-30 19:52:50,"Having `jsnext:main` pointing at untranspiled code will actively break Rollup users (and anybody else looking at that field).

I'll have to defer to @flying-sheep as to whether there are any benefits to having an ES2015 module build aside from the possibility of tree-shaking. I think tree-shaking matters a lot for allowing e.g.



over the much uglier



for minimizing bundle size, but that doesn't seem relevant here if everybody needs both `<Provider>` and `connect()`.

---

Separately, I'd say `mod/` might make sense in a vacuum, but unfortunately `modules/` already is used for non-transpiled source on a number of projects – `es6` at least conveys that you're using ES6 modules rather than CJS ones.
",taion,flying-sheep
256,2016-02-01 03:43:42,"@flying-sheep 

I don't think that's correct. Looking at the implementation of `_interopRequireDefault`, you wouldn't be able to do e.g.



At this point in time, I also don't think the extra bundle size purely from using CJS modules rather than ES6 ones (when tree shaking is not part of the picture) is really all that meaningful.
",taion,flying-sheep
255,2016-11-09 19:59:59,"@gaearon , I'm not sure I quite follow, how do we get dispatch passed into our component that also uses the mapDispatchToProps argument?

Thanks!
",tnrich,gaearon
255,2016-11-09 20:29:34,"@tnrich : yep, that looks correct. My personal opinion is that components generally shouldn't actually reference `dispatch` directly (per my article [Why Use Action Creators?](http://blog.isquaredsoftware.com/2016/10/idiomatic-redux-why-use-action-creators/) ), but if you want both `dispatch` and bound action creators, that's how you'd do it.
",markerikson,tnrich
253,2016-10-30 22:23:02,"@markerikson I'm not sure what that means.   Are you saying ""because of the temporal dead zone, we can't do better with an error message for this issue""?
",GreenAsJade,markerikson
240,2016-02-08 18:00:58,"@lucadegasperi I have raised an issue against the frame component and it's being worked on.
https://github.com/ryanseddon/react-frame-component/issues/29
",timjacobi,lucadegasperi
240,2016-02-08 19:59:57,"@timjacobi for now I have avoided using this technique, good thing someone is working on improving it.
",lucadegasperi,timjacobi
237,2016-01-04 23:52:50,"@gaearon Thanks for the info.

With that taken into consideration, I still think having `getState` in `mapDispatchToProps` is an important missing piece. Obviously, not everyone agrees with putting asynchrony downstream of the store. But as long as that's not an _unreasonable_ architectural choice, then the downstream still needs a way to get the state after it may have been updated. As far as I can tell, it would add a possibility that doesn't exist today. I may be missing something, but I don't think the solutions you presented account for this, because I don't think `mergeProps` allows for it. Also, It doesn't seem like having a `getState` callback would ruin performance, as it could be injected once and always work.

react-redux is a _great_ API, and I hope my comments haven't come off to the contrary. But I hope you understand that it makes more sense to try to advocate for ideas in an existing library than to maintain a fork or entirely separate product. I realize that a great deal of thought has been put into this already, so no disrespect intended to the work that's already been done. I haven't read #1 yet, but I definitely will, because I want to present productive ideas that haven't already been beaten to death.
",acjay,gaearon
237,2017-03-16 21:33:19,"@gaearon Dan, I wonder, the default `mergeProps` is `Object.assign({}, ownProps, stateProps, dispatchProps)` as stated in the docs.
Doesn't that also create a new object all the time, just like when one would override `mergeProps` with a custom function for binding action creators?

> Absolutely correct, this is a performance nightmare scenario where nothing really changes but bound functions kill the performance optimizations.

But when nothing really changed, the default `mergeProps` still creates a new object on every render. How does that not matter?
Maybe I'm confused, where the pure-render optimisation kicks in and which props it checks.",pke,gaearon
236,2016-01-07 18:41:35,"Before checking anything I just replaced `import { connect } from 'react-redux/native'` with `import { connect } from 'react-redux'`. Also updated the following:



I use the most recent version of `react-redux`:



I didn't need to change anything in the `react-redux` package. It just works, as expected by a tool from @gaearon ;-)
",Purii,gaearon
236,2016-01-07 19:07:19,"In npm 2.x, if you define peerDependencies, it will install it in your root node_modules. `react-redux` has a peerDependency to `react` and react-native has `react` module. if you start the app using `react-native start`, `haste` will throw an exception that `fbjs` on `react` has a conflict with `fbjs` in `react-native`. @Purii I would like to see an example from you. Would you create a repo and upload an example?
",alinz,Purii
236,2016-01-07 19:50:31,"@spicyj That's an interesting idea. Making react a peer dep sounds like it could be semantically correct. I think it's probably more correct that fbjs is a normal dependency though, and RN 0.19 may address the issue with conflicting fbjs modules with some patches that are being reviewed. (Alternatively npm3 fixes this too.)
",ide,spicyj
236,2016-01-07 20:20:22,"@alinz I use npm@3
",Purii,alinz
236,2016-01-07 20:26:29,"@Purii That should be it, since `npm@3` promises flat `node_modules`. The only issue is that, not all modules in `npmjs` are compatible with `npm@3`. Thanks though for letting me know
",alinz,Purii
236,2016-01-11 12:23:39,"@Purii thanks. your method works perfectly for me with npm@3
",mcz,Purii
236,2016-01-21 16:29:39,"I think it's safer to modify the instructions if/after `react-native` is a peer of `react`.
@spicyj Plans to make this happen?
",gaearon,spicyj
236,2016-02-04 15:49:13,"@zuk @alinz How did it work for you guys?
This is the error I get:



I'm using NPM3 with these dependencies:



I don't have `react` dependency in my package.json (should I have?)
Please anyone help :)
",ranyefet,zuk
236,2016-02-04 15:49:13,"@zuk @alinz How did it work for you guys?
This is the error I get:



I'm using NPM3 with these dependencies:



I don't have `react` dependency in my package.json (should I have?)
Please anyone help :)
",ranyefet,alinz
236,2016-02-04 16:04:00,"@gaearon Thanks Dan, looks like it's working :)

But, now I get a different error:



Which seems there's [no solution](https://github.com/facebook/react-native/issues/4968) yet :(
",ranyefet,gaearon
236,2016-02-04 16:50:59,"@ranyefet we do have `react@0.14.5` as our dependency in our project.  make sure to delete node_modules folder and try again. and here is my react-native module as a reference. 

![screen shot 2016-02-04 at 11 49 42 am](https://cloud.githubusercontent.com/assets/967050/12822317/85cd7022-cb35-11e5-9c80-4e1b88f60452.png)

my npm version is 3.6.0
my node version is v5.5.0
",alinz,ranyefet
236,2016-02-07 10:24:25,"Thanks @alinz upgrading Node to 5.5 appear to fixed other issues I had, weird!
",ranyefet,alinz
236,2016-02-17 15:05:02,"Good! But wasn't it included in 0.20? @gaearon do you recommend reinstalling the modules to make it work right now? 
",Emilios1995,gaearon
236,2016-02-17 17:54:57,"@gaearon working on it :) We'll know by Friday if ""React as as a peer dep"" is going to make it into the 0.21-RC branch cut.

Thanks for the ping. Trust me, we're working hard to get this stuff worked out and make React Native a better member of the general React ecosystem.
",skevy,gaearon
234,2016-02-07 23:48:59,"Hi @gaearon 

I'm not sure to understand your answer to @chrishowes .

Can you provide an example of what you mean by creating a custom higher-order component and how to use it.

Thx

Best regards
",lauterry,gaearon
234,2016-02-07 23:48:59,"Hi @gaearon 

I'm not sure to understand your answer to @chrishowes .

Can you provide an example of what you mean by creating a custom higher-order component and how to use it.

Thx

Best regards
",lauterry,chrishowes
228,2015-12-26 22:50:57,"@gaearon I share your point that it's fine to copy/paste and fork and really like these posts on the subject:
- http://us3.campaign-archive2.com/?u=1090565ccff48ac602d0a84b4&id=92902a19e4&e=6dbbf45b40
- http://udidahan.com/2009/06/07/the-fallacy-of-reuse/

Here it seems that the API surface to implement the connect feature is very small and that an abstraction make sense (like you probably did for react-hot-api?). Also if it's possible to avoid forking and benefit from further optimizations done by the community without having to backport it's better for me :)

I would be interested to know how you see implementations could diverge because I'm not sure how it could happen unless new redux store methods are added?

---

Anyway I've found another simpler option.



Let's consider the Redux store API as a reference implementation of a ""react connect standart"": I'll wrap my framework so that it exposes the exact same API in react context and it should work. Other frameworks could easily do the same too
",slorber,gaearon
227,2015-12-23 11:36:02,"@gaearon Thanks! Works fine with [v4.0.4](https://github.com/rackt/react-redux/releases/tag/v4.0.4).
",xcatliu,gaearon
223,2015-12-28 10:34:15,"@vsviridov I had the same situation :D, thanks to @gaearon advice, this works for me


",allochi,gaearon
223,2015-12-28 10:34:15,"@vsviridov I had the same situation :D, thanks to @gaearon advice, this works for me


",allochi,vsviridov
223,2015-12-29 00:05:21,"@allochi Thanks. That cleared things up.
",vsviridov,allochi
217,2015-12-13 22:10:14,"@mmahalwy try to get rid of `.map()` in `mapStateToProps`, as it creates new array each time `mapStateToProps` called (move it into `mergeProps`).
",alexkuz,mmahalwy
217,2015-12-14 03:37:22,"@alexkuz interesting suggestion. I guess i am struggling with the difference or their different purposes?
",mmahalwy,alexkuz
217,2015-12-14 09:53:31,"@mmahalwy yeah,`stateProps` are never shallow equal because of that.
You don't have to use `reselect` though, this should be enough:


",alexkuz,mmahalwy
217,2015-12-15 20:32:05,"@alexkuz awesome example, i am going to write it up now and get back to you on it EOD 

thanks!
",mmahalwy,alexkuz
217,2015-12-18 05:42:55,"@alexkuz just to update you, i changed things to look like this:



I am not super content with it and perhaps will visit reselect as @gaearon suggested. What I found is that the router state changes, and that creates many problems with the merge state as the component is still rendered and fails given the params have changed. I found the best solution was using react router's params being passed as props. But i may look to use reselect to clean this up more.
",mmahalwy,gaearon
217,2015-12-18 05:42:55,"@alexkuz just to update you, i changed things to look like this:



I am not super content with it and perhaps will visit reselect as @gaearon suggested. What I found is that the router state changes, and that creates many problems with the merge state as the component is still rendered and fails given the params have changed. I found the best solution was using react router's params being passed as props. But i may look to use reselect to clean this up more.
",mmahalwy,alexkuz
215,2015-12-12 11:29:20,"Hi @ohkaiby, thanks for the report (and creating a working example :+1:). I am looking at babel 6 stuff this weekend so hopefully we can get this resolved too.
",ellbee,ohkaiby
215,2016-02-11 18:27:43,"@gajus The documentation is unfortunately not in the README, it is in one of the release notes for Redux: https://github.com/rackt/redux/releases/tag/v2.0.0
",ohkaiby,gajus
215,2016-02-11 18:29:39,"Thank you @ohkaiby 
",gajus,ohkaiby
215,2016-02-11 19:10:03,"Sorry, @gaearon. Wrong thread to discuss the issue. Though I think @ohkaiby was talking about Redux documentation.

I couldn't find anything searching ""site:rackt.org HMR"", which would be useful. I came across this issue searching for ""store.replaceReducer"".
",gajus,gaearon
215,2016-02-11 19:10:03,"Sorry, @gaearon. Wrong thread to discuss the issue. Though I think @ohkaiby was talking about Redux documentation.

I couldn't find anything searching ""site:rackt.org HMR"", which would be useful. I came across this issue searching for ""store.replaceReducer"".
",gajus,ohkaiby
212,2015-12-12 19:05:59,"@ellbee Any other work there, or can I release 4.0.1 that doesn't have `.babelrc`?
",gaearon,ellbee
212,2015-12-12 19:08:09,"@gaearon Go for it.
",ellbee,gaearon
211,2017-03-08 23:17:43,"@biels : per the prior discussion, if you _really_ need to handle things that way, the ""approved"" method is to provide the third argument to connect, a `mergeProps` function, and handle it yourself there.",markerikson,biels
210,2015-12-18 02:16:30,"@jedborovik did you find a solution to this?
Adding something like this to render functions is a bit ugly:
`if (!this.props.xyz) return`
",lsapan,jedborovik
210,2015-12-18 04:45:15,"@gaearon alright after doing some digging, I found the problem. `connect` doesn't call `trySubscribe` until `componentDidMount`. As such, it doesn't see the dispatch/state change that happens in `componentWillMount`. I'll add a `componentWillMount` and some logic to catch this scenario.
",lsapan,gaearon
210,2016-03-26 17:30:01,"> @jedborovik did you find a solution to this?
> Adding something like this to render functions is a bit ugly:
> if (!this.props.xyz) return

@lsapan: can't do `return` in render, because `Uncaught Invariant Violation: <X>.render(): A valid ReactComponent must be returned. You may have returned undefined, an array or some other invalid object.`
",evandrix,lsapan
210,2016-03-26 17:30:01,"> @jedborovik did you find a solution to this?
> Adding something like this to render functions is a bit ugly:
> if (!this.props.xyz) return

@lsapan: can't do `return` in render, because `Uncaught Invariant Violation: <X>.render(): A valid ReactComponent must be returned. You may have returned undefined, an array or some other invalid object.`
",evandrix,jedborovik
210,2016-03-26 17:37:49,"@evandrix you can return an empty div, I just didn't write it out.
",lsapan,evandrix
210,2016-04-19 22:06:37,"@gaearon would something like Alt.js `componentDidConnect` be applicable to `react-redux`? This seems like a valid case that would be nice to have support for. 

https://github.com/altjs/connect-to-stores/issues/6

https://github.com/altjs/utils/blob/master/src/connectToStores.js#L80-L88
",chrishoage,gaearon
210,2016-05-24 10:37:40,"@chrishoage Did you manage to dispatch actions in the `react-router` event handlers and use the changed data in the component? I'm getting the same results as I would when dispatching in `componentWillMount`.

@gaearon I'm having the issue where I need the changes in my first render because it being on the server side and if it would be picked up later it causes my server side rendered HTML would differ from the HTML on the client. So the changes being ""picked up"" on the next render is not good enough, or am I overseeing a solution to this?
",yn5,gaearon
210,2016-05-24 10:37:40,"@chrishoage Did you manage to dispatch actions in the `react-router` event handlers and use the changed data in the component? I'm getting the same results as I would when dispatching in `componentWillMount`.

@gaearon I'm having the issue where I need the changes in my first render because it being on the server side and if it would be picked up later it causes my server side rendered HTML would differ from the HTML on the client. So the changes being ""picked up"" on the next render is not good enough, or am I overseeing a solution to this?
",yn5,chrishoage
210,2016-05-24 11:14:29,"> @gaearon I'm having the issue where I need the changes in my first render because it being on the server side and if it would be picked up later it causes my server side rendered HTML would differ from the HTML on the client.

Usually the solution is to _hydrate data first_ and then render. So rather than render in a lifecycle hook, you would get the matched components from the router, call a static method on them which dispatches an action, and wait for the promise to resolve. Does this make sense? https://github.com/markdalgleish/redial is one way of doing it.
",gaearon,gaearon
210,2016-05-24 11:32:12,"> Usually the solution is to hydrate data first and then render. So rather than render in a lifecycle hook, you would get the matched components from the router, call a static method on them which dispatches an action, and wait for the promise to resolve. Does this make sense? https://github.com/markdalgleish/redial is one way of doing it.

Thanks for your response @gaearon! I do hydrate my store before rendering. If I understand correctly that is not the problem. To be a little more specific:
I have a parameter to specify the language in the url. I would like to call an action to set the language with that value and use the newly `selectedLanguage` from the store in my component on the first render in order to render the app with the correct language. So what I tried first is calling the action `setLanguage` in the `componentWillMount` of the highest order component and came to understand the props (which are connected to the redux state_ can not be updated before the component renders. So I went with @chrishoage's suggestion to dispatch the `selectLanguage` action inside the onEnter hook of my highest order route but throughout the first render of the component this newly `selectedLanguage` does not get picked up. 
",yn5,gaearon
210,2016-05-24 11:32:12,"> Usually the solution is to hydrate data first and then render. So rather than render in a lifecycle hook, you would get the matched components from the router, call a static method on them which dispatches an action, and wait for the promise to resolve. Does this make sense? https://github.com/markdalgleish/redial is one way of doing it.

Thanks for your response @gaearon! I do hydrate my store before rendering. If I understand correctly that is not the problem. To be a little more specific:
I have a parameter to specify the language in the url. I would like to call an action to set the language with that value and use the newly `selectedLanguage` from the store in my component on the first render in order to render the app with the correct language. So what I tried first is calling the action `setLanguage` in the `componentWillMount` of the highest order component and came to understand the props (which are connected to the redux state_ can not be updated before the component renders. So I went with @chrishoage's suggestion to dispatch the `selectLanguage` action inside the onEnter hook of my highest order route but throughout the first render of the component this newly `selectedLanguage` does not get picked up. 
",yn5,chrishoage
210,2016-05-24 11:53:48,"> I think the problem is you’re effectively duplicating the data between the store and the router. Why not just use the router params for this? Is there any particular reason you prefer it coming from the store?

Since there are other ways to change the language than just with the URL I would have to then have to duplicate the state between the store and the router if I understand correctly.

Edit: I think you're right though, I should not try to do this with redux, I'll try to only use the params only. Thanks a lot for your help @gaearon.
",yn5,gaearon
210,2016-06-17 08:27:31,"@gaearon I have sync action which fill up data in store while dispatching action using higher order component `componentWillMount` , but I am facing issue that the values are not defined with the WrappedComponent on the server side rendering. But client side it renders two times and it works. Am I doing something wrong ?


",mihirsoni,gaearon
210,2016-07-30 15:53:07,"Any new recommendations how to deal with this situation? This is a real pain in the ass... I'm dispatching an action from `componentWillMount` that changes `isFetching` to true, but this doesn't get picked up by the `render()` method... I'm using react-router, so the `componentWillMount` is ideally the best option to change the application state when entering a new page (or using the onEnter hook). I ended up using @Strato's suggestion, but this seems like a hacky solution...
",rafaeltikva,Strato
210,2016-08-24 11:57:53,"@jimbolla a case was provided as a PR further up, #222. The test in the top as well should be good enough to understand the issue. The current test is basically wrong, it doesn't assert what it's supposed to do. 

However, this was closed as working as intended. I'd argue it's not as intended, just a weakness in how connect works and more of a wont-fix.
",Matsemann,jimbolla
210,2016-09-04 10:33:17,"I'm also looking for a good solution to this problem. I have a component that dispatches an action (to fetch data from an API) in its `componentWillMount` which will update a slice of my state to set `isLoading: true`. The initial state for this slice is `{isLoading: false, data: []}`, which means that a component I `connect` to this state will initially render with the value of `isLoading` being `false`, then a brief moment later the state is updated as a result of the dispatched action and the component will render again, this time with the value of `isLoading` being `true`. And of course, shortly after this a success/failure action will be dispatched that sets `isLoading: false` and triggers another render.

The issue this causes is that in the component I `connect` to this state, I can't do the following:



The intention here is of course to render `<Spinner/>` until we have received the response from the API, and then to render `<Message/>` or `<SomeComponent/>` based on the response. But on the first render `isLoading` will actually be `false` so `<Message/>` will be rendered for a brief moment, then `<Spinner/>` for 1-2 seconds, and then finally the correct component based on the API response.

Anyone have a solution to get the intended behaviour here without having to do hacky 'first render' checks such as @Strato's solution?
",jordanmkoncz,Strato
210,2016-09-05 15:44:03,"@jordanmkoncz 

At a high level, I believe the issue is you're trying to squish 3 distinct states into only 2.

Here are your three states:
1. don't have data
2. fetching data
3. have data (even if it's empty data)

You _cannot_ adequately represent this as 2 states:
1. fetching data
2. have data

This issue is intrinsic to fetching initial data asynchronously; it's not specific to redux or react.  There is no escaping it, although it's _feasible_ to build abstractions around components and data fetching so you can hide these details from individual components.

One way to handle this for an individual component is to introduce another boolean in your state slice like `haveFetchedData` that is initialized as `false` and set to `true` once you have receive data.

Another way is to use `null` as your initial value for `data`, and change it to an array (including an empty one) once you have received data.

Your component can display the spinner until `haveFetchedData` is true or until `data` is not `null`.
",naw,jordanmkoncz
210,2016-09-05 15:49:20,"@jordanmkoncz 

Also, depending on your exact needs, the simplest change to get the correct spinner behavior is to make the initialState for `isLoading` be `true`, even though you haven't actually started fetching yet.  This will result in correct spinner behavior, at the risk of not being able to dinstinguish between ""not fetching yet"" and ""currently fetching"".

Or, for more clarity, you could rename `isLoading` to `notFetchedOrIsLoading` and set its initial value to `true`.
",naw,jordanmkoncz
210,2016-09-06 00:56:02,"@naw At one point I was actually trying to solve this using one of those suggestions; for every `isFetching` (initialised as `false`) I also had an `isFetched` (initialised as `false`), and then in `mapStateToProps` I'd have logic like `const isLoading = isFetching || !isFetched;` and pass this `isLoading` variable to my component in order to get the behaviour I wanted in the component.

However I ran into an issue with this solution as well - it works when rendering a component for the first time, but if I switch to a different component (e.g. via route change) and then back again, the `isLoading` logic will not have the same effect, because when the component is rendered `isFetching` will be `false` but `isFetched` will actually be `true`, which will cause the same issue as before except instead of empty data being rendered for a brief moment, the old data from the previous call is what will be rendered for a brief moment. This problem would also happen with your solution to initally set `data` to `null`.
",jordanmkoncz,naw
210,2016-09-06 17:26:37,"@jordanmkoncz 

Yes, the issue you point out is certainly a very real issue, and one that I've experienced myself.

There are various challenges that arise when you build a single page application using a store that persists across different URL's.  In a traditional server-rendered application, every time you land on a new URL, all of your data is thrown away and fetched from scratch synchronously, and then passed to your template.  You don't have to worry about a template getting the wrong data from an old URL

In a single page application with a store (i.e. redux/react with react-router), all of your data is just sitting there, and nothing automatically marks it as ""stale"" when you visit a new URL.  There might be abstractions you can build on top of redux/react that will help with this, but vanilla redux/react doesn't solve this problem for you.

Suppose you have a `<BlogPost>` component that displays the content of a blog post, based on an ID in the URL (e.g. `example.com/blog/5` and `example.com/blog/27`).  If you have a slice in your redux store responsible for holding the ""current"" blog post content, merely having `isFetched` and `isFetching` booleans _will be inadequate_ just as you said.

The solution to this problem is similar to the solution I mentioned previously ---- you need to identify all of the distinct states you might find yourself in, and make sure your store slice has adequate information to help you distinguish these states, or at least distinguish the ones that matter (i.e. should I show a spinner or not). You actually have 4 distinct states:
1. data not fetched
2. data fetched, but data is for the _wrong_ blog post id
3. fetching data
4. fetched data, and data is for the _correct_ blog post id

One way to implement this is adding a `blogPostId` field to your store slice:



Then, if your component connects to this slice and sees that the `blogPostId` (5) is _different_ than the `blogPostId` provided in the URL (27, via react-router params), it knows to display the spinner.  Once the fetch for post 27 is received, you update the slice, and the component re-renders without the spinner since the ids match.

Another way to organize your state is to have a slice that holds all fetched blog posts in a hash by id.  Your component knows the desired blog post id (e.g. from react-router params), and reaches into that slice to find the correct blog post --- if the key for that id is missing, you display the spinner and wait for the correct blog post to be received.

There really is no getting around this, unless you use a higher-level abstraction on top of react/redux.  Personally I'm still brainstorming on building such an abstraction for my own projects.  Until then, I believe the aforementioned techniques are adequate, albeit a little painful.  The reality is that redux is a low-level tool, not a high-level tool, so you have to do more from scratch unless you're using other tools on top of it.  

Finally, just a a warning in case you haven't run into this yet -- if you're using react-router and link directly from blog post 5 to blog post 27, the `<BlogPost>` component does not get re-mounted (i.e. `componentDidMount` is _not_ called), so if you're fetching data for a component _only_ in `componentDidMount`, you probably need to consider also fetching in `componentWillReceiveProps`. This is just a ramification of how react-router and react work.

You have some great questions, and I'm just responding because I've run into the same issues and spent a lot of time thinking about it.    **If anyone knows of a simpler way to solve this with vanilla redux, I'd be interesting in hearing it.**
",naw,jordanmkoncz
210,2016-09-06 17:34:28,"@naw : this deserves to be turned into a blog post of its own, really.  We could use more publicly available info on how to think in terms of app state.
",markerikson,naw
210,2016-09-06 17:52:31,"@jordanmkoncz Yeah we faced the same problem, as written far up here somewhere. One can make it work for the first render, but that only postpones the problem to when the component is hidden and shown again. It becomes a lot of boilerplate and pit falls to make sure a simple spinner can be shown.

@naw, great post

> At a high level, I believe the issue is you're trying to squish 3 distinct states into only 2.

I disagree with this. The code declares an invariant that should hold, but then Redux goes ahead and breaks it.

> This issue is intrinsic to fetching initial data asynchronously; it's not specific to redux or react.

and 

> There really is no getting around this, unless you use a higher-level abstraction on top of react/redux.

It's specific to Redux. If one had used setState from React instead of dispatching an action in componentWillMount, the correct props would be available on first render. This is a promise made in React's API, so no wonder people get confused when this doesn't prove to be true when switching state handling to Redux.
",Matsemann,naw
210,2016-09-06 17:52:31,"@jordanmkoncz Yeah we faced the same problem, as written far up here somewhere. One can make it work for the first render, but that only postpones the problem to when the component is hidden and shown again. It becomes a lot of boilerplate and pit falls to make sure a simple spinner can be shown.

@naw, great post

> At a high level, I believe the issue is you're trying to squish 3 distinct states into only 2.

I disagree with this. The code declares an invariant that should hold, but then Redux goes ahead and breaks it.

> This issue is intrinsic to fetching initial data asynchronously; it's not specific to redux or react.

and 

> There really is no getting around this, unless you use a higher-level abstraction on top of react/redux.

It's specific to Redux. If one had used setState from React instead of dispatching an action in componentWillMount, the correct props would be available on first render. This is a promise made in React's API, so no wonder people get confused when this doesn't prove to be true when switching state handling to Redux.
",Matsemann,jordanmkoncz
210,2016-09-06 18:23:07,"@Matsemann : Not sure what ""invariant"" you're referring to.  I also don't see this as anything specific to Redux.  It looks like this applies to _any_ use of the ""container component"" pattern, where a presentational component is asking a parent component to fetch data.  That means that the data is coming in via props instead of being applied internally via `setState`.  Really, the ""odd"" part about this is that React tries to optimize the ""`setState` during `componentWillMount`"" case.  Otherwise, you'd expect that to cause a second render as well.
",markerikson,Matsemann
210,2016-09-06 22:15:10,"@Matsemann Yes, I think you make a great point!    

You are correct that the React API for `componentWillMount` specifies that state changes will take place before the first render.  It's easy to expect a synchronous dispatch to a Redux store from within `componentWillMount` to behave the same way.

I agree this is confusing, and I think it's worth discussing how (or if) its feasible to improve it.

**To be clear, this is not a Redux issue, it's a ramification of how the `react-redux` bindings are implemented**. 

As @markerikson  said, `react-redux` pushes everything from the store down to connected components via `props`.  This means at the time of mounting, the props have already been pushed down, and there is no way for the component to intercept those props with an immediate state change like you can do with `setState`.

Back to the `isFetching` stuff: I hope you can agree that there _are_ three distinct states --- the question is which of those states `render` needs to be capable of handling?  In vanilla React, you can _ensure_ that `render` never ""sees"" one of those states, by running your `setState({ isFetching: true})` in `componentWillMount` (I believe this is the invariant that @Matsemann is talking about).

The problem in `react-redux` is there is no way _from within the component itself_ to change props; by the time you're inside `componentWillMount`, it's too late.

As far as I know, there are only three ways to remedy this issue:
1. Modify `react-redux` to subscribe to the Redux store from within your component (rather than from within a wrapper around your component). This likely has many ramifications that could lead to different problems, although perhaps it's worth exploring.
2. Modify your application so that your component never sees certain states (i.e. find a different way to ensure that `{ isFetching: true}` is the first state seen by your component).   Ultimately this means putting your fetch dispatch somewhere _outside_ of your component (personally, this is what I do)
3. Modify your application so that `render`  can handle all 3 states (which is what[ I proposed earlier](https://github.com/reactjs/react-redux/issues/210#issuecomment-244774674) to @jordanmkoncz ).

Ultimately (and perhaps unfortunately), it's not as simple as blindly swapping out `setState` for `dispatch`. 

I agree with @markerikson that this is intrinsic to a parent-child props relationship.  However, a potential problem is that **it's not conceptually obvious that `react-redux` _is using_ such a relationship in its implementation of `connect`.**

In other words, we are not encouraged to think of connected components as presentational ""children"" receiving props from a connected wrapper --- instead, we tend to think of the component being connected and the resulting decorated component as one-and-the-same. At least, that's my _perception_.  It's pretty common to see connected components that have data fetching inside of them, which _can_ lead to problems.

Perhaps `react-redux` or Redux needs to clearly delineate suggestions for how you might need to modify your application to handle these subtleties?

One conceptual way to handle these subtleties is to treat your components as _presentation only_ as @markerikson suggested. In other words, force yourself to think of your components as simply receiving state with no ability to change state (as opposed to what you might traditionally do in `componentWillMount`)

Personally I take _presentation only_ to an extreme -- I use a modified version of `connect` that accepts a `componentWillMount` argument that runs in the context of the connected wrapper instead of the underlying wrapped component.  This means the component knows nothing about fetching data. It also means that my `dispatch` occurs _before_ my component is mounted, which means **I actually get the behavior you desire** (i.e. my `render` function _doesn't_ have to deal with the ""not fetching yet"" state).  However, this is not a simple library tweak we could code into `react-redux` -- it's a fundamental shift in how I (or you) think about components.

**TL;DR**

In vanilla React, components are meant to be a mix of state management and presentation.

In vanilla Redux, if you try to mix state management and presentation, you _can_ run into non-obvious problems.

**Ultimately, the switch from `state` to `props` is subtle, but significant**, and you cannot blindly change `setState` to `dispatch`.

Perhaps `react-redux` docs could do a better job at helping people navigate these subtleties?

Perhaps `react-redux` could be rewritten to use `state` instead of `props`? (various difficulties in doing that, I believe).

I appreciate the discussion and would welcome your thoughts.
",naw,Matsemann
210,2016-09-06 22:15:10,"@Matsemann Yes, I think you make a great point!    

You are correct that the React API for `componentWillMount` specifies that state changes will take place before the first render.  It's easy to expect a synchronous dispatch to a Redux store from within `componentWillMount` to behave the same way.

I agree this is confusing, and I think it's worth discussing how (or if) its feasible to improve it.

**To be clear, this is not a Redux issue, it's a ramification of how the `react-redux` bindings are implemented**. 

As @markerikson  said, `react-redux` pushes everything from the store down to connected components via `props`.  This means at the time of mounting, the props have already been pushed down, and there is no way for the component to intercept those props with an immediate state change like you can do with `setState`.

Back to the `isFetching` stuff: I hope you can agree that there _are_ three distinct states --- the question is which of those states `render` needs to be capable of handling?  In vanilla React, you can _ensure_ that `render` never ""sees"" one of those states, by running your `setState({ isFetching: true})` in `componentWillMount` (I believe this is the invariant that @Matsemann is talking about).

The problem in `react-redux` is there is no way _from within the component itself_ to change props; by the time you're inside `componentWillMount`, it's too late.

As far as I know, there are only three ways to remedy this issue:
1. Modify `react-redux` to subscribe to the Redux store from within your component (rather than from within a wrapper around your component). This likely has many ramifications that could lead to different problems, although perhaps it's worth exploring.
2. Modify your application so that your component never sees certain states (i.e. find a different way to ensure that `{ isFetching: true}` is the first state seen by your component).   Ultimately this means putting your fetch dispatch somewhere _outside_ of your component (personally, this is what I do)
3. Modify your application so that `render`  can handle all 3 states (which is what[ I proposed earlier](https://github.com/reactjs/react-redux/issues/210#issuecomment-244774674) to @jordanmkoncz ).

Ultimately (and perhaps unfortunately), it's not as simple as blindly swapping out `setState` for `dispatch`. 

I agree with @markerikson that this is intrinsic to a parent-child props relationship.  However, a potential problem is that **it's not conceptually obvious that `react-redux` _is using_ such a relationship in its implementation of `connect`.**

In other words, we are not encouraged to think of connected components as presentational ""children"" receiving props from a connected wrapper --- instead, we tend to think of the component being connected and the resulting decorated component as one-and-the-same. At least, that's my _perception_.  It's pretty common to see connected components that have data fetching inside of them, which _can_ lead to problems.

Perhaps `react-redux` or Redux needs to clearly delineate suggestions for how you might need to modify your application to handle these subtleties?

One conceptual way to handle these subtleties is to treat your components as _presentation only_ as @markerikson suggested. In other words, force yourself to think of your components as simply receiving state with no ability to change state (as opposed to what you might traditionally do in `componentWillMount`)

Personally I take _presentation only_ to an extreme -- I use a modified version of `connect` that accepts a `componentWillMount` argument that runs in the context of the connected wrapper instead of the underlying wrapped component.  This means the component knows nothing about fetching data. It also means that my `dispatch` occurs _before_ my component is mounted, which means **I actually get the behavior you desire** (i.e. my `render` function _doesn't_ have to deal with the ""not fetching yet"" state).  However, this is not a simple library tweak we could code into `react-redux` -- it's a fundamental shift in how I (or you) think about components.

**TL;DR**

In vanilla React, components are meant to be a mix of state management and presentation.

In vanilla Redux, if you try to mix state management and presentation, you _can_ run into non-obvious problems.

**Ultimately, the switch from `state` to `props` is subtle, but significant**, and you cannot blindly change `setState` to `dispatch`.

Perhaps `react-redux` docs could do a better job at helping people navigate these subtleties?

Perhaps `react-redux` could be rewritten to use `state` instead of `props`? (various difficulties in doing that, I believe).

I appreciate the discussion and would welcome your thoughts.
",naw,jordanmkoncz
210,2016-09-06 22:15:10,"@Matsemann Yes, I think you make a great point!    

You are correct that the React API for `componentWillMount` specifies that state changes will take place before the first render.  It's easy to expect a synchronous dispatch to a Redux store from within `componentWillMount` to behave the same way.

I agree this is confusing, and I think it's worth discussing how (or if) its feasible to improve it.

**To be clear, this is not a Redux issue, it's a ramification of how the `react-redux` bindings are implemented**. 

As @markerikson  said, `react-redux` pushes everything from the store down to connected components via `props`.  This means at the time of mounting, the props have already been pushed down, and there is no way for the component to intercept those props with an immediate state change like you can do with `setState`.

Back to the `isFetching` stuff: I hope you can agree that there _are_ three distinct states --- the question is which of those states `render` needs to be capable of handling?  In vanilla React, you can _ensure_ that `render` never ""sees"" one of those states, by running your `setState({ isFetching: true})` in `componentWillMount` (I believe this is the invariant that @Matsemann is talking about).

The problem in `react-redux` is there is no way _from within the component itself_ to change props; by the time you're inside `componentWillMount`, it's too late.

As far as I know, there are only three ways to remedy this issue:
1. Modify `react-redux` to subscribe to the Redux store from within your component (rather than from within a wrapper around your component). This likely has many ramifications that could lead to different problems, although perhaps it's worth exploring.
2. Modify your application so that your component never sees certain states (i.e. find a different way to ensure that `{ isFetching: true}` is the first state seen by your component).   Ultimately this means putting your fetch dispatch somewhere _outside_ of your component (personally, this is what I do)
3. Modify your application so that `render`  can handle all 3 states (which is what[ I proposed earlier](https://github.com/reactjs/react-redux/issues/210#issuecomment-244774674) to @jordanmkoncz ).

Ultimately (and perhaps unfortunately), it's not as simple as blindly swapping out `setState` for `dispatch`. 

I agree with @markerikson that this is intrinsic to a parent-child props relationship.  However, a potential problem is that **it's not conceptually obvious that `react-redux` _is using_ such a relationship in its implementation of `connect`.**

In other words, we are not encouraged to think of connected components as presentational ""children"" receiving props from a connected wrapper --- instead, we tend to think of the component being connected and the resulting decorated component as one-and-the-same. At least, that's my _perception_.  It's pretty common to see connected components that have data fetching inside of them, which _can_ lead to problems.

Perhaps `react-redux` or Redux needs to clearly delineate suggestions for how you might need to modify your application to handle these subtleties?

One conceptual way to handle these subtleties is to treat your components as _presentation only_ as @markerikson suggested. In other words, force yourself to think of your components as simply receiving state with no ability to change state (as opposed to what you might traditionally do in `componentWillMount`)

Personally I take _presentation only_ to an extreme -- I use a modified version of `connect` that accepts a `componentWillMount` argument that runs in the context of the connected wrapper instead of the underlying wrapped component.  This means the component knows nothing about fetching data. It also means that my `dispatch` occurs _before_ my component is mounted, which means **I actually get the behavior you desire** (i.e. my `render` function _doesn't_ have to deal with the ""not fetching yet"" state).  However, this is not a simple library tweak we could code into `react-redux` -- it's a fundamental shift in how I (or you) think about components.

**TL;DR**

In vanilla React, components are meant to be a mix of state management and presentation.

In vanilla Redux, if you try to mix state management and presentation, you _can_ run into non-obvious problems.

**Ultimately, the switch from `state` to `props` is subtle, but significant**, and you cannot blindly change `setState` to `dispatch`.

Perhaps `react-redux` docs could do a better job at helping people navigate these subtleties?

Perhaps `react-redux` could be rewritten to use `state` instead of `props`? (various difficulties in doing that, I believe).

I appreciate the discussion and would welcome your thoughts.
",naw,markerikson
210,2016-09-07 00:25:23,"Thanks for your perspective and also the link, @markerikson 

For context, let me explain my personal philosophy (just an opinion):

I believe a truly presentational component should:
1. Never fetch data
2. Never use `dispatch`

A presentational component receives props. Those props are generally either a piece of data to render, or a function to call when something interesting (like a click) happens.  These pieces of data generally are slices of Redux state, or at least _derived_ from Redux state.  The functions are often bound-action-creators.  (I know you know this, @markerikson, just trying to be very clear within the discussion)

I don't think a presentational component should ever dispatch something like `dispatch({type: FETCH_RECORDS})` or call a function like `this.props.fetchRecords()` --- if it did that, I wouldn't call it a presentational component.

I suppose you could consider ""I am mounting"" as something interesting, in which case the parent could expose a function through props like`this.props.iAmMounting()`, which could fetch data indirectly.  In this case, it would be very clear that you have to `render()` with your existing props, and patiently wait for your parent to react to your `iAmMounting()` call by delivering new props to you.

If we _did_ think about our components like this, [which I believe was your point farther up](https://github.com/reactjs/react-redux/issues/210#issuecomment-245042597), then the subtleties discussed in this issue could be avoided. I think we're on the same page in this regard. :heart: 

So, one question is whether people generally ""get"" that they need to construct their components differently when they use Redux than when they use vanilla React?  Or, is it trivial to convert an application from vanilla React to Redux?  Can (or should) we make it more trivial to do so?

There are two extremely different conceptual ways to approach this:
1. Encourage a high-level of separation between the wrapped presentational component and the connected wrapper. 
2. Encourage React-like hybrids where state management and presentation are mixed.

**My opinion is that the current `react-redux` implementation falls in the middle somewhere, doing a reasonably good job at both, but not a spectacularly good job at either.**

A better version of (1) would put things like `componentWillMount` _inside_ the wrapper, and explicitly discourage anything but presentation in the wrapped component.

A better version of (2) would subscribe to the Redux store directly inside the component (i.e. no wrapper), so that the component's state can be manipulated directly (e.g. `mapReduxStateToComponentState` instead of `mapStateToProps`)

To be clear, I'm not trying to rag on `react-redux` --- It's great --- I'm just brainstorming some ideas for improvement --- I hope nobody's toes get crunched.
",naw,markerikson
210,2016-09-07 02:12:33,"@jimbolla : dude, you beat me to it by 13 seconds.  :(
",markerikson,jimbolla
210,2016-09-07 02:20:58,"@markerikson 
![frabz-oh-you-almost-had-it-you-gotta-be-quicker-than-that-782d6e](https://cloud.githubusercontent.com/assets/1851364/18297648/29da4282-7480-11e6-90b4-f4de75c3b1d3.jpg)
",jimbolla,markerikson
210,2016-09-07 04:51:57,"Great posts @naw, you've definitely helped clarify the subtle implications of how `connect` is implemented and the fact that the component created by `connect` represents a parent-child props relationship between the parent component and the wrapped component. Your `<BlogPost>` example is spot on and I agree that there are actually 4 different states we can be in.

After taking this into consideration, I've come up with a solution to this problem. I'll extend your `<BlogPost>` example to explain my solution.

I'm using [normalizr](https://github.com/paularmstrong/normalizr) for my project, which manages an `entities` slice of my store's state that holds all fetched blog posts in a hash by `id` (as you suggested).  I also have a separate slice of my store's state, `visibleBlogPosts`, which has the following initial state:



My `visibleBlogPostsReducer` looks like this:



When I successfully fetch a given blog post, it will be added to `entities.blogPosts`, and my `visibleBlogPosts` will update to have the `id` of the fetched blog post.

Given this state shape and reducer functionality, I now have the following variables which are used to determine my loading state at any given time:
- `object` - The Blog Post object I want to render, which may be present but stale (i.e. found in my entities cache), or present and fresh (i.e. just fetched), or not present at all.
- `objectId` - The ID of the Blog Post I want to render, which is a number.
- `storedObjectId` - The ID of the Blog Post in my store (i.e. `visibleBlogPosts.id`), which is a number or `null`.
- `isFetching` - Whether we're currently fetching a Blog Post (i.e. `visibleBlogPosts.isFetching`), which is `true` or `false`.

Based on these variables, I want to reduce my loading state at any given time to be one of the following:
- `'FIRST_LOADING'` - Object is loading for the first time (object is not present).
- `'RELOADING'` - Object is reloading (object is present but stale).
- `'LOADED'` - Object is loaded (object is present and fresh).

I can do so with the following logic:



Given these 3 possible loading states, I can have the following logic in my component.



Of course, in my actual implementation I'm using constants rather than direct string comparisons, and I've created some abstractions for getting the current loading state, but I've deliberately tried to be explicit here.

So far, this solution appears to work well and keeps state/reducer boilerplate to a minimum (e.g. no need to maintain a separate `isFetched` variable). I'm curious to hear people's thoughts on this and whether there are any problems with this solution.
",jordanmkoncz,naw
210,2016-09-07 21:56:38,"@jordanmkoncz 

At first glance this looks like a solid approach.  However, there _are_ some nuances to consider.

> object - The Blog Post object I want to render, which may be present but stale (i.e. found in my entities cache), or present and fresh (i.e. just fetched), or not present at all.

In the scenario where you visit `/blog/5`, and then visit `/some_other_page`, and then visit `/blog/5` (for a second time), you have no way of distinguishing if `object` is stale or fresh.  `storedObjectId` will match immediately even though the object is stale, which means you'll have `LOADED` for a brief time before you switch to `RELOADING` and then back to `LOADED`.  This may or may not be a big deal depending on your application.   The `storedObjectId` is really `mostRecentlyReceivedObjectId`, and just because an object is the most recently received object doesn't mean it is fresh (indeed, it could be seconds, minutes, hours, or days old).

Also, it's feasible for AJAX calls to return in the wrong order.  Suppose you visit `/blog/5`, and then `/blog/27`, but you receive the response for 27 before you receive the response for 5.  In this case, you'll see:
1. `FIRST_LOADING` spinner
2. `LOADED` content for 27 when 27 returns
3. `LOADING` spinner perpetually once 5 returns

Probably the easiest way to guard against this is to prevent more than one fetch at a time. However, some features _need_ to fire off more than one request at at time (like an autocomplete query, for example), so you may have to use more complicated techniques.
",naw,jordanmkoncz
210,2016-10-04 18:05:31,"@naw 

Any chance you've found a decent way to work around this? I have a very similar problem and been banging my head on the wall for a few days with no success. I'm new to React and Redux which is making this even more frustrating.
",alien109,naw
210,2016-10-04 18:16:58,"@alien109 could you clarify what specific issue you've been having trouble with?  
",naw,alien109
210,2016-10-04 18:54:19,"@naw 

Sorry for not being more clear. I'm assuming I'm running into a similar situation as you'd described in a comment above. I'm dispatching an action in ComponentWillMount to perform multiple ajax calls to receive data. Once all of the ajax calls have completed, I'm dispatching an action that updates a slice in my store that sets a fetching status for the entire page. This way I can check that rather than for each individual entity that's being passed in from the store. For the first time a visit the route, the data all gets returned, the store updates, props update, and the component is rendered correctly. If I then navigate away from that route, and then return, the process of fetching data above is started again, except the component is then rendered before the props are updated. Even though I can see that the store is being updated correctly, the component calls render before it's props are updated with the new store state. Any sort of fetching status flags I'm using are pointless since they are out of date.

The only solution I've come up with is moving all data rendering bits into separate helper functions in the class and then wrapping them in try/catch statements. I then can return an empty tag in the catch block so that errors get swallowed and don't halt the execution of the component rendering again once the props actually do get updated. This feels super janky though.

I'm assuming this was the primary issue you were having, but maybe that's my misunderstanding. As I stated, I'm just getting started with React and Redux, so it's possible I'm just being confused.

BTW, thanks for a quick response.
",alien109,naw
210,2016-10-04 19:59:16,"@alien109 

Conceptually, the act of navigating to the page should cause a state change (mark existing data as stale, set a fetching flag, etc.).  The problem is that the component must render _before_ anything has a chance to update the redux state.  This means there is no way for `mapStateToProps` to derive for the component whether it should show a spinner or not --- the redux store (and `mapStateToProps`) simply don't have enough information yet (in particular, they don't know that the user just navigated to the page).  

One workaround is for the component itself to provide some of the key information (in particular, the fact that it was just navigated to).

As an example, the component can track when it was mounted (i.e. as a `mountedAt` value in local react state), and compare this to a `fetchedAt` value for the data stored in redux to determine whether to show a spinner or not.  Once the component fetches new data, the redux data is fresher and has a `fetchedAt` value newer than the component's `mountedAt` value.

A sample implementation might be this:



Depending on your application, you'd likely have to do something similar in `componentWillReceiveProps`.

There are variations of this approach (for example, you don't have to use a timestamp, you could use a unique id instead).   

I believe it's feasible to implement something like this completely outside of the component itself by using the factory version of `mapStateToProps`, but I haven't experimented with that approach enough to recommend it.

The fundamental cause of this issue is that a connected component has two sources of input (ownProps, and redux-derived props) which can be out-of-sync.  This manifests itself when you using a router like react-router (which passes information to you via ownProps).  Conceptually you might be able to solve this by ignoring ownProps, and rigging the router to pass route changes to you _through_ redux, but that's a large can of worms probably best avoiding right now.
",naw,alien109
210,2016-10-25 17:18:54,"@naw Your solution worked really well for me. The spinner is never even visible.. it just needed a few extra milliseconds to retrieve the data from the `componentWillMount()` call. The store data is populated before the user ever sees it.
",jgentes,naw
208,2015-12-13 14:07:17,"@gaearon The macro problem I am trying to solve is simply knowing when react is finished flushing changes to the DOM. Unfortunately the only affordance to do that is through a callback in every call to `setState`. I was hoping it would be ok to try to thread that through redux, but given that you rejected the necessary changes to Redux core I don’t think this PR will help by itself.
",mhodgson,gaearon
208,2015-12-13 14:28:22,"For the purpose of discussion, here’s a more detailed explanation of why this is necessary in some use cases: 

Assume that you are trying to create a WYSIWYG text editor for the browser (fairly common and painful endeavor). The state at any given moment is primarily composed of two things: 
1. The document itself (the thing the user is creating).
2. The current text selection within the document.

At first glance you might wonder why it is important to keep the text selection in state. The answer is simple: undo/redo. When a user triggers an undo or redo action, we not only need to restore the document to the previous state, we also need to restore the text selection to the previous state. 

It is important in this case that we fully restore the document state to the DOM **before** trying to restore the text selection. It should be obvious that trying to restore a selection of something that doesn’t yet exist on the page is problematic. Hence the need to know when the DOM has been fully rendered within the normal action emit/listener/render loop provided by Redux. After the DOM has been fully rendered, we can do the manual task of restoring the selection state on top of the DOM.

As far as I can tell, the current Redux and `connect` implementations do not support this use case. I can’t think of another use case that would require this off the top of my head, but I assume that the callback in React’s `setState` method was added for these types of rare but important edge cases. 

@gaearon do you see a different approach to this that would still allow for using redux and react-redux? Are there other scenarios in React or React-Native or even angular which might require knowing when changes to state have been fully flushed to the UI?
",mhodgson,gaearon
206,2015-12-05 23:22:26,"Interesting, @NullDivision -- so you basically kill the local installations and rely on the global? In theory, it sounds like this might also let you compile `react-native@0.16` with a different version of Babel? I'm currently using the `@connect` decorators that are no longer supported in Babel 6 (and also not resolved with the current workaround in [babel-plugin-transform-decorators-legacy](https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy))
",ajwhite,NullDivision
206,2015-12-14 11:09:15,"> The reason is that it breaks react-native apps builds.

The Babel version we use internally doesn't matter. What mattered is that we shouldn't have shipped `.babelrc` in the package at all. We fixed this already. 

And it is also already removed from Redux. Please update to the latest version.

@NullDivision As far as I know there is no issue to solve. What do you mean? It's already solved in the latest update to both packages. 
",gaearon,NullDivision
204,2015-11-27 17:32:48,"@gaearon , yeah they did, pretty recently, about a month ago - https://github.com/facebook/react/pull/5185
",conorhastings,gaearon
193,2015-11-20 15:31:44,"Having same issue, both with and without React Router.
Anyone solved this?

ps: I've ensured that there is only one React instance loaded
I Didn't receive the store even on props, and I have the exact dependecies of @m19:


",gabrieledarrigo,m19
193,2015-11-21 13:01:42,"Hi @awestroke;
Yep, props are populated with the data coming from the store and with the dispatch function.

So, Do You confirm that the store object is not injected into props?

About the subscribing, isn't store.subscribe purpose just to be used to listen and retrieve a piace of state from store? 
",gabrieledarrigo,awestroke
193,2015-11-21 20:35:20,"@awestroke, 

I am using connect to pick the parts of the state that I want. But that doesn't let me subscribe to state changes. I realise react will re render when the connected parts change, but I think it is a perfectly valid use case to observe changes to a specific property on the store, and trigger an action based on this - not all state changes need to trigger a re render. If the observed property can be updated via various means, this is a neat way of responding to that. 

Yes I could do this where I setup my store, but then I end up with irrelevant logic together in that file. 

I'm using [redux-rx's observableFromStore](https://github.com/acdlite/redux-rx) to do this, which requires the store passed in. 

I'm pretty sure I've already tried to set contextTypes without success, but can try again tomorrow. 
",marcuswhit,awestroke
193,2015-11-23 01:41:42,"@awestroke was correct, I just needed to correctly specify `contextTypes` in my component, and the store was then added as expected:


",marcuswhit,awestroke
193,2015-11-23 15:40:38,"@awestroke @marcuswhit So it is confirmed that store is not passed in with props?
",gabrieledarrigo,awestroke
193,2015-11-23 15:40:38,"@awestroke @marcuswhit So it is confirmed that store is not passed in with props?
",gabrieledarrigo,marcuswhit
193,2015-11-24 23:39:12,"Thanks @gaearon 

I get that you should only use `context.store` with really good reason - I'm just wondering if my use case falls into that category.  I'm using [redux-rx's](https://github.com/acdlite/redux-rx) `rx-middleware` and `observableFromStore`, and have something like the following:



Essentially, I watch for any changes to the ccyPair on a tile object, and then subscribe to the price stream each time.  The ccyPair could be changed by the user or programatically in a reducer, so putting this logic in a component handler doesn't quite fit. I'm defining this as a payload on an action, which then gets handled by `rx-middleware` to push the notifications through to my reducers.

Is this a valid use case for observing the store?  If I just use `connect()` and watch for ccyPair changes in `componentWillReceiveProps`, it seems like much more work - I have to cache the last ccyPair to ensure it's changed, then if it has I should clean up the last priceStream subscription, then subscribe to a new one.  It seems much cleaner all being contained within a single observable.
",marcuswhit,gaearon
193,2015-11-24 23:58:59,"@marcuswhit Can you show your whole component? I'm confused why it needs both `connect()` to subscribe, and a store itself to form that stream. Maybe having just the store is enough?
",gaearon,marcuswhit
193,2015-11-29 03:37:47,"Any thoughts on the above @gaearon?
",marcuswhit,gaearon
193,2017-01-23 04:39:57,@gaearon Is there any better way to use store.subscribe other than getting store from context ('connect' doesn't help)? I'm new to Redux but I feel it's quite weird when I try to follow http://redux.js.org/docs/api/Store.html doc to do subscribe but don't know how to get the store object. Searched a long time on the internet and finally get here. I feel there should be a more apparent place to let people know the normal way to get store for store.subscribe().,shlinx,gaearon
193,2017-01-23 04:48:27,"@shlinx : Dan isn't actively maintaining Redux any more.

As Dan said earlier in the thread, 99.9% of the time, you shouldn't be trying to access the store directly in your React component.  Use the `connect` function from the React-Redux library, and let it manage the subscriptions for you.  This is described in the Redux docs at http://redux.js.org/docs/basics/UsageWithReact.html .

There's also many other Redux tutorials listed at https://github.com/markerikson/react-redux-links/blob/master/redux-tutorials.md as well.",markerikson,shlinx
193,2017-01-23 05:04:29,@markerikson Thanks.,shlinx,markerikson
193,2017-01-27 12:23:03,"@markerikson What if I want to pass state but don't want to subscribe to store updates? Whenever I pass `mapStateToProps` the component will get subscribed, or is there another way around it?",Damnum,markerikson
193,2017-01-27 13:29:15,"@Damnum `connect(..., ..., ..., { shouldHandleStateChanges: false })`",jimbolla,Damnum
193,2017-01-27 13:44:23,@Damnum: could you share a scenario where you do not want to subscribe to state changes? ,awestroke,Damnum
185,2016-02-02 11:58:30,"@tgriesser Would you be interested in implementing https://github.com/rackt/react-redux/pull/185#issuecomment-175832321 as an alternative approach? Would it solve your problem?
",gaearon,tgriesser
183,2015-11-11 01:14:51,"@acdlite I believe it's about enabling per-component memoization: #179, #180, #182
",gaearon,acdlite
183,2015-11-11 01:26:01,"I think we've concluded it's actually not possible to do the per-component memoization without a global LRU cache as @ellbee [mentions here](https://github.com/rackt/react-redux/pull/179#issuecomment-155565193), so this would be the next best thing.

@acdlite I typically like to use a one layer deeper shallow `===`. I have a lot of connected components and selectors which have plain Arrays as return values, and so it ends up there's a lot more unnecessary updating going on than there'd need to be if we could just check the returned Array or Object props are themselves shallow equal.

I've found the amount of time it takes to do an extra shallow compare of a few Arrays is virtually nothing compared to the expense of React going through an update cycle.
",tgriesser,acdlite
183,2015-11-11 16:57:42,"@ellbee updated, although before we go with this (although I do think it'd be a nice option to configure), I've got one more idea on an approach for #179 that wouldn't be too intrusive.
",tgriesser,ellbee
183,2015-11-12 19:49:35,"@tgriesser Appreciate the thoroughness of trying out all these approaches! I wish I had some time right now to look at this and give some thoughts, but something's come up and I'm not going to have any 'github time' at all in the next few days :disappointed:
",ellbee,tgriesser
183,2015-11-12 22:24:24,"@ellbee no worries / no rush, whenever you get around to it! I've had the same problem with my own projects lately, have no problem working off of a fork.

I really appreciate a project which takes longer to figure out the simplest solutions rather than to just merge everything - keep up the great work all! :+1:
",tgriesser,ellbee
183,2015-11-24 19:59:49,"@tgriesser Assuming we can think of an acceptable name for the option I think I like this PR the best; it doesn't add to the top level API and changes to existing code are minimal.

Coming at it from the `Reselect` angle, would a selector like the following a) work b) be performant for your use case? It occurs to me that in the common case there is probably a prop (or a few props combined) that will uniquely identify an instance of the component and can therefore be used as a key for the cache (I suppose a key could be purposely added to the props if this is not the case). I have been benchmarking a few different things and this one seems pretty good.





The `hashFn` and ignored parameter in the example is hacky but if this does actually turn out to be a usable solution I will do something with `Reselect` to support this in a nicer way (probably somehow passing the props directly to the `hashFn`).
",ellbee,tgriesser
183,2015-11-25 15:34:11,"> @tgriesser Assuming we can think of an acceptable name for the option I think I like this PR the best; it doesn't add to the top level API and changes to existing code are minimal.

Ah cool, thanks for sharing this does look pretty neat - I'll need to dig in a bit and see how this ends up working in practice.

At first glance I still believe it requires you to know too much about the shape of the component props you're connecting to in order to properly use the cache. If a key is required to make guarantees it seems it'd be leaking the selector implementation details into the component. While it probably works well it, my initial impression is that it's the wrong place to be solving the issue of having every connected component instance share a singleton selector.

Top level API concerns aside (and I'd contend it's not much of an addition since it's really a higher order `connect` - analogous to `createSelectorCreator` in `Reselect`) did you get a chance to look at what all #185 does? It passes `connect` through `connectComponent`, providing an outlet for solving the underlying issue with no change to the current API use.
",tgriesser,tgriesser
183,2015-12-17 04:38:34,"(I am coming from similar issue in `reselect`)

Let me do a recap. In short, all we want is support per-instance memoize function. I think there are few things we could do:
- Per-instance memoize function (cache bound to the instance, not ""global"")
- Per-instance selector function (since memoize function's lifecycle is bound to the selector, i.e. every selector will have their own memoize)
- LRU cache, IMHO, housekeeping and hashing takes too much effort

Since `react-redux` is designed not to expose the component instance (e.g. when `mapStateWithProps` is called, `this` is `undefined`, and, `stateProps` returned from `mapStateWithProps` will not come back again as `ownProps`), it become very difficult to maintain a per-instance selector/memoize.

@tgriesser suggested we could hold something per-instance by either:
- Keep selector as a props (search `__valueSelector` in this thread), but it requires parent component to understand what data to ""bind"", or we need to create another wrapper class
- #185 ""Thunk"" approach, `connectComponent` create the actual selector when the component is created

I like #185 ""thunk"" approach more because ""props"" approach requires another wrapper or knowledge in parent. ""Thunk"" approach is cleaner.

Consider the following nested selector scenario, `quotationSelector` is a selector shared amongst few pages. And `welcomePageSelector` is a selector only used by the welcome page.

In the old days, we write something like this, and this doesn't works well with multiple instances:



This doesn't works very well if there are multiple components on the page and each have different props. The memoize function inside `createSelector` will always cache miss.

Then in the new days (with ""thunk"" approach):



Note that `quotationSelector` is created inside `welcomePageSelectorFactory`. Thus, the top-level selector maintains lifecycle of nested selectors (and memoize functions).

I am almost good with #185, except that the name `connectComponent` and `connect` is a bit confusing. I have no objection if we are going to obsolete `connect`.

Update:

In short, I think what we are doing is:
- In the old days, `ComponentClass` holds a reference to `selectorInstance`, so every `componentInstance` share the same `selectorInstance`
- What we really want, `ComponentClass` holds a reference to `SelectorClass`, so every `componentInstance` could have their own `selectorInstance` (if they really want, they could use singleton pattern to share the instance)

And we are finding ways, either:
- `selectorInstance` could identify independent `componentInstance`, which seems impossible for now
- Every `componentInstance` will create their own `selectorInstance`, which #185 is doing
",compulim,tgriesser
183,2015-12-22 16:16:14,"Yep, @compulim gave a great summary of the value proposition of this API addition, and why I believe #185 is correct solution to proper memoization per component instance without needing to alter the existing `connect` implementation. I just updated against the current master, all tests passing.

> I am almost good with #185, except that the name connectComponent and connect is a bit confusing.

Totally. I am up for changing this, and wanted to see what anyone else thought might be a good name. I initially had `connectFactory`, maybe that'd be better. Or perhaps `createConnector`? Anyone have any other suggestions?

> I have no objection if we are going to obsolete connect.

I don't think changing the current `connect` implementation is the right option here, since it's a very common approach everyone uses, in the case where you're using both `props` and `state` and want to properly memoize, I think exposing this additional top level function is the right approach.
",tgriesser,compulim
183,2015-12-22 17:44:54,"@tgriesser, thanks so much for your work on this!

> I don't think changing the current connect implementation is the right option here, since it's a very common approach everyone uses
1. Should memoization per component instance not be the default way of implementing or using connect? What would be good reasons to use the default connect method instead?
2. As we go ahead with this, it would be very helpful to have an example in the README that explains how this works and ways to use this.
",oyeanuj,tgriesser
183,2015-12-25 06:12:48,"@oyeanuj, for your question.

> 1. Should memoization per component instance not be the default way of implementing or using connect? What would be good reasons to use the default connect method instead?

I think we should not break existing usages. But I do agree the current implementation is weak.

@tgriesser, I think `connectFactory` is better. But let's wait for @ellbee to make that final call.

Your code is good, I really hope to see it in the official branch sooner.
",compulim,ellbee
183,2015-12-25 06:12:48,"@oyeanuj, for your question.

> 1. Should memoization per component instance not be the default way of implementing or using connect? What would be good reasons to use the default connect method instead?

I think we should not break existing usages. But I do agree the current implementation is weak.

@tgriesser, I think `connectFactory` is better. But let's wait for @ellbee to make that final call.

Your code is good, I really hope to see it in the official branch sooner.
",compulim,tgriesser
183,2015-12-25 06:12:48,"@oyeanuj, for your question.

> 1. Should memoization per component instance not be the default way of implementing or using connect? What would be good reasons to use the default connect method instead?

I think we should not break existing usages. But I do agree the current implementation is weak.

@tgriesser, I think `connectFactory` is better. But let's wait for @ellbee to make that final call.

Your code is good, I really hope to see it in the official branch sooner.
",compulim,oyeanuj
183,2016-01-04 19:48:18,"+1 to getting this merged soon! @ellbee? :)

@tgriesser What documentation do you think we need in the guide/docs for this?
",oyeanuj,ellbee
183,2016-01-04 19:48:18,"+1 to getting this merged soon! @ellbee? :)

@tgriesser What documentation do you think we need in the guide/docs for this?
",oyeanuj,tgriesser
183,2016-01-04 22:13:39,"@oyeanuj Yeah, sorry for not being responsive on this, been super busy :frowning: I am going to make some time in the next couple of days to get to all my loose ends.
",ellbee,oyeanuj
183,2016-01-27 17:48:26,"@tgriesser do you need some help to bring this branch up-to-date?
",compulim,tgriesser
183,2016-01-27 19:35:23,"@compulim I am happy to clean this up for this merging if this is the PR we want to use but there is also #185..

@gaearon #185 is another proposal for solving this issue, and although the discussion is happening on this PR, #185 seems to be the preferred proposal of the participants in this thread. #185 is not a breaking change, but it does introduce a new ""connect factory"" function to the API, while this PR only adds an option to `connect`. Is adding a new function to the API a deal breaker for #185? 

Both PRs look fine to me, so I don't have a big preference.
",ellbee,gaearon
183,2016-01-27 19:35:23,"@compulim I am happy to clean this up for this merging if this is the PR we want to use but there is also #185..

@gaearon #185 is another proposal for solving this issue, and although the discussion is happening on this PR, #185 seems to be the preferred proposal of the participants in this thread. #185 is not a breaking change, but it does introduce a new ""connect factory"" function to the API, while this PR only adds an option to `connect`. Is adding a new function to the API a deal breaker for #185? 

Both PRs look fine to me, so I don't have a big preference.
",ellbee,compulim
181,2015-12-14 03:44:47,"@kjs3 did you get anywhere with this, or post to stack-overflow, etc?

i was just trying to figure out what a redux-friendly version of the [auth-flow example at react-router](https://github.com/rackt/react-router/blob/master/examples/auth-flow/app.js#L122) might look like, and i found my self trolling the react-redux issues for info on that as well.

**edit**: nvm, found [your stack-overflow post](http://stackoverflow.com/questions/33643290/how-do-i-get-a-hold-of-the-store-dispatch-in-react-router-onenter), sorry about that...
",tony-kerz,kjs3
181,2015-12-14 23:27:55,"@tony-kerz I ended up answering my own stack overflow question. Let me know if it's at all unclear.
",kjs3,tony-kerz
179,2015-11-09 11:50:44,"@ellbee Appreciate you taking a look. Thanks. :100: 
",gaearon,ellbee
179,2015-11-09 12:32:34,"I don't understand your latest proposal yet and I'm busy with something else, so I trust @ellbee to make the right call on this.
",gaearon,ellbee
179,2015-11-09 17:46:40,"I have checked out the PR, and the approach looks reasonable but I am concerned that the `memoize` HOC in the tests is accessing private `react-redux` API, and I can't currently see how it would work if you don't access private API.

I was also wondering if we can achieve the same thing without making any changes to `react-redux`? I knocked together the following HOC to be called in place of `connect` that seems to work for a simple test project:



Advantages of the approach above: No changes to `react-redux` needed.
Disadvantages: Creates a new wrapper class for each instantiation of the component

Advantages of the PR: Does not create a new wrapper class for each instantiation of the component
Disadvantages: Changes to `react-redux` needed. Still requires a wrapping HOC to be written. Looks like the wrapping HOC needs to use non-public internal `react-redux` API.

@tgriesser What do you think? Is creating a new wrapper class every time going to be a problem? Have I missed anything?
",ellbee,tgriesser
179,2016-02-04 19:48:39,":tada: Nice work @tgriesser!
",ellbee,tgriesser
175,2015-11-05 16:03:38,"@sirreal thank you :grin: It probably just hasn't been updated to 0.14 yet.
",omnidan,sirreal
174,2015-11-06 18:53:53,"@gaearon do you have a link to the functional component in React 0.14?
",kennetpostigo,gaearon
174,2015-11-06 21:00:30,"Thank you @gaearon !
",kennetpostigo,gaearon
170,2015-11-11 00:03:48,"I agree with @gnoff about using the term ""container."" The terms ""smart"" and ""dumb"" definitely get the point across, but ""container"" is used elsewhere as @gaearon said (I'll throw recompose into the list as well) and does a better job describing the fact that the component is in fact wrapped by a higher-order component.

Personally I think it helps demonstrate the fact that everything is in fact a ""dumb"" component, but some of those are just wrapped in a container.
",davezuko,gaearon
170,2015-11-11 00:03:48,"I agree with @gnoff about using the term ""container."" The terms ""smart"" and ""dumb"" definitely get the point across, but ""container"" is used elsewhere as @gaearon said (I'll throw recompose into the list as well) and does a better job describing the fact that the component is in fact wrapped by a higher-order component.

Personally I think it helps demonstrate the fact that everything is in fact a ""dumb"" component, but some of those are just wrapped in a container.
",davezuko,gnoff
163,2015-11-04 10:07:49,"@adamscybot

Language features don't just ""stop working"" out of the blue. :-)

It's not something we can or should fix in the library. Most likely you're using decorator incorrectly but it's hard to say without code. Please create a StackOverflow question with code example and we will be happy to help. And try not using decorator syntax, instead following examples in the docs. 

It is unrelated to this issue. 
",gaearon,adamscybot
163,2015-11-04 13:31:56,"@gaearon 

Indeed, the problem was actually because (after moving to babel 6) I was loading `babel-plugin-syntax-decorators` but not `babel-plugin-transform-decorators`. This setup doesn't throw any errors/warnings when it comes across a decorator.

For other reasons, it looks like decorators are broken anyway: https://github.com/babel/babel/issues/2702

But as you mentioned this is unrelated. Cheers!
",adamscybot,gaearon
163,2016-03-05 03:03:10,"OK, so this is actually much more fun than I thought it was.

@rockingskier Not sure whether you’re still curious but here’s what happened.
1. You were using _both_ `react-hot-loader` _and_ `babel-plugin-react-transform` which is something I missed initially. I wouldn’t say it’s unsupported straight away but this definitely isn’t something we test for.
2. Because of this, both the component wrapped by `connect()` and the component returned by `connect()` were wrapped with [react-proxy](https://github.com/gaearon/react-proxy).
3. [Proxy tries to be smart to prevent double-wrapping](https://github.com/gaearon/react-proxy/blob/a8b0486bca3899e30995281c0b344c448aecefee/src/createClassProxy.js#L31-L35). It sets a hidden field on the class to look up its “current” proxy. 
4. Now comes the fun part. [`connect()` tries to be smart](https://github.com/reactjs/react-redux/issues/53) and hoists all static fields to the wrapping component _including the unfortunate proxy field_. So now proxies will think that `connect()`ed component has already been wrapped in a proxy, but will point to the inner component’s proxy. :sob: 
5. Nothing works.

I’ll look if I can fix it on `react-proxy` side. In the retrospect hoisting _all_ statics including non-enumerable ones was a silly decision, so we need to reconsider this in `connect()`.

The quick fix is to avoid using `react-hot-loader` and `react-transform-hmr` in a single project :smile: .
",gaearon,rockingskier
162,2016-10-09 20:16:50,"@paramsingh88 can you paste your code? I was getting this same error message but that's because I put a comment between the <Provider></Provider> tags.

**FROM**



**TO**



The second code block works fine for me after I removed this comment `{/* Provider component from react-redux */}`
",dannypule,paramsingh88
161,2016-08-18 06:46:10,"This solution will only apply on the component dispatch function. if the component uses redux-thunk ( for async functions ) then the dispatch within this functions will not go through the interceptor, so any change/use of the actual payload is impossible.

You may do something like : 



but this will make redux-thunk redundant and will require to duplicate its code. 

In addition, I can't see how to pass getState function (without accessing directly to the store) to pass along to the thunk with this approach, as it is being done when implementing middleware . @gaearon 
",jony89,gaearon
161,2017-03-02 00:44:31,"I got into this issue today and here's what I did using @jony89's suggestion:
",pankajvishwani,jony89
159,2017-01-18 17:59:59,"I started wondering the same thing, whether `connect` was intended to be used on ± every component individually, or only on the top level component. The link @gaearon gives is broken, I think https://github.com/reactjs/redux/issues/419 is the correct thread to refer to for more discussion.",natevw,gaearon
158,2015-10-18 05:38:41,"@gaearon: I have been using a similar solution to this for my tests for quite some time. Recently we have switched to using the [shallow renderer](https://facebook.github.io/react/docs/test-utils.html#shallow-rendering), which has allowed us to remove jsdom from our tests completely. This has given our tests a significant speed boost. Shallow rendering also forces you to keep each component relatively simple since it prevents you from testing heavily nested components. 

Just thought I'd share a tip on something that we've found to be valuable.
",zpratt,gaearon
156,2015-10-14 12:32:04,"Hi @ccorcos, have you seen [this?](http://rackt.github.io/redux/docs/basics/UsageWithReact.html) Check out the Connecting to Redux section.

If that doesn't answer your question, could you be a little more specific?
",ellbee,ccorcos
150,2015-11-18 04:49:17,"@gaearon Sorry to dig up a closed issue - but is the recommended way of accessing the store from descendent components to just pass the store as a prop down through the tree?  I want to subscribe to some state updates, and intend to use [redux-rx](https://github.com/acdlite/redux-rx) to do so, but just not sure on the best way to access the store from descendent components.
",marcuswhit,gaearon
145,2015-10-14 18:53:27,"I have certainly noticed that, as my application grows, I have many `connect`ed components nested inside other `connect`ed components, as @jdefontes has rendered in his last comment. I have been operating under the assumption that the redux listener system is probably robust enough to notify all the elements when a change occurs.

The way my pre-flux isomorphic React app was structured involved passing down _all the data_ from the initial route component all the way to the farthest leaves, which gets disgusting _very_ quickly, and avoiding that via state stored in the context is one of the biggest benefits of the Flux architecture.

I agree with @jdefontes' conclusion:

>  Each HOC has it's own relationship with the store, and trying to roll up multiple components' needs into a single connect() call seems to be mixing up things that should be separate.
",erikras,jdefontes
145,2015-10-15 14:03:14,"Thanks for the discussion.

Just one further observation... if you try to force a tree of HOCs to share a top level `<Connect>` then the whole tree gets notified when any of the various HOCs state changes, which becomes pathological in the case of, say, redux-form, where every keystroke updates the store. When you nest `<Connect>`s, each one of them gets separately notified, but they have the very nice property of acting as a guard for their children, and only updating the children if the state they care about has changed. So I see that as another vote for nested  `<Connect>`s.

I agree with @erikras that, even setting aside the question of HOCs, it is just too damn convenient to not have a few nested `<Connects>` in a real app. Threading props through a deep component tree is a PITA and doesn't separate concerns very well. The previous version of my app using vanilla Flux had nested components that individually subscribed to the stores they cared about, so nesting `<Connect>`s is the functional equivalent of that for me. Viva Redux! (and redux-form is awesome too! ;-)
",jdefontes,erikras
145,2015-10-25 03:43:50,"After my exploration of redux and its advantages / tradeoffs I have concluded that this is the one piece I strongly dislike (as it applies to React): no convenient / modular way to nest higher order components (HOC). 

Most apps I build consist of numerous HOCs with demanding (i.e. complex) business rules that will require their own reducer because a parent is incapable of determining its state transformation needs. You certainly don't need to `connect()` each component that requires a reducer, but you might need to connect them for the purposes of selection. Simply put...



... won't work unless I hand down the state to the child explicitly in the view via `<Child state={this.props.child}/>`. This requirement isn't _that_ bad, since it's kind of the foundation of pass-down props defined by React. What stinks is when `<Child />` also has `<Grandchild />`. Now I'm trapped in this highly-coupled pass-down party®.



To be fair, I suppose this could be alleviated by avoiding doubly-nested components and instead using a `grandchildReducer` and maintaining that only a `<Child />` ""knows"" a `<Grandchild />`.



**For the sake of argument**, what if we `connected` each HOC? That would avoid the prop pass-down problem, though I fear it would introduce another issue (that might be worse).

As mentioned by @jdefontes, authentication is a big piece of any app. Normally I write applications to be ""secured"" via different containers entirely for `public` or `secure` inner applications, where an intercepted `statusCode 401` moves people from `secure` back out to `public`.



The selector for each of these components becomes immediately annoying, fragile, and error-prone.



Now, luckily the atom for these pieces _can_ be flat, since there's no real state sharing between a secure / public app or the root. We could even use a special ""global"" state indicator for those key pieces of app knowledge.



The problem arises when you get into nesting of related components that _can't_ be flattened. Perhaps an array of group of categories with an array of items belonging to a group.



The reducers would look like the following:



This means that an `<Item />` would become a `connect(itemSelector)(Item)` component that extracts necessary state from the atom. But can we even do this? How would we know which item to pick from the list of items, assuming that list _even exists at all_ in the early stages of an app's lifecycle. 



This just isn't possible. There is a limit to the depth inside the atom at which you can `connect`, and that limit starts with anything created at runtime. 

Let's take a step back and reexamine the prop pass-down strategy. Another annoyance is that only `connected` apps receive a dispatch. This is good for keeping knowledge of `redux` away from the leaves of an app, but is also a lot of boilerplate (and potential coupling). How does the `<Grandchild />` create an action? Well, it invokes the callback that was provided to it from the `<Child />`, which itself received the callback from the `<Parent />`, which declared the callback as `cb = (value) => this.props.dispatch(someAction(value))`. This also (kind of?) couples the parent to the grandchild because the parent has to know that the grandchild might want to `doSomeAction`, and `someAction` might be a separate piece of the domain. Consider `onChildSelected` versus `onGrandchildSelected`. Should the parent really have to know the domain of the grandchild in the sense of `<Child onChildSelected={() => this.props.dispatch(childSelected)} onGrandchildSelected={() => this.props.dispatch(grandchildSelected)} />`?

I would appreciate anyone else's thoughts on this matter. Is the ""cleanest"" solution simply a prop pass-down as demonstrated above? Is there a way around all the boilerplate? How much nesting can / should we do in the atom? 
",aft-luke,jdefontes
145,2016-01-13 04:17:07,"@gaearon

I fiund thus question by you (on S.O.) and another one by @ide (i just commented on that too so i apologize for the inadvertent loop) grappling with the effecf of this same exact issue, which was not satisfied IMO with the batchedupdate answer (you are still going to have overhead that grows with the complexity of the component tree)

https://github.com/rackt/redux/issues/125

http://stackoverflow.com/questions/25701168/at-what-nesting-level-should-components-read-entities-from-stores-in-flux

I think the answer on S.O. is not ideal... leaving it to the programmer is not a comforting solution

have you any updated insight?
",idibidiart,gaearon
141,2017-03-21 02:34:22,"@mini-eggs : hmm.  If it's something you can reproduce, please go ahead and file a new issue.  ",markerikson,mini-eggs
138,2015-10-09 14:37:59,"This way you're bundling whole recompose for one method.
The build size increased 4x, it was 2867 before the change.

@acdlite Do you support importing individual files?
",gaearon,acdlite
137,2016-12-01 12:34:03,@averyvery can you give a bit more detail on your approach? where did you put these files?,ericmasiello,averyvery
137,2016-12-01 15:16:39,"@ericmasiello sure:

",averyvery,ericmasiello
136,2015-10-28 17:25:32,"@gaearon Just out of interest: Was there any conclusion on this topic?
",aflatter,gaearon
132,2015-10-01 05:57:42,"@rockingskier Nice work. Depending on what the maintainers of react-redux think, maybe this should become a little package of its own. That wouldn't be as discoverable, though.
",bebraw,rockingskier
131,2015-09-29 20:32:18,"@gaearon thanks for getting back to me, I will extract it from our production code and get a running example.
",sabeurthabti,gaearon
131,2015-09-29 21:07:56,"@gaearon hi - I pushed similar code to this project: https://github.com/sabeurthabti/redux-friendlist-demo
`DEBUG=true npm start`

click `hello` and i expect the 1 to update into 2. 

I am quite new to react state management. So far I am loving redux, so thank you +1
",sabeurthabti,gaearon
131,2015-09-30 07:31:54,"@gaearon you are amazing, i am trying to get redux adopted by my team (net-a-porter.com/mrporter.com). Thank you so much. 
",sabeurthabti,gaearon
129,2015-10-12 13:05:38,"@jesenko Can you try creating a test that emits the warning?
",gaearon,jesenko
129,2015-10-12 15:48:59,"Tried creating a failing test for this

https://github.com/rackt/react-redux/compare/master...epeli:fail129?expand=1

but it's not failing! I don't know why. Seems like it should because the constructor and dispatch is called between the component render calls which would indicate it's part of the render but I guess it's not...

btw @gaearon I had a weird issue with the testing environment https://github.com/rackt/react-redux/commit/bba883ab347064d5d75c05a222a874fbeda17061
",epeli,gaearon
129,2015-10-12 16:03:15,"@bmueller-sykes your example is not actually async but actually this issue seems to be about sync dispatches from constructor anyway.

https://github.com/epeli/redux-setstate-test/commit/62c3dc885fb17b598ac74559ac6f6adc15ef401c
",epeli,bmueller-sykes
126,2015-09-29 04:45:27,"@roine here is a example: https://github.com/chentsulin/react-native-counter-ios-android
",chentsulin,roine
120,2015-09-26 01:18:01,"@gaearon you were right.

It was the way the new version of react-router handled the history with:



instead of the beta3 way:



It was a bit tricky to troubleshoot. The react-router team is changing the API too much. Thanks for your re-assurance that it was not the cause of the issue, it helped anyways.

Also congrats for react-redux, awesome work.
",pbreah,gaearon
119,2016-07-22 07:42:17,"@alex-wilmer Thanks for leaving the link wide open in here, i would even go further here because this one is google top1 url for now and easy to reach:

**In your tests, import the connect()'ed component via curly braces like so to avoid the error:**
import { App } from './App'

While in your app you still use default imports:
import App from './App'
",EugeneHlushko,alex-wilmer
118,2015-09-28 10:45:56,"@vslinko can you try whether #122 fixes this for you.
",epeli,vslinko
118,2015-09-28 16:59:26,"@epeli it works, thank you
",vslinko,epeli
116,2015-09-24 04:34:03,":+1: Ran into the same thing. Thanks, @gaearon & @theaqua.
",gasi,gaearon
115,2016-04-18 18:58:50,"> This is fixed in React Hot Loader 3.
> It is built with lessons learned from both React Hot Loader and React Transform.
> It’s still in alpha but I encourage you to check it out!

@gaearon Great stuff! ran into this today when teaching redux to someone. I'll give it a whirl :)
",glenjamin,gaearon
111,2016-08-01 15:22:23,"@gaearon shouldn't this be handled by the library? It doesn't feel very intuitive this way (_especially when using decorators and static properties_), and doing the opposite (by requiring to manually `delete` the `defaultProps` from the wrapper element should the forwarding be undesirable) seems a saner default behaviour.
",arcanis,gaearon
108,2015-09-15 16:04:42,"@jamiewinder this might not work with you but consider possibly using selectors (consider [faassen/reselect](https://github.com/faassen/reselect))

You taskData will exist in your store normalized but when you connect your task list or whatever use selectors to compose the userData with the taskData into a denormalized unit for consumption by your TaskItem component.

This lets your dumb components be truly dumb, they get exactly and only what they need and they don't have to know how to query your user data
",gnoff,jamiewinder
108,2015-09-15 16:20:17,"Thanks @gnoff - it looks like it might help, though if I have my dumb components `@connect`-ed then doesn't that make smart by definition? Not that it's necessarily a problem, but I imagine having thousands of store-connected components (i.e. my lists **and** their items) will have a performance impact, I'd guess? I'll have a look into it all the same. Thanks again.
",jamiewinder,gnoff
108,2015-09-22 16:24:21,"@bmueller-sykes 

Context is opt-in; you _have to_ specify `contextTypes` on the component to get it.
See [the above comment for an example](https://github.com/rackt/react-redux/issues/108#issuecomment-140778557).
",gaearon,bmueller-sykes
108,2015-09-22 16:25:37,"@bmueller-sykes 

Oh, also, if you want to access `this.context` in the constructor, you need to change your `super` call:



You can skip this if you're only reading it later because React will put `context` onto your instance after the constructor has run.
",gaearon,bmueller-sykes
108,2016-02-10 17:14:44,"Ok, here is the code. I am just pasting the relevant parts (ommitted lots of import calls). Thanks for looking into this @gaearon 

**app.js** (look at the OrderContainer component)



**order-container.jsx**



Feel free to critique anything that you see wrong/unusual :)
",rodryquintero,gaearon
108,2016-02-10 19:46:17,"Thanks for the quick reply @gaearon. At the time I posted my comment I needed access to `getState()` to tell wether there were any changes in the component state and thus prevent/allow navigating away from it.

The code I posted has been refactored and I no longer need the access state within the component (I check if there are changes to be saved in the reducer. So you are right, I don't need access the store from context.

> connect() generates a new component that wraps your component and already has contextTypes specified for you. You never need to specify them explicitly when you use connect().

The weird thing is, I don't have access to the store in a ""connected"" component. Here is the context for the OrderContainer component. 

![image](https://cloud.githubusercontent.com/assets/1271370/12959434/5e75c4e2-d004-11e5-973b-a91b5e1a36ee.png)

I refactored the code and it is now much cleaner. I use the state from the `select` function to check for differences. But if you ever need to access the store within the component, at least in my case, I was not able to.
",rodryquintero,gaearon
105,2015-09-15 03:13:16,"+1 to keeping things simpler

Perhaps it'd be a good idea to explicitly mention that in the Support for Decorators section? @gaearon 
",cesarandreu,gaearon
105,2015-09-16 00:12:51,"@gaearon You're right and it was nothing personal. I could have sworn all your examples used to use it, but that was a few months back - at least I remember going through something which had it. Good to see it's not the case anymore :+1: 
",blakeembrey,gaearon
104,2016-07-10 16:59:37,"@epeli I know it's been a while, but any progress on this?
",timdorr,epeli
103,2016-07-07 04:12:16,"@gaearon Hi I have a question about the way to connect the component.

Here is the code:



so this way, it will connect the component firstly then do the didMount, so what's the different between the 'before' and 'after' connect the component and the cons or pros.

Thanks,
",KaroseLiu,gaearon
102,2015-09-11 17:34:12,"@mikeyamadeo Bingo. Thanks!
",iammerrick,mikeyamadeo
102,2016-07-18 19:20:35,"@tomascharad : I believe Redux-Saga provides a `select()` operation, which you would use roughly like:


",markerikson,tomascharad
102,2016-07-18 20:31:04,"Correct, forgot to update! thanks @markerikson. 
",tomascharad,markerikson
101,2015-09-10 06:04:19,"@duro interesting problem. I haven't dug into your gist too much but my initial intuition is that you'd be better served rendering an intermediate component between the vanilla TransitionGroup and your connected component. Is there anything in the transition lifecycle methods that actually need to be colocated with the connected component?

so instead of doing



you could do



and TransitionWrapper would just render `return this.props.children` or something like that

I _think_ that would work and would probably be more idiomatic and easier to test etc...
",gnoff,duro
101,2015-09-10 21:14:12,"@gnoff I got it!!! Here is the final Decorator:

https://gist.github.com/duro/0534a9c5fe4bd8b868a8

And here is how it's implemented on a Connected component:


",duro,gnoff
100,2015-09-10 22:37:02,"@gnoff ok, thanks. Could you tag this as a question? Just so it's easier to find if someone else is thinking about a similar problem.
",despairblue,gnoff
99,2015-09-08 22:25:24,"@epeli this brings us back to the way things were before #1 which as @gaearon says makes the worst case performance the default. I'm inclined to leave the existing behavior as is. If we did adopt this form I would hope that it be made optional and opt-in much like the 2nd arg props parameter to the first two connect arguments.
",gnoff,epeli
99,2015-09-10 06:54:40,"@epeli took a better look and you I retract my earlier statements about regressing performance-wise. However regarding the lack of consistent batched updating is it true then that for this PR to not regress in any case one needs to use either the redux-batched-updates middleware or does the lack of that simply return us to the edge-case broken state that we are in with the reported issue #86 ?
",gnoff,epeli
98,2016-05-22 16:44:50,"@gaearon Any thoughts on reopening this now that Redux has an official definition?

There's a really nasty issue right now where the DefinitelyTyped react-redux definition doesn't actually work correctly with the officially-maintained Redux definition, only the DT Redux definition. It'd be nice if there was an official definition for react-redux that was kept in sync with the official Redux definition :)
",thomasboyt,gaearon
95,2015-09-06 22:18:10,"@Agamennon It's not working for me :(
First, there is a link to a local repo in `package.json`: 



I've installed it from npm, but didn't manage to make it work (via `npm start`) - seems like `/build/bundle.js` redirects to index page.
",alexkuz,Agamennon
95,2015-09-06 22:36:05,"@gaearon ,  i don't think i can, the Reopen Issue button does not show up for me.
",Agamennon,gaearon
95,2015-09-06 23:02:04,"@gaearon   awsome, thank you!
",Agamennon,gaearon
94,2015-09-08 22:13:04,"@preflight the `() => ({})` parameter is actually not necessary in this case since that is the default mapper so using `connect()(App)` actually gets you the same functionality. That said there isn't much use in subscribing to the redux store if you don't provide a mapper to grab some state. The CartContainer and ProductsContainer which are both connected will work just fine with an unconnected parent App. If anything it triggers unnecessary re-renders though in this simple example it's irrelevant
",gnoff,preflight
92,2015-09-06 21:31:02,"Made an [example repo](https://github.com/Agamennon/example), details to help understand the example in the repository readme.  @alexkuz  i think that maybe that's whats happening inside react-redux, what is not clear, is how the app is triggering it.
",Agamennon,alexkuz
88,2015-09-02 21:34:24,"@dallonf yup this is a tricky situation. My thought is that in keeping with the paradigm that redux assumes state is not mutated we should guide people towards making more pure Components and leave the aggressive `shouldComponentUpdate` as is.

Given that you won't always have control over this situation though i think there are a couple of workarounds that might be worth exploring (some more hack-ish than others). I haven't tried any of these but in theory they should work

~~1) make your `mapStateToProps`, `mapDispatchToProps`, or `mergeProps` arguments return a purposely 'dirty' props object. something like~~



~~This will eliminate all preformance optimizations from shouldComponentUpdate since there will always be a prop that has a new object reference and therefore should fail the shallowEqual test~~
this doesn't work per @dallonf 's testing. 

2) develop your own 'impure' Component decorator that wraps your connected component and have it call forceUpdate on the connected component child whenever it's props change.

maybe something like this



btw, i never actually use forceUpdate so not sure if it would need to go there or in componeDidUpdate or somewhere else but essentially this _should_ force the connected component to update on every prop change

you would use it like this


",gnoff,dallonf
87,2015-09-02 19:52:50,"Hi @K4stor I have looked into your code, it seems you are mutating your state in your reducer, you are pushing a new entry into operations array instead of creating a new array. See http://rackt.github.io/redux/docs/basics/Reducers.html or http://rackt.github.io/redux/docs/Troubleshooting.html in the first section. Your state needs to be immutable so that re-render is triggered. Hope it helps !
",alanrubin,K4stor
83,2015-09-02 06:30:17,"@arkwright I believe you are slightly misinterpreting the point of the the readme where is says

> Don’t do this! It kills any performance optimisations because TodoApp will rerender after every action.

The example is showing an connect select function that maps the entire state to the connected component



In any application of reasonable size this is likely unnecessary since parts of your state are likely not of concern for the given connected component. The point about performance is recognizing that in this given example the component will be re-rendered anytime any state changes even if it isn't relevant to the connected component.

I think the readme example could probably make this a little more clear so that future readers don't also come away with the impression you did.

Hopefully that helps clear things up.

Thanks,
Josh
",gnoff,arkwright
82,2015-09-02 06:32:45,"@joker-777 not super familiar with coffeescript but @billyjanitsch 's analysis seems to be spot on. 

Closing but let me know if the provided solution doesn't resolve the issue.
",gnoff,joker-777
82,2015-09-02 06:32:45,"@joker-777 not super familiar with coffeescript but @billyjanitsch 's analysis seems to be spot on. 

Closing but let me know if the provided solution doesn't resolve the issue.
",gnoff,billyjanitsch
82,2015-09-02 09:17:43,"@billyjanitsch Thanks so much for your answer. This really fixed it. Could you explain why I have to do this but the documentation doesn't show it. Maybe it is part of this `export default` but I have no idea. It would be also nice to add it to the documentation.
",joker-777,billyjanitsch
80,2017-02-08 16:08:23,"@aFarkas You can look at where the repo is located now, and use that to fix the link 😉  https://github.com/reactjs/redux/pull/667",gaearon,aFarkas
79,2015-09-02 14:46:19,"@gaearon sorry for not closing an issue, I've already find the solution.
",gyzerok,gaearon
79,2015-09-03 12:58:13,"@gaearon I guess here is another problem. I thougt that if I place router variable as and return value from function inside Provider it would be similar to put <Router> tag inside Provider. I think its all about how JSX work. Dont know how to describe it better. Hope you can :)
",gyzerok,gaearon
76,2015-08-27 05:39:52,"@gnoff The issue was more around distributable browser bundle than cdnjs.
Is there a way currently to use it, that I am missing?

cc @gaearon 
",vipulnsward,gnoff
75,2015-11-06 13:52:12,"Sorry to drag this up but i had a similar question. Because the props are passed from the top level root component, i.e the APP itself, it seems that every inherit component will render.
This doesn't seem to be an issue with other flux implementations as you can have the even listener, listening for updates - somewhere deep in the component hierarchy. ShouldComponentUpdate works ok here but where as in Redux components will need to update to pass the props down.

This seems to be conflicting with React fundamentals where a full app render is taking place all the time?
I'm envisaging performance bottlenecks. 

Am i missing something? @gaearon @gnoff 
",farzd,gaearon
75,2015-11-06 13:52:12,"Sorry to drag this up but i had a similar question. Because the props are passed from the top level root component, i.e the APP itself, it seems that every inherit component will render.
This doesn't seem to be an issue with other flux implementations as you can have the even listener, listening for updates - somewhere deep in the component hierarchy. ShouldComponentUpdate works ok here but where as in Redux components will need to update to pass the props down.

This seems to be conflicting with React fundamentals where a full app render is taking place all the time?
I'm envisaging performance bottlenecks. 

Am i missing something? @gaearon @gnoff 
",farzd,gnoff
72,2015-08-25 16:56:29,"@udfalkso since React Native is not using React 0.14 the correct fix would be to change https://github.com/udfalkso/react-redux/blob/console-warn-instead-of-error-for-function-wrap/src/components/createProvider.js#L6 to `return true;`

In fact i believe it is a genuine bug that we are returning false here since the only version of React today not using Parent Context is 0.14 beta.
",gnoff,udfalkso
60,2015-08-17 15:39:46,"Indeed, as @gnoff said above, you can't just return Immutable object because we spread over the values you return, and this wouldn't make sense with Immutable.

> I’m able to do something like @connect(state => {return {state};}), and then unwrap the object in App’s render(), but I get the sense that this is not an ideal solution.

The idiomatic way is to do this:



only for the fields you actually care about, so `@connect` can bail out when the parts the component doesn't need, did not change. I don't suggest using `toJS()` because AFAIK it's deep, but deep conversions won't be as performant as just extracting the stuffy you want.

> I also consider using several @connect() a bit higher up the tree, instead of one at the root component.

This is the way to go, and it's more performant than just one `@connect` at the top.
",gaearon,gnoff
60,2016-01-17 23:41:32,"@gaearon Hey Dan, what are your thoughts of running immutable AND reselect together versus just one or the other?
",thewillhuang,gaearon
60,2016-12-28 15:44:36,@bherrmann7 How about those nested immutable Data?They can't be converted to a plain object by toObject() function.Only by toJS() can we convert all nested immutable data.,lee1994522,bherrmann7
58,2015-08-17 19:34:21,"@gaearon Thanks for your quick response, here is an example of the error:

https://github.com/ghondar/reduxExample
",ghondar,gaearon
58,2015-08-17 20:54:47,"oh @gaearon i'm sorry, I forgot to put in the readme that port open in the browser u.u.

open http://localhost:3000/
",ghondar,gaearon
58,2015-08-18 17:16:08,"nice @gaearon it works, thank for all :D 
",ghondar,gaearon
57,2015-11-27 11:54:48,"@micky2be It's hard to help without seeing your code :-). With React 0.14 it should be enough just to wrap root component of your app into Provider. The discussion above is no longer relevant.  
",gaearon,micky2be
57,2015-12-11 18:40:04,"@micky2be You can refer to [react-router-starter-kit](https://github.com/davezuko/react-redux-starter-kit), just put your sidebar code into `Corelayout`
",JuoCode,micky2be
52,2015-08-17 10:41:22,"@PSpSynedra https://github.com/gaearon/react-redux/pull/59#issuecomment-131764832
",evgenyrodionov,PSpSynedra
48,2015-08-11 08:06:02,"@gaearon I got it now. If I pass an object with action creator it will automatically bind them with `bindActionCreators`. In those examples (my bad, didn't read this code right) you are passing a function that returns bound action creators and so `wrapActionCreators` doesn't get called.
",constb,gaearon
47,2015-08-10 11:35:23,"@dzannotti Is it possible to call an action from within another action right now? If it were possible, this might be better done from an action. 

This also reminds me of [Cerebral's signals](https://www.youtube.com/watch?v=ylJG4vUx_Tc), which stack up actions.
",volkanunsal,dzannotti
45,2015-08-10 08:42:57,"Thank you @gaearon. 
",jptaylor,gaearon
43,2015-08-09 16:49:58,"@gaearon Ok) Here is an [example](https://github.com/smashercosmo/redux-react-router-issue)
",smashercosmo,gaearon
41,2017-03-06 23:46:09,"@gate5th : yes, that is _absolutely_ doing direct mutation.  You're only copying the first level of nesting - you need to copy and update _every_ level of nesting.  You also shouldn't copy `newState` like that at the _start_ of the reducer - only copy it when you actually hit a case that needs to update.

I'd encourage you to read through http://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html , which shows how to do proper nested immutable updates, and discusses several common mistakes, as well as some of the articles listed at http://redux.js.org/docs/recipes/reducers/PrerequisiteConcepts.html . There's also a new FAQ section on immutability: http://redux.js.org/docs/faq/ImmutableData.html .",markerikson,gate5th
41,2017-03-06 23:55:36,"Thank you for the super fast response @markerikson! I had not yet seen that new FAQ on immutability and looks extensive so that will be helpful. I didn't realize that the copying had to go further down since I wasn't modifying the middle. I'll read the links in detail and see if I can determine the fix. 

This is actually my first coding post: from an etiquette standpoint should I re-post with a solution once I've resolved it? Or is that unnecessary?",gate5th,markerikson
41,2017-03-07 00:51:38,"@gate5th : since this was a usage question, it actually should probably have been posted over on Stack Overflow, especially since this is a dead thread.  You're lucky I saw the notification and answered :)

No need to re-post anything here.  It's a common issue (which is why it's discussed in the docs and FAQ).

Glad you got it working now!",markerikson,gate5th
30,2015-08-07 18:29:18,"@TimothyKrell, it looks like in v0.5.0 you now have access to the components parent props via the third argument passed to connect

https://github.com/gaearon/react-redux/blob/master/README.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops

Example from readme:

##### Inject `todos` of a specific user depending on props, and inject `props.userId` into the action


",hartzis,TimothyKrell
29,2015-08-07 18:53:12,"Thanks for the feedback @hartzis. Perhaps the problem then is the import statements– `Counter` is imported but never used, while `CounterContainer` is not imported nor defined anywhere, but is then used as a function argument. At the least running the code as-is will give you a ReferenceError :)
",af,hartzis
29,2015-08-07 19:52:25,"@af is correct.

@hartzis Master is a bit outdated, I just released `react-redux@0.5.0` so official examples will be updated later. The intermediate component isn't needed anymore! See also https://github.com/gaearon/react-redux/releases/tag/v0.5.0 release notes.
",gaearon,af
29,2015-08-07 19:52:25,"@af is correct.

@hartzis Master is a bit outdated, I just released `react-redux@0.5.0` so official examples will be updated later. The intermediate component isn't needed anymore! See also https://github.com/gaearon/react-redux/releases/tag/v0.5.0 release notes.
",gaearon,hartzis
29,2015-08-07 20:57:18,"@gaearon That is awesome! I totally see that now.

@af Great catch!
",hartzis,af
29,2015-08-07 20:57:18,"@gaearon That is awesome! I totally see that now.

@af Great catch!
",hartzis,gaearon
16,2015-07-31 07:48:52,"@gaearon mind also checking out this additional PR (currently on my fork only since it looks cleaner comparing to my master)

https://github.com/gnoff/react-redux/pull/1
",gnoff,gaearon
16,2015-07-31 10:26:08,"ok, thank you @gaearon :)
",quirinpa,gaearon
16,2015-08-02 18:03:47,"@quirinpa I'm not the one that did the PR!
It's @gnoff 
",Keats,quirinpa
16,2015-08-02 18:03:47,"@quirinpa I'm not the one that did the PR!
It's @gnoff 
",Keats,gnoff
16,2015-08-03 01:59:22,"@Keats oh :P my mistake
",quirinpa,Keats
15,2015-07-30 23:56:43,"@Keats Not sure if this will help, but here is the implementation I did as a shim from fluxxor to redux to aid in us converting: https://gist.github.com/aaronjensen/95e505cdcbbe9d46019d

This skips the need for `Connector` and has merge (you can ignore the `subscriptions` parameter, that's fluxxor specific).

@gaearon one thing we noticed is that there are times when we want to pass the props to the selector function. Can you think of any reasons that'd be a bad idea?

Also, it looks like you envisioned not proxying the props along in the default merge, so your default merge would just be `(state, actions) => ({ ...state, ...actions })`. Is that right? Or should it include props? (in my experience, if you include props, state should probably be merged after props or confusing things happen with nested containers and liberal `{...this.props}` passing.
",aaronjensen,gaearon
15,2015-07-30 23:56:43,"@Keats Not sure if this will help, but here is the implementation I did as a shim from fluxxor to redux to aid in us converting: https://gist.github.com/aaronjensen/95e505cdcbbe9d46019d

This skips the need for `Connector` and has merge (you can ignore the `subscriptions` parameter, that's fluxxor specific).

@gaearon one thing we noticed is that there are times when we want to pass the props to the selector function. Can you think of any reasons that'd be a bad idea?

Also, it looks like you envisioned not proxying the props along in the default merge, so your default merge would just be `(state, actions) => ({ ...state, ...actions })`. Is that right? Or should it include props? (in my experience, if you include props, state should probably be merged after props or confusing things happen with nested containers and liberal `{...this.props}` passing.
",aaronjensen,Keats
15,2015-07-31 07:16:18,"Thank you for the effort @Keats! I'm closing in favor of #16 because it's more feature complete and already avoids using `Connector`.
",gaearon,Keats
14,2015-07-31 09:20:03,"@jlogsdon don't forget to look at #1 and #16 so you don't write documentations for something that's going to be removed/changed
",Keats,jlogsdon
14,2015-07-31 09:31:46,"@Keats @jlogsdon 

While #1 and #16 are important, it's more important to document the existing APIs right. I'm releasing Redux 1.0 very soon, and I'm going to have examples using React Redux 0.2.1. When we figure #16 out, we'll rewrite the docs, but it might take another week or so. Documenting 0.2.1 is still very important because lots of projects depend on it.
",gaearon,jlogsdon
14,2015-07-31 09:31:46,"@Keats @jlogsdon 

While #1 and #16 are important, it's more important to document the existing APIs right. I'm releasing Redux 1.0 very soon, and I'm going to have examples using React Redux 0.2.1. When we figure #16 out, we'll rewrite the docs, but it might take another week or so. Documenting 0.2.1 is still very important because lots of projects depend on it.
",gaearon,Keats
14,2015-07-31 13:48:44,"Thanks for pointing those out, but I am going to focus on the existing API for the reasons @gaearon said. The new API isn't quite ready, and having docs of the stable release will be very important for the Redux 1.0 release.

I'm working on expanding some of the sections right now and will have something to push up here today.
",jlogsdon,gaearon
6,2016-08-17 05:02:56,"@badtant A fix I just discovered, which allows you to use the decorator:



Note the use of the static property `WrappedComponent`, which is ""The original component class passed to connect()"", and can be found in the documentation here: https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options
",joshmanderson,badtant
6,2016-08-17 05:08:22,"@blesswinsamuel In regards to your example using static propTypes...
Does that work for you? Using static propTypes as you have done there still gives me the same warning messages...

**EDIT:**
I got it to work correctly with no warnings using the `connect` decorator and `static propTypes`.
My problem was babel related... I had the `transform-class-properties` plugin listed before the `transform-decorators-legacy` plugin.

`transform-decorators-legacy` **must** come before `transform-class-properties` to be able to use the `connect` decorator and `static propTypes` together (note that there are other issues that occur, entirely unrelated to redux, if you specify the order of the plugins incorrectly).
",joshmanderson,blesswinsamuel
5,2015-07-17 21:42:35,"@jlongster Relay no longer uses static props, but instead pass a 2nd argument to their createContainer API that contains the queries. Let me find the blog post that shows this... 
",phated,jlongster
5,2015-07-17 21:44:07,"@jlongster blog post with the newest API reference I've seen http://facebook.github.io/react/blog/2015/03/19/building-the-facebook-news-feed-with-relay.html
",phated,jlongster
5,2015-07-17 21:54:43,"@phated ah I had missed that! thanks. I really liked the statics approach, but maybe the disadvantages are stronger than I first thought.

It appears that those properties are still available statically on components though. The `Story` component in that article has a `getQuery` method, so you can just say `Story.getQuery('story')` to get that query for the `Story` component. This is needed for server-side rendering (and is just interesting for debugging).

It's possible they steered away from statics thought so that the can separate smart/dumb components. If you are using static properties, I don't see why you need to do that if you just make the dump component accessible on the `dumb` static property.

So anyway, I don't know what `react-redux` might learn from this but I'll probably just experiment outside of it for now and blog about it.
",jlongster,phated
5,2015-07-17 22:01:02,"@jlongster yeah, their higher-order component produced by `Relay.createContainer` has a few statics so they can traverse the tree, but I think they are straying away from statics on the underlying components.  I've been experimenting with an API similar to the linked Relay API over at https://github.com/iceddev/sovereign but I also want a different API that allows `handlers` (very similar to your actions and namedActions) to be passed in but be outside the re-render path.
",phated,jlongster
5,2015-07-17 22:59:01,"@jlongster Relay originally used statics + a mixin, but we moved to HOCs for a few reasons. Our goal was to have dumb components receive their data as `props`, but that meant one of two options:
- The component somehow resolves its _own_ data and updates its own props (an anti-pattern in React). Re-rendering requires using private APIs (because you can't just `setState`).
- Have _some_ parent component intercepts the props, merge the results of the queries, and pass the merged props to the component. It can also subscribe for data changes and re-render when necessary.

Option 1 requires reaching into React internals and will not be supported going forward. It also complicates the component itself with subscription logic. The only option is for the parent to pass the data in. _Without_ a HOC - if you just use components with static properties -  every component would have to resolve all the data for its children and keep them updated. Components become much more complicated to reason about, because for example `<Feed>` has to handle its own logic, as well as the logic to update all of the `<Story>`s that it composes whenever their data changes. In short, dumb components get really complicated.

HOCs allow removing this complex, async data-resolution logic and state-machinery from the dumb components, making them much easier to reason about and test.

Another advantage is each type of component will always receive the same type of data:
- smart components receive a ""pointer"" (ex: which story to render, perhaps just an `id`)
- dumb components receive data (ex: the story data as `query(id)`)

For Relay specifically, we typically have one file per component with the following:
1. require statements
2. dumb component (render + event handling)
3. container (queries)
4. styles (eg in React Native)
",josephsavona,jlongster
5,2015-07-17 23:05:28,"@josephsavona thanks for much for explaining! to be clear, I'm not advocating for not using a HOC. In fact my current approach does this: https://github.com/jlongster/redux-experiments/blob/master/static-queries/connect.js#L13. `connect` returns a new component. The difference is I pick off the query from the static property of the dumb component. The dumb component doesn't have to do anything else, it just uses props, so if it's rendered from a smart component it will be live data, otherwise it's just props. Basically: I use static props but _not_ a mixin.

However, it seems like everyone is moving towards declaring the queries outside the component, so I'll probably just do that then. :)

I'm glad to hear you still use one file per component; what I wouldn't want to do is declare a dumb component is one place and a smart one in another file. Do you only export the container? If so, how do you access the dumb component if you want it (for testing or something)?
",jlongster,josephsavona
5,2015-07-17 23:18:21,"@jlongster gotcha, that makes sense. It definitely seems like the choice of using a static property or an argument to the HOC function is just a matter of preference. 

It's up to developers what they want to export - just the container or both - though we typically export only the container.
",josephsavona,jlongster
5,2015-07-17 23:21:08,"@jlongster @josephsavona I would think you could mock the `createContainer` method to just return the dumb component for testing
",phated,jlongster
5,2015-07-17 23:21:08,"@jlongster @josephsavona I would think you could mock the `createContainer` method to just return the dumb component for testing
",phated,josephsavona
4,2016-04-21 08:24:29,"Hi, @gaearon  In npm3  peerDependencies  will not install in node_modules.
And this will  not transform react in react-redux by browserify-shim.
",Tankpt,gaearon
1,2015-07-12 02:13:49,"@gaearon 

> On the other hand once you start selecting data in a tricky way, you begin to want finer control over perf optimizations, lifecycle hooks and maybe passing data down in a trickier way so it's likely you'll want a component anyway.

I really think accessing props from the owner is a much more common case that using lifecycle hooks. Props passing is the fundamental contract of React. We'll soon live in a world where [pure functions are valid React components](https://github.com/facebook/react/pull/3995). The fewer ""smart"" components the better — creating class components will start to become a low-level implementation detai. Function components will be the new default. (At least that's what _should_ happen. We'll see if the community catches on.)

> However, this forces us to bind on every prop change, which is a perf hit and unfriendly to shouldComponentUpdate optimizations down the rendering chain.

This seems like a micro-optimization but okay. You could get around this by binding once if an object is passed (""bind automatically if an object is passed"") but bind every time if its a function.  Also if an action creator depends on a prop it's going to lead to updates further down the rendering chain, anyway.
",acdlite,gaearon
1,2015-07-12 02:16:44,"@acdlite also, it's easy enough to prevent constant rebinding with memoization. We had explored this a bit in redux#86
",skevy,acdlite
1,2015-07-12 04:17:31,"@ryancole I still think `bindActionCreators()` (or some equivalent) is useful. You shouldn't pass `dispatch()` to a dumb component; you should bind it in a smart component first. E.g. your dumb components should look like this:



Rather than this:



It may seem like a trivial difference, but the first version is more separated from the implementation details of how it receives its callback. This leads to more scalable, maintainable, testable code.

> It'd be cool if you could just import your action methods and call them, no?

You have to bind them _somewhere_. Remember, action creators in Redux are simply pure functions. Either we bind them in smart components, or we have to bind them at store creation time, in which case we'd need some sort of API for accessing the bound components. Or you could use singletons, but yuck.
",acdlite,ryancole
1,2015-07-12 04:25:42,"I like @gaearon's idea of passing action creators as the second param and auto-binding:



That way we only need to bind once, and the user doesn't need to worry about bindActionCreators.

I would amend that proposal to also support a second form, where you pass a function that maps to _unbound_ action creators:



that way you can access the store state and props, if needed. `bindActionCreators()` becomes an implementation detail.
",acdlite,gaearon
1,2015-07-12 04:53:35,"@acdlite I agree with how you explained why `bindActionCreators` is needed, now. I wasn't thinking in terms of smart and dumb components.

Although something about the idea of a tree of components having most of the parent, outer-most components as smart components and then all the edge node components as dumb (this is what I think this smart / dumb component pattern lends itself to) kind of seems like a stink. I don't have an optimal pattern in mind, and I know smart / dumb components are a current popular pattern, but this as a pattern seems like it creates scenarios where if a dumb component is way down the tree you'll have to pass down action methods or dispatch all the way down the tree to get to it, thus making the components on the way to that component possibly carry along unneeded props just to satisfy their children. Maybe this is result of bad component tree design or something, though, on my part.
",ryancole,acdlite
1,2015-07-12 05:25:13,"@aaronjensen Regarding your first proposal:

First of all, the state object is not necessarily a plain JavaScript object. Redux makes no assumptions about the type of state returned from the reducer. For instance, you could use an Immutable Map.

Second of all, where are the action creators coming from? You say they're part of the state, but how did they get there? We'd need some sort of system for registering action creators at the global level.
",acdlite,aaronjensen
1,2015-07-12 05:39:19,"@acdlite Yep, that's right. We have a system for registering reducers, it didn't seem a long stretch to have one for actions. And you're right re: state not being a plain JS object of course. In that case two arguments could come along: `(state, actions)` or actions could have their own reducer but that seems a little odd.

Tbh, I can't think of a particularly compelling reason for it other than slight convenience at that point at the cost of required registration.
",aaronjensen,acdlite
1,2015-07-12 09:17:51,"> we could drop `<Connector>` altogether and encourage people to use `@connect` decorator

I think it's a good idea, and we can do the same for `Provider`. This will simplify the API and create less confusion.

> This leads to more scalable, maintainable, testable code

@acdlite I was also thinking of dropping `bindActionCreators`, as it's just syntactic sugar for `dispatch(myAction())`, but you make a valid point.

And passing the actions as a second argument of `connect` makes it a good API, given that the binding becomes an implementation detail of the decorator and the user doesn't care about it.

One thing I would also like to have is **namespacing** props. Basically instead of just spreading the actions or whatever to `this.props`, we can have a `actions` object that contains all the actions, and just pass the object to `props`. Same thing could be done for `state`. I think this is important when you start having other data in `props` (e.g.: router) and helps avoiding possible conflicts when merging props.
Here an example:



Thoughts?
",emmenko,acdlite
1,2015-07-12 13:04:07,"@emmenko Namespacing will also kill `shouldComponentUpdate` optimizations because you can't shallowly compare props anymore and nobody will write code to handle namespaces separately.
",gaearon,emmenko
1,2015-07-12 13:20:36,"@gaearon right, haven't consider this. I guess there's no much way around it then...
",emmenko,gaearon
1,2015-07-12 14:09:34,"@gaearon @acdlite considering another approach, what would be the pros / cons of using `context`?

Currently we have `getState` and `dispatch` there. Would it make sense to have also `getActions`? Then you don't have to pass them around anymore via `props`, you can just get them from the `context`. This would also keep `connect` a simple component that subscribes to changes.

I don't know, just thinking out loud... 
",emmenko,gaearon
1,2015-07-12 14:09:34,"@gaearon @acdlite considering another approach, what would be the pros / cons of using `context`?

Currently we have `getState` and `dispatch` there. Would it make sense to have also `getActions`? Then you don't have to pass them around anymore via `props`, you can just get them from the `context`. This would also keep `connect` a simple component that subscribes to changes.

I don't know, just thinking out loud... 
",emmenko,acdlite
1,2015-07-12 14:13:01,"@emmenko this is kind of what I'm getting at as well, but admittedly have not though through possible cons of the ""context"" idea. 
",skevy,emmenko
1,2015-07-12 14:40:19,"> But just to understand, if actions were a core concept, would it have been ok to put them into context and just access them wherever I want?

Can you rephrase? I don't understand what exactly you are asking.

> Anyway, are we heading now towards this connect signature and give it more responsibilities, as you said?

This signature is what feels right to me at the moment. Waiting for @acdlite to take a look.
",gaearon,acdlite
1,2015-07-12 16:05:14,"@acdlite 

If we agree on that, what do you think is reasonable release-wise? We could release this version as `react-redux@1.0.0`, or we could release the current version as 1.0 but jump to 2.0 with this proposal.

It probably makes sense to use the new version in new docs..
",gaearon,acdlite
1,2015-07-12 18:29:05,"@gaearon do you think `connect` is still a correct name for the new signature?
",emmenko,gaearon
1,2015-07-12 19:36:54,"@gaearon I think we should hold of moving react-redux to 1.0 for a while until we've settled on the new API. The current API is not a 1.0 in my view, and I don't see any problem in keeping react-redux at 0.12 (or whatever) even while Redux gets a 1.0 release. That's the advantage of separating the projects.
",acdlite,gaearon
1,2015-07-14 14:55:21,"@jlongster you definitely can fire actions on the server. For instance, what if you have an action that ""gets"" data. You may want to do that when bootstrapping a component for instance. And you'd want that to work on both the client and server.
",skevy,jlongster
1,2015-07-14 14:55:29,"Hey @jlongster, thanks for coming by!

> For server-side rendering, do you ever actually fire actions on the server? I'm not sure why you would, it seems like action firing is only in response to some external event.

You want to fire actions to prepare the stored state.
This way you can render actual state before sending it to the client.

> Server-rendering seems like one of the main reasons to not create global action creators that are already bound to your store.

Yes, this is the main reason why we don't bind right away.
",gaearon,jlongster
1,2015-07-14 15:04:00,"@skevy @gaearon Thanks! I'm rewriting my blog admin to use Redux and finally making time to think through this.

Currently, all my components can define a static method which can fetch data (performed when I resolve all the routes and stuff), and this data is automatically available. Other than data fetching, are there any other use cases? I'm trying to reconcile Relay with this, and I see some opportunities. With Relay that data fetching happens automatically for you. Since Relay isn't released yet, I don't know how you perform updates, but I think the general flux-style flow of actions works for that.

If I solve the data fetching part, are there any other reasons why I'd need redux on the backend?

EDIT: May just have to wait for Relay, and I could just follow the patterns here and use Redux for data fetching too. Still thinking through.
",jlongster,gaearon
1,2015-07-14 15:04:00,"@skevy @gaearon Thanks! I'm rewriting my blog admin to use Redux and finally making time to think through this.

Currently, all my components can define a static method which can fetch data (performed when I resolve all the routes and stuff), and this data is automatically available. Other than data fetching, are there any other use cases? I'm trying to reconcile Relay with this, and I see some opportunities. With Relay that data fetching happens automatically for you. Since Relay isn't released yet, I don't know how you perform updates, but I think the general flux-style flow of actions works for that.

If I solve the data fetching part, are there any other reasons why I'd need redux on the backend?

EDIT: May just have to wait for Relay, and I could just follow the patterns here and use Redux for data fetching too. Still thinking through.
",jlongster,skevy
1,2015-07-27 11:58:06,"@quirinpa 

Redux 1.0 RC does not include React bindings. We separated them in this repository precisely because we want to iterate on them separately.

React-Redux 0.2.1 still has the old API. If you'd like to implement the API proposed here, you're welcome to send a PR! We can then publish it as 0.3.0.
",gaearon,quirinpa
1,2015-07-27 12:09:36,"@gaearon Thanks man but i think i still i don't have the knowledge to :P you have developed awesomeness, thanks!
",quirinpa,gaearon
1,2015-07-27 15:34:34,"@ForbesLindesay Right, my typo.
",gaearon,ForbesLindesay
1,2015-07-27 16:25:47,"Just a substitute until Keats solution is merged :P



**Edit**: I've made a few changes. It now supports the following;



@gaearon i'm probably doing something wrong and i'm not very confortable with git, so i'd rather hear from you before i send a PR... Cheers.

**Edit**: Now supports merge :)
",quirinpa,gaearon
1,2015-07-31 10:10:27,"@Keats Yeah we might. I haven't looked into it yet, want to get the Connector stuff sorted out first.
",gaearon,Keats
1,2015-07-31 10:11:20,"@Keats To clarify, I don't propose anybody actually remove it before we discuss. There are many concerns: universal rendering, hot reloading, DevTools, etc, and we want to make sure we handle all these scenarios gracefully.
",gaearon,Keats
1,2015-08-06 23:10:03,"I second the idea @mmerickel describes above. I was actually going to suggest exactly the same thing since I have been binding the actionCreators at the top level and passing them down. I'd love if actions could be ""selected"" in the same way as slices of state in the connect decorator. 

I've been staying away from using dispatch in my dumb components and instead just using pre-bound actionCreators from props, but I like that there is a very easy way in his sample above to get at the dispatcher. To me this supports both styles of working with actions, and because the api would be very similar to what is already understood for selecting state, it would reduce cognitive load required to start being productive with the react-redux bindings.
",danmartinez101,mmerickel
1,2015-08-07 10:05:26,"@danmartinez101 @mmerickel 

One of the reasons I don't want to do this is because code splitting will be harder.
People are likely to keep wanting the same structure, and will do hacks to make it work with code splitting.
The current proposal works with code splitting with no modifications.

I feel this is more opinionated than I'm willing to go. I'm happy to see this explored in alternative bindings though!

Everyone, thanks for the discussion, let's continue in #16.
",gaearon,mmerickel
1,2015-08-07 10:05:26,"@danmartinez101 @mmerickel 

One of the reasons I don't want to do this is because code splitting will be harder.
People are likely to keep wanting the same structure, and will do hacks to make it work with code splitting.
The current proposal works with code splitting with no modifications.

I feel this is more opinionated than I'm willing to go. I'm happy to see this explored in alternative bindings though!

Everyone, thanks for the discussion, let's continue in #16.
",gaearon,danmartinez101
1,2015-08-07 15:19:32,"@gaearon Can you clarify what you mean by code splitting? My assumption by exposing the `dispatch` to the action getter was that this would help if you didn't want to do `<Provider actions={actions}>`. Maybe exposing a binder instead of dispatch works better which seems quite similar to what your original proposals have been above.
",mmerickel,gaearon
1,2015-08-07 15:24:37,"@mmerickel Code splitting = when your app's modules are loaded by demand. As result, not all `actions` are available from the beginning.
",gaearon,mmerickel
652,2017-03-20 12:47:28,"Hello every one ! I had a problem with redux : I create a simple application with this tutorial : https://medium.com/@jonlebensold/getting-started-with-react-native-redux-2b01408c0053#.ridphemkc

But it's impossible to my to import Provider from react-redux :(
I did :
`import {Provider}  from 'react-redux'`
But Provider is undefined and it result in this exception when I try to use it :

> Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined.

Any idea ?

Here is the version of my packages :
""react"": ""15.4.2"",
    ""react-native"": ""0.42.0"",
    ""react-redux"": ""^5.0.3"",
    ""redux"": ""^3.6.0"",
    ""redux-logger"": ""^2.8.2"",
    ""redux-thunk"": ""^2.2.0""

Thanks in advance !",arsenalol69,jonlebensold
635,2017-02-27 06:01:14,"So I had a rather frustrating evening debugging an issue. I'm using `transform-decorators-legacy` and I went to use `redux-react`.

Here's the error I received:



This told me none of what I actually needed to know:

  1. Which component
  2. What the object was
  3. What this likely related to

I edited the source code to get some more useful errors, changing:



to:



Which changed the error message to:



This was way more useful, but still I had no idea what was going on so I found that text (The `""children""` field):



Nothing strange here, so I looked at the `Anchor` component:




Turns out you can't use `@connect` bare like that, you *have* to provide it some function that results in the props object.

I'm just making this issue as a helpful guide for anyone else searching for this very error message.
",krainboltgreene,connect
631,2017-03-13 14:37:24,"@data-doge Any chance you can reproduce that error with source maps enabled so we know what line of code is actually causing the problem? That stack trace is from a minified bundle.

@jimbolla Any idea what's up here? ",timdorr,jimbolla
629,2017-02-22 16:19:04,"@jimbolla @timdorr If you plan to cut a new release, could you include this one with it? I could cut it separately myself too if you don't have the time. Thanks!",gaearon,timdorr
629,2017-02-22 16:19:04,"@jimbolla @timdorr If you plan to cut a new release, could you include this one with it? I could cut it separately myself too if you don't have the time. Thanks!",gaearon,jimbolla
589,2016-12-30 02:22:49,@timdorr Thoughts on pushing a patch release for this and the other handful of fixes we have waiting to go out?,jimbolla,timdorr
589,2017-01-31 04:33:55,"@jimbolla , @timdorr : following up on this at @davidkpiano 's request.  It's Jim's code thus far, and Tim's been cutting releases (something I should go figure out for myself at some point, but don't have time to dig into atm).  Are we good to go on this?",markerikson,timdorr
584,2017-01-10 01:05:07,@timdorr Any thoughts on pushing out a patch release?,jimbolla,timdorr
574,2016-12-14 16:58:41,"@btd, Any insight on this?",jimbolla,btd
573,2016-12-14 14:51:54,"Ok, what kind of details do you need? I can give you some of my code setup:

I noticed that NavigationContainer defines a childContextTypes of its own. Perhaps it overwrites the react-redux setting instead of merging it?

index.ios.js
	
	import './app/dev/Reactotron';
	import { AppRegistry } from 'react-native';
	import Root from './app/App';

	AppRegistry.registerComponent('Ology', () => Root);

	

App.js

	
	import React from 'react';
	import { Provider } from 'react-redux';
	import { MenuContext } from 'react-native-popup-menu';
	import UIContainer from './modules/navigation/components/UIContainer';
	import routez from './resources/routez';

	import { styles } from './MSA';

	import configureStore from './store/configureStore';
	const store = configureStore();

	export default class Root extends React.Component {

		render() {
			return (
		  <Provider store={store}>
			  <MenuContext style={styles.stretch}>
				  <UIContainer
					  routes = {routez}
				  />
			  </MenuContext>
		  </Provider>
			);
		}
	}
	

configureStore.js
	
	import { createStore, applyMiddleware, compose } from 'redux';
	import thunkMiddleware from 'redux-thunk';
	import loggerMiddleware from 'redux-logger';
	import rootReducer from './reducers';
	import { persistStore, autoRehydrate } from 'redux-persist';

	import { middleware as netInfoMiddleware } from '../modules/connection/middleware';

	import config from '../config';

	const initialState = {};

	export default function configureStore() {

		let enhancer;

		if(__DEV__) {

			const Reactotron = require('reactotron-react-native').default;
			const createReactotronEnhancer = require('reactotron-redux');
			const reactotronEnhancer = createReactotronEnhancer(Reactotron);

			enhancer = compose(
		  reactotronEnhancer,
		  applyMiddleware(
			thunkMiddleware,
			netInfoMiddleware,
			loggerMiddleware(),
		  )
		);
		}else{

			enhancer = compose(
		  applyMiddleware(
			thunkMiddleware,
			netInfoMiddleware,
		  )
		);
		}

		const store = createStore(rootReducer, initialState, enhancer);

		if (module.hot) {
			module.hot.accept('../reducers', () => {
				const nextRootReducer = require('./reducers').default;
				store.replaceReducer(nextRootReducer);
			});
		}

		return store;
	}
	
NavigationContainer

	@connect(
		(state) => {
			const { notifications, inboxReducer, progress,  navigation, connection, wsReducer, menu } = state;

			return {
				spinner : progress.spinner,
				navigationState : navigation.navigationState,
				routeRegistryRoutes : navigation.routeRegistry.routes,
				notificationCount : notifications.newNotificationsCount,
				messageCount : inboxReducer.newMessageCount + inboxReducer.newInviteCount,
				connected : connection.connected,
				wsActiveGroups : wsReducer.activeGroups
			};
		},
	  (dispatch) => {
		  return {
			  dispatch,
			  navigate : (path, title) => dispatch(doNavigate(path, title)),
			  navigateReset : (path, title) => dispatch(doReset(path, title)),
			  navigateBack : () => dispatch(doNavigatePop()),
			  formActions : bindActionCreators(formActionCreators, dispatch)
		  };
	  }
	)
	@autobind
	class NavigationContainer extends React.Component {
        [...]
        }

        NavigationContainer.childContextTypes = {
           navigator	: PropTypes.object.isRequired
        };

",mschipperheyn,autobind
573,2016-12-14 14:51:54,"Ok, what kind of details do you need? I can give you some of my code setup:

I noticed that NavigationContainer defines a childContextTypes of its own. Perhaps it overwrites the react-redux setting instead of merging it?

index.ios.js
	
	import './app/dev/Reactotron';
	import { AppRegistry } from 'react-native';
	import Root from './app/App';

	AppRegistry.registerComponent('Ology', () => Root);

	

App.js

	
	import React from 'react';
	import { Provider } from 'react-redux';
	import { MenuContext } from 'react-native-popup-menu';
	import UIContainer from './modules/navigation/components/UIContainer';
	import routez from './resources/routez';

	import { styles } from './MSA';

	import configureStore from './store/configureStore';
	const store = configureStore();

	export default class Root extends React.Component {

		render() {
			return (
		  <Provider store={store}>
			  <MenuContext style={styles.stretch}>
				  <UIContainer
					  routes = {routez}
				  />
			  </MenuContext>
		  </Provider>
			);
		}
	}
	

configureStore.js
	
	import { createStore, applyMiddleware, compose } from 'redux';
	import thunkMiddleware from 'redux-thunk';
	import loggerMiddleware from 'redux-logger';
	import rootReducer from './reducers';
	import { persistStore, autoRehydrate } from 'redux-persist';

	import { middleware as netInfoMiddleware } from '../modules/connection/middleware';

	import config from '../config';

	const initialState = {};

	export default function configureStore() {

		let enhancer;

		if(__DEV__) {

			const Reactotron = require('reactotron-react-native').default;
			const createReactotronEnhancer = require('reactotron-redux');
			const reactotronEnhancer = createReactotronEnhancer(Reactotron);

			enhancer = compose(
		  reactotronEnhancer,
		  applyMiddleware(
			thunkMiddleware,
			netInfoMiddleware,
			loggerMiddleware(),
		  )
		);
		}else{

			enhancer = compose(
		  applyMiddleware(
			thunkMiddleware,
			netInfoMiddleware,
		  )
		);
		}

		const store = createStore(rootReducer, initialState, enhancer);

		if (module.hot) {
			module.hot.accept('../reducers', () => {
				const nextRootReducer = require('./reducers').default;
				store.replaceReducer(nextRootReducer);
			});
		}

		return store;
	}
	
NavigationContainer

	@connect(
		(state) => {
			const { notifications, inboxReducer, progress,  navigation, connection, wsReducer, menu } = state;

			return {
				spinner : progress.spinner,
				navigationState : navigation.navigationState,
				routeRegistryRoutes : navigation.routeRegistry.routes,
				notificationCount : notifications.newNotificationsCount,
				messageCount : inboxReducer.newMessageCount + inboxReducer.newInviteCount,
				connected : connection.connected,
				wsActiveGroups : wsReducer.activeGroups
			};
		},
	  (dispatch) => {
		  return {
			  dispatch,
			  navigate : (path, title) => dispatch(doNavigate(path, title)),
			  navigateReset : (path, title) => dispatch(doReset(path, title)),
			  navigateBack : () => dispatch(doNavigatePop()),
			  formActions : bindActionCreators(formActionCreators, dispatch)
		  };
	  }
	)
	@autobind
	class NavigationContainer extends React.Component {
        [...]
        }

        NavigationContainer.childContextTypes = {
           navigator	: PropTypes.object.isRequired
        };

",mschipperheyn,connect
567,2016-12-10 23:11:55,"This fixes #513. I'm not sure how to write a proper automated test for HMR, but I tested it against @patrikholcak's repo mentioned in https://github.com/reactjs/react-redux/issues/513#issuecomment-263126565.",jimbolla,patrikholcak
560,2016-12-06 10:20:36,"Current latest `@next` version published on npm is v5.0.0-rc.1, which is uses `Array.prototype.find` that [not supported by IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Browser_compatibility). It seems find was removed since then but new version was not released.
thanks",iotch,next
557,2016-11-30 15:38:46,"Instead of using the `setState` callback, doing `notifyNestedSubs` in `componentDidUpdate` seems to avoid the cursor bug (#525) without the need for the compatibility setting BS. (I swear the first time I tried this, it didn't work; I must've screwed something up. /shruggie) I'll perf test this tonight when I'm at my home PC with all my test projects. Assuming that goes well, this is a much cleaner solution. Thanks @istarkov.

",jimbolla,istarkov
557,2016-12-07 16:48:38,"I know @ryanflorence was building a bunch of stuff to prepare for it in Router 4.0, but scrapped it because it's hard to design for a moving target. And I'd rather not contribute to any anxiety on the React team by releasing libraries that are trying to commit to stuff that's not yet finalized and creating breakage where there shouldn't be any.

I'm guessing we'll get a way to enable Fiber in 16 and then can start playing with it and preparing for it. But no need to go crazy just yet :)",timdorr,ryanflorence
543,2016-11-13 23:15:30,"In order to satisfy a prerelease version, the major/minor/patch versions must match exactly. This change makes `react-redux` `yarn` friendly when used with `react@15.4.0-rc.4`. Without this change, you always fail a `yarn check`.

cc: @gaearon @bestander.

",zertosh,gaearon
543,2016-11-13 23:15:30,"In order to satisfy a prerelease version, the major/minor/patch versions must match exactly. This change makes `react-redux` `yarn` friendly when used with `react@15.4.0-rc.4`. Without this change, you always fail a `yarn check`.

cc: @gaearon @bestander.

",zertosh,bestander
541,2016-12-14 14:31:32,@timdorr Why is it closed? Should we stop our effort to release the typings inside react-redux repo?,bbenezech,timdorr
541,2017-03-17 16:25:58,"@theduke They are totally usable and include a lot of improvements over the DT ones.
If you add them to your app, simply nest them like this:

and remove the @types/react-redux package.

It may change a bit before release, but unless you have thousands of connected components, this should not be of concern.

@maclockard lack of time, sadly. I do not use this part of the API, I have no time to investigate atm.
Any help is welcome.",bbenezech,types
534,2016-10-26 17:07:29,"I am seeing the following error in the Chrome dev tools:



The error happens when I `@connect` a component that contains another connected component somewhere deeply in the tree. The error is on the nested component, not the parent component. I have tried boiling this down to a minimally reproducible case, but I am having trouble coming up with one. When I remove the `@connect` from my top-level component, the error goes away. I haven't noticed any functional problems.

Any suggestions on creating a reproducible case?

FYI, the following case does **not** produce the error in the console:


",chrisvasz,connect
525,2016-10-19 17:26:35,"Hmm.  Pinging @gaearon and @timdorr for thoughts...
",markerikson,gaearon
525,2016-10-19 17:26:35,"Hmm.  Pinging @gaearon and @timdorr for thoughts...
",markerikson,timdorr
525,2016-10-24 16:06:32,"@johnnycopperstone From what I gather from facebook/react#955, there are (at least) 2 scenarios in which this bug manifests itself, one being not updating the input's value prop soon enough (which is what I think is happening with react-redux v5) and one related to updating the prop with a value different than what's in the textbox, typically because of data altering (input masking or whitespace stripping, for example). Are you doing anything like that? 
",jimbolla,johnnycopperstone
523,2016-10-17 20:13:48,"I have a very similar use case to https://github.com/reactjs/react-redux/pull/488

I've reused @bsideup's code as-is, with the same test. We've started moving to v5 in production, hoping to see this soon in there!
",neeharv,bsideup
523,2017-02-18 08:19:27,@timdorr @jimbolla I've cleaned up the test and memoized the response of the factory. Also updated API docs. Do let me know if there is anything else you'd like me to do. Thanks!,neeharv,jimbolla
517,2016-10-14 02:01:37,"Looks good to me. Second opinion, @markerikson or @timdorr? 
",jimbolla,timdorr
517,2016-10-14 02:01:37,"Looks good to me. Second opinion, @markerikson or @timdorr? 
",jimbolla,markerikson
507,2016-09-28 16:59:52,"There was some [good discussion](https://twitter.com/ryanflorence/status/779320581678174208) on Twitter (between @gaearon, @markerikson, @timdorr, @mjackson, @ryanflorence, et al.) about `connect`'s component implementing `shouldComponentUpdate`.

If I understand correctly, the main issue being that any component wrapped in `connect` then blocks updates related to context changes, and this has an adverse impact on libraries that pass data via context that need to trigger rerenders (such as React Router's Link component.)

The changes in the `next` branch of React Redux make its implementation of `shouldComponentUpdate` much less necessary, mainly because now `setState` is no longer called as a response to every store state change, but only if the final merged props have changed. So now when `shouldComponentUpdate` is called as a result of calling `setState`, it's always going to return true anyways. (The call to setState could probably be replaced with forceUpdate and would work exactly the same.)

In the case of `shouldComponentUpdate` being called after receiving new props from parent, it's effectively just acting like `PureComponent`. That responsibility can be given to the components being wrapped, which would have better knowledge about if/how they should implement `shouldComponentUpdate`. I personally would use recompose and do something like:



An alternative to removing connect's `shouldComponentUpdate` completely would be to make it an another `option` argument, and decide whether it should be opt-in or opt-out.
",jimbolla,gaearon
507,2016-09-28 16:59:52,"There was some [good discussion](https://twitter.com/ryanflorence/status/779320581678174208) on Twitter (between @gaearon, @markerikson, @timdorr, @mjackson, @ryanflorence, et al.) about `connect`'s component implementing `shouldComponentUpdate`.

If I understand correctly, the main issue being that any component wrapped in `connect` then blocks updates related to context changes, and this has an adverse impact on libraries that pass data via context that need to trigger rerenders (such as React Router's Link component.)

The changes in the `next` branch of React Redux make its implementation of `shouldComponentUpdate` much less necessary, mainly because now `setState` is no longer called as a response to every store state change, but only if the final merged props have changed. So now when `shouldComponentUpdate` is called as a result of calling `setState`, it's always going to return true anyways. (The call to setState could probably be replaced with forceUpdate and would work exactly the same.)

In the case of `shouldComponentUpdate` being called after receiving new props from parent, it's effectively just acting like `PureComponent`. That responsibility can be given to the components being wrapped, which would have better knowledge about if/how they should implement `shouldComponentUpdate`. I personally would use recompose and do something like:



An alternative to removing connect's `shouldComponentUpdate` completely would be to make it an another `option` argument, and decide whether it should be opt-in or opt-out.
",jimbolla,ryanflorence
507,2016-09-28 16:59:52,"There was some [good discussion](https://twitter.com/ryanflorence/status/779320581678174208) on Twitter (between @gaearon, @markerikson, @timdorr, @mjackson, @ryanflorence, et al.) about `connect`'s component implementing `shouldComponentUpdate`.

If I understand correctly, the main issue being that any component wrapped in `connect` then blocks updates related to context changes, and this has an adverse impact on libraries that pass data via context that need to trigger rerenders (such as React Router's Link component.)

The changes in the `next` branch of React Redux make its implementation of `shouldComponentUpdate` much less necessary, mainly because now `setState` is no longer called as a response to every store state change, but only if the final merged props have changed. So now when `shouldComponentUpdate` is called as a result of calling `setState`, it's always going to return true anyways. (The call to setState could probably be replaced with forceUpdate and would work exactly the same.)

In the case of `shouldComponentUpdate` being called after receiving new props from parent, it's effectively just acting like `PureComponent`. That responsibility can be given to the components being wrapped, which would have better knowledge about if/how they should implement `shouldComponentUpdate`. I personally would use recompose and do something like:



An alternative to removing connect's `shouldComponentUpdate` completely would be to make it an another `option` argument, and decide whether it should be opt-in or opt-out.
",jimbolla,mjackson
507,2016-09-28 16:59:52,"There was some [good discussion](https://twitter.com/ryanflorence/status/779320581678174208) on Twitter (between @gaearon, @markerikson, @timdorr, @mjackson, @ryanflorence, et al.) about `connect`'s component implementing `shouldComponentUpdate`.

If I understand correctly, the main issue being that any component wrapped in `connect` then blocks updates related to context changes, and this has an adverse impact on libraries that pass data via context that need to trigger rerenders (such as React Router's Link component.)

The changes in the `next` branch of React Redux make its implementation of `shouldComponentUpdate` much less necessary, mainly because now `setState` is no longer called as a response to every store state change, but only if the final merged props have changed. So now when `shouldComponentUpdate` is called as a result of calling `setState`, it's always going to return true anyways. (The call to setState could probably be replaced with forceUpdate and would work exactly the same.)

In the case of `shouldComponentUpdate` being called after receiving new props from parent, it's effectively just acting like `PureComponent`. That responsibility can be given to the components being wrapped, which would have better knowledge about if/how they should implement `shouldComponentUpdate`. I personally would use recompose and do something like:



An alternative to removing connect's `shouldComponentUpdate` completely would be to make it an another `option` argument, and decide whether it should be opt-in or opt-out.
",jimbolla,timdorr
507,2016-09-28 16:59:52,"There was some [good discussion](https://twitter.com/ryanflorence/status/779320581678174208) on Twitter (between @gaearon, @markerikson, @timdorr, @mjackson, @ryanflorence, et al.) about `connect`'s component implementing `shouldComponentUpdate`.

If I understand correctly, the main issue being that any component wrapped in `connect` then blocks updates related to context changes, and this has an adverse impact on libraries that pass data via context that need to trigger rerenders (such as React Router's Link component.)

The changes in the `next` branch of React Redux make its implementation of `shouldComponentUpdate` much less necessary, mainly because now `setState` is no longer called as a response to every store state change, but only if the final merged props have changed. So now when `shouldComponentUpdate` is called as a result of calling `setState`, it's always going to return true anyways. (The call to setState could probably be replaced with forceUpdate and would work exactly the same.)

In the case of `shouldComponentUpdate` being called after receiving new props from parent, it's effectively just acting like `PureComponent`. That responsibility can be given to the components being wrapped, which would have better knowledge about if/how they should implement `shouldComponentUpdate`. I personally would use recompose and do something like:



An alternative to removing connect's `shouldComponentUpdate` completely would be to make it an another `option` argument, and decide whether it should be opt-in or opt-out.
",jimbolla,markerikson
505,2016-09-27 14:55:16,"I've tried it with our application locally and it did not seem to impact memory utilization (it still seemed to be using as much memory as master).  Even though the changes in the @next branch are relatively concise, I found it hard to track through the code to see if it was preserving stale state references.  I'd imagine you'd be the expert on that.

That JSFiddle is just a copy of another react-redux example I found and I am not an expert on those various CDN links, do you know how I'd replace the CDN links to react-redux@next?
",jvanderberg,next
505,2016-09-27 16:42:37,"Thanks, that seems to be much better: http://jsfiddle.net/3xwkg3p6/81/

I revisited our app, and I think I maybe had a babel cache issue with node modules when I tried out @next.  I cleared out the babel cache, rebuilt and memory usage seems to be much improved.

I guess just consider this a verification that @next really is a huge improvement.
",jvanderberg,next
496,2016-09-23 13:02:26,"My ownProps is an object containing objects. connect looks something like this: 



Props received:



Also its worth mentioning that a grand parent of this component also has a @Connect on it. 
",Daniel-Baranowski-BJSS,Connect
490,2016-09-17 04:36:10,"@markerikson Hey Mark, thanks for looking over react-redux-blackbox for me. I took a look at the new v5 react-redux, learned a lot about how to do perf testing, and the thought process that goes into accepting a major rewrite on a plugin.

Anyways, before v5 is official rolled out, I thought I would add these minor changes to improve v4 performance (Things that I picked up on while writing blackbox). Actually, if I'm not mistaken, the only real performance boost that v5 delivers is nullified with these changes. The big one is adding the ShouldComponentUpdate component, which stops rerendering if the computed props and own props are the same as their previous versions.
",l2silver,markerikson
490,2016-09-17 04:40:25,"Hmm.  Given the path we're on towards v5, I'm not sure there's much point in changing anything further with v4.

Also, how specifically does this improve perf?  Do you have some benchmarks and comparisons you can provide?  How does this compare with v5?

Tagging @jimbolla and @timdorr .
",markerikson,timdorr
490,2016-09-17 04:40:25,"Hmm.  Given the path we're on towards v5, I'm not sure there's much point in changing anything further with v4.

Also, how specifically does this improve perf?  Do you have some benchmarks and comparisons you can provide?  How does this compare with v5?

Tagging @jimbolla and @timdorr .
",markerikson,jimbolla
473,2016-08-27 14:29:33,"Starting a list of things related getting v5 out the door.
- [x] Unhide new features - currently they are hidden so that nobody starts using them, just in case we roll this back. I'll make a PR (#474) that will unhide them that can be merged in once we're confident that these changes will go live.
- [x] Create release notes - needs to describe: still API compatible, synopsis of internal architectural changes, perf changes, bugs fixed, new features added
- [x] Review/revise [release notes](https://github.com/reactjs/react-redux/issues/473#issuecomment-242927656) @timdorr toughts?
- [x] Write documentation for new features. Need to adequately describe `connectAdvanced`, as well as new options passable to `connect`. PR #480
- [x] Review/revise new docs. @timdorr @markerikson toughts?
- [x] Fix controlled input issues #525
- [x] Release another beta with the new features exposed. Add beta to the github Releases page.
### Nice to Haves:
- Refactor tests? - now that `connect` is split into to conceptual pieces: `connectAdvanced` for store subscription and component lifecycle stuff vs connect's selector functions, many of the tests could be refactored to deal with just one or the other. This would be nice because would split the 2000+ line spec file in two, making it a little easier to work with. Also add new tests for some of the new `connect` options. (I personally need to learn how to run the new test coverage tools so I can see what's not covered.)
",jimbolla,timdorr
473,2016-08-27 14:29:33,"Starting a list of things related getting v5 out the door.
- [x] Unhide new features - currently they are hidden so that nobody starts using them, just in case we roll this back. I'll make a PR (#474) that will unhide them that can be merged in once we're confident that these changes will go live.
- [x] Create release notes - needs to describe: still API compatible, synopsis of internal architectural changes, perf changes, bugs fixed, new features added
- [x] Review/revise [release notes](https://github.com/reactjs/react-redux/issues/473#issuecomment-242927656) @timdorr toughts?
- [x] Write documentation for new features. Need to adequately describe `connectAdvanced`, as well as new options passable to `connect`. PR #480
- [x] Review/revise new docs. @timdorr @markerikson toughts?
- [x] Fix controlled input issues #525
- [x] Release another beta with the new features exposed. Add beta to the github Releases page.
### Nice to Haves:
- Refactor tests? - now that `connect` is split into to conceptual pieces: `connectAdvanced` for store subscription and component lifecycle stuff vs connect's selector functions, many of the tests could be refactored to deal with just one or the other. This would be nice because would split the 2000+ line spec file in two, making it a little easier to work with. Also add new tests for some of the new `connect` options. (I personally need to learn how to run the new test coverage tools so I can see what's not covered.)
",jimbolla,markerikson
471,2016-08-22 20:59:53,"Are you attempting to access the `<Provider>` context directly? You should be `@connect`ing your components and providing your action creators as bound functions to `dispatch`, which you can then access via props.
",timdorr,connect
471,2016-08-22 21:04:34,"Yes, but that's removing a big benefit of having this library. You should use `@connect` instead like so: https://github.com/reactjs/react-redux/blob/master/docs/api.md#inject-todos-and-all-action-creators-addtodo-completetodo--as-actions
",timdorr,connect
457,2016-08-20 10:06:10,"Don't hesitate to send a PR with minimal repro setup for the branch I created @vhmh
",Restuta,vhmh
448,2016-07-31 01:55:49,"Yeah, `mapState` and `mapDispatch` don't support that scenario directly.  That's actually part of what prompted @jimbolla to start implementing a new approach to `connect()`.  

There are two ways you could do something like that right now:
1. Select the data using `mapState`, and have the component call `this.props.doStateDependentAction(this.props.someValueFromState)`
2. Select the data using `mapState`, and use the third argument to connect (`mergeProps` ) to define the action creator.  Note that this would probably involve re-defining the action creator function every time the state changes, which could be a performance issue.
",markerikson,jimbolla
435,2016-07-14 18:24:14,"Suppose the following simple and common example:



So `<Foobar/>` needs `name`, `age` and `dispatch` whereas `age` and `dispatch` are provided via the `@connect` HOC. But when I render the component as one would exepect with



I get warnings from React, saying that `Connect(Foobar)` is missing the required props `age` and `dispatch`, even though `<Foobar/>` itself never get rendered without these props (so from `<Foobar/>`'s point of view everything is fine). To work around this I have two bad options:
1. Make `age` and `dispatch` non required or
2. Render `<Foobar/>` resp. `<Connect(Foobar)/>` with dummy values for `age` and `dispatch`.

The warning is strange by itself anyway, because looking at the code I see



And I also checked that the `.propTypes` of the returned HOC only contain the `store` props. Still I keep getting this warnings.

Btw, I am using the following versions:
- react 15.2.1
- react-redux 4.4.5

Thanks for your help.
",choffmeister,connect
435,2016-07-14 18:33:14,"Yeah, as soon as I finished writing this issue, I noticed the root of the issue. The ES7 class properties are not applied to `<Foobar/>` and then `@connect` gets applied to that, but the other way around, again overriding the `propTypes` of the HOC...
",choffmeister,connect
435,2016-07-14 18:34:52,"So I just have to apply `@connect` afterwards. This might get better, when there is a non-legacy version of decorators for babel... 😢 

Will close this issue since it is not related to this project in any way.
",choffmeister,connect
433,2016-10-20 15:52:08,"@codeandcats suggested I fork and re-request these additions. Before I start, I wonder what are the tasks that need to be performed? I don't mind opening a PR but I'd rather not just copy the code without adding anything myself, unless we are content with the state of this PR before it was closed.  
@DaanDeMeyer raised some questions which I'd like to get answered before I begin.
- @timdorr Do the Typescript definitions have to take into account that the library can be used as an UMD module? Also, can I make use of the Typescript 2.0 features for the definitions?
- The rest of the definitions seem to be correct. Anything missing? Probably needs to be converted to external module though.
- Do we have any typescript files that can be used to test this with typescript-definition-tester?
",Zalastax,codeandcats
433,2016-11-07 13:14:02,"Since MS is pushing the whole @types namespacing on npm, I don't think we need to add them here. They exist on DT and that should be good enough. 
",timdorr,types
433,2016-11-07 16:25:25,"> Since MS is pushing the whole @types namespacing on npm, I don't think we need to add them here

It is not true. @types repos is a fallback for libs that doesn't maintain typings in house. It also introduces compatibility issues.
In house typings still prefered way, because lives near source code and shares the same version.
Of course there is a cost for it too:
- increased maintainance load
- it affects semver: breaking change in typings would require major bump in whole package

But again it is much more convinient for consumer to use lib with typings included:
- no additional deps to install and maintain
- typings always describe code that you use since it located at the same package
- it usually have higher quality than 3rd parties
",Guria,types
428,2016-07-06 11:50:26,"Still makes sense to me to fix the current implementation in the short-term even if it ends up getting replaced in a month or so when the next major is released. Plus, the test introduced in #429 is a worthwhile addition to make sure #416 or any future work doesn't create a regression. I guess it's up to @gaearon as to whether #429 is worth merging or not...
",andydavies92,gaearon
428,2016-07-06 23:35:07,"The root of the problem actually lies in `this.haveOwnPropsChanged` not being set correctly.



From [https://github.com/reactjs/react-redux/blob/master/src/components/connect.js#L215](https://github.com/reactjs/react-redux/blob/master/src/components/connect.js#L215)

In this scenario, we want to update the component using a dispatch to the store. This is a state change, hence `componentWillReceiveProps` is not called. This does not set the `haveOwnPropsChanged` field to `true` (which it should for an impure component), so in `render()` the optimised route is taken.

#429 fixes the current problem, but does not fix the root of it, which is that the impure component needs to update on store change (which is a state change), so `componentWillUpdate` is required together with `componentWillReceiveProps`. We can test this by using

`@connect(() => ({}), null, () => {invocationCount++; return {}}, { pure: false })`

and seeing that invocationCount does not increase with the current fix.

However, since `componentWillUpdate` is called after `shouldComponentUpdate` as opposed to `componentWillReceiveProps`, and that hot-loading overrides `componentWillUpdate` in the prototype, there might be a better alternative solution.

#416 should ultimately fix this as it uses `shouldComponentUpdate` to do all the checks.

**Edit**: Also worth to mention, is this the expected behaviour? The component's props from store or from parent has not changed, so even if it was impure should a re-render be called?
",gelguy,connect
416,2016-06-24 03:53:41,"# Update: Released as alpha!

[See below](https://github.com/reactjs/react-redux/pull/416#issuecomment-239678590). You can now install this as `react-redux@next`:



Please test it out!
## TL;DR

Rewrote `connect`, same basic API plus advanced options/API, all tests pass, roughly 8x faster, more modular/extensible design
# Overview

I rewrote `connect` into modular pieces because I wanted to be able to extend with custom behavior in my own projects. Now connect is a facade around `connectAdvanced`, by passing it a compatible `selectorFactory` function.

I also was able to greatly improve performance by changing the store subscriptions to execute top-down to work with React's natural flow of updates; component instances lower in the tree always get updated after those above them, avoiding unnecessary re-renders.
# Design/Architecture

I split the original `connect` into many functions+files to compartmentalize concepts for better readability and extensibility. The important pieces:
- components/
  - `connectAdvanced.js`: the HOC that connects to the store and determines when to re-render
  - `Provider.js`: (hasn't changed)
- selectors/
  - `connect.js`: composes the other functions into a fully-compatible API, by creating a selectorFactory and options object to pass to `connectAdvanced`.
    that performs memoiztion and detects if the first run returns another function, indicating a factory
  - `mapDispatchToProps.js`: used to create a selector factory from the `mapDispatchToProps` parameter, to be passed to `selectorFactory.js` as `initMapDispatchToProps`. Detects whether `mapDispatchToProps` is missing, an object, or a function
  - `mapStateToProps.js`: used to create a selector factory from the `mapStateToProps` parameter, to be passed to `selectorFactory.js` as `initMapStateToProps`. Detects whether `mapStateToProps` is missing or a function
  - `mergeProps.js`: used to create a selector factory from the `mergeProps` parameter, to be passed to `selectorFactory.js` as `initMergeProps`. Detects whether `mergeProps` is missing or a function.
- `selectorFactory.js`: given `dispatch`, `pure`, `initMapStateToProps`, `initMapDispatchToProps`, and `initMergeProps`, creates a `connectAdvanced`-compatible selector
- `wrapMapToProps.js`: helper functions for wrapping values of `mapStateToProps` and `mapDispatchToProps` in compatible selector factories
  - 
- utils/
  - `Subscription.js`: encapsulates the hierachial subscription concept. used by `connectAdvanced.js` to pass a parent's store Subscription to its children via context
  - `verifyPlainObject.js`: used to show a warning if `mapStateToProps`, `mapDispatchToProps`, or `mergeProps` returns something other than a plain object
## file graph

![graph](https://cloud.githubusercontent.com/assets/1851364/16901604/b1426f0c-4c16-11e6-8895-5234885f48b0.png)



The modular structure of all the functions in `connect/` should allow greater reuse for anyone that wants to create their own `connect` variant. For example, one could create a variant that handles when `mapStateToProps` is an object by using reselect's createStructuredSelector:
### customConnect.js:


### ExampleComponent.js



And for scenarios where connect's three-function API is too constrictive, one can directly call, or build a wrapper around, `connectAdvanced` where they have full control over turning `state` + `props` + `dispatch` into a props object.
# Performance

I'm using a [modified version of react-redux-perf](https://github.com/jimbolla/react-redux-perf) to performance test+profile the changes. It's configured to try to fire up to 200 actions per second (but becomes CPU bound), with 301 connected components. There are 2 scenarios being tested:
- NB: a parent component with 300 child components, with no other React components between them.
- WB: the same setup as NB but there's a ""Blocker"" React component between the parent and children that always returns false for `shouldComponentUpdate`.

I measured the milliseconds needed to render a frame using the [stats.js](https://github.com/mrdoob/stats.js/) used by react-redux-perf:

| MS: avg (min-max) | current NB | rewrite NB | current WB | rewrite WB |
| --- | --- | --- | --- | --- |
| Chrome | 170 (159-223) | 20 (17-55) | 170 (167-231) | 17 (15-59) |
| Firefox | 370 (331-567) | 20 (16-51) | 430 (371-606) | 19 (15-60) |
| IE11 | 270 (127-301) | 40 (36-128) | 300 (129-323) | 33 (30-124) |
| Edge | 240 (220-371) | 37 (32-102) | 260 (97-318) | 28 (24-100) |

On the conservitive end, the rewrite is about 8x faster under these circumstances, with Firefox even doubling that improvement. Much of the perf gains are attributed to avoiding calls to `setState()` after a store update unless a re-render is necessary.

In order to make that work with nested connected components, store subscriptions were changed from ""sideways"" to top-down; parent components always update before their child components. Connected components detected whether they are nested by looking for an object of type `Subscription` in the React `context` with the key `storeSubscription`. This allows `Subscription` objects build into a composite pattern.

After that I've used Chrome and Firefox's profilers to watch for functions that could be optimized. At this point, the most expensive method is `shallowEqual`, accounting for 4% and 1.5% CPU in Chrome and Firefox, respectively. 
# connectAdvanced(selectorFactory, options) API

In addition to the changed related to performance, the other key change is an additional API for `connectAdvanced()`. `connectAdvanced` is now the base for `connect` but is less opinionated about how to combine `state`, `props`, and `dispatch`. It makes no assumptions about defaults or intermediate memoization of results, and leaves those concerns up to the caller. It does memoize the inbound and outbound props objects. A full signature for `connectAdvanced` with its `selectorFactory` would look like:



A simple usage may look like:



An example using `reselect` to create a bound actionCreator with a prop partially bound:



An example doing custom memoization with actionCreator with a prop partially bound:



Note these are meant as examples and not necessarily ""best practices.""
# Pros/cons

I understand there is great risk to accepting such drastic changes, that would have to be justified with significant benefits. I'll reiterate the two main benefits I believe these changes offer:
1. Performance: There's potentially huge perf gains in situations where the number of connected components is high, stemming from conceptual changes to subscriptions so they go with the natural flow of events in React vs across them, as well as method profiling+optimizing using Chrome/FF.
2. Extensibility/Maintainability: By splitting the responibilities of connect into many smaller functions, it should be easier both for react-redux contributors to work with the codebase and end users to extend its functionality though the additional APIs. If users can add their desired features in their own projects, that will reduce the number of feature requests to the core project.

Despite passing all the automated tests as well as week of manual testing, there is risk of impacting users dependent on implicit behavior, or that performance is worse in some unexpected circumstances. To minimize risk of impacting end users and downstream library authors, I think it would be wise to pull these changes into a ""next"" branch and first release an alpha package. This would give early adopters a chance to test it and provide feedback
# Thanks

I'd like to thank the other github users who have so far offered feedback on these changes in #407, especially @markerikson who has gone above and beyond.
",jimbolla,markerikson
416,2016-06-24 18:51:44,"Can I ask you to manually test Redux examples in the repo as well as some popular apps?
@markerikson might suggest a few.
",gaearon,markerikson
416,2016-07-05 16:12:50,"@jimbolla , @reactjs/redux : if no one else has any comments in the next few hours, I'll do as Dan asked and ping him to set up a beta.
",markerikson,reactjs
416,2016-07-05 18:14:35,"I think tagging it with `@rewrite` or similar is a good idea. I don't intend to make any other changes right now besides add more comments unless anyone has any feedback on things that could be changed.
",jimbolla,rewrite
416,2016-07-05 18:31:36,"There are only two hard things in computer science: cache invalidation and naming things. (There are only two hard problems in distributed systems: 2. Exactly-once delivery 1. Guaranteed order of messages 2. Exactly-once delivery)

Let's just call it `react-redux@next` then. No implication of the contents being good or bad, just something we might be trying next. I think most people are used to `*@next` dist-tags anyways.
",timdorr,next
416,2016-07-05 18:38:27,"@next is good :)
On Tue, Jul 5, 2016 at 11:31 AM Tim Dorr notifications@github.com wrote:

> There are only two hard things in computer science: cache invalidation and
> naming things. (There are only two hard problems in distributed systems: 2.
> Exactly-once delivery 1. Guaranteed order of messages 2. Exactly-once
> delivery)
> 
> Let's just call it react-redux@next then. No implication of the contents
> being good or bad, just something we might be trying next. I think most
> people are used to *@next dist-tags anyways.
> 
> —
> You are receiving this because you were mentioned.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/reactjs/react-redux/pull/416#issuecomment-230562851,
> or mute the thread
> https://github.com/notifications/unsubscribe/ACly0fWx1fNbbexYE7PMqmGxkfComxa8ks5qSqMMgaJpZM4I9cav
> .
",gnoff,next
412,2016-08-09 19:12:06,"Higher order Component

check out https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.b5clq7pea
",gnoff,dan
407,2016-06-17 20:36:26,"@reactjs/redux, @phoenixmatrix, @Aweary: would be particularly interested in other thoughts and opinions on this, especially from people who have actually been hands-on with `connect()`.

I wrote up my initial thoughts in Reactiflux (chat transcript at https://gist.github.com/markerikson/561ce2d8830a34c35701ea77564c7073).  Way TL;DR: 

> at this point I would probably be against unless there's some specific demonstrated improvements in speed, maintainability, or use cases. And, given that I'm just ""an opinion"", I'd really like to hear from others who have actually worked on the code and know what they're doing with it (Dan in particular)

But: 

> full API compat / all tests passing is certainly a good start
",markerikson,Aweary
407,2016-06-17 20:36:26,"@reactjs/redux, @phoenixmatrix, @Aweary: would be particularly interested in other thoughts and opinions on this, especially from people who have actually been hands-on with `connect()`.

I wrote up my initial thoughts in Reactiflux (chat transcript at https://gist.github.com/markerikson/561ce2d8830a34c35701ea77564c7073).  Way TL;DR: 

> at this point I would probably be against unless there's some specific demonstrated improvements in speed, maintainability, or use cases. And, given that I'm just ""an opinion"", I'd really like to hear from others who have actually worked on the code and know what they're doing with it (Dan in particular)

But: 

> full API compat / all tests passing is certainly a good start
",markerikson,reactjs
407,2016-06-17 20:36:26,"@reactjs/redux, @phoenixmatrix, @Aweary: would be particularly interested in other thoughts and opinions on this, especially from people who have actually been hands-on with `connect()`.

I wrote up my initial thoughts in Reactiflux (chat transcript at https://gist.github.com/markerikson/561ce2d8830a34c35701ea77564c7073).  Way TL;DR: 

> at this point I would probably be against unless there's some specific demonstrated improvements in speed, maintainability, or use cases. And, given that I'm just ""an opinion"", I'd really like to hear from others who have actually worked on the code and know what they're doing with it (Dan in particular)

But: 

> full API compat / all tests passing is certainly a good start
",markerikson,phoenixmatrix
407,2016-06-18 00:53:08,"@Aweary I've been working on adding comments to the code to explain as much as possible, but I can provide an executive overview:
- The API for `connect()` is exactly the same, but its internals are completely different, ultimately delegating to `connectAdvanced()`. 
- The API for `connectAdvanced()` is `connectAdvanced(selectorFactory, {connectOptions})`. `selectorFactory` is a func with the signature `({factoryOptions}) => (state, props, dispatch) => {finalProps})`
- While Reselect is utilized internally, there's no requirement for a user to use it as their memoization engine for the functions they pass to either `connect` or `connectAdvanced`, nor is memoization even a requirement.
- Exposing an advanced API will allow end users to customize the connect functionality by building their own wrappers. For example, the whole reason I started this was so that I could define a wrapper that let me define my mapping using reselect's `createStructuredSelector`. Another example would be #323. 

Looking at a diff probably won't be super useful, since it's a total rewrite. It's probably better to look at the new files as a whole.

@timdorr Can you elaborate on why you think this implementation would fall through more often? Unless I'm missing something, I expect render to NEVER execute unnecessarily.
",jimbolla,Aweary
407,2016-06-21 20:46:47,"@Aweary The subscriptions aren't ""sideways"" but they will _always_ fire, independent of any optimizations. If the parent component doesn't rerender or an intermediate non-connected component doesn't rerender, the child components still get to do their thing. The key parts are [Subscription.js](https://github.com/jimbolla/react-redux/blob/connect-rewrite/src/utils/Subscription.js) and [these parts of connectAdvanced.js](https://github.com/jimbolla/react-redux/blob/connect-rewrite/src/components/connectAdvanced.js#L154) 



It puts Subscription in the context to be the ""wormhole"" like Dan mentioned. Subscriptions build into a tree.
",jimbolla,Aweary
403,2016-06-09 00:52:50,"Hmm.  A couple thoughts:
- I'm not really following exactly why that ""double-connect"" is necessary, as such.  
  I get that you want state available in `mapDispatch`, and technically `mergeProps` _is_ the escape hatch that allow for that, but why is the ""double-connect"" needed?  Feels like there's got to be some other way to do what you want.
- Is there any reason why the component can't call the action creator with the necessary props, rather than having those pre-bound?
- Seems kinda like what you really need is a Higher-Order Component that is specialized for handling auth stuff somehow.  You might want to watch @acdlite's talk from React Europe: https://youtu.be/zD_judE-bXk.  You're _sorta_ doing that now, but I think it'd be cleaner if you separate that part out.
",markerikson,acdlite
396,2016-05-30 15:14:06,"Thanks @gaearon!

I decided NOT TO use the approach of (un)subscribe anyway since it also makes the App slow.

I'll explain it in case some other people read this issue in the future:

I worked a bit more on the idea. I passed a prop from the parent though intermediate components to the final subscribed list Items: `pauseSubscriptions = true/false`. Then the list items unsubscribed and resubscribed when it's parent Page was hidden or shown.

The problem is that passing that prop triggers a chain of renders which would not have happened without it. I guess there are ways to directly (un)subscribe the children items not passing props but I have the feeling I was over-engineering the problem.

I'll try different approaches to avoid having thousands of connected components. Maybe connecting only from the parent and passing props to the children. This will make the program a bit verbose (lots of props-passing) but may do the trick!

Thanks again @gaeron for such great tools and support!
",landabaso,gaeron
395,2016-06-15 17:05:25,"Am I the only one that thinks that the `Connect` wrapper should just leverage the same `displayName` as the original wrapped component?

> @ianobermiller (FormidableLabs/radium#271 on [Jul 17, 2015](https://github.com/FormidableLabs/radium/issues/271#issuecomment-122227566))
> Can you imagine if every decorator did the same thing? `Radium(Relay(autobound(Button)))` 👎 
",TigerC10,ianobermiller
393,2016-05-26 19:01:19,"Thanks @gearon. How would that work with a static method on the parent container, though? static renderNavigationBar() still wouldn't get picked up with the technique you linked to:


",braco,gearon
389,2016-05-25 00:35:32,"@gaearon I tried to support the case when `mapDispatchToProps` is an object, but I can't seem to find a way.

So far my entire type definition heavily relies on the magic type `$Diff<A, B>`. It's something flow uses internally to subtract DefaultProps from Props to get the external requirements.

It turns out, that B has to be a strict subset of A for it to work.
So `$Diff<{name: string}, {name: any}>` doesn't work.

But to support `mapDispatchToProps` is an object, I can't just subtract the value returned by `mapDispatchToProps` from props. I need to map into functions somehow, which I can't find any way to do.

I can still fix the type if you're willing to merge this. It's a little more wordy to write out the function version but I think people who use Flow will trade it for the improved type-safety.
",nmn,gaearon
373,2016-05-04 09:07:51,"@gaearon did you have time to check my PR?

I've tried to run benchmarks of @mweststrate . Not sure to have done them correctly, but I actually see increased performances :) It's not huge, and maybe I did something wrong during the benchmark.



Maybe you can run them yourself and confirm?

I've published the benchmark app [before](http://slorber.github.io/connect-refactor/before.html) and [after](http://slorber.github.io/connect-refactor/after.html) so that anyone can take a look
",slorber,gaearon
373,2016-05-04 09:07:51,"@gaearon did you have time to check my PR?

I've tried to run benchmarks of @mweststrate . Not sure to have done them correctly, but I actually see increased performances :) It's not huge, and maybe I did something wrong during the benchmark.



Maybe you can run them yourself and confirm?

I've published the benchmark app [before](http://slorber.github.io/connect-refactor/before.html) and [after](http://slorber.github.io/connect-refactor/after.html) so that anyone can take a look
",slorber,mweststrate
373,2016-05-05 07:21:59,"thanks :)

I'm going on holiday 2 weeks until the 21 so you will have some time to check the code :)

I'm confident globally but not really about the `checkMergedEquals` attribute that @tgriesser added. Don't really understand the usecase as all my tests are passing without using that, but it has probably be done for a good reason so...
",slorber,tgriesser
369,2016-04-25 04:19:42,"I create redux store use the facebook immutable js. 
so I get state in my component like this:

`@connect(state => { rules : state.get('rules').toJS() })`

because connect only receive the plain object, so I need use `toJS` to pass object to connect.

there is a problem , my `rules` is a array of object like `I.fromJS([{id: 1} , {id: 2}, {id, 3}])`

so every time `state.get('rules').toJS()` result is not equal. so when store change, this component always will rerender, because the `shouldComponentUpdate` in connect() only make a shallow equal. not a deep equal.

so how can I use the `Immutable.is` for `shouldComponentUpdate` in connect(), or other method to improve the performance with the array of object props equal problem?
",Yixi,connect
368,2016-05-01 01:51:22,"@gaearon it was quite hard and the code is not clean yet but I made all tests pass!

You can take a look at [#373]

At first I thought that I would never be able to make pass the last test related to the stale props when both parent/child are connected, because the transactionnal setState callback can be called multiple times in a single batch.

I had to use a trick like that:



@tgriesser I also succeeded make all the tests pass without using `checkMergedEquals`. Do you think there might be a missing test case?
",slorber,tgriesser
365,2016-04-22 20:19:50,"If I change `renderList(list)` in `Comment.js` to dispatch an action on click, I don’t get any log messages about re-renders:



Therefore, “any action” does not cause “all container components” to re-render, so it looks like there is no bug here.

When I run the app for the first time, I see this:



It looks correct to me: we first render the initial state, which is an empty screen, then we `REQUEST_POST_LIST` causes a re-render because there is a loading indicator now, and then `RECEIVE_POST_LIST` causes a re-render because the list is ready.

If I open a post’s comments, I see this:



The initial `@@Render CommentList for post: 4` is caused by the empty list appearing. It looks fine to me. The second `@@Render CommentList` also makes sense to me here: the comments are loaded so it’s time to render the actual list.

The one that doesn’t quite make sense to me is `REQUEST_COMMENT_LIST` causing `@@Render PostList. Requesting comments shouldn’t re-render the posts.

I dug into why this happens, and it seems like [returning a cached element in `render()`](https://github.com/reactjs/react-redux/blob/253ce8b3068d9d9bfe55f70a6f18a5fde313b326/src/components/connect.js#L324-L326) is not enough to prevent a re-render in some cases when there is an additional context between `<Provider>` and the `connect()`ed component [because of this check in `ReactReconciler`](https://github.com/facebook/react/blob/5ddfee8cfece399d686862f2ac2796b63eb78f00/src/renderers/shared/reconciler/ReactReconciler.js#L98).

I don’t fully understand in which cases this happens yet so I’ll file a separate issue for the future.
For now, you have two options to avoid this:

### Option 1

Remove `ownProps` from your `mapStateToProps` function in `Post.js`.
This will turn on the optimizations earlier, and that code path will be avoided altogether.



### Option 2

Add a custom `shouldComponentUpdate()` function to `Post.js` because React Redux could not optimize it in this particular case, and you need to do it manually.



I hope this helps!
",gaearon,Render
356,2016-04-17 17:42:07,"I'm trying to use redux with react-redux react-router-redux and redux-immutable and I get an error when the initial  `@@router/LOCATION_CHANGE` action is triggered:



My Root component looks as follows:



I have implemented a custom `routerReducer` to work with immutable, as explained in the react-router-redux docs:



This is my dev configureStore:



And my initial rendering:



I've been trying all evening multiple things but I have not been able to figure out what is the problem 😞 
",remojansen,router
355,2016-04-15 03:42:12,"Yep, that should work.  @GrumpyPants , if you have more concerns beyond that let us know, but yeah, simply rendering multiple providers with the same store reference should do exactly what you want.
",markerikson,GrumpyPants
355,2016-09-29 17:01:41,"@GrumpyPants Do you have a public repo that shows how you implemented rendering of multiple `<Provider>` components for a shared store? More specifically, is there any way you've found to do this while still creating container components via `{ connect }`? 

Feel free to email me at todd.groff@gmail.com as this is not so much a bug as a use case question like Mark stated.
",toddgroff,GrumpyPants
354,2016-04-14 15:20:48,"The new link here is wrong too, the repository simply doesn't exist anymore and we'll switch back to airbnb. See @gaearon's comment in #353 – thanks so much for notifying us of the issue and even submitting this PR though, we appreciate it a lot!
",mxstbr,gaearon
353,2016-04-14 11:54:55,"I _think_ the repo for that doesn't exist anymore, but maybe it got moved and I missed it – @mjackson any input here?
",mxstbr,mjackson
349,2016-04-13 00:50:59,"Hey @gaearon ,
Something I don't understand.
Why the function `e1` and `_.get` are treated differently? Is it also due to different identity of function, or something else?
",haohcraft,gaearon
348,2016-04-12 19:09:29,"cc @slorber, @ellbee, @tgriesser who might be interested in this
",gaearon,ellbee
348,2016-04-12 19:09:29,"cc @slorber, @ellbee, @tgriesser who might be interested in this
",gaearon,slorber
348,2016-04-12 19:09:29,"cc @slorber, @ellbee, @tgriesser who might be interested in this
",gaearon,tgriesser
329,2016-04-02 11:48:35,"It does not _change_ the existing name. It wraps your existing component with another component that manages the updates. Wrapping it with the component of the same name but a different implementation would be confusing. cc @lelandrichardson
",gaearon,lelandrichardson
329,2016-06-13 18:45:46,"I disagree, `WrappedComponent` is not a perfect solution.

> @ianobermiller (FormidableLabs/radium#271 on [Jul 17, 2015](https://github.com/FormidableLabs/radium/issues/271#issuecomment-122227566))
> Can you imagine if every decorator did the same thing? `Radium(Relay(autobound(Button)))` 👎 

Or are you suggesting that `react-redux` is the king of React standards and every HOC project out there should adopt the `WrappedComponent` standard?  What if other HOCs provided `InnerComponent` or `BaseComponent` as their standard method?  What we end up with is chaos.

> @gaearon
> Display name is meant for debug purposes and tooling like React DevTools. Why do you rely on it?

No matter how you slice it, the wrapped component appears to be a change in the display name to the consuming developer(s).  So I ask, why does `react-redux` modify `displayName` in the first place?  If it's something that is expected for people not to rely on, why does `react-redux` rely on changing the `displayName` at all?  If `displayName` is truly inconsequential - then the `react-redux` team should have no problem removing their reliance on the ""change"" of the `displayName`.
",TigerC10,ianobermiller
329,2016-06-13 18:49:34,"+1 for @tigerC10. 👍
",RBdevelop,tigerC10
323,2016-03-20 18:24:31,"cc @ellbee @faassen @erikras 
",slorber,ellbee
323,2016-03-20 18:24:31,"cc @ellbee @faassen @erikras 
",slorber,faassen
323,2016-03-20 18:24:31,"cc @ellbee @faassen @erikras 
",slorber,erikras
323,2016-04-25 09:28:21,"People did not comment here, so comments received on twitter are:

> @CyrilSilverman: the convenience gained is not worth the clarity lost.
> 
> @natenorberg: I like it. I actually keep accidentally writing it like that already
> 
> @sebas5384: I think the first choice is more easy to understand. Because you should code for other people
",slorber,CyrilSilverman
323,2016-04-25 09:28:21,"People did not comment here, so comments received on twitter are:

> @CyrilSilverman: the convenience gained is not worth the clarity lost.
> 
> @natenorberg: I like it. I actually keep accidentally writing it like that already
> 
> @sebas5384: I think the first choice is more easy to understand. Because you should code for other people
",slorber,sebas5384
323,2016-04-25 09:28:21,"People did not comment here, so comments received on twitter are:

> @CyrilSilverman: the convenience gained is not worth the clarity lost.
> 
> @natenorberg: I like it. I actually keep accidentally writing it like that already
> 
> @sebas5384: I think the first choice is more easy to understand. Because you should code for other people
",slorber,natenorberg
323,2016-10-04 09:19:02,"@jimbolla @gaearon @timdorr I suspect this will be doable in userland with `connectAdvanced` no?
",slorber,timdorr
323,2016-10-04 09:19:02,"@jimbolla @gaearon @timdorr I suspect this will be doable in userland with `connectAdvanced` no?
",slorber,jimbolla
322,2016-03-21 21:02:20,"Yes, Dan @gaearon,
This is the [repo](https://github.com/srlopez/rntest), and in the [src/pages/TestForm.js](https://github.com/srlopez/rntest/blob/master/src/pages/TetsForm.js) you can see:



Direct dispatching in point 1, does not reflect in screen (the field name remains empty), but delayed dispatching as in point 2, reflect the mutation in field URL (and in NAME  too if both lines of code are executed, without comment marks)

Talking about Redux, the 'scene' is connected in [App.js](https://github.com/srlopez/rntest/blob/master/src/App.js) lines 55-67



And the `App` is on lines 21-53 of the same file, as a typical `Navigator` component, so all the scenes are 'connected' and the connectComponent is the typical  react-redux '`connect`' function in [AppContainer.js](https://github.com/srlopez/rntest/blob/master/src/AppContainer.js), just few lines ...



There is no doubt, the component is '`connect'ed` and Redux is well working, the trace display all the actions are dispatched. 

To test the behavior we are talking about, you know, clone the repo, run it (you can run using `npm run nurse`), next on first screen, press 'Go to Form' and ... you pass throw the `componentWillMount()` above.

If you need some help, this Form is inspired by @kasprownik and his code in this [repo](https://github.com/kasprownik/react-forms-tutorial) write in ReactJS and well explained in this [http://x-team.com/2016/02/tutorial-forms-in-react-and-redux/](blog)
",srlopez,kasprownik
305,2016-03-01 16:27:27,"Clarify that when an object is given, its action creators are automatically wrapped into a dispatch call.

Only managed to figure it out after:
- @gaearon 's twitter response https://twitter.com/dan_abramov/status/696033039953092608
- checking line https://github.com/reactjs/react-redux/blob/v4.4.0/src/components/connect.js#L38
",grifotv,gaearon
294,2016-02-23 18:19:48,"I agree with what you are saying. @gaearon `react-css-modules` is invasive and @FredyC you are correct you _can_ go very far with vanilla css modules, but dasherized css class names i.e. `my-css-class-name` is a very common use case it supports. To me it felt like the lesser of two evils. I mean what if you want to include third party css? Was thinking about writing a postcss plugin that rewrites the class names to camel case to fix this the 'easy' way, but realized that React looks for dasherized class names when adding CSS transitions :/ . cc @gajus
",kristoferjoseph,gajus
292,2016-02-17 20:48:40,"Prompted by https://github.com/reactjs/redux/issues/1415, please read the discussion there. We currently subscribe in `componentDidMount` but it runs from children first. This has a potential of introducing inconsistencies when a child receives some update state earlier than its parent that passes a state-dependent prop to it.

Would subscribing the parents first fix the inconsistencies? Can we do that somehow (e.g. by passing subscribers up via context)?

Alternatively, can/should we wrap `dispatch` into `ReactDOM.unstable_batchedUpdates()` by default like Relay does?

cc @epeli @chandlerprall @tappleby @acdlite 
",gaearon,tappleby
292,2016-02-17 20:48:40,"Prompted by https://github.com/reactjs/redux/issues/1415, please read the discussion there. We currently subscribe in `componentDidMount` but it runs from children first. This has a potential of introducing inconsistencies when a child receives some update state earlier than its parent that passes a state-dependent prop to it.

Would subscribing the parents first fix the inconsistencies? Can we do that somehow (e.g. by passing subscribers up via context)?

Alternatively, can/should we wrap `dispatch` into `ReactDOM.unstable_batchedUpdates()` by default like Relay does?

cc @epeli @chandlerprall @tappleby @acdlite 
",gaearon,epeli
292,2016-02-17 20:48:40,"Prompted by https://github.com/reactjs/redux/issues/1415, please read the discussion there. We currently subscribe in `componentDidMount` but it runs from children first. This has a potential of introducing inconsistencies when a child receives some update state earlier than its parent that passes a state-dependent prop to it.

Would subscribing the parents first fix the inconsistencies? Can we do that somehow (e.g. by passing subscribers up via context)?

Alternatively, can/should we wrap `dispatch` into `ReactDOM.unstable_batchedUpdates()` by default like Relay does?

cc @epeli @chandlerprall @tappleby @acdlite 
",gaearon,chandlerprall
292,2016-02-17 20:48:40,"Prompted by https://github.com/reactjs/redux/issues/1415, please read the discussion there. We currently subscribe in `componentDidMount` but it runs from children first. This has a potential of introducing inconsistencies when a child receives some update state earlier than its parent that passes a state-dependent prop to it.

Would subscribing the parents first fix the inconsistencies? Can we do that somehow (e.g. by passing subscribers up via context)?

Alternatively, can/should we wrap `dispatch` into `ReactDOM.unstable_batchedUpdates()` by default like Relay does?

cc @epeli @chandlerprall @tappleby @acdlite 
",gaearon,acdlite
292,2016-02-18 15:39:17,"Cc @skevy who worked to get the web/native compatibility implemented in Relay. 
",josephsavona,skevy
290,2016-02-16 16:05:25,"The problem is likely that those typings don’t tell TypeScript that parent props are going to be merged with what you return from `mapStateToProps` and `mapDispatchToProps`. We don’t maintain those typings officially so I can’t vouch for their quality.

Related: https://github.com/reactjs/redux/issues/1401.

cc @aikoven @ulfryk
",gaearon,ulfryk
290,2016-02-16 16:05:25,"The problem is likely that those typings don’t tell TypeScript that parent props are going to be merged with what you return from `mapStateToProps` and `mapDispatchToProps`. We don’t maintain those typings officially so I can’t vouch for their quality.

Related: https://github.com/reactjs/redux/issues/1401.

cc @aikoven @ulfryk
",gaearon,aikoven
278,2016-02-02 21:54:49,"This post is meant to be a start for a discussion. [Moved from here](https://github.com/rackt/redux/issues/1353#issuecomment-178781992) as @gaearon [suggested here](https://github.com/rackt/redux/issues/1353#issuecomment-178783973).
## Intro

I'm interested in finding best practices on how to architect complex components implemented in React and Redux so that they are reusable as a whole in another app.

Not sure how widespread is the problem, but I encounter it from time to time. I hope the developers from the front-end community encounter similar problems, too.
## Terms and definitions

A **complex component** -- a UI (React, Redux actions), coupled with business logic (Redux reducer), and data access logic (Redux actions' side effects; middleware).

Traits of a complex component:
- can be instantiated more than once, maybe simultaneously (not a singleton)
- each instance can have its own configuration
- can query and manipulate the global environment:
  - the URL and the history (routing, back-forward)
  - network communication (AJAX, WebSockets etc.)
  - storage (cookie, localStorage, sessionStorage etc.)
  - viewport dimensions, global events like viewport scrolling/resizing
- can depend on the app state:
  - query and manipulate other components
  - delegate some functionality, e.g. asset loading, full-screen modal container etc.
- should not pollute the environment
- when used from another app, the component should be reused, not copy-pasted

An **app** -- a UI environment where the components are configured and instantiated.

Traits of an app to consider:
- can be a React + Redux app
- can be a React-only app
- can be a non-React app
## Examples of components
- a [wizard](http://ui-patterns.com/patterns/Wizard), a multi-step form, a [questionnaire](https://en.wikipedia.org/wiki/Questionnaire)
- a complex stateful popup, like a multi-tab settings dialog, or a chat
- a WYSIWYG editor with autocompletion and image uploads

Developing such components with Redux adds the invaluable benefits of predictability and replayability.
## Questions to answer
- How to structure the component code (where to put reducers, actions, UI code)
- How to put a component into a React + Redux app
- How to put a component into an app that has no Redux and/or React
- How to isolate the state of the component instance
- How to configure the component reducers' logic based on the component instance configuration
- How to target actions at specific component instances' state
- How to handle actions of a specific component instance in the app reducers
- How to bridge the component with the global environment (URL and history, network, storage)
- How to bridge the component with the app state
- How to bridge the component with the functionality provided by an app (asset loading, full-screen modal container etc.)

React developers from Facebook answered that I should ""start by reusing React components only"", but having a lot of business logic copied from app to app is not the best way to go.

Elm architecture answers some of the questions, but Redux is quite different (no view+reducer coupling, no explicit serializable side-effects).
## References
- Similar discussion, but not so broad: https://github.com/rackt/react-redux/issues/123
- Similar discussion, but about just actions / reducers / side-effects: https://github.com/rackt/redux/issues/1171
- Similar question: https://github.com/rackt/redux/issues/1314
- Related: https://github.com/yelouafi/redux-saga/issues/62 Though I'd like to avoid sticking to redux-saga until these sagas' state is serializable as well as redux state to at least survive a page reload. ( https://github.com/yelouafi/redux-saga/issues/22, https://github.com/yelouafi/redux-saga/issues/5 )
- Related: https://github.com/rackt/redux/issues/1098
- Related, about action types convention: https://github.com/rackt/redux/issues/786
- Related: https://github.com/rackt/redux/issues/913
- Related: https://github.com/rackt/redux/issues/943#issuecomment-150712338
- Related, reducer logic customization: [BurntCaramel/flambeau reducer props](https://github.com/BurntCaramel/flambeau/blob/master/docs/reducers.md#props)
- https://github.com/erikras/redux-form
- https://github.com/tonyhb/redux-ui
- https://github.com/erikras/multireducer
- https://github.com/acdlite/reduce-reducers
- https://github.com/artsy/react-redux-controller
",sompylasar,gaearon
278,2016-02-14 00:54:27,"@sompylasar Thanks for the kind words in https://github.com/reactjs/redux/issues/419#issuecomment-183775729.  I believe everything in my article, [React, Automatic Redux Providers, and Replicators](https://medium.com/@timbur/react-automatic-redux-providers-and-replicators-c4e35a39f1), covers most of your questions and provides solutions for nearly all of them.  I'd be glad to answer any specific questions.  In advance, if you can include some background/reasoning behind your questions, it would help me answer them to the best of my ability.  :)
",timbur,timbur
276,2016-02-01 20:08:42,"I'm asking this from a discussion in https://github.com/yahoo/react-intl/issues/196 that got me curious on this decision. 

The gist of the discussion in from the `injectIntl` HOC via @ericf: 

> I don't consider it a bug, but a design choice. Forwarding statics can be brittle and isn't required for React's component rendering protocol. I did research this and found that many of the usages where people want statics forwarding were for Flux related metadata and functions are not part of the component's own encapsulation; i.e. the component itself never accesses these statics, nor does React the framework. It seems that statics is used as a convenience in a component created with React.createClass() that's defined as a CommonJS module so that people don't have to type FooComponent. multiple times when defining their statics.

This makes sense to me. While I have used `connect`'s hoisted statics for server rendering, I wonder if it's encouraging a bad pattern. Since the result of `connect` is indeed another function, and static methods aren't normally maintained in higher order functions, should developers using `connect` be aware of this and instead define statics on the result of `connect` instead?

I personally am not looking for change by removing `hoist-non-react-statics`--simply interested in reasoning about the decision to use it.
",quicksnap,ericf
274,2016-01-28 16:19:18,"@gaearon Thanks!!
",e-jigsaw,gaearon
270,2016-01-26 03:24:03,"copy **all** wrapped component's methods (prototype and static except react methods) into the wrapper component.

so methods like `focus` on `@connect() class Composer { focus() { this.refs.input.focus } }` will still be available if `Composer` is `ref`ed somewhere else.

Original issue: https://github.com/rackt/react-redux/issues/267

`hoist-non-react-methods` is here: https://github.com/elado/hoist-non-react-methods
",elado,connect
270,2016-01-27 00:02:04,"@gaearon:
Currently, `static` methods are hoisted, why not `prototype` methods? What's the difference? Current implementation just seems incomplete.
With this functionality, `@connect` can be added or removed without caring about changing how `refs` are managed from containers.
I integrated this into my app and it works flawlessly.

A. Can you think of a scenario where it wouldn't be desired?
B. If I change the code to hoist methods optionally, e.g. `{ withRef: true, hoistMethods: /* whitelist */ ['focus', 'scrollToBottom'] }` or `{ withRef: true, hoistMethods: /* all methods */ true }` 
would this be merged?
",elado,connect
270,2016-01-27 00:30:56,"> Currently, static methods are hoisted, why not prototype methods? What's the difference? Current implementation just seems incomplete.

Static methods are hoisted because that's where people tend to put data fetching methods. There's no workaround here, and call sites are often generic doing something like ""grab every `fetchData` static on components matched by router"". So it's worth it there.

In case of methods on the prototype, it's fragile (can't name methods with same names as `connect()`ed class methods). This means if I later rename a method inside `connect()` I can break somebody's code. I don't want my implementation details to leak into consuming projects like this. Also, component instance interface is props. For static methods, we're still ""out of React land"" but with instances, you have props, and you should consider _them_ component API.

> With this functionality, @connect can be added or removed without caring about changing how refs are managed from containers.

This is a non-goal. If you're accessing instances directly you need to be aware that there is an intermediate instance. We don't want to pretend there isn't because that will just be more confusing and magic and will force us to deal with even worse edge cases (like the naming problems I suggested above).

> I integrated this into my app and it works flawlessly.

I don't doubt that it works. I just don't want to support it in the library in terms of docs, bugs, feature requests (“a method works but a getter doesn’t!”, “inherited methods don’t show up!”, “third party mixin has a `handleChange` method and it clashes, I can’t change the mixin!”), etc. You can write your own `connect()` that uses `connect()` from React Redux but adds this functionality.

> Can you think of a scenario where it wouldn't be desired?

I hope examples above show why I don't want to support this.

> B. If I change the code to hoist methods optionally

No, that's more configuration to support and doesn't help with the bug / feature request burden and potential name clashes.

> composer.focus doesn't necessarily mean input.focus(). It could be opening a menu. I wouldn't want to expose internal component types.

Use props when possible. What's wrong with passing `<Composer isOpen>` and doing the side effect in `componentDidUpdate`? Apart from one-off things like `focus()` and `scrollIntoView()` I think it's best to do this via props.

And you don't have to pass nodes via callback props either. You can do something like


",gaearon,connect
269,2016-01-25 23:21:35,"Let's also consider [redux-batched-subscribe](https://github.com/tappleby/redux-batched-subscribe) of @tappleby

It exposes 2 methods:
- `store.subscribe` is batched (because it's wrapped)
- `store.subscribeImmediate` is not batched

If you use this store enhancer in your project, then all your connect HOC's become batched by default. This proposal would permit the user to connect components in both batched and immediate mode. I don't really have a real usecase for this but maybe it could permit to give some control over the priority the components should render themselves.
",slorber,tappleby
267,2016-01-25 07:31:55,"A simple component may have public methods that are accessible if it's a ref somewhere. I usually use if for `focus`, `scrollToBottom` etc.



In case component is `@connect`ed, the methods aren't accessible anymore.

I can use `withRef: true` and `this.refs.articleSearch.getWrappedInstance().focus()` but that wouldn't be clean, as I explicitly specify the `getWrappedInstance()`. If I remove the `@connect` code will break.

Would it make sense to copy some selective methods from wrapped component into the `Connect` component?

~~Something like (https://github.com/rackt/react-redux/blob/master/src%2Fcomponents%2Fconnect.js) :~~



~~Usage:~~



I'll make a PR if it seems fine.

**Update**

I see all static methods are copied with `hoistStatics`, but prototype methods are left out. Solution can be something similar that also copies all prototype methods and binds them to the ref.
",elado,connect
264,2016-08-15 06:51:55,"@timdorr could you leave a comment why the task was closed? If it's a duplicate / resolved could you link to the related ticket or if it's a ""wont fix"" could you describe why?
",vicapow,timdorr
264,2016-09-07 22:50:54,"@timdorr For future reference, please comment with a reason for closing so we know what the intention was :wink:
",gaearon,timdorr
263,2016-01-21 20:23:29,"On boot, the app I'm building gets a stream of data from a server. This stream can have hundreds of messages and entities and each message is handled separately.

It takes **a tremendous amount of time** to dispatch actions after UI has rendered, because every state change re-renders the `@connect`ed component.

I wrote a short example that shows dispatching 1000 actions before render (5-15ms) and 500 after render (**~2.5s**). So this is clearly not a redux issue.

https://jsbin.com/ruziwa/edit?js,console,output

Obviously component doesn't need to re-render every single dispatched action, but re-rendering should be throttled (say, every 50ms). Is there an established approach for that or does it need to be integrated in `@connect`?
",elado,connect
256,2016-01-30 19:19:20,"A few comments:
- `mod/` is not an ideal name; a number of packages use `modules/` for their actual source (e.g. all the @rackt/routing packages). I think `es6/` or `es2015/` would be better.
- You can't just switch to ES2015 modules with Babel 6 unless you add https://www.npmjs.com/package/babel-plugin-add-module-exports; otherwise you break CJS users.
- It's really odd to me that the ES2015 build uses the external-helpers plugin but the CJS build doesn't; IMO the ES2015 build should be identical to the CJS build, save only for the lack of module transpliation.
",taion,rackt
256,2016-01-30 19:37:08,"> mod/ is not an ideal name; a number of packages use modules/ for their actual source (e.g. all the @rackt/routing packages). I think es6/ or es2015/ would be better.

:+1: on `es6`

> You can't just switch to ES2015 modules with Babel 6 unless you add https://www.npmjs.com/package/babel-plugin-add-module-exports; otherwise you break CJS users.

This is not entirely accurate because we don't have a default export. The only reason we switched from ES6 modules to CommonJS a few releases ago is to work around Babel outputting `.default` rather than `['default']` which breaks in IE8. However we can fix this problem by putting https://github.com/sorrycc/es3ify-loader in our Webpack config.

> It's really odd to me that the ES2015 build uses the external-helpers plugin but the CJS build doesn't; IMO the ES2015 build should be identical to the CJS build, save only for the lack of module transpliation.

I think I agree with this, curious to hear the reasons.
",gaearon,rackt
256,2016-02-02 15:39:05,"This is recommended by @sokra too: https://gist.github.com/sokra/27b24881210b56bbaff7#babel-and-webpack

However, we aren't using presets on the project, so it's just a matter of [removing this line](https://github.com/rackt/react-redux/blob/master/.babelrc#L21).
",timdorr,sokra
253,2016-10-31 03:17:38,"Actually, I have good news for you.  Looking at the `next` branch, it seems that @jimbolla has already implemented such a check, here: [connectAdvanced.js#L67-L71](https://github.com/reactjs/react-redux/blob/6cb82a52ee6751f36ef1c2759ca083161ad3f2ff/src/components/connectAdvanced.js#L67-L71)
",markerikson,jimbolla
249,2016-01-14 03:14:35,"First off, thanks so much for Redux and the amazing tooling and introductory content around it. It's been awesome to learn how all of the parts fit together.

I've been running into an issue while building out my first foray into a React/dux app dealing with action creators. I'm having to use `mapDispatch` a ton for just passing the same action creators into the `props` of each of my top-level components (without React Router I end up having around 5 top-level components so far, which I've called ""containers"" following the examples I've seen). 

And the `mapDispatch` that I'm writing is often just a super plain object like `{ loadUser, loadTeam, loadCollection }` that maps keys to keys. It's getting really boilerplate-y to have to keep doing this all the time, when really I'd just like to have all my action creators already bound to my single store.

It would be amazing to be able to pass them into the `<Provider>`:



And be able to use that inside components as:



From looking through the issues, I found that I'm not the first to suggest this, which means others are grappling with this problem too. Here are a few that mention discuss similar things:
- @mmerickel suggested it in https://github.com/rackt/react-redux/issues/1, except with the extra addition of using `mapDispatch` as well, which I think we can eliminate.
- @maxguzenski suggested it in https://github.com/rackt/react-redux/issues/23.
- @gyzerok brought up the same pain point in https://github.com/rackt/redux/issues/231.
- And a few of the [example snippets in the Readme](https://github.com/rackt/react-redux/blob/master/docs/api.md#inject-todos-and-all-action-creators-addtodo-completetodo-) actually mention a similar use case (of binding all action creators easily), but they do it at `connect`-time for each component, instead of at the `Provider` level, which would mean not having to worry about it any more.

One time when it was brought up, it was discarded because of not wanting to pollute `props` with all of the actions, since the ""clobber likelihood"" would be high. I totally get the concern about not wanting to pollute `props` with tons of actions, but we can avoid that by nesting them in `props.actions` instead.

Another time, @gaearon mentioned the (important) needs of code splitting. I think that's definitely a use case to support, but surely we could have a load-later approach that works very similarly to the current `mapDispatch` that would facilitate loading extra modules, while also making it easy for the main use case?

Curious to hear everyone's thoughts.

From my initial use of both React and Redux, this would save me boilerplate code, and make it possible for people to write nicer boilerplate-reducing functionality on top of the base libraries.
",ianstormtaylor,mmerickel
249,2016-01-14 03:14:35,"First off, thanks so much for Redux and the amazing tooling and introductory content around it. It's been awesome to learn how all of the parts fit together.

I've been running into an issue while building out my first foray into a React/dux app dealing with action creators. I'm having to use `mapDispatch` a ton for just passing the same action creators into the `props` of each of my top-level components (without React Router I end up having around 5 top-level components so far, which I've called ""containers"" following the examples I've seen). 

And the `mapDispatch` that I'm writing is often just a super plain object like `{ loadUser, loadTeam, loadCollection }` that maps keys to keys. It's getting really boilerplate-y to have to keep doing this all the time, when really I'd just like to have all my action creators already bound to my single store.

It would be amazing to be able to pass them into the `<Provider>`:



And be able to use that inside components as:



From looking through the issues, I found that I'm not the first to suggest this, which means others are grappling with this problem too. Here are a few that mention discuss similar things:
- @mmerickel suggested it in https://github.com/rackt/react-redux/issues/1, except with the extra addition of using `mapDispatch` as well, which I think we can eliminate.
- @maxguzenski suggested it in https://github.com/rackt/react-redux/issues/23.
- @gyzerok brought up the same pain point in https://github.com/rackt/redux/issues/231.
- And a few of the [example snippets in the Readme](https://github.com/rackt/react-redux/blob/master/docs/api.md#inject-todos-and-all-action-creators-addtodo-completetodo-) actually mention a similar use case (of binding all action creators easily), but they do it at `connect`-time for each component, instead of at the `Provider` level, which would mean not having to worry about it any more.

One time when it was brought up, it was discarded because of not wanting to pollute `props` with all of the actions, since the ""clobber likelihood"" would be high. I totally get the concern about not wanting to pollute `props` with tons of actions, but we can avoid that by nesting them in `props.actions` instead.

Another time, @gaearon mentioned the (important) needs of code splitting. I think that's definitely a use case to support, but surely we could have a load-later approach that works very similarly to the current `mapDispatch` that would facilitate loading extra modules, while also making it easy for the main use case?

Curious to hear everyone's thoughts.

From my initial use of both React and Redux, this would save me boilerplate code, and make it possible for people to write nicer boilerplate-reducing functionality on top of the base libraries.
",ianstormtaylor,gaearon
249,2016-01-14 03:14:35,"First off, thanks so much for Redux and the amazing tooling and introductory content around it. It's been awesome to learn how all of the parts fit together.

I've been running into an issue while building out my first foray into a React/dux app dealing with action creators. I'm having to use `mapDispatch` a ton for just passing the same action creators into the `props` of each of my top-level components (without React Router I end up having around 5 top-level components so far, which I've called ""containers"" following the examples I've seen). 

And the `mapDispatch` that I'm writing is often just a super plain object like `{ loadUser, loadTeam, loadCollection }` that maps keys to keys. It's getting really boilerplate-y to have to keep doing this all the time, when really I'd just like to have all my action creators already bound to my single store.

It would be amazing to be able to pass them into the `<Provider>`:



And be able to use that inside components as:



From looking through the issues, I found that I'm not the first to suggest this, which means others are grappling with this problem too. Here are a few that mention discuss similar things:
- @mmerickel suggested it in https://github.com/rackt/react-redux/issues/1, except with the extra addition of using `mapDispatch` as well, which I think we can eliminate.
- @maxguzenski suggested it in https://github.com/rackt/react-redux/issues/23.
- @gyzerok brought up the same pain point in https://github.com/rackt/redux/issues/231.
- And a few of the [example snippets in the Readme](https://github.com/rackt/react-redux/blob/master/docs/api.md#inject-todos-and-all-action-creators-addtodo-completetodo-) actually mention a similar use case (of binding all action creators easily), but they do it at `connect`-time for each component, instead of at the `Provider` level, which would mean not having to worry about it any more.

One time when it was brought up, it was discarded because of not wanting to pollute `props` with all of the actions, since the ""clobber likelihood"" would be high. I totally get the concern about not wanting to pollute `props` with tons of actions, but we can avoid that by nesting them in `props.actions` instead.

Another time, @gaearon mentioned the (important) needs of code splitting. I think that's definitely a use case to support, but surely we could have a load-later approach that works very similarly to the current `mapDispatch` that would facilitate loading extra modules, while also making it easy for the main use case?

Curious to hear everyone's thoughts.

From my initial use of both React and Redux, this would save me boilerplate code, and make it possible for people to write nicer boilerplate-reducing functionality on top of the base libraries.
",ianstormtaylor,maxguzenski
249,2016-01-14 03:14:35,"First off, thanks so much for Redux and the amazing tooling and introductory content around it. It's been awesome to learn how all of the parts fit together.

I've been running into an issue while building out my first foray into a React/dux app dealing with action creators. I'm having to use `mapDispatch` a ton for just passing the same action creators into the `props` of each of my top-level components (without React Router I end up having around 5 top-level components so far, which I've called ""containers"" following the examples I've seen). 

And the `mapDispatch` that I'm writing is often just a super plain object like `{ loadUser, loadTeam, loadCollection }` that maps keys to keys. It's getting really boilerplate-y to have to keep doing this all the time, when really I'd just like to have all my action creators already bound to my single store.

It would be amazing to be able to pass them into the `<Provider>`:



And be able to use that inside components as:



From looking through the issues, I found that I'm not the first to suggest this, which means others are grappling with this problem too. Here are a few that mention discuss similar things:
- @mmerickel suggested it in https://github.com/rackt/react-redux/issues/1, except with the extra addition of using `mapDispatch` as well, which I think we can eliminate.
- @maxguzenski suggested it in https://github.com/rackt/react-redux/issues/23.
- @gyzerok brought up the same pain point in https://github.com/rackt/redux/issues/231.
- And a few of the [example snippets in the Readme](https://github.com/rackt/react-redux/blob/master/docs/api.md#inject-todos-and-all-action-creators-addtodo-completetodo-) actually mention a similar use case (of binding all action creators easily), but they do it at `connect`-time for each component, instead of at the `Provider` level, which would mean not having to worry about it any more.

One time when it was brought up, it was discarded because of not wanting to pollute `props` with all of the actions, since the ""clobber likelihood"" would be high. I totally get the concern about not wanting to pollute `props` with tons of actions, but we can avoid that by nesting them in `props.actions` instead.

Another time, @gaearon mentioned the (important) needs of code splitting. I think that's definitely a use case to support, but surely we could have a load-later approach that works very similarly to the current `mapDispatch` that would facilitate loading extra modules, while also making it easy for the main use case?

Curious to hear everyone's thoughts.

From my initial use of both React and Redux, this would save me boilerplate code, and make it possible for people to write nicer boilerplate-reducing functionality on top of the base libraries.
",ianstormtaylor,gyzerok
243,2016-01-08 11:36:01,"what that means is “syntax the platform (browser/node) can read except for the ES2015 import/export syntax”

funnily my test project doesn’t work with specifically react-redux:
- <code>rollup([babel](https://github.com/rollup/rollup-plugin-babel)(), [commonjs](https://github.com/rollup/rollup-plugin-commonjs)(), [npm](https://github.com/rollup/rollup-plugin-npm)({'jsnext:main': true}))</code> → rollup’s acon can’t parse the object spread syntax [here](https://github.com/rackt/react-redux/blob/master/src/components/connect.js#L12)
- `'jsnext:main': false` → https://github.com/rollup/rollup-plugin-commonjs/issues/29

cc @Rich-Harris @TrySound @Victorystick
",flying-sheep,TrySound
243,2016-01-08 11:36:01,"what that means is “syntax the platform (browser/node) can read except for the ES2015 import/export syntax”

funnily my test project doesn’t work with specifically react-redux:
- <code>rollup([babel](https://github.com/rollup/rollup-plugin-babel)(), [commonjs](https://github.com/rollup/rollup-plugin-commonjs)(), [npm](https://github.com/rollup/rollup-plugin-npm)({'jsnext:main': true}))</code> → rollup’s acon can’t parse the object spread syntax [here](https://github.com/rackt/react-redux/blob/master/src/components/connect.js#L12)
- `'jsnext:main': false` → https://github.com/rollup/rollup-plugin-commonjs/issues/29

cc @Rich-Harris @TrySound @Victorystick
",flying-sheep,Rich-Harris
243,2016-01-08 11:36:01,"what that means is “syntax the platform (browser/node) can read except for the ES2015 import/export syntax”

funnily my test project doesn’t work with specifically react-redux:
- <code>rollup([babel](https://github.com/rollup/rollup-plugin-babel)(), [commonjs](https://github.com/rollup/rollup-plugin-commonjs)(), [npm](https://github.com/rollup/rollup-plugin-npm)({'jsnext:main': true}))</code> → rollup’s acon can’t parse the object spread syntax [here](https://github.com/rackt/react-redux/blob/master/src/components/connect.js#L12)
- `'jsnext:main': false` → https://github.com/rollup/rollup-plugin-commonjs/issues/29

cc @Rich-Harris @TrySound @Victorystick
",flying-sheep,Victorystick
243,2016-04-16 12:02:56,"Even if it worked, we _don’t_ want to end up with the whole React in React Redux bundle. It’s not supposed to be embedded in the output. Webpack lets use set “externals” to express that; I presume Rollup has a similar mechanism? cc @Rich-Harris
",gaearon,Rich-Harris
241,2016-01-07 21:47:21,"I have a reduxForm with a mapDispatchToProps that adds a method ""change"" (mapped to reduxForm.change), but it doesn't end up on this.props.  If I rename it to ""props2"" then it does.



this was working when I was using `@connect` with the mapDispatchToProps
",arolson101,connect
240,2016-02-10 02:56:41,"Just a heads up I've merged and published a fix for this, all kudos goes to @ibash for coming up with the fix.
",ryanseddon,ibash
236,2016-01-07 17:25:23,"OK, I got `react-redux 4.0.6` to work with `react-native`, it will be available in [example-react-native-redux](https://github.com/alinz/example-react-native-redux).

There are couple of steps need to be done which I hide them at the moment in `package.json`'s `postscript`. Here's the details:
1. `react` module in `react-native/node_module` must be deleted.
2. `fbjs` module in `react-native/node_modules` must be deleted.
3. `fbjs` module in `react/node_modules` must be deleted.
4. `fbjs` module must be added as module to project in main `package.json`
5. `all .babelrc` files must be deleted under node_module folder

There is a discussion here https://github.com/facebook/react-native/issues/2985#issuecomment-168412030 which @spicyj talks about changing fbjs.

Also @gaearon I still need to remove all .babelrc files under node_modules before I can run the [example-react-native-redux](https://github.com/alinz/example-react-native-redux). What is your suggestion?
",alinz,gaearon
236,2016-01-07 17:25:23,"OK, I got `react-redux 4.0.6` to work with `react-native`, it will be available in [example-react-native-redux](https://github.com/alinz/example-react-native-redux).

There are couple of steps need to be done which I hide them at the moment in `package.json`'s `postscript`. Here's the details:
1. `react` module in `react-native/node_module` must be deleted.
2. `fbjs` module in `react-native/node_modules` must be deleted.
3. `fbjs` module in `react/node_modules` must be deleted.
4. `fbjs` module must be added as module to project in main `package.json`
5. `all .babelrc` files must be deleted under node_module folder

There is a discussion here https://github.com/facebook/react-native/issues/2985#issuecomment-168412030 which @spicyj talks about changing fbjs.

Also @gaearon I still need to remove all .babelrc files under node_modules before I can run the [example-react-native-redux](https://github.com/alinz/example-react-native-redux). What is your suggestion?
",alinz,spicyj
236,2016-01-07 17:39:09,"I don't have any suggestions here. Feedback from people more knowledgeable in RN is welcome. 

Perhaps @ide or @spicyj could clarify the situation. 
",gaearon,spicyj
236,2016-01-07 17:39:09,"I don't have any suggestions here. Feedback from people more knowledgeable in RN is welcome. 

Perhaps @ide or @spicyj could clarify the situation. 
",gaearon,ide
236,2016-02-17 17:28:56,"Still appears to be a dependency in 0.20: https://github.com/facebook/react-native/blob/6496feb61e9205baa3f25cf448c4fce912bd6250/package.json#L136

cc @skevy
",gaearon,skevy
225,2015-12-22 12:15:39,"This attempts to completely remove any internal side effects from `shouldComponentUpdate()` because is not in line with how React tells us to treat it and [may not even be called in certain cases, e.g. during hot reloading](https://github.com/rackt/react-redux/issues/224).

I didn't touch any tests, and that they pass is a good sign because it means we didn't regress over #99 which is where those side effects were moved to `shouldComponentUpdate()`. Here, instead, I moved them to `render()`, and applied a different optimization (namely, returning a constant element) to achieve the same effect as `shouldComponentUpdate()` did while always calling `mapStateToProps` and `mapDispatchToProps` with up-to-date props.

I confirm this PR fixes #224. It should not regress on performance.

@epeli Would you like to review?
",gaearon,epeli
224,2015-12-21 22:51:44,"So this _is_ a bug. In particular it is caused by us recomputing child props inside `shouldComponentUpdate()` which is not at all guaranteed to run (for example, it won't run if the connect wrapper is `forceUpdate()`d which is exactly what `react-transform-hmr` does). This was introduced in #99.

@epeli Can you look at this? Ideally we shouldn't care if `shouldComponentUpdate()` is called or not. We definitely shouldn't rely on React doing it before every render. Maybe we should move the calculations back into `componentWillReceiveProps` and `handleChange` and solve #99 in some other way.
",gaearon,epeli
212,2015-12-12 18:04:50,"@gaearon Do we want loose mode for IE8? React-Redux previously used it but this PR does not.
",ellbee,gaearon
206,2015-12-05 23:22:26,"Interesting, @NullDivision -- so you basically kill the local installations and rely on the global? In theory, it sounds like this might also let you compile `react-native@0.16` with a different version of Babel? I'm currently using the `@connect` decorators that are no longer supported in Babel 6 (and also not resolved with the current workaround in [babel-plugin-transform-decorators-legacy](https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy))
",ajwhite,connect
206,2015-12-05 23:28:40,"I'm not sure about the `@connect` decorators but all my dependencies work just fine with the global installation of babel-cli. For reference I'm using Webpack as my main builder and everything works as it should.

I need `babel-core/register` for runtime transpiling on Karma and Gulp but everything else uses the global binary. 
",NullDivision,connect
204,2015-11-27 14:13:30,"Bumped node version to 5 to fix lint error.
Made failing test 'should throw an error if the store is not in the props or context' not have to match the exact error string as suggested [here](https://github.com/rackt/react-redux/pull/196#issuecomment-160009368) (thanks @schmeedy!) 
",ellbee,schmeedy
196,2015-11-24 20:34:00,"This looks good to me.
@epeli What do you think about this change? Any reason `storeState` was initialized to `null` in b6272698d2fc9ff7f67014b3e527579f738cd81d?
",gaearon,epeli
194,2015-11-19 20:20:04,"This started off from a discussion in https://github.com/rackt/redux/issues/980

As far as I can tell there is no way to get the information that I need from listeners using the approach suggested by @gaearon, but if we have the `handleChange` return some data for us then it's straightforward.

The approach I took here is to have `handleChange` take an optional parameter which is a function that should extract the data we need, given the wrapped component's name, the `nextState`, and to leave the door open to other requirements, the instance of the connect component itself.

If this or some variation of this is accepted, it would be great to also do a point release for 3.x in order to support React Native right away (which is the context where I am using this).

An example of how you might use this:



The result:


",brentvatne,gaearon
194,2015-11-30 06:48:20,"@epeli @gaearon - any feedback?
",brentvatne,epeli
194,2015-11-30 06:48:20,"@epeli @gaearon - any feedback?
",brentvatne,gaearon
193,2015-11-19 00:23:07,"My top level component is like so:



And my App component is like so:



I'm not using React Router, and I've ensured that there [is only one React instance loaded](https://medium.com/@dan_abramov/two-weird-tricks-that-fix-react-7cf9bbdef375#.12hz4y8rg).  

If I break at the top of `App.render`,  `this.context` has no store on it.  However, `this._reactInternalInstance._context` does have the store attached.  Obviously I can grab this, but I'm guessing I shouldn't really use that one.

Why is there no store on `this.context`?  I want to subscribe to certain state changes.  

Thanks.
",marcuswhit,dan
183,2015-11-11 01:26:01,"I think we've concluded it's actually not possible to do the per-component memoization without a global LRU cache as @ellbee [mentions here](https://github.com/rackt/react-redux/pull/179#issuecomment-155565193), so this would be the next best thing.

@acdlite I typically like to use a one layer deeper shallow `===`. I have a lot of connected components and selectors which have plain Arrays as return values, and so it ends up there's a lot more unnecessary updating going on than there'd need to be if we could just check the returned Array or Object props are themselves shallow equal.

I've found the amount of time it takes to do an extra shallow compare of a few Arrays is virtually nothing compared to the expense of React going through an update cycle.
",tgriesser,ellbee
182,2015-11-11 00:24:53,"Similar to `createSelectorCreator` in reselect, provides `createConnect` to optionally wrap `connect` providing a custom implementation of `shallowEqual`. 

@ellbee thoughts? Are there any other functions that might be worth allowing customization of?
",tgriesser,ellbee
179,2015-11-09 00:00:31,"Can you please elaborate on usage? I don't quite understand this.
@ellbee Is there a way to solve this problem without changing React Redux API? I don't want it to “know” about the fact that user has Reselect, this feels wrong.
",gaearon,ellbee
171,2015-10-30 22:47:09,"Thanks for the report. I'd say you should file this with `redux-router`.

By default it sets `router` state field to `null`, but I think it should have initial value before first change action. The app should never see `null` state there, I think, but `RESET` effectively gets us back to the initial state. The same error will occur if you “toggle” action in DevTools.

@acdlite Ideas?
",gaearon,acdlite
170,2015-11-08 00:55:03,"Khan Academy [calls these](https://github.com/Khan/style-guides/blob/master/style/react.md#make-presentation-components-pure) “logic components” and “presentation components”. This matches [what I originally meant](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) by “smart” and “dumb” components (before Redux or support for functional components in React) although I'm not sure I'm fond of these names.
",gaearon,dan
165,2015-10-23 08:25:43,"My code base isn't entirely React-based, so there are points in which I want to use React components in a non-React context. In this situation I have a component that acts as an editor form; the form takes model data as an input, and the component has a 'getValue' method to get the model data back with the changes made on the form. 

To do this, I'm effectively using the method explained here:
https://facebook.github.io/react/tips/expose-component-functions.html

So...



However my component also uses react-redux, so the above actually looks like:



Plus, my Editor component has the `@connect` decorator. This appears to have the side-effect of hiding my component API. Is this a bug, or is there a way around this? 
",jamiewinder,connect
163,2015-10-19 23:47:47,"To be honest I'm not sure if this is the right repo but I'm at an impasse and this is the most obvious place for now.

I have a [simple test repo](https://github.com/rockingskier/redux-problem).  It is heavily based off the redux-router [basic example](https://github.com/rackt/redux-router/tree/master/examples/basic) but simplified for this example.

Among other webpack-esque things the following react/redux libs are installed:



Fairly standard stuff.

There are two files worth looking at:

`index.jsx` - Basically a whole application
`App.jsx` - The main component exported to a separate file.

When run in one file, `index.jx` the application work as expected.  The component receives props from the `@connect`-ed store, all good and happy.  Routes run, props are passed, everyone gets what they want.

In the name of splitting things out for a real project I started by moving the main App component to a separate file.  When I do this however the `@connect`-ing doesn't appear to work.
This is first made clear by the Props warning that appears.



This points to `redux-router` however after adding some logging I can see that the `@connect` mapStateToProps function is not being called when exporting the component.

This all seems very odd to me but tbh it could point to any number of places.  The eco system is moving very quickly and its hard to keep up.

Is there an issue with `react-redux`, `@connect`, `webpack`, `babel`, `redux-router` or any of the (incredible) hot reloading features?
",rockingskier,connect
163,2015-10-20 16:46:31,"Just the one `App`.

Defining the class inline with `@connect` works fine.

Moving the class to a separate file, still with `@conenct`, does not run the `mapStateToProps`.
Importing the so-called `@conenct`-ed App and then passing it through `connect(fn)(App)` again works.  Obviously now what I want to achieve.

But yes, removing `""plugins"": [""react-transform""],` from `.babelrc` works fine so I'll do that.

Thanks! Great work as always!
",rockingskier,connect
163,2015-10-20 16:46:31,"Just the one `App`.

Defining the class inline with `@connect` works fine.

Moving the class to a separate file, still with `@conenct`, does not run the `mapStateToProps`.
Importing the so-called `@conenct`-ed App and then passing it through `connect(fn)(App)` again works.  Obviously now what I want to achieve.

But yes, removing `""plugins"": [""react-transform""],` from `.babelrc` works fine so I'll do that.

Thanks! Great work as always!
",rockingskier,conenct
163,2015-11-04 09:52:46,"I have this issue but I dont have `react-transform`. My components are in different files -- es6 classes with `export default`. These are imported in various places. Also noticed that `@connect` doesnt seem to get executed in that neither the state or actions are available.
",adamscybot,connect
163,2016-03-05 04:09:21,"@thejameskyle would so love this.
",gaearon,thejameskyle
157,2015-10-15 09:07:55,"So, we're encouraged to pass actions down the component tree via `@connect`'s second parameter `mapDispatchToProps`. How does this fit with `shouldComponentUpdate()`? Actions are functions, their equality can't be easily compared.
",gsklee,connect
145,2015-10-14 18:30:09,"@erikras Thoughts?
",gaearon,erikras
145,2016-01-13 04:17:07,"@gaearon

I fiund thus question by you (on S.O.) and another one by @ide (i just commented on that too so i apologize for the inadvertent loop) grappling with the effecf of this same exact issue, which was not satisfied IMO with the batchedupdate answer (you are still going to have overhead that grows with the complexity of the component tree)

https://github.com/rackt/redux/issues/125

http://stackoverflow.com/questions/25701168/at-what-nesting-level-should-components-read-entities-from-stores-in-flux

I think the answer on S.O. is not ideal... leaving it to the programmer is not a comforting solution

have you any updated insight?
",idibidiart,ide
138,2015-10-08 23:36:59,"I'm cool with using Recompose's `wrapDisplayName()` — true story, I copied the code for `getDisplayName()` from this repo — though I know Dan likes to keep the dependencies to a minimum. 

@gaearon?
",acdlite,gaearon
137,2015-10-06 07:46:46,"I don't really know enough about Flow to fix this.
@leoasis, any ideas?
",gaearon,leoasis
123,2015-09-28 12:31:26,"Hey guys,

I'm developing an app with pretty complex form logic. I'm trying to follow the advice of @gaearon about Smart and Dumb components.

My form is dynamic, and is constructed out of several `fieldsets`. The fieldsets that are being displayed are chosen based on user roles.

Each fieldset has it's own validation logic and own actions to retrieve async data based on user input, in order to guide the user towards completion of the form.

Not only that, but the inputs inside each fieldset are dynamic as well. Again, based on user permissions.

I've tried to implement this use case using only one Smart Component (the route handler), however without much success.

As I see it, in such use case, a fieldset is both a smart component and a dumb component. It both `connects` to redux, in order to dispatch some private use case actions and it also acts as a dumb component to bubble up state changes using events.

Am I getting it right?

In your opinion, where does validation should take place? Inside each fieldset or in the route handler?

Basically, I'm planning to use same validation logic both on client and server.

The model that I'm validating on the server, looks something like:



The original way I tried to implement it, is to  is to simply validate in the route handler level, but it got really messy and complex. Basically unmaintainable. Some validation logic needs to be async. 

On the server I prefetch all the validation logic before validating.

On the client, it's a bit harder because the fieldsets are dynamic.

What do you think? How would you approach nested forms with react-redux?

Thanks.
",tounano,gaearon
123,2016-01-24 18:07:23,"A complex form usually entails multiple controls of several types and is likely to require interaction with a number of different domain models and perhaps client-side caching of unsaved changes. As Redux users will see, creating even medium-complexity forms there are performance issues handling input `onChange`. Rather than going Immutable for better performance, or adding complexity with `redux-form`, I had good luck simply creating a UI form reducer and implementing the workaround as suggested by [`@trashgenerator against redux-form`](https://github.com/erikras/redux-form/issues/529#issuecomment-172653330).

**Aside:** Because React throws a `validateDOMNesting` exception when nesting forms (a likely case when composing forms of reusable other forms) I'm interested in knowing if anyone has successfully used the `form` attribute of the HTML5 [`Input`](http://devdocs.io/html/element/input) as a `formOwner` prop to workaround the form nesting limitation, and enable robust serialization of complex forms without sacrificing composability or introducing additional app dependencies.
",jhabdas,trashgenerator
116,2015-09-24 04:34:03,":+1: Ran into the same thing. Thanks, @gaearon & @theaqua.
",gasi,theaqua
108,2015-09-15 16:20:17,"Thanks @gnoff - it looks like it might help, though if I have my dumb components `@connect`-ed then doesn't that make smart by definition? Not that it's necessarily a problem, but I imagine having thousands of store-connected components (i.e. my lists **and** their items) will have a performance impact, I'd guess? I'll have a look into it all the same. Thanks again.
",jamiewinder,connect
105,2015-09-15 23:39:36,"Shouldn't decorator functions follow the [canonical definition](https://en.wikipedia.org/wiki/Decorator_pattern) in the sense that they merely _add_ new behavior?

Maybe we should call these something other than ""decorator functions"", because this is a point of confusion I've seen a lot in the React community, lately. When I use `@decorator`, I typically expect it to maintain the usual contract of the decorator pattern, i.e. it wont clobber anything that already exists unless explicitly stated in the function's API.
",namuol,decorator
100,2015-09-10 16:19:48,"After talking with @lunaris on slack, that's what we came up with: https://gist.github.com/despairblue/4ae15b40bc47d8efc2af
",despairblue,lunaris
99,2015-09-08 22:25:24,"@epeli this brings us back to the way things were before #1 which as @gaearon says makes the worst case performance the default. I'm inclined to leave the existing behavior as is. If we did adopt this form I would hope that it be made optional and opt-in much like the 2nd arg props parameter to the first two connect arguments.
",gnoff,gaearon
99,2015-09-08 23:08:29,"> this brings us back to the way things were before #1 which as @gaearon says makes the worst case performance the default

Not able apprehend right away every point made in #1 but I'd like hear why this would be the **worst** case compared to the current implementation because in it `mapState` is also executed always when the store changes. Also note the PureWrap optimization in this PR which prevents any useless renders in the wrapped components if the `mapState` does not produce any changes.
",epeli,gaearon
99,2015-09-09 13:43:49,"> Could it be possible to somehow force React in to the batching mode when store updates?

To answer myself: Yes with [`React.unstable_batchedUpdates(cb)`](https://github.com/facebook/react/issues/4525#issue-98261422). Previous discussion: https://github.com/rackt/redux/issues/125

In that issue sebmarkbage [mentions](https://github.com/rackt/redux/issues/125#issuecomment-119381649) that React has a plan to move batching by default. Can you @sebmarkbage confirm that that's still the case?

If so then that issue will be resolved by itself with React update. Until then [redux-batched-updates](https://github.com/acdlite/redux-batched-updates) middleware can be used as a workaround.

---

Anyone wanting to help and test this I pushed a compiled version to `epeli/react-redux#fix86`. Put that in your package.json as the `react-redux` version number.
",epeli,sebmarkbage
98,2015-09-13 06:38:17,"PRs are always welcome. I don't use TS, don't think @gaearon does either. Hopefully someone out there using it will contribute
",gnoff,gaearon
97,2015-09-07 11:13:29,"@gaearon  I've already posted a link to my project about a month ago under the Redux repository. That time it was called `redux-graphql`. I've did a lot of work to understand what it should be. Now I think of it as a React binding for Redux with Relay idea behind.
Today I've ended up with some clunky readme, but I suppose it would be enough for you to get an idea
Now its [adrenaline](https://github.com/gyzerok/adrenaline). Can I somehow contact you to get feedback on what I've done?
",gyzerok,gaearon
90,2015-09-03 19:28:53,"This looks good to me.
@gnoff what do you think?
",gaearon,gnoff
88,2015-09-02 20:52:05,"The `@connect` decorator, by default, appears to add a very aggressive `shouldComponentUpdate` hook to the decorated component. This is great if Redux and props are the only sources of statefulness in your app - but that's not always true and leads to some seriously confusing behavior with non-obvious workarounds when it's not.

This is a known issue, of course, with react-router 0.13, but I'm having the same issue with [react-intl](http://formatjs.io/react/)'s `IntlMixin`, which adds localization data to context. And I get the feeling that this is going to keep happening as long as the React ecosystem is as fragmented as it is right now. 

It would be really nice to just be able to throw an option on the `@connect`ed components that I know are impure (or, similar to React core's `PureRenderMixin`, throw an option on the ones I know _are pure_; there's certainly room for debate as to whether opt-in or opt-out is the right choice here).
",dallonf,connect
88,2015-09-02 21:49:29,"Cool, I'll see if I can add an options argument (defaulting to `pure: true`) over the weekend. I'm actually rather fond of the `forceUpdate: {}` workaround (and slightly embarrassed I didn't think of it myself :wink:), but probably better to have something a bit more readable in the long run. And it opens the door for more configuration options on `@connect`, should you ever need them...
",dallonf,connect
88,2015-09-03 17:45:30,"FYI to anyone looking at this issue, the `forceUpdate: {}` hack actually doesn't have the intended effect; the `shouldComponentUpdate` definition compares the props that were already calculated the last time there was a store update or new props were received, so it won't be able to handle updates outside the Redux flow.

Also, after diving into the implementation of a `pure: false` option, I think that the `options` argument is going to always need to be the fourth argument to `@connect`; trying to make it the last argument regardless of which others are present would probably lead to madness.

Anyways, I've got a PR incoming soon.
",dallonf,connect
76,2015-08-27 05:39:52,"@gnoff The issue was more around distributable browser bundle than cdnjs.
Is there a way currently to use it, that I am missing?

cc @gaearon 
",vipulnsward,gaearon
75,2015-08-27 04:19:55,"React-Redux implements a pretty aggressive `shouldComponentUpdate` so state changes will only trigger re-renders if the slice of state `@connect`'d to results in a different set of state props (only checked shallowly)

That said. If the smart component does trigger a re-render and you are concerned about performance then you should implement `shouldComponentUpdate` in your 'dumb' components. In practice most components can use something like https://facebook.github.io/react/docs/pure-render-mixin.html
",gnoff,connect
75,2015-08-27 05:11:22,"I am not so much concerned about performance yet but I think many people are and that should be addressed in the docs.

As you said:

>  state changes will only trigger re-renders if the slice of state @connect'd to results in a different set of state props

In that case in the simple todo example form the doc, why would the footer component re-render when a todo is added? It doesn't share any state with the todo list.
",m4nuC,connect
66,2015-08-20 23:14:22,"It's not really about “keep decorators” or “keep components”.
It's about “which does a better job in which case”.

### `connect()`

`connect()` makes more sense as higher order component because:
1. You never need to change the selecting function mid-flight. We couldn't do some perf optimizations with `<Connector>` because it had to correctly handle changing `select` prop although there was no valid use for this.
2. Function-as-a-child default case has performance downsides because people often write it as a lambda so they're allocating functions every time `render` is called.
3. We have no way to restrict `shouldComponentUpdate` _outside_ `Connector` but that would be really useful to make connected components faster.
4. `<Connector>` forced you to write “semi-smart” components that knew about Redux but couldn't, for example, handle its state changes in `componentWillReceiveProps` because they just used `<Connector>` inside without access to its state.
5. Even if you didn't want an intermediate component you had to write it anyway. Now you can `connect()` your dumb component and get the smart component right away, without writing another `class` in between.

It was a poor choice of abstraction and added unnecessary layers and clumsiness. We got rid of it.

### `<Provider>`

`<Provider>` makes more sense as a normal component.
1. Unlike with `connect()`, it actually _does_ make sense to change the parameters (store in this case) at runtime. For server rendering, we want to pass a new `store` for every request. Offering it to specify as a singleton at the top makes server rendering non-obvious. Making it a prop points you to the right direction.
2. It was a shortcut for shortcut's sake, it didn't bring any valuable opportunities.
3. It didn't work well with React Router.
4. It didn't work with Redux DevTools.
5. It made stubbing store for tests more complicated.
6. In React 0.14, we'll be able to further simplify `<Provider>{() => <App />}</Provider>` to `<Provider><App /></Provider>`. At this point it's hard to justify `@provider` even as a shortcut.

Good riddance.
",gaearon,provider
61,2015-08-18 06:41:36,"Apologies for polluting the issue list since it's not really an issue but I believe there is some interest in coming up with a workable solution that

a) Keeps the Smart/Dumb component divide clean & generally near the top of the component tree for a given part of the app domain AND
b) Avoid the hassle of passing @connect results down deep chains of children

I liked the Provide/connect pattern a lot so I generalized it in [react-tunnel](https://github.com/gnoff/react-tunnel) and starting playing with a patter like so



The Provider in react-tunnel puts props into context under the provided namespace and inject pulls them off with the mapProvidedToProps function.

It's not react-redux specific nor really related to redux in any way (and there are probably plenty of other DI type libraries that will get the same job done) but i thought it fit nicely with the react-redux paradigm but would give you the option to use similar semantics deeper in the component tree without bringing along anything specific to redux.

As a final note, you could actually do away wiht the react-redux Provider and just use the react-tunnel provider and inject by doing



anyhow, just some food for thought... would love feedback even if it's why this is a horrible idea.

Thanks,
Josh
",gnoff,connect
60,2015-08-16 16:13:11,"My store is an `Immutable.Map` object, and I would like to pass it down my tree of React components. I suppose that in most cases I can get good performance by using something like `PureRenderMixin` (or ES2015 equivalent) when doing so.

I started out simple decorating my `App` class with `@connect(state => state)`, and I got this error:

“Uncaught Error: Invariant Violation: `mapStateToProps` must return an object. Instead received Map {…”

I’m able to do something like `@connect(state => {return {state};})`, and then unwrap the object in `App`’s `render()`, but I get the sense that this is not an ideal solution.
",alexanderteinum,connect
60,2015-08-16 17:07:17,"The return of the mapStateToProps needs to be an object because the object is spread as props to the wrapped component. Your work around is in fact the idiomatic way to use @connect. In this case your wrapped component will have a prop named 'state' which is an Immutable.Map 

Now you may want to reconsider passing the entire app state to your connected component however. This will make refactoring your state shape a lot harder when your app is more complicated. Though in simple cases it is fine.
",gnoff,connect
60,2015-08-16 18:48:18,"Ah, I understand.

I already pass what that I consider being the app state. By passing the entire app state, do you mean doing `@connect(state => state.toJS())`?

I haven’t fully decided whether or not I want the immutable or a plain JavaScript object floating through the component tree, but performance is the number one priority in this particular case. I need to look into how `shouldComponentUpdate()` and each alternative will work with my data. I also consider using several `@connect()` a bit higher up the tree, instead of one at the root component.
",alexanderteinum,connect
60,2015-08-17 15:36:24,"> I already pass what that I consider being the app state. By passing the entire app state, do you mean doing @connect(state => state.toJS())?

That would be slow. I suggest you don't do that, and if perf is your main concern, use `@connect` granularly.

> I need to look into how shouldComponentUpdate() and each alternative will work with my data.

Actually `@connect` already implements a rather decent `shouldComponentUpdate` so don't worry about it too much.
",gaearon,connect
60,2015-08-17 15:39:46,"Indeed, as @gnoff said above, you can't just return Immutable object because we spread over the values you return, and this wouldn't make sense with Immutable.

> I’m able to do something like @connect(state => {return {state};}), and then unwrap the object in App’s render(), but I get the sense that this is not an ideal solution.

The idiomatic way is to do this:



only for the fields you actually care about, so `@connect` can bail out when the parts the component doesn't need, did not change. I don't suggest using `toJS()` because AFAIK it's deep, but deep conversions won't be as performant as just extracting the stuffy you want.

> I also consider using several @connect() a bit higher up the tree, instead of one at the root component.

This is the way to go, and it's more performant than just one `@connect` at the top.
",gaearon,connect
60,2016-07-24 22:21:58,"Sorry for commenting a closed issue but I keep coming here when googling for a similar issue.
I spent a lot of time to understand how to integrate Immutable with Redux, even implementing my own version of connect, and finally understood how to use the @connect from 'redux-connect'
I just wanted to understand @gaeron answer from 17 august 2015

`connect(state => ({
  stuff: state.get('stuff'),
  otherStuff: state.get('otherStuff')
})`

It seems to work ( and looking at the shallowEqual code it seems reasonable ) when state.get('stuff') and state.get('otherStuff') are Immutable objects, not plain JS. 
Can someone confirm it is the case or am I missing something ? 
",msuperina,gaeron
60,2016-07-24 22:21:58,"Sorry for commenting a closed issue but I keep coming here when googling for a similar issue.
I spent a lot of time to understand how to integrate Immutable with Redux, even implementing my own version of connect, and finally understood how to use the @connect from 'redux-connect'
I just wanted to understand @gaeron answer from 17 august 2015

`connect(state => ({
  stuff: state.get('stuff'),
  otherStuff: state.get('otherStuff')
})`

It seems to work ( and looking at the shallowEqual code it seems reasonable ) when state.get('stuff') and state.get('otherStuff') are Immutable objects, not plain JS. 
Can someone confirm it is the case or am I missing something ? 
",msuperina,connect
59,2015-08-16 10:56:39,"@gaearon 
",jhollingworth,gaearon
57,2016-02-05 00:27:43,"I'm having a very strange issue related to this and I'm not sure what's going on. **TL;DR** I'm nesting `@connect`ed component inside a `@connect`ed component and it's erroring and I have no idea why.

I'm using [react-redux-universal-hot-example](https://github.com/erikras/react-redux-universal-hot-example) as my base.

The **top level** component looks like this:



The **route handler `<HighLevelComponent />`** uses `@connectData` and `@connect`:



**`<SubComponent />`** (inside `<HighLevelComponent />` above) only has `@connect`:



**`<ChildWithConnect />`** (inside `<SubComponent />` above) also has `@connect`:



**This errors:**

> Warning: Failed Context Types: Required context `store` was not specified in `Connect(ChildWithConnect)`. Check the render method of `SubComponent`.
> Uncaught Invariant Violation: Could not find ""store"" in either the context or props of 
> ""Connect(ChildWithConnect)"". Either wrap the root component in a <Provider>, or explicitly pass ""store"" as a prop to ""Connect(ChildWithConnect)""

This happens even if I have `contextTypes` defined:



If I make `<ChildWithConnect />` a direct child of `<HighLevelComponent />`, then there is no error.

You can see in the call stack for the error/warning above, `context` is an empty object and `maskedContext` has `undefined` for the store key:

 ![screen shot 2016-02-04 at 4 25 45 pm](https://cloud.githubusercontent.com/assets/79215/12834418/fbc3b77a-cb5b-11e5-86ce-c3dece278bd2.png)

Since it's defined as a `contextType`, shouldn't my sub component get the `store` passed to it automatically? Been pulling my hair out over this for a while, and I'm not sure if this is desired behavior, a bug, or I'm doing something incorrectly. 
",AndrewRayCode,connectData
57,2016-02-05 00:27:43,"I'm having a very strange issue related to this and I'm not sure what's going on. **TL;DR** I'm nesting `@connect`ed component inside a `@connect`ed component and it's erroring and I have no idea why.

I'm using [react-redux-universal-hot-example](https://github.com/erikras/react-redux-universal-hot-example) as my base.

The **top level** component looks like this:



The **route handler `<HighLevelComponent />`** uses `@connectData` and `@connect`:



**`<SubComponent />`** (inside `<HighLevelComponent />` above) only has `@connect`:



**`<ChildWithConnect />`** (inside `<SubComponent />` above) also has `@connect`:



**This errors:**

> Warning: Failed Context Types: Required context `store` was not specified in `Connect(ChildWithConnect)`. Check the render method of `SubComponent`.
> Uncaught Invariant Violation: Could not find ""store"" in either the context or props of 
> ""Connect(ChildWithConnect)"". Either wrap the root component in a <Provider>, or explicitly pass ""store"" as a prop to ""Connect(ChildWithConnect)""

This happens even if I have `contextTypes` defined:



If I make `<ChildWithConnect />` a direct child of `<HighLevelComponent />`, then there is no error.

You can see in the call stack for the error/warning above, `context` is an empty object and `maskedContext` has `undefined` for the store key:

 ![screen shot 2016-02-04 at 4 25 45 pm](https://cloud.githubusercontent.com/assets/79215/12834418/fbc3b77a-cb5b-11e5-86ce-c3dece278bd2.png)

Since it's defined as a `contextType`, shouldn't my sub component get the `store` passed to it automatically? Been pulling my hair out over this for a while, and I'm not sure if this is desired behavior, a bug, or I'm doing something incorrectly. 
",AndrewRayCode,connect
52,2015-08-11 19:32:02,"cc @jhollingworth, @danharper, @ForbesLindesay who wanted to make this happen
",gaearon,ForbesLindesay
52,2015-08-11 19:32:02,"cc @jhollingworth, @danharper, @ForbesLindesay who wanted to make this happen
",gaearon,danharper
52,2015-08-11 19:32:02,"cc @jhollingworth, @danharper, @ForbesLindesay who wanted to make this happen
",gaearon,jhollingworth
52,2015-08-17 10:33:02,"@gaeron What is the current state of this issue? 
We were just updating to redux 1.0.x and have serious problems with props not being available to mapStateToProps. The reason is that we pass memoized selector functions via props that select the desired childProperties from the state. 
As a workaround we could select the whole state and thus have it passed to the mergeProps callback. The problem using this workaround is, that the potentionally expensive mergeProps becomes the mapStateToProps and is callled much to often (the recomputeState is actually called for every state change in the redux store, no matter what part of the state was influenced by the change).
",PSpSynedra,gaeron
52,2015-08-17 10:45:48,"@theaqua, Yeah I just saw it :-) Looking forward to it already.
",PSpSynedra,theaqua
50,2015-08-11 15:59:18,"I've add failing test, (without @connect it works as expected)
",istarkov,connect
47,2015-08-10 10:36:17,"@prepare(props => action) where action may be async action?
",gaearon,prepare
37,2015-08-08 16:48:57,"Hi,

I have the following behavior after upgrading to `0.5.0`
1. I changed the `@provide` to use `Provider`
2. didn't change connect for now



Now, when component is mounted it calls the action to load the initial state



component is rendered with default props

I could see the action causes the state to be populated 



but there is no re-render. The new state is shown in the UI (rendered by the component) next time. that is if the same button/nav item is clicked again or navigate away and back to the same screen. 

Let me know what else needed to help me with this issue.
",bsr203,provide
36,2015-08-11 15:58:07,"I am finding this to be a really frustrating use case for me.  I almost always want `props` to be available to both the `selectState` and `mapDispatchToProps` functions.  Could we have `@conenct` behave as it does currently, but have a second connector `@connectWithProps` that gave props to both functions?  We could still avoid re-binding when props haven't changed by checking shallowEqual on the props.

Another option, we could check `fn.length` and not pass props if that returns `1`.
",ForbesLindesay,connectWithProps
36,2015-08-11 15:58:07,"I am finding this to be a really frustrating use case for me.  I almost always want `props` to be available to both the `selectState` and `mapDispatchToProps` functions.  Could we have `@conenct` behave as it does currently, but have a second connector `@connectWithProps` that gave props to both functions?  We could still avoid re-binding when props haven't changed by checking shallowEqual on the props.

Another option, we could check `fn.length` and not pass props if that returns `1`.
",ForbesLindesay,conenct
34,2015-08-08 12:20:28,"This should address #32.
@maxguzenski Can you try this branch?
",gaearon,maxguzenski
28,2015-08-07 19:40:27,"OK I introduced this bug while tweaking @gnoff's code. :-(
Will push out a fix soon.
",gaearon,gnoff
25,2015-08-07 11:09:38,"This is based on #16, plus a few style tweaks I want to make + boring stuff like removing dead bones of deprecated APIs. Big thanks to @gnoff!
",gaearon,gnoff
23,2015-08-06 01:32:48,"First at all, thanks for build redux. 

I read all discussion on https://github.com/gaearon/react-redux/issues/1 but I still don't get it: 

Why Provider/Connection decoration just doesn't bind all actions creator to dispatch only once (willComponentMount or something like that) and pass it (all app actions) to nested component as props? 

With the new api proposal, I still have to pass to @connect that actions that I want to use, and its look like to been ""re bind"" all time that render() is called...  I just dont get why.. what have I missed?
",maxguzenski,connect
23,2015-08-06 23:45:30,"Yes, but it looks like that you have to pass actions on @connect, why not <Provide actions={allActions} />  and @connect just pass it forward all the time?
",maxguzenski,connect
16,2015-07-31 06:38:22,"Alright,

Here's my take on the new connectDecorator API. Normal Args examples should all work from @gaearon 's comment in #1 

https://github.com/gaearon/react-redux/issues/1#issuecomment-120729921
### API



~~I didn't delete createConnector but I did move createConnectDecorator to createConnectDecoratorDeprecated until we can decide if we should just delete these.~~

the old Connector and connect decorator have been deleted

I have tested through mocha only so no guarantees it is 100%

I'm happy to make changes/work on it etc... as opinions change on best api going forward if it's not ready to merge yet.

State is handled like Connector did on any notification from the store. shouldComponentUpdate will bail if the slice is the same

actions are bound using the provided dispatchBinder (2nd arg) only on component mount. Not sure if this is what you were aiming for in the API but it certainly reduces the number of binds to a lot less than every render and it seemed find since the typical use case for dispatchBinder is to simply bind dispatch to the action creator methods

merge is called on every render, reading stateProps and dispatchBinderProps from component state (not store state) and taking whatever current component props as the 3rd argument.

~~finally the decorated component is rendered with this.props, and mergedProps in that order.~~
If you want choose to provide a custom merge function then only the props returned from merge will be added to the underlying component

I also wrote a util for wrapActionCreators that fits the dispatchBinder argument signature and delegates to redux/bindActionCreators. This is called form connectDecorator if the actionCreators argument is a plain object
",gnoff,gaearon
16,2015-07-31 17:18:19,"Should we consider changing the static member DecoratedComponent on our wrapped component. If you use  `@connect()(Component)` you will end up with the Symbol for `Component` pointing to the decorated component `Component.DecoratedComponent` pointing to the undecorated component. This feels... misleading?

Perhaps we change `static DecoratedComponent` in [createConnectDecorator.js](https://github.com/gnoff/react-redux/blob/master/src/components/createConnectDecorator.js#L29) to `static UndecoratedComponent`

or `static Decoratee`
",gnoff,connect
16,2015-07-31 20:14:35,"@Keats Hey Keats, great job! I have a question: If we use the merge method to select inside a store, does it update only when that particular ""reselect"" gives up different values or does it re-render every time the main store changes?
",quirinpa,Keats
12,2015-07-27 23:34:24,"I have been hunting a bug that turns out to have been caused by the fact that Connector shallowly compares the current slice to the next. The diffs buried deep in a slice doesn't trigger updates in the connected components because of this. For example:

Before:



After:



...no updates. 

I know I can do `@connect(state => state.MapReducer)` but I also want the component to receive the state from other reducers. Any tips for me?
",volkanunsal,connect
6,2015-07-17 11:20:00,"When you use the `@connect()` decorator, your `Info` class is decorated as a `ConnectorDecorator` component.

When you then set `Info.propTypes`, you’re actually setting those prop types on the Connector, not on your Info component. So React is enforcing the props in the wrong place!

Instead, use an `InfoContainer`. I’d say this is a best practice in general, as it keeps your `Info` component as a “dumb component”, keeping the connected component separate. I do this even though I use static properties.



Or, you could probably do this (which is less extensible)


",danharper,connect
5,2015-07-17 05:10:04,"Hey there,

Redux is great. You all have done an awesome job finding a simple foundation for lots of things to be built on. I like that I can pretty much do anything I want, while still (theoretically) getting the benefit of everything like various devtools and debugging plugins. Great job!

I've been dwelling the past few days on a few personal customizations that I'm going to use, and I thought you all would be interested in one thing specifically. I'm not pushing for any changes to be integrated here because I know there's been a ton of discussion about the current API. But who knows, maybe you'll like it.

Relay (abstractly, don't know the details yet) does a ton of cool stuff, like data syncing. But there's actually something simple that I really love about it: a component can specify its data dependencies as a simple static property on itself. This ""colocation"" is _really_ powerful in my opinion.

The current API with `@connect` is not too far off from something similar: a primitive query that sits close to the component. But first, I don't love decorators, but that's not a huge deal (it's just a function). The main thing that I don't love is having to think about the separation of smart/dumb components.

What I love seeing is this:



The `localQueries` static property specifies paths into the app state that this component depends on. You can specify as many queries as you like, and they will all be available on `props`, under the last name in the path. This is just a slight change, it's exactly the same as this:



But I think it's easier to read. Also, there's a big opportunity to support _other_ types of queries, like if you use [`DataScript`](https://github.com/tonsky/datascript) to store app state in, you could specify DataScript queries.

The other nice thing is you can statically specify actions:



And my connector will automatically bind them to the current store.

Now, I know you recommend separating smart/dumb components, and the one wrapped by `connect` would live elsewhere, but personally I think it feels like too much work. I still need to wrap my component with `connect`, but it doesn't take any parameters, and the query exists on the component itself.

If you want the ""dumb"" component version of `LoggedInUser`, it's simply available as `LoggedInUser.dumb`. My `connect` wrapper adds it as a static property, so you can use it for testing and stuff.

I created a repo where I'm experimenting with this stuff: https://github.com/jlongster/redux-experiments. Look in ""static-queries"" and you'll see a demo of this in action. There are links in the README to the main source and a demo of it running.

Note the `static-queries-datascript` example also. This is the same thing, but demonstrates specifying a DataScript query instead, and using DataScript as the app state instead of JS object.

Sorry that this is a long dump, I thought you might find this interesting though. Feel free to close this issue.
",jlongster,connect
1,2015-07-11 22:34:38,"This API is taken from Redux `<Provider>`, `<Connector>`, `@provide`, `@connect`.
Right now I don't have examples in this repo but it matches what you've seen in Redux so far.

It's the best we've got now, but I think we can do better!

Common pain points:
- Not intuitive how way to separate smart and dumb components with `<Connector>`, `@connect`
- You have to manually bind action creators with `bindActionCreators` helper which [some don't like](https://github.com/gaearon/redux/pull/86)
- Too much nesting for small examples (`<Provider>`, `<Connector>` both need function children)

Let's go wild here. Post your alternative API suggestions.

They should satisfy the following criteria:
- Some component at the root must hold the `store` instance. (Akin to `<Provider>`)
- It should be possible to connect to state no matter how deep in the tree
- It should be possible to select the state you're interested in with a `select` function
- Smart / dumb components separation needs to be encouraged
- There should be one obvious way to separate smart / dumb components
- It should be obvious how to turn your functions into action creators
- Smart components should probably be able to react to updates to the state in `componentDidUpdate`
- Smart components' `select` function needs to be able to take their props into account
- Smart component should be able to do something before/after dumb component dispatches an action
- We should have `shouldComponentUpdate` wherever we can
",gaearon,connect
1,2015-07-11 22:34:38,"This API is taken from Redux `<Provider>`, `<Connector>`, `@provide`, `@connect`.
Right now I don't have examples in this repo but it matches what you've seen in Redux so far.

It's the best we've got now, but I think we can do better!

Common pain points:
- Not intuitive how way to separate smart and dumb components with `<Connector>`, `@connect`
- You have to manually bind action creators with `bindActionCreators` helper which [some don't like](https://github.com/gaearon/redux/pull/86)
- Too much nesting for small examples (`<Provider>`, `<Connector>` both need function children)

Let's go wild here. Post your alternative API suggestions.

They should satisfy the following criteria:
- Some component at the root must hold the `store` instance. (Akin to `<Provider>`)
- It should be possible to connect to state no matter how deep in the tree
- It should be possible to select the state you're interested in with a `select` function
- Smart / dumb components separation needs to be encouraged
- There should be one obvious way to separate smart / dumb components
- It should be obvious how to turn your functions into action creators
- Smart components should probably be able to react to updates to the state in `componentDidUpdate`
- Smart components' `select` function needs to be able to take their props into account
- Smart component should be able to do something before/after dumb component dispatches an action
- We should have `shouldComponentUpdate` wherever we can
",gaearon,provide
1,2015-07-12 01:37:50,"For example, we could drop `<Connector>` altogether and encourage people to use `@connect` decorator _as a function in another module_.

### Common case

A dumb component would look exactly as it does now.
A smart component would look like



Note that _the smart component doesn't have to be declared as a component_. Also note that `state => ...` and `dispatch => ...` is all it accepts.

### Case with more control

Want more customization? Want a `componentDidUpdate` hook? Want to select different things depending on the current props? Well, maybe you need to put a component in the middle then:



This is an “explicit” smart component that is required for more advanced cases.
Note that you didn't have to move files or refactor anything.
You just put a component in the middle into the same file.

### Shortcuts

Finally, we can still offer `bindActionCreators`, but with a `actionCreators => dispatch => obj` signature, so that the result is usable as the second parameter:



Perhaps we can even go further and bind automatically if an object is passed.



“Wait!”, I hear you say. What if an action depends on some prop from the state? Well, _in this case you put a component in the middle_ like I described above.



Any sufficiently complicated case => component in the middle. Easy!

Am I missing something?
",gaearon,connect
1,2015-07-12 09:17:51,"> we could drop `<Connector>` altogether and encourage people to use `@connect` decorator

I think it's a good idea, and we can do the same for `Provider`. This will simplify the API and create less confusion.

> This leads to more scalable, maintainable, testable code

@acdlite I was also thinking of dropping `bindActionCreators`, as it's just syntactic sugar for `dispatch(myAction())`, but you make a valid point.

And passing the actions as a second argument of `connect` makes it a good API, given that the binding becomes an implementation detail of the decorator and the user doesn't care about it.

One thing I would also like to have is **namespacing** props. Basically instead of just spreading the actions or whatever to `this.props`, we can have a `actions` object that contains all the actions, and just pass the object to `props`. Same thing could be done for `state`. I think this is important when you start having other data in `props` (e.g.: router) and helps avoiding possible conflicts when merging props.
Here an example:



Thoughts?
",emmenko,connect
1,2015-07-12 14:16:35,"I'd love to hear some thoughts from @faassen here.
",gaearon,faassen
1,2015-07-22 12:42:26,"The bindActionsCreators and dispatch thing got me thinking a bit.
I'm currently creating my store in a dedicated file and bind all my actions creators at the same place (the lazy method :) ).

Something like that:

store.js



and just reference this module to call actions in smart components (this part could use a decorator to pass arbitrary data into props to make it more explicit that this is a smart component):

MyComponent.js



(Side note: I'm not the only one doing something like that, see https://github.com/jhewlett/react-reversi/blob/master/js/actions/gameActions.js)

That got me thinking, what would be the downside in removing `<Provider/>` and `@provide` and use the store instance directly in the @connect decorator like this:

MyComponent.js



Maybe I'm missing something (any advantages in having the store in context?) but it seems more simple than the current API and easier to explain, it's actually one level ""lower"" than the current API, and the current API could be rebuilt on this in a separate lib.

It could also be simplified a bit by using a method to enrich the store with the react connect method:

store.js



MyComponent.js



Any thoughs on this? It's just an idea I don't use React/redux much except for a toy project so I'm not really a reference in this area but it never hurt to share ideas.
",guillaume86,connect
1,2015-07-22 12:42:26,"The bindActionsCreators and dispatch thing got me thinking a bit.
I'm currently creating my store in a dedicated file and bind all my actions creators at the same place (the lazy method :) ).

Something like that:

store.js



and just reference this module to call actions in smart components (this part could use a decorator to pass arbitrary data into props to make it more explicit that this is a smart component):

MyComponent.js



(Side note: I'm not the only one doing something like that, see https://github.com/jhewlett/react-reversi/blob/master/js/actions/gameActions.js)

That got me thinking, what would be the downside in removing `<Provider/>` and `@provide` and use the store instance directly in the @connect decorator like this:

MyComponent.js



Maybe I'm missing something (any advantages in having the store in context?) but it seems more simple than the current API and easier to explain, it's actually one level ""lower"" than the current API, and the current API could be rebuilt on this in a separate lib.

It could also be simplified a bit by using a method to enrich the store with the react connect method:

store.js



MyComponent.js



Any thoughs on this? It's just an idea I don't use React/redux much except for a toy project so I'm not really a reference in this area but it never hurt to share ideas.
",guillaume86,provide
1,2015-08-06 20:39:30,"Late to the conversation but wanted to add an alternative I haven't seen discussed for an action api. One thing I've noticed when writing my first couple redux apps is that redux does a fantastic job of getting almost all of the coupling of my model out of my components. I wanted to continue this trend by removing any coupling to the exact actions creators I'm invoking. The idea was to bind the actions to the dispatcher at the same/similar time that I ""bind"" the store to the react component tree. In this way I didn't need to import and/or know exactly which action creator I was invoking. I simply use it by name just like I use the state.



This is nice because action creators tend to store most of the business logic in the app and they often need things like api utils, etc. This pre-binding is a perfect opportunity to configure your action creators with things like an `apiUtils` object and then that stuff doesn't need to be known about in the view components and your action creator also doesn't need to be coupled to a specific `apiUtils` singleton like I see in many examples.

To be clear the `Provider` would be responsible for binding all actions passed into it to the store. This could be separated into a `StoreProvider` and `ActionProvider` if desired, and do not need to be done at the same time but I think that may be too much. The `Provider` then just adds the `store` and `actions` context values allowing `@connect` to access them.
",mmerickel,connect
