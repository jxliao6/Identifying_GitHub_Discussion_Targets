issue_num,datetime,body,login,mention_login
652,2017-03-20 15:59:07,"@ugogo No problem :) Thanks for your help !
@timdorr I just tested to delete the folder, and re-install the module again but still the same problem ..",arsenalol69,timdorr
652,2017-03-21 09:28:35,@jimbolla I don't understand why u want me to try a Jest test ? I has never used it and it will just try to run the project as I do myself... Maybe I just misunderstood the utility of the tool...,arsenalol69,jimbolla
650,2017-03-14 17:09:40,"Was about to write exactly what @timdorr wrote - you can pass the store as prop:

https://github.com/reactjs/react-redux/blob/master/src/components/connectAdvanced.js#L122",BTMPL,timdorr
648,2017-03-13 22:12:38,"As @markerikson said, you're better off doing that optimization inside `mapStateToProps`.",jimbolla,markerikson
647,2017-03-09 19:44:30,"I don't have 1 month in React/Redux, so, I'm pretty new at it.

And you're right @markerikson, I was trying to say that I want multiple components to use the same matpStateToProps function, without creating other Containers, just determining the component by using the connect(props, dispatchs)([component1, component2, component3)",DanZeuss,markerikson
647,2017-03-09 19:52:28,"Yeap, and I'm doing this. I just wish verify if would be a nice implementation by doing as I said before. Thanks anyway @markerikson ",DanZeuss,markerikson
644,2017-03-08 05:42:42,"Sorry about that @markerikson, I did check the opened Issues but I didn't checked the opened PRs. Well, I hope that PR gets merged soon. Thanks!",josepot,markerikson
640,2017-03-03 23:49:02,"Thanks for the input, @markerikson. I changed the calling of `playFile` to `playFile(sectionArray[0],sectionArray)(dispatch)` and it's working now.",natashache,markerikson
640,2017-03-04 00:23:33,@gaearon thanks! It definitely reads better that way.,natashache,gaearon
628,2017-02-22 15:28:19,"@jquense  For consistency, can you change the one in [Provider](https://github.com/reactjs/react-redux/blob/master/src/components/Provider.js#L54) as well?",jimbolla,jquense
628,2017-02-22 18:02:00,@jimbolla Took care of that. Put our shape definitions in one spot.,timdorr,jimbolla
625,2017-02-17 19:40:55,@markerikson Yeah. I think https://github.com/reactjs/react-redux/issues/507#issue-179829234 explains why sCU isn't a requirement anymore.,jimbolla,markerikson
625,2017-02-18 02:44:24,"Yeah, that was really meant for @jimbolla .

Looking at that deleted couple lines, I'm pretty sure `sCU` is still necessary for preventing re-renders from parents, and that without it, the wrapper is really only able to deal with changes from `map*`-related values.

Although re-reading Jim's comment from the other thread, maybe I'm misunderstanding this?",markerikson,jimbolla
622,2017-02-16 12:58:48,@timdorr thank you!,TrevorHinesley,timdorr
620,2017-02-11 17:14:28,@jimbolla I didn't know that this was mutating the state 👍 . However the issue at hand is not resolved by implementing the suggestion. I still have the exact same behavior. Any other things that this could cause?,nealoke,jimbolla
620,2017-02-11 17:32:27,"@jimbolla Also when using the destructuring redux no longer updates the state correctly. It says the state is equal. See attachements

**Redux state**
![image](https://cloud.githubusercontent.com/assets/17417414/22855927/375eacb6-f088-11e6-81d9-17e898acf029.png)
 
**Action**
![image](https://cloud.githubusercontent.com/assets/17417414/22855936/5325649e-f088-11e6-9b8c-2cf4f528a18e.png)

**Diff**
![image](https://cloud.githubusercontent.com/assets/17417414/22855940/6b3be026-f088-11e6-8092-1005ca647446.png)
",nealoke,jimbolla
619,2017-02-28 03:15:57,"@timdorr @dsgkirkby Hi, this seems to be still broken.

Please see

https://github.com/reactjs/react-redux/issues/636

Thanks",BerndWessels,timdorr
616,2017-02-05 20:05:59,"@jimbolla no problem, test added",lukeapage,jimbolla
610,2017-01-27 20:12:22,"@timdorr _

> you would just issue actions to your redux store and each component would subscribe to the relevant bits of state.

_Could please relavent reference or  sample piece code to better understanding. 

Exact issue I am not able to reslove dispatch action  updating source component but not getting update data in other component.

![screenshot from 2017-01-28 01-30-04](https://cloud.githubusercontent.com/assets/13597781/22385980/fb79beae-e4fa-11e6-9e14-0ba3770048f2.png)
",iiitmahesh,timdorr
610,2017-01-27 21:00:22,@timdorr Thank you.,iiitmahesh,timdorr
609,2017-01-26 22:02:45,"Thanks for the solution guys, got it going with what @markerikson suggested but the option of enhanced profile seems very clean as well, thanks!",oshalygin,markerikson
606,2017-01-23 02:54:14,"@jimbolla Oh,you're right, thanks",crimsonskyrem,jimbolla
603,2017-01-20 02:20:55,"@jimbolla  @timdorr 

As you say, our framework depend on **react-redux@4.x**, we plan to upgrading **react-redux** to v5 and increment framework **MAJOR** version, not MINOR.

e.g.



I'm happy to see **react-redux@5.x**, it's nice for **compatibility**, **performance improvements** and others features.
But sometime, something isn't controlled by me, I have to think about that the framework must be stable, safe and other.

I can't promise that anything is ok if I upgrading **react-redux** to v5 and increment framework **MINOR** number.
It may bring some hidden problems, it has some risk. 

So I want to fix this issue for currently framework with **react-redux@4.x**.
And next, I will plan to upgrading **react-redux** to v5 and increment framework **MAJOR** version.",ipluser,timdorr
603,2017-01-20 02:20:55,"@jimbolla  @timdorr 

As you say, our framework depend on **react-redux@4.x**, we plan to upgrading **react-redux** to v5 and increment framework **MAJOR** version, not MINOR.

e.g.



I'm happy to see **react-redux@5.x**, it's nice for **compatibility**, **performance improvements** and others features.
But sometime, something isn't controlled by me, I have to think about that the framework must be stable, safe and other.

I can't promise that anything is ok if I upgrading **react-redux** to v5 and increment framework **MINOR** number.
It may bring some hidden problems, it has some risk. 

So I want to fix this issue for currently framework with **react-redux@4.x**.
And next, I will plan to upgrading **react-redux** to v5 and increment framework **MAJOR** version.",ipluser,jimbolla
602,2017-01-19 17:25:03,"@markerikson Well, part of the reason why I love Redux so much is that it's very minimalistic and both understanding the internal logic and writing extensions is so easy. If need be I'll make it into a package, but I really believe that basic support for HMR should be built into Redux, that's why I initially decided to open a ticket for it.
@jimbolla You're right, it should have been a ticket for the Redux repository. When I first opened the ticket I wasn't sure about that because I thought maybe the Provider can be modified to support this feature, but after some more research and writing the snippet I provided it's clear as day that this isn't the place. Furthermore, I'd really like to see your overall solution for store enhancers, it sounds like the right approach! When you're ready, of course :)",iMoses,jimbolla
602,2017-01-19 17:25:03,"@markerikson Well, part of the reason why I love Redux so much is that it's very minimalistic and both understanding the internal logic and writing extensions is so easy. If need be I'll make it into a package, but I really believe that basic support for HMR should be built into Redux, that's why I initially decided to open a ticket for it.
@jimbolla You're right, it should have been a ticket for the Redux repository. When I first opened the ticket I wasn't sure about that because I thought maybe the Provider can be modified to support this feature, but after some more research and writing the snippet I provided it's clear as day that this isn't the place. Furthermore, I'd really like to see your overall solution for store enhancers, it sounds like the right approach! When you're ready, of course :)",iMoses,markerikson
599,2017-01-08 16:23:36,@jimbolla I get the error getChildContext is not a function. Am I missing something?,MartinDawson,jimbolla
599,2017-01-08 17:41:31,"@jimbolla That worked and is exactly what I needed. Thank you so much. If you want the bounty on SO I will award it to you if you copy that answer. If not, I shall post the answer and link here.",MartinDawson,jimbolla
599,2017-03-18 21:54:43,"Thanks @jimbolla for this answer, it was exactly what I was looking for.  Question:  what kind of performance hit should we expect from always using props now in our `mapStateToProps` and `mapDispatchToProps`?",neurosnap,jimbolla
592,2016-12-31 23:35:39,Also thanks for your help @markerikson. If you want I can try to come up with a gist that has a reproduction of the areMergedPropsEqual method not being called. Though all of the key info is in my snippet in the original comment. ,bdwain,markerikson
592,2016-12-31 23:50:18,@jimbolla won't shouldComponentUpdate do that? It seems to work in my specific case at least.,bdwain,jimbolla
589,2016-12-28 22:10:57,"Thanks @jimbolla  - the general idea is that this should work:



If I'm not mistaken, `<Bar>` should subscribe to its `ownStore` as if it were its own `<Provider>` (because it essentially is) instead of depending on parent subscriptions.",davidkpiano,jimbolla
589,2017-01-31 04:33:55,"@jimbolla , @timdorr : following up on this at @davidkpiano 's request.  It's Jim's code thus far, and Tim's been cutting releases (something I should go figure out for myself at some point, but don't have time to dig into atm).  Are we good to go on this?",markerikson,jimbolla
589,2017-02-05 17:05:17,@timdorr @markerikson It might be easier to review the 2 commits separately. The bugfix one is pretty small and the refactor one just moves a few things and adds some more comments.,jimbolla,timdorr
589,2017-02-05 17:05:17,@timdorr @markerikson It might be easier to review the 2 commits separately. The bugfix one is pretty small and the refactor one just moves a few things and adds some more comments.,jimbolla,markerikson
589,2017-02-14 14:52:55,@timdorr please release this fix,anru,timdorr
589,2017-02-28 02:17:43,"@timdorr The `react-redux 5.0.3` update breaks HMR with latest `react-hot-loader 3.0.0-beta.6`.

Basically after a hot-reload the state is somehow broken.

This worked fine in `react-redux 5.0.2` :(


repo to reproduce: https://github.com/BerndWessels/react-redux-rr4-wp2-rhl3.git

Work fine with `react-redux 5.0.2` but broken when you upgrade to  `react-redux 5.0.3`",BerndWessels,timdorr
582,2016-12-21 16:53:59,"> Are you updating the first store, but expecting a component inside the second <Provider> to respond to that update?

Nop. Everything inside the ""mini app"" is self contained. So something inside send an action and update its own reducer. I only expect the mini app to be updated. The ""parent app"" has nothing to do with that.

I'm making another small project to reflect the issue. Stay tuned.

@jimbolla Maybe it's not the usual use case, but I'm having the issue because my ""mini app"" can live as a standalone application, but also embedded inside another app.
",tleunen,jimbolla
582,2016-12-21 17:44:42,"@jimbolla : I'd say that if we can fix it without much hassle, then we might as well go ahead and do so.  Sounds like it's ""just"" a matter of adding a couple more entries to context, right?",markerikson,jimbolla
576,2016-12-17 16:44:25,I agree with @appden here. For instance `shallowEqual` in react-redux doesn't account for `NaN`. If an object contained any `NaN` value then `shallowEqual` would always return `false`.,jcready,appden
575,2016-12-14 19:11:05,"@jimbolla If you have some complex containers, that connect some components on different levels of result tree, the scenario with `<Container propName=""propB""/>` suggests passing `propName` from outer component to inner component. `Provider` component is really great thing because it passes `store` in tree context. I think that passing `propName` is a step back in this circumstances.

@markerikson Isn't it a good decision to add some component to `react-redux` (just like `Provider`) that makes this context and store manipulations?",verkholantsev,jimbolla
575,2016-12-14 19:11:05,"@jimbolla If you have some complex containers, that connect some components on different levels of result tree, the scenario with `<Container propName=""propB""/>` suggests passing `propName` from outer component to inner component. `Provider` component is really great thing because it passes `store` in tree context. I think that passing `propName` is a step back in this circumstances.

@markerikson Isn't it a good decision to add some component to `react-redux` (just like `Provider`) that makes this context and store manipulations?",verkholantsev,markerikson
574,2016-12-14 17:02:50,@jimbolla looks like just copy paste mistake. Sorry.,btd,jimbolla
574,2016-12-14 17:24:30,@timdorr thanks 👍,btd,timdorr
571,2016-12-14 04:16:05,@gaearon thank you much!,toranb,gaearon
564,2016-12-10 20:23:52,Ah. The good news is this seems to be fixed if built against the head of `next` branch. @timdorr Any chance we can push an rc2?,jimbolla,timdorr
551,2016-11-27 18:43:18,"@markerikson wow, thanks, I'll try))",BjornMelgaard,markerikson
541,2016-12-14 14:42:53,@timdorr Awesome thanks!,bbenezech,timdorr
540,2016-11-15 20:53:00,"@timdorr Currently swamped with other things. Will perf test when I have a large block of time. Hopefully this weekend.
",jimbolla,timdorr
540,2016-11-21 05:48:40,@timdorr why remove the provider api? I want to use this compat mode for redux-form components but want everything else in the app to use the efficient sub ordering. Having to set this on each connected component seems an unnecessary chore. have it be defaulted to true in 5.0 but why make opting into performance more difficult than it needs to be?,gnoff,timdorr
540,2016-11-21 07:19:29,This works but it also means code modding / find replacing a large number of files with the need to do so again as soon as 5.1 comes out. I'm not adamant that this get added back in but the trade offs aren't cost free for users ( I realize they aren't cost free for the lib either since it requires supporting ). I could be misguided here but I think the cost is higher on lib consumers. Just lending my annecdote to @jimbolla intuition that a configurable global default might be desired.,gnoff,jimbolla
540,2016-11-21 14:45:04,"@timdorr I'll concede taking it out of provider, but we should leave in the ability to pass the setting from props/context. Props is especially important if you want to control it through a library such as redux-form that hides the `connect` call. ",jimbolla,timdorr
540,2016-11-21 19:49:07,"@jimbolla Yeah, I think that works better. Maybe call it `connect.setDefaultReact15CompatibilityMode()` so it's clear that it's global and changes the default.",timdorr,jimbolla
540,2016-11-21 22:17:02,@jimbolla @timdorr @markerikson thanks all,gnoff,timdorr
540,2016-11-21 22:17:02,@jimbolla @timdorr @markerikson thanks all,gnoff,jimbolla
540,2016-11-21 22:17:02,@jimbolla @timdorr @markerikson thanks all,gnoff,markerikson
539,2016-11-07 23:06:59,"@markerikson oops, I meant submit this to a completely different project, I guess I had the wrong window open.  my bad
",clindsey,markerikson
538,2016-11-09 21:01:48,"@timdorr I can't change my own branch in edit. I opened a new PR.
",bbenezech,timdorr
534,2017-01-10 12:43:26,@jimbolla I include only once **react-redux** at each component where **connect** is required :(,plandem,jimbolla
534,2017-01-10 13:14:18,"@jimbolla 

1) I have npm package with component that connects to redux (so it has dependency on **react-redux**). let's name it **MyProvider**

2) in my application I also connect other components, so it depends on **react-redux**

I moved **MyProvider** from npm package directly to application and there is no error anymore.

Is problem here? ",plandem,jimbolla
528,2016-10-22 21:47:24,"<s>@timdorr Where can I find the official lodash next npm module?

Nevermind - got the repos mixed up.
",kzc,timdorr
525,2016-10-19 17:22:53,"@markerikson Indeed it is.

As another experiment, I just tried [switching React for Preact](https://preactjs.com/guide/switching-to-preact) in my own project and the bug goes away.
",jimbolla,markerikson
525,2016-10-24 16:09:13,"Hey @jimbolla Sorry didn't see your reply - I just removed my comment as I realised it was a different issue and didn't want to pollute this issue. I was still using `15.0.0` and the cursor fix was in `15.0.1`
",johnnycopperstone,jimbolla
525,2016-10-24 16:33:57,"@timdorr True, but our answer can't just be ""use Preact instead"" unfortunately. What I'm thinking...
- IMO, the new top-down ordering is the ""right"" way to do it, and much of the perf gains and many of the bug fixes are because of it. We could remove it, but that undoes a lot of the benefits of v5.
- This does seem like a bug in React that the new subscription ordering is exposing, but one that doesn't seem easy to fix, and even if it was, that fix wouldn't make it to release in a timely fashion, such that we can ignore it. I did pull and build react master, and the bug still exists.
- I'm guessing this bug might manifest itself in react-redux v4 if redux were to fire subscriptions in reverse order because of how it relates to the timing of which components receive new props first. I might try test this just for awareness of the issue.
- If we keep top-down as the default behavior, we need to make it as painless as possible to work around this issue, and make devs aware of it.
  - While it's certainly solvable in userland using the code provided above, I'd hate to force that on everyone, lest we be accused of creating javascript fatigue. 👅
  - The best solution I have right now is for `connect` (actually `connectAdvanced`) to offer an opt-in option that would allow that component to skip the subscription tree and subscribe directly to the store, making it work like v4. Devs that are using controlled text inputs would have to set this option to true. I don't know what to name this option. Libraries like redux-form would have to handle this as well. Docs would have to stress this as it's a bug that isn't discovered easily, because I doubt many devs test entering values in the middle of an input.
",jimbolla,timdorr
525,2016-10-26 09:28:17,"@gaearon 
[repro with react only](http://www.webpackbin.com/E1rDED_1f): 


",Guria,gaearon
525,2016-10-26 13:28:46,"@jimbolla This does not look like a bug to me. It is documented that `this.state` contains _the rendered_ value of the state. There is no guarantee that calling `setState()` will update `this.state` synchronously. Therefore, by reading from `this.state` you won't get the just-updated value.
",gaearon,jimbolla
525,2016-10-26 13:50:59,"@gaearon But It's happening as part of the callback of setState(), which _should_ have the new state. But even still, if I store the state in a global variable and read from there instead of component state, it behaves the same way. This seems more related to when React reconciles the current value of the input's value prop with what's actually in the DOM element. Basically, by the time the callback to setState fires, it's too late. I can update the code to make this more clear.
",jimbolla,gaearon
525,2016-10-26 14:13:25,"@gaearon I updated my above example to use global variable. You can toggle the `makeTheCursorJump` variable to see the 2 different behaviors. This is the core difference between react-redux master and next in its simplest form. A lot of the perf gains and the bugfix related to props/state being out of sync boiled down to this change.
",jimbolla,gaearon
525,2016-11-08 20:55:29,"@jimbolla Can you submit a PR to React with a test case for this?
",gaearon,jimbolla
525,2016-11-08 21:48:28,"I confirmed commit https://github.com/facebook/react/commit/5f49b63bde09567fb3d52a13e3e264dfcda5cac6 (PR https://github.com/facebook/react/pull/8204) is the commit that fixes the problem. Bug exists when the above demo is run against its parent, but doesn't when run against it.

I'll see what I can do about turning that code above into a complete test, but admittedly, this will be pushing the limits of my JS/testing abilities. Assuming I can turn it into a test, do I submit it as a PR to react master?

I still need to test react-redux@next against react master to confirm the fix. I'm probably like 85% sure that it will work though.

@gaearon Do you have any insight into when React v16 might launch? Are we sure 8204 will be a part of that and not a 15.x minor release?

Is our plan to not release react-redux v5 to stable until we can bump our React dependency to whatever version includes the fix? If so, do we want to offer an interim solution for the users that want to use the beta? Something like:



This would be a temporary feature that bypasses the subscription ordering.
",jimbolla,gaearon
525,2016-11-09 17:56:03,"> Yes, we can't release a stable version of React Redux that is incompatible with the stable version of React.

We'll do it within a set of 5.0 and 5.1 releases. 5.0 goes with React 15 and has this extra option for those that need it; 5.1 goes with React 16 and doesn't need the option (basically, it switches default to enabled). Hence the 5.1 milestone on this issue :)

@jimbolla Can you prep a PR to add the option to reorder the subscriptions? Maybe call it `reorderSubscriptions`? It doesn't need to be lengthy and scary. It would be ignored in 5.1. 
",timdorr,jimbolla
525,2016-11-10 00:07:18,"@jimbolla If you're able to make a simple test case depending only on React that exhibits the issue in a browser but you're struggling with jsdom, that would be very helpful and I can look at turning it into an automated test.
",spicyj,jimbolla
525,2016-11-10 16:11:32,"@jimbolla With the compat option on, does the perf regress over 4.x? What is the main benefit of 5.x for the people while it's enabled?
",gaearon,jimbolla
523,2017-02-18 07:24:01,@timdorr this slipped my mind completely! I'll work on the changes requested over this weekend,neeharv,timdorr
523,2017-02-18 08:19:27,@timdorr @jimbolla I've cleaned up the test and memoized the response of the factory. Also updated API docs. Do let me know if there is anything else you'd like me to do. Thanks!,neeharv,timdorr
523,2017-02-18 14:26:40,@timdorr much easier to just do it in a new branch for me. The new PR is here is #626. Closing this so you can take a look there! Thanks.,neeharv,timdorr
522,2016-10-13 21:26:44,"Ahhhhhhhh - thank you @markerikson, it never occurred to me that it had applications for HoCs as well, not just middlewares :)
",rubyruy,markerikson
522,2016-10-13 21:27:13,"Amusingly, @epeli pointed it out at the exact same time I did, just right before your ""concrete example"" comment :)
",markerikson,epeli
522,2016-10-13 21:30:08,"See #407 and #416 for the gory details, but it's basically a complete reimplementation to improve performance and fix edge cases.  Courtesy of @jimbolla .
",markerikson,jimbolla
517,2016-10-14 01:19:59,"@jimbolla I rebased and amended the commit to include a test that would fail with an exception prior to this change. It's a pretty contrived reduction of what happened in my codebase.
",appden,jimbolla
513,2016-11-27 14:54:18,@timdorr Recently discovered the same error — [here’s the project](https://github.com/patrikholcak/hot-loader-demo/tree/81e03e19b4a22b68038431482d7cb225f5f25f90). If you try to HMR `./src/routes/counter.js` you’ll see the exact same error. Downgrading to `react-redux@^4.4.6` fixed it,patrikholcak,timdorr
510,2016-10-04 17:39:42,"In addition to what @markerikson said, there's also more comments in the new version, currently in the `next` git branch. I tried to add comments to the stuff that is not-obvious, but what's obvious to one person, won't be the same was what's obvious to another. If there's specific areas of the code that you feel need greater explanation, please point them out.
",jimbolla,markerikson
510,2016-10-04 18:00:43,"Thanks @markerikson & @jimbolla 

I have two questions about the wrappedcomponent generated by connect function, .
1. the state of every wrappedcomponent is the whole state tree ? 
2. trigger re-rendering of wrappedcomponent based on the state selected in mapstattoprops()?

these concepts should be clarified in the introductory, or people will get confused.
",zhangk2000,jimbolla
510,2016-10-04 18:00:43,"Thanks @markerikson & @jimbolla 

I have two questions about the wrappedcomponent generated by connect function, .
1. the state of every wrappedcomponent is the whole state tree ? 
2. trigger re-rendering of wrappedcomponent based on the state selected in mapstattoprops()?

these concepts should be clarified in the introductory, or people will get confused.
",zhangk2000,markerikson
510,2016-10-05 00:31:00,"Yeah, given that we now have some more examples in there thanks to @jimbolla , I can live with that.
",markerikson,jimbolla
509,2016-10-03 14:06:13,"Thanks @epeli this worked very well! BTW is this the way you solved it in v5?
",ynonp,epeli
507,2016-09-28 18:15:34,"@timdorr I don't think changing where the computed props are stored would unblock things. The issue is that the implementation of `shouldComponentUpdate` can't do ""the computed props have changed **or something in context has changed**"". I'm pretty sure there are some open issues in React about adding new methods for components to communicate context changes, but that doesn't help us today.
",jimbolla,timdorr
507,2016-10-24 16:04:01,"@jimbolla How about we do this as a test release (5.0.0-test.1) and see what the effects the community can find? I'd also love to have a benchmark suite available so we can have an objective analysis on our own, but that could work in a pinch until we get something built out.
",timdorr,jimbolla
506,2016-09-28 13:43:37,"@timdorr done!
",roncohen,timdorr
504,2016-09-27 13:32:04,"@jimbolla Thanks a lot :+1: 
I've misunderstood the behavior of this function
",mafzst,jimbolla
503,2016-09-27 02:43:09,"@markerikson thank you for the reply.  In my example, NewCustomerContainer is the container and CustomerForm is my plain one, so I think I am already doing what you suggest.
",stevenmusumeche,markerikson
502,2016-12-19 16:51:21,"I had to struggle a bit but @timdorr is right about the `Provider`. I'm sharing my setup below with the hopes that it'll help.

**index.ios.js**


**Main.js**


**configureStore.js**
",a-koka,timdorr
498,2016-09-24 05:36:20,"@timdorr ok, but can it be in both branches? I just want to get this published sooner than later.
",btd,timdorr
496,2016-09-23 16:00:10,"You should inspect what props your underlying component receives. If `ownProps` has a key called `myProps`, then your component should have a props key called `myProps` without needing to explicitly include it in `mapStateToProps`, like @markerikson said.

It sounds like you might be mutating the nested pieces of the `myProps` object in place, which won't trigger a re-render in and of itself.  How are you actually ""updating"" `changedProp`?

When you said ""props received"", how do you know they are received? Are you investigating inside `compnentWillReceiveProps` or something?

Forgetting redux for a moment, consider this example:



Changing `window.someValue` will not cause `ChildComponent` to rerender --- `ChildComponent` won't receive the new value until `Parent` renders.  When you change values, you need a component somewhere in the ancestor chain to get the ball rolling, with something like a `setState`
",naw,markerikson
490,2016-09-17 13:38:14,"Fair enough. I just thought I would put it out there in case there's a rollback or something.

@jimbolla it's funny you should say that about needless setState calls because I thought that was the important problem to solve when doing blackbox. But if I'm not mistaken, react made some internal changes to deal with this issue. (it's extremely possible that I'm completely missing something here, so please correct me if I am wrong.)

Here's the scenario
 lets say you have two connect components that will setState on the same store changes, and one component is inside the other. When the store changes, they both setState,  but the parent setState takes priority, and the child setState will only fire if the render propagation fails to reach it. (Because of a false shouldCompomentUpdate in between them)

Is there still a performance gain then?
",l2silver,jimbolla
490,2016-09-18 01:07:47,"@jimbolla Ah, got it! Brilliant. Now it makes sense.
",l2silver,jimbolla
488,2016-10-05 00:32:39,"@jimbolla's correct. I'd like to leave new features/APIs to the next branch for now. We can do bugfixes on 4.x, but I kind of doubt it's going to need anything major in the meantime :)
",timdorr,jimbolla
483,2016-09-06 09:42:01,"@markerikson object shorthand syntax is very handy, and I do use it. But we can still introduce errors. Imagine we have a container that the only thing it does is to dispatch an action (to fetch data for instance) when the component is mounted. I'd be very nice if I can double check that the action it dispatches is the one we want.

@jimbolla that's really interesting approach, I'm going to rethink my implementation with that in mind. Though it also needs `connect` to be executed, and it's not ideal as markerikson pointed. But I can't think of any approach to verify the action without connecting the component. 

Another thing that I'm trying to achieve with my PR is to avoid expensive operations that the actions may execute (like fetching data from an API). Using Sinon to generate test doubles of the actions is not easy.

Keep your good feedback and ideas guys, very appreciated!
",alexlbr,jimbolla
483,2016-09-06 09:42:01,"@markerikson object shorthand syntax is very handy, and I do use it. But we can still introduce errors. Imagine we have a container that the only thing it does is to dispatch an action (to fetch data for instance) when the component is mounted. I'd be very nice if I can double check that the action it dispatches is the one we want.

@jimbolla that's really interesting approach, I'm going to rethink my implementation with that in mind. Though it also needs `connect` to be executed, and it's not ideal as markerikson pointed. But I can't think of any approach to verify the action without connecting the component. 

Another thing that I'm trying to achieve with my PR is to avoid expensive operations that the actions may execute (like fetching data from an API). Using Sinon to generate test doubles of the actions is not easy.

Keep your good feedback and ideas guys, very appreciated!
",alexlbr,markerikson
483,2016-09-06 16:38:43,"@gaearon: Dan.  You're supposed to be on vacation.  STOP COMMENTING ON ISSUES AND GO DO VACATION-Y THINGS! :)

(But yeah, exposing `mapState` and `mapDispatch` seems totally reasonable, since we already do the component as well.)
",markerikson,gaearon
475,2016-08-28 14:13:12,"Your solution works perfectly.  Thanks @jimbolla !
",wookiem,jimbolla
473,2016-09-09 15:26:33,"@markerikson Can you give me an example of what to add in there for manual tags and I'll update the docs this weekend?

@timdorr Thoughts on adding the beta release to the github releases tab?
",jimbolla,timdorr
473,2016-09-09 15:26:33,"@markerikson Can you give me an example of what to add in there for manual tags and I'll update the docs this weekend?

@timdorr Thoughts on adding the beta release to the github releases tab?
",jimbolla,markerikson
473,2016-09-09 15:41:54,"@jimbolla : You can stick HTML straight into Markdown, so what I did was insert `<a>` tags right before each appropriate section header.  I gave each anchor a custom relevant shorter name, as opposed to the long auto-generated names from the slugified header text:


",markerikson,jimbolla
473,2016-09-11 00:43:38,"@markerikson I threw some a tags in PR #480
",jimbolla,markerikson
473,2016-09-12 20:22:41,"@timdorr It's all good. I appreciate that everyone has their own things going on. I just want to make sure this doesn't get lost.
",jimbolla,timdorr
473,2016-11-29 20:29:45,@timdorr Let me know if I can help.,jimbolla,timdorr
473,2016-12-07 16:40:41,"@timdorr I think everything's good to go. Perf tests look good. The only known issue is broken HMR (#513) which I can spend some time fixing while on christmas vacation. I added a note about that to the release notes draft, which look good.",jimbolla,timdorr
473,2016-12-07 21:50:34,@timdorr Can we publish an rc2 with the expected 5.0 change?,gnoff,timdorr
473,2016-12-07 22:45:01,"@gnoff If you're eager to test it, I published the latest changes as `@jimbolla/react-redux`. You can `npm install` that and then if you're using webpack, you can alias that on top of react-redux proper: 
```js
{
  resolve: {
    alias: {
      'react-redux': '@jimbolla/react-redux',
    }
   }
}",jimbolla,gnoff
473,2016-12-07 22:45:01,"@gnoff If you're eager to test it, I published the latest changes as `@jimbolla/react-redux`. You can `npm install` that and then if you're using webpack, you can alias that on top of react-redux proper: 
```js
{
  resolve: {
    alias: {
      'react-redux': '@jimbolla/react-redux',
    }
   }
}",jimbolla,jimbolla
473,2016-12-08 08:56:16,"@jimbolla sorry, I didn't understand well the release note. As I don't have any issue with the beta3, I'll keep it until the flag is removed. Thanks for your reply.",ghigt,jimbolla
473,2016-12-10 03:06:03,"Just saw your Reddit comment at https://www.reddit.com/r/reactjs/comments/5hf4d4/an_artificial_example_where_mobx_really_shines/db09sf2/ .  Quoting for posterity:

> To be honest I'm still feeling wary about subscribing in order. This feels like a hack for something React can already do in the batched mode. But I'm not actively involved now so it's hard for me to say.

@jimbolla is way more familiar with the guts of this, and you're obviously _way_ more familiar with the guts of React, but as I understand it there's two main intended benefits:

- Ensure that we don't have children subscribing before parents, as can happen in 4.x.  The current behavior results in nasty bugs if you're using the ""connected parent passing IDs to connected children"" pattern, as a child whose item just got deleted may try to retrieve no-longer-existing data before its parent has a chance to re-render without that child.  Top-down subscriptions solve that by ensuring that the parent re-renders first, causing the child to unmount.
- By handling things top-down, it minimizes wasted effort, since a connected child won't call `setState` before its parent has.",markerikson,jimbolla
473,2016-12-11 23:17:54,"@jimbolla , side question: per your comments in https://github.com/dtinth/pixelpaint/pull/1#issuecomment-266211907 , any other tweaks you can think of that would help improve perf in that kind of scenario?  I know, I know, all programming is tradeoffs and nothing is perfect, just would be nice to say that v5 is better in every way :)",markerikson,jimbolla
472,2016-08-25 19:13:15,"@timdorr Do you think this is ready for another alpha release?
",jimbolla,timdorr
469,2016-12-29 22:05:28,"I can help out with this if nobody has dibs. Wouldn't the PR have to go to ""redux"" repo proper for this file: https://github.com/reactjs/redux/blob/master/docs/basics/ExampleTodoList.md ? @markerikson @timdorr 

Thanks guys!",mtomcal,timdorr
469,2016-12-29 22:05:28,"I can help out with this if nobody has dibs. Wouldn't the PR have to go to ""redux"" repo proper for this file: https://github.com/reactjs/redux/blob/master/docs/basics/ExampleTodoList.md ? @markerikson @timdorr 

Thanks guys!",mtomcal,markerikson
466,2016-08-19 13:21:44,"I agree with @gaearon that `mapStoreToProps` would be incorrect. I suppose `mapStoreStateToProps` would be correct and would be slightly more clear, but ugh... getting too verbose for my liking.

I will say that the method signature for `connect` has been an issue for several of my team, who I'll admit probably just need to read the docs a little more carefully. I've thought a lot about alternate signatures but so far haven't come up with anything that's clearly better.
",jimbolla,gaearon
465,2016-08-18 17:49:55,"@jimbolla will do as soon as I get back to my computer.
",vhmth,jimbolla
465,2016-08-19 21:05:18,"Sounds good @timdorr. Saw that @jimbolla already has a fix he's playing around with. Again - thanks for the work on this next release guys!
",vhmth,timdorr
465,2016-08-19 21:05:18,"Sounds good @timdorr. Saw that @jimbolla already has a fix he's playing around with. Again - thanks for the work on this next release guys!
",vhmth,jimbolla
460,2016-08-16 20:51:27,"@jimbolla Thanks your answer!! In this component , your way is worked! But the most serious problem is on `ReduxListView` component, i change this issue , the example code is the `selector` of `ReduxListView` component. 
",fengliu222,jimbolla
457,2016-08-16 06:19:19,"@timdorr not it does not, I created a branch that you can use to repro it.

Branch: https://github.com/Restuta/rcn.io/tree/react-redux-connect-bug

Steps to repro:
- `git clone git@github.com:Restuta/rcn.io.git`
- cd `rcn.io`
- `npm i && npm run dev`
- open [http://localhost:8888/events/8](http://localhost:8888/events/8) in your browser
- open console
- click on MTB in the header and then back to ""Event 8""

You should see in console:

""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Connect(EventDetails) component.""

Notice that the only change from ""dev"" branch is bump of `redux-react` and you can test it yourself that issue is not happening with `4.4.5`.  @jimbolla 
",Restuta,timdorr
457,2016-08-16 06:19:19,"@timdorr not it does not, I created a branch that you can use to repro it.

Branch: https://github.com/Restuta/rcn.io/tree/react-redux-connect-bug

Steps to repro:
- `git clone git@github.com:Restuta/rcn.io.git`
- cd `rcn.io`
- `npm i && npm run dev`
- open [http://localhost:8888/events/8](http://localhost:8888/events/8) in your browser
- open console
- click on MTB in the header and then back to ""Event 8""

You should see in console:

""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Connect(EventDetails) component.""

Notice that the only change from ""dev"" branch is bump of `redux-react` and you can test it yourself that issue is not happening with `4.4.5`.  @jimbolla 
",Restuta,jimbolla
457,2016-08-16 18:59:02,"@jimbolla that address is in SSH format, of you prefer HTTPS then yes, use that one
",Restuta,jimbolla
457,2016-08-19 21:49:56,"@jimbolla what do you think the timeline is for getting this in? This is the last thing before #465 gets in, which is causing some UI issues for our beta users so I'm more than happy to write some tests if you're feeling tied up. :-)
",vhmth,jimbolla
457,2016-08-20 04:59:35,"@vhmth Unfortunately I have commitments this weekend, so I won't be able to work on it again until Monday evening. I have off Tuesday and plan to work on it then as well.

I started writing a test but am having difficulty reproducing the behavior from scratch. I'm going to take a different approach and start with @Restuta's project and just start ripping out all the unrelated code until I'm left with the minimum code that reproduces the error. Then I'll turn that into a test.
",jimbolla,vhmth
457,2016-08-20 05:07:08,"Sounds like a plan @jimbolla. If I have some time later on Sunday, I'll see if I can repro too. Maybe that will save ya some time and you could turn that into a test if I come up with that minimal example.
",vhmth,jimbolla
457,2016-08-22 06:15:06,"Hey guys I'm sorry about the push off. A lot of stuff landed on my plate (life stuff) this weekend and couldn't get to working on repro-ing that bug. I will try tomorrow afternoon. I know @jimbolla said he wouldn't be able to get to it until tomorrow too, but it may be good to have two set of eyes on trying to repro it.
",vhmth,jimbolla
455,2016-08-15 02:31:22,"I've got to agree with @jimbolla here. Redux has both an API and a guaranteed way of behaving. And that behavior can be fairly critical to this library and isn't always documented exactly. If you happen to build something that works with it, great, but a hard requirement on Redux is going to be needed. 

At the very least, if your minification process is sufficient, any bytes spent on Redux code should be eliminated by dead code removal. And if you _really_ want to get rid of it, you can use an alias in your build process to an empty module.
",timdorr,jimbolla
455,2016-08-15 06:42:21,"@timdorr Thanks for the explanation!
",adamterlson,timdorr
452,2016-08-12 16:34:44,"@gaearon I kept looking into this and discovered there are two reasons why I might be missing some printWasted entries:
1) some are being filtered out by DONT_CARE_THRESHOLD which you seem to have removed from React in this https://github.com/facebook/react/pull/6647/files#diff-f5e99eb03b46b76237d2e7632d018f91L16 (we're still using v15.0.2)

2) after updating to the latest React, some entries were still missing, this (I believe) is because of the way perf tools work (not sure if it is a bug). As suggested, I will close and have opened a bug on the react project: https://github.com/facebook/react/issues/7484
",foiseworth,gaearon
448,2016-07-31 03:28:37,"Got it,Thanks! @markerikson 
",Mutefish0,markerikson
446,2016-07-28 06:58:12,"I got my answer here:  http://redux.js.org/docs/FAQ.html#react-rendering-too-often . That's because some state is produced by Array.map() method. And thank you so much. @markerikson 
",RubyZhuuu,markerikson
444,2016-07-27 21:14:08,"@jimbolla is there any other way? I'm sticking to the stateless components. 
",tomitrescak,jimbolla
443,2016-07-28 16:50:57,"@jimbolla there is the only action in my example. and button pressing causes the only dispatching and the only rendering. the issue happens because of delay between dispatching and rendering. not because of multiple rerenderings. 
",alsh76,jimbolla
443,2016-08-02 19:14:00,"@lourd, @jimbolla, @foiseworth As it turned out the cause of this issue is all components from navigation chain are staying unmounted and get rerendered behind of the visible scene
See more details here [Possible navigation issue in React Native/Redux app](http://stackoverflow.com/questions/38728435/possible-navigation-issue-in-react-native-redux-app)

So it seems not a redux issue but nevertheless I would be very grateful for advices how to handle multiple unmounted components from navigation stack in the best way.  I am checking in shouldComponentUpdate if current component is visible but maybe there is the better way?
",alsh76,jimbolla
440,2016-07-22 15:18:44,"



@jimbolla The import / export definitely works because I can render the SnippetContainer inside the <Page /> if I do it directly. The <Cta /> component also work using the dynamic way.
",bretthadley,jimbolla
434,2016-09-11 12:28:57,"@timdorr Could you please reply?
",fatfisz,timdorr
433,2016-09-06 09:19:38,"@timdorr Do the Typescript definitions have to take into account that the library can be used as an UMD module? Also, can I make use of the Typescript 2.0 features for the definitions?

@bbenezech I don't see what's missing. Could you explain more in depth?
",DaanDeMeyer,timdorr
433,2016-10-20 15:52:08,"@codeandcats suggested I fork and re-request these additions. Before I start, I wonder what are the tasks that need to be performed? I don't mind opening a PR but I'd rather not just copy the code without adding anything myself, unless we are content with the state of this PR before it was closed.  
@DaanDeMeyer raised some questions which I'd like to get answered before I begin.
- @timdorr Do the Typescript definitions have to take into account that the library can be used as an UMD module? Also, can I make use of the Typescript 2.0 features for the definitions?
- The rest of the definitions seem to be correct. Anything missing? Probably needs to be converted to external module though.
- Do we have any typescript files that can be used to test this with typescript-definition-tester?
",Zalastax,timdorr
433,2016-11-07 11:34:21,"@timdorr **_bump**_

Also, _imho_ it would be fine to target TypeScript 2 since it's backwards compatible with 1.x code so there's really no reason consumers shouldn't be using it now.
",codeandcats,timdorr
433,2016-11-07 13:59:07,"@timdorr
Redux typings and flow typings are successfully maintained in-house, why not react-redux?
DT is a gigantic mess, noise there is overwhelming. It makes sense to have it maintained here, with PR merged by react-redux maintainers, unless you do want to reduce the load on the library's maintenance, which is very understandable.
",bbenezech,timdorr
428,2016-07-06 11:02:41,"> #416 probably already fixes this

@jimbolla, ""probably"" is a bit wooly for my liking; please could you verify by running the new test I added in #429? Also, #416 seems more like a long-term project than a fix for the current implementation so I'd say this is still a worthwhile improvement in the short-term.
",andydavies92,jimbolla
424,2016-07-01 21:42:52,"Got it. Thanks @gaearon 
",realbugger,gaearon
416,2016-06-24 11:47:10,"@gnoff. I can probably refactor the factories/selectors relationship to be a little clearer. I may have made it too abstract for the sake of hypothetical reuse. Keep an eye out for an update.

As for tests, right now everything is indeed being tested indirectly through the original tests. It would be valuable to write tests directly against some of the lower level parts but I wasn't ready to do that until I get some kind of feedback on the likelihood of these changes being accepted. If the project maintainers say they'll accept the PR if I write some tests, then I'll def write the tests.
",jimbolla,gnoff
416,2016-06-24 18:56:13,"@gaearon I removed connectAdvanced from index.js and filtered out any extra options props to connect(). Does that adequately hide the new functionality, or do we have to worry about users importing from `react-redux/lib/something`? I'll test the repo's examples and any recommended projects this weekend.
",jimbolla,gaearon
416,2016-06-25 00:12:59,"@jimbolla : perhaps some of the repos listed at https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md might be suitable for experimentation?
",markerikson,jimbolla
416,2016-06-25 17:43:54,"@gaearon I've run all the examples in redux/examples against the rewrite and didn't find any problems. Steps were:
1. npm run build:examples
2. npm: run test:examples
   3 overwrite node_modules/react-redux/lib with rewrite in each example
3. repeat 1 & 2. all tests still passed
4. run each example manually to see if there was any unexpected behavior. I did not see any

Next I am going to look at @markerikson 's list as well as reach out to the folks on reactiflux chat for repos to test.
",jimbolla,gaearon
416,2016-06-25 17:43:54,"@gaearon I've run all the examples in redux/examples against the rewrite and didn't find any problems. Steps were:
1. npm run build:examples
2. npm: run test:examples
   3 overwrite node_modules/react-redux/lib with rewrite in each example
3. repeat 1 & 2. all tests still passed
4. run each example manually to see if there was any unexpected behavior. I did not see any

Next I am going to look at @markerikson 's list as well as reach out to the folks on reactiflux chat for repos to test.
",jimbolla,markerikson
416,2016-06-26 22:57:37,"@gaearon I haven't been able to get anything React Native running on my machine. Once I got past errors related to installing python, now it's complaining about missing c++ things.
",jimbolla,gaearon
416,2016-07-02 21:35:48,"I did a review pass through the new codebase, trying to get a feel for what's going on.  Jim was hanging around in Reactiflux, so I asked him several questions about behavior in the process.  The one vague hypothetical concern I saw would be if somehow a child unsubscription happened during `Subscription.notifyNestedSubs`, causing a callback to be removed shortly before the loop tries to call it.  Should be easily fixable with an object copy, similar to how Redux handles its own notification process.

Code quality looks very good.  Functions are generally short and readable.  The helper functions don't generally have comments, but are clear enough that that's not an issue.  The higher-level logic in `connectAdvanced()` has considerably more comments, especially around the arguments.  Very well-written overall.

I built the branch and swapped out the `react-redux` folder in my own app's `node_modules`, rebuilt my dependencies bundle with Webpack's DllPlugin, and loaded up my app.  Didn't do an exhaustive test or any specific perf benchmarks, but did run through several chunks of functionality.  Everything looked just fine.

My only concern at this point is trying to follow how all of the various levels of selectors fit together.  Even with the diagram in this PR, things are a bit hazy.  The `match` approach used for handling the various possible argument forms for `mapState` and `mapDispatch` also took me a couple minutes to grasp, although the individual case handling functions themselves are very nice and encapsulated.  Not immediately sure what would be needed to make the selector connections and interplay more understandable.

Overall, the PR is looking very solid.  I am generally :+1: on the PR at this point.  @gaearon , any thoughts?  Anyone else have a chance to play around with this?
",markerikson,gaearon
416,2016-07-03 01:44:12,"Talked with Mark on Reactiflux today after running across this and pulled it into our company project. All our tests pass and I've run through multiple workflows with the app and everything works fine. 

Just to note, our application runs with the following packages. I'll only list the ones that are relevant here:

`
    ""react"": ""15.1.0"",
    ""react-redux"": ""4.4.5"",
    ""redux"": ""3.5.2"",
    ""redux-saga"": ""0.10.5"",
    ""reselect"": ""2.5.1"",
`

We also make use of a few factory functions in some of our connect calls as we are controlling how often updates are sent to the connected component.

The chrome extension dev tool also handles this change completely fine.

Unfortunately I cannot contribute to the React-Native cases yet since we havn't gotten a chance to dig into it yet.

Edit:  @jimbolla If you can tell me where in the code to measure performance, I have a load test suite setup for my application. I can put it through some heavy strain and post the results.
",Sinistralis,jimbolla
416,2016-07-03 16:55:16,"@ellbee : just to confirm, you did use Jim's branch of `react-redux`?
",markerikson,ellbee
416,2016-07-03 17:09:11,"@markerikson Yep, used the branch. `""react-redux"": ""4.4.5""` is the version that we are running in production. Sorry if it wasn't clear!
",ellbee,markerikson
416,2016-07-04 15:10:38,"@markerikson I'll add comments to match... will explain why it goes backwards.

@Sinistralis I describe how I did perf testing under the Performance header at the top of this page. Basically just recording before/after values for stats.js. Also, just using FF/Chrome's profiler to see methods with longest times.
",jimbolla,markerikson
416,2016-07-05 16:12:50,"@jimbolla , @reactjs/redux : if no one else has any comments in the next few hours, I'll do as Dan asked and ping him to set up a beta.
",markerikson,jimbolla
416,2016-07-05 18:23:20,"@timdorr @jimbolla @markerikson depends on how many people we want using this in the wild and how soon. If we tag it as `rewrite` then we reduce the number of people who are likely to come across it and exercise it. We would still need a `alpha` or `beta` phase then to get critical mass to move to general release.

if we use more traditional prerelease vernacular then we are likely to pick up a much larger proportion of experimenters and early adopters.

since the public API does not change we can silently bail out of the rewrite with no community fallout. I'm more concerned about when we expose `connectAdvanced` api as public. This is where the extra very obvious opt-in to non-standard release makes the most sense to me.

That said, being conservative isn't generally a bad thing, I can see the argument to protect this more deliberately from accidental opt-in.
",gnoff,timdorr
416,2016-07-05 18:23:20,"@timdorr @jimbolla @markerikson depends on how many people we want using this in the wild and how soon. If we tag it as `rewrite` then we reduce the number of people who are likely to come across it and exercise it. We would still need a `alpha` or `beta` phase then to get critical mass to move to general release.

if we use more traditional prerelease vernacular then we are likely to pick up a much larger proportion of experimenters and early adopters.

since the public API does not change we can silently bail out of the rewrite with no community fallout. I'm more concerned about when we expose `connectAdvanced` api as public. This is where the extra very obvious opt-in to non-standard release makes the most sense to me.

That said, being conservative isn't generally a bad thing, I can see the argument to protect this more deliberately from accidental opt-in.
",gnoff,jimbolla
416,2016-07-05 18:23:20,"@timdorr @jimbolla @markerikson depends on how many people we want using this in the wild and how soon. If we tag it as `rewrite` then we reduce the number of people who are likely to come across it and exercise it. We would still need a `alpha` or `beta` phase then to get critical mass to move to general release.

if we use more traditional prerelease vernacular then we are likely to pick up a much larger proportion of experimenters and early adopters.

since the public API does not change we can silently bail out of the rewrite with no community fallout. I'm more concerned about when we expose `connectAdvanced` api as public. This is where the extra very obvious opt-in to non-standard release makes the most sense to me.

That said, being conservative isn't generally a bad thing, I can see the argument to protect this more deliberately from accidental opt-in.
",gnoff,markerikson
416,2016-07-16 21:14:06,"I went through a round of refactorings/optimizations based on the results @gaearon found in redux-todomvc.  The scenario is that we have a list of 10,000 todo items components, each of which is connected. The speed being measured is when a todo is marked completed. To measure the results consistently, I set up a timer to check the first 10 items in the list like this:



This gave me enough time to let the page load and start Chrome's profiler. (Also profiled in Firefox but didn't bother writing down timings, but the results were consistent.) The `connect()` call of importance is the one for TodoItem. Note that this connect uses the factory style to grab the `id` from `initialProps` so that its selector doesn't have to depend on props :

### version 1



The second test I profiled was to change the `mapStateToProps` to the following. Note that this version grabs `id` from props in the final selector:

### version 2



For the third test, I removed the extra factory wrapper that's no longer needed from version 2:

### version 3



Finally I wrote a version that used `connectAdvanced` directly, which handles its own value memoization:

### connectAdvanced



### results

Aveage time in ms per `dispatch(completeTodo(...))` for 10 samples:

| test | current | rewrite |
| --- | --- | --- |
| version 1 | 28.6 | 36.9 |
| version 2 | 223.2 | 35.8 |
| version 3 | 215.4 | 32.4 |
| advanced | N/A | 24.3 |

So where I ended up is that for the original (version 1) `makeMapStateToProps`, the rewrite performs slightly slower, but performs significantly faster for a more ""typical"" selector (version 3). I think this is related to the added code to solve #292, #368, and #398. But the `connectAdvanced` version can eek out a little bit more speed (mostly by avoiding some calls to `shallowEqual`) by handling its own memoization.
",jimbolla,gaearon
416,2016-07-25 19:09:44,"@stevewillard You may be able to install directly from @jimbolla's branch:



It _should_ work, but you might need to mess with your build setup to get the code to be transpiled. Alternatively, you can check it out locally, run the build steps, and install against that local copy.
",timdorr,jimbolla
416,2016-08-09 13:41:09,"@gaearon Is there anything else you'd like me to do/test with this?
",jimbolla,gaearon
416,2016-08-09 17:14:41,"Unfortunately, only Dan has the publish bit set on npm, so only he can push out the planned `react-redux@next` dist-tagged testing release.

@gaearon Can you package up a release for testing? Everything here looks good to me. If not, I can take care of it if you are OK with adding me to npm.
",timdorr,gaearon
416,2016-08-11 14:00:11,"In the interim, I published `@jimbolla/react-redux` to npm for anyone that's eager to experiment with this. If you're using webpack, you can add an alias to substitute this package for the official one w/o having to change any other individual files. Just add the following code to your webpack.config.js:


",jimbolla,jimbolla
416,2016-08-12 08:23:25,"@timdorr Sorry, I’ve been unexpectedly swamped by Create React App which started as a hackathon project 😄 . I’ll give you the npm ownership so you could publish it.
",gaearon,timdorr
416,2016-08-12 08:24:31,"@timdorr You should have access to `redux`, `react-redux`, `redux-thunk`.
",gaearon,timdorr
416,2016-08-13 13:40:38,"@jimbolla When do you plan to release it?
",max-mykhailenko,jimbolla
416,2016-08-14 15:07:57,"#### Publicity and such: https://twitter.com/timdorr/status/764848054528774144

This version of react-redux is now available on npm for you to install and test:



It's tentatively called 5.0.0, although technically it has no breaking API changes. semver schmemver!

Please report any bugs you find with it as a separate issue on the repo. 

As some housekeeping, I'm going to close out this PR and instead merge it into the `next` branch on the repo (since this is against `master`). @jimbolla, you (or anyone else for that matter) can open up any followup PRs with further improvements and bug fixes against that branch. I'll go through and close out any issues that this PR solves (so many!) and we can plow forward on getting this released. I'll give it a week or so and we'll promote to beta status so we can get even more people trying it out. 

Everyone please give @jimbolla a huge round of virtual applause for this PR. He's done some really great work here!
",timdorr,jimbolla
416,2016-08-14 17:13:56,"And thank _you_, @jimbolla , for your initiative and all the time and effort you've put into working on this, as well as everyone else who has participated in the discussion.  This has been a very nice example of open source collaboration at work.
",markerikson,jimbolla
416,2016-08-14 18:11:45,"Oh my gwd @jimbolla love you man for all the hard work you've done!!!
",OshotOkill,jimbolla
416,2016-08-15 09:31:13,"thanks @jimbolla . Didn't have much time to see what you have done so far but it looks great and will probably solve some of my own issues
",slorber,jimbolla
416,2016-09-04 07:39:25,"@timdorr upgrading to `5.0.0-beta.1` but i cant see exported `connectAdvanced` in lib. I see file `src\components\connectAdvanced.js` but it is not exported in index so i cant use it directly by my own. Can you add that export and publish updated beta version?
",psulek,timdorr
416,2016-09-28 17:33:28,"Love this! I just dropped the beta into an existing application that uses Redux to store form information. In my application, each field is connected to the store, similar to `redux-form`'s approach after the v6 upgrade. I loaded a fairly complex form and noticed with `Perf.printWasted()` that each field was performing a ""wasted"" render each time any other field changed. This quickly adds up to hundreds of wasted renders on a medium-sized form. (Imagine that each character in an `<input>` causes a state change in the store. For an average typist, that is 3-4 characters per second. Multiply that by the number of form fields and you arrive at hundreds of wasted renders _per second_ on a form with just 25 fields, which is a small number for our use case.)

With the new `react-redux`, against the exact same code, the hundreds of wasted renders have dropped to zero! Love it! Way to go @jimbolla!
",chrisvasz,jimbolla
416,2016-10-01 00:12:41,"@jimbolla can explain further, but it's a combination of several factors.  Primarily, there's a ton of custom memoization going on using selectors, which avoids the need to call `setState`.  v4, on the other hand, called `setState` and then did the real checking in the wrapper's `render` function.  It also ensures that subscriptions are handled top-down, fixing a loophole where children could get notified by the store before ancestors and causing unnecessary render checks.  See the rest of this thread, as well as #407 for discussion and details.
",markerikson,jimbolla
416,2016-10-01 01:55:39,"@slorber @markerikson The short short version... Forcing the order of components' store subscriptions to trigger top-down allows connect to avoid extra calls to setState, render, and mapStateToProps'n'friends.
",jimbolla,markerikson
416,2016-10-03 22:49:11,"That's nice! so finally it somehow breaks compatibility (not in a way that's likely to break someone's app) and the new behavior makes connect more performant, in addition to being more flexible.

However @jimbolla can you take a look at this usecase of a list of 100k connected elements? http://stackoverflow.com/a/34788570/82609
I've seen your comments pointing out that the new implementation will permit to solve this problem in an efficient way, but I'm not sure how it can be done. Any code to share?
",slorber,jimbolla
413,2016-06-24 18:55:27,"@markerikson: Please, look at https://github.com/reactjs/react-redux/pull/417. I hope my english is good enough :)
",erykpiast,markerikson
407,2016-06-18 00:53:08,"@Aweary I've been working on adding comments to the code to explain as much as possible, but I can provide an executive overview:
- The API for `connect()` is exactly the same, but its internals are completely different, ultimately delegating to `connectAdvanced()`. 
- The API for `connectAdvanced()` is `connectAdvanced(selectorFactory, {connectOptions})`. `selectorFactory` is a func with the signature `({factoryOptions}) => (state, props, dispatch) => {finalProps})`
- While Reselect is utilized internally, there's no requirement for a user to use it as their memoization engine for the functions they pass to either `connect` or `connectAdvanced`, nor is memoization even a requirement.
- Exposing an advanced API will allow end users to customize the connect functionality by building their own wrappers. For example, the whole reason I started this was so that I could define a wrapper that let me define my mapping using reselect's `createStructuredSelector`. Another example would be #323. 

Looking at a diff probably won't be super useful, since it's a total rewrite. It's probably better to look at the new files as a whole.

@timdorr Can you elaborate on why you think this implementation would fall through more often? Unless I'm missing something, I expect render to NEVER execute unnecessarily.
",jimbolla,timdorr
407,2016-06-18 13:21:43,"I made a small change in `handleChange` that fixes my own performance issues. The key being to avoid excess `setState(...)` calls, which @jimbolla mentioned.



I'm not aware of the repercussions of this change, as I just start messing with the code here, well, 30 mins ago. I just started using React, Redux, etc. etc. this week, so I'm not quite up-to-speed on the performance problems here, but it didn't take long to run into them. Glad I'm not alone!

Anyway, I'm happy to see that this thread is pretty active, so I wanted to take the opportunity to post my 2 cents and see what others thought before I spend the rest of the weekend catching up on this particular issue. Thanks, all!
",jonkelling,jimbolla
407,2016-06-18 21:50:48,"@jimbolla I'll do what I can! I was able to get it functioning, but the first go at it saw decreased performance. I may not be doing it the way you intended, so I can try it again a bit differently if this seems off.



A couple of things:
1. I had to add `children: props.children` to get things to render.
2. I think `shouldComponentUpdate` is always returning try because it's comparing all of the properties returned by the selector, including the onMouseOver and onMouseOut functions--I really only want it to update if ""active"" is different, in this case.
3. I love the intentions of reselect in general, but as I'm only after a single boolean property, caching would technically be less efficient, and would sort of defeat the purpose of what reselect does.

Let me know if I can help any other way!
",jonkelling,jimbolla
407,2016-06-21 14:21:12,"@markerikson I'm still refactoring for clarity, and need to add some comments, but I'm getting close to being ready to submit as a PR. Any feedback you have is greatly welcome.
",jimbolla,markerikson
407,2016-06-21 17:07:20,"@markerikson I totally agree, and was already thinking all those things. It's just a matter of time. I'm hoping to have all that by some time this weekend, optimistically. The code is more-or-less complete, barring any renames to make things clearer. Next up is comments to clarify things at the local level, where needed. Then I'll work on the ""conceptual"" documentation. Do you think it makes sense to write that as an .md file to be included with the code?
",jimbolla,markerikson
407,2016-06-21 19:06:28,"I'm with @jimbolla on avoiding unnecessary calls to setState and render. Might I also suggest calling out the specific cases and adding unit tests for them. My own change to avoid extra calls to setState breaks one of existing tests in react-redux. When I get the time, I hope to understand the intention behind that test case and the original code so I can decide how I really want to/should handle it. I look forward to seeing what you come up with!
",jonkelling,jimbolla
407,2016-06-21 19:30:39,"@jonkelling @markerikson I broke the same test when I removed the ""unnecessary"" setState() calls. The solution was to enforce top-down subscriptions. Then it's no longer a ""re-run"", it's just a ""run"". This also added significant perf gains because in most cases, a whole tree of connected components will re-render in a single frame. By the time the child components get their notification from the store, they've already done their work... they fire the getFinalProps selector, which sees that current ownProps and state are the same as previous, and avoids the extra setState/render cycle.
",jimbolla,markerikson
407,2016-06-21 20:19:47,"Cool, yeah, I haven't had much time to look over all of these changes. Seems reasonable though, great work @jimbolla 
",aweary,jimbolla
407,2016-06-21 20:52:37,"@markerikson I never modify the context so no need to trigger an update. That should be a non issue. I followed the same ""props.store"" or ""context.store"" pattern like the original.
",jimbolla,markerikson
407,2016-06-23 06:29:15,"@jimbolla 

having gone through your implementation of connectAdvanced (and to some extend the connect api reimplementation) I have the following very disjointed thoughts and questions.
1. in many respects `connectAdvanced` seems simpler than `connect` to me. would you intend to ever use the original api over the advanced api. If the benefits of the new api consistently outweigh those of the existing one I wonder if this framing is the correct one long term.
2. Should connectAdvanced have sensible defaults for when say you just want dispatch? Obviously one can use the connect wrapper for advanced but this adds a lot of internal complexity (for the backwards compat sake which is great) and if users are using the advanced api already there may be some value in providing defaults
3. ~~using options to control depends on state feels clunky to me. Can the selector arity be used to modulate this behavior whereby `(state, props, dispatch) =>` depends on state and `(props, dispatch) =>` does not?~~  scratch that, babel transpilation can alter fn arity when using default values. explicit is fine if a bit clunky
4. would the perf boost from enforcing subscription updates top down make the performance parity more equal? I think as great as the new implementation is, I'm worried that the parent subscription tracking feature is doing the heavy lifting perf wise and that a similar implementation in the current form may show possibly even higher performance than your new implementation (not that I hope it does one way or the other)

I'm torn because the risk of major reimplementations is real but the simplicity of the new implementation is valuable too. Part of me feels like if the new implementation is worth adopting we ought to deprecate the existing api in a major and move over to the new api in another major. In my mind most of the complexity in the new implementation is in trying to keep backwards compatibility which is a valuable target but if the new API turns out to be genuinely better (which we would of course need plenty of time in production use to adequately gauge this) then why hide it behind a veil of 'advanced-users-only' connotations.

I don't make decisions, just been around this project for a bit. take my opinions for what little they are worth :)
",gnoff,jimbolla
407,2016-06-23 13:03:50,"@jimbolla, I've got your latest code. Kudos on making it work with connect()! My own performance problems resolved :+1: I'll work on test cases for ya this weekend. Thanks for all of your work on this!
",jonkelling,jimbolla
407,2016-06-23 20:14:57,"@markerikson Thank you for your all your help. Your participation has helped me flesh out my ideas and force me to critically think about what I'm trying to do and how to do it. I understand the potential impact of such a large change, and therefore the need to make a strong justification for it. I'm working on that ""justification"" doc now, and even as I'm writing it, I'm tweaking my design to make the explanation less awkward. I'm still hoping to get it done by this weekend.

@gnoff `connectAdvanced` appears simpler than `connect` because it does less for you. But the responsibility to memoize intermediate results is now on the caller. This is especially important for any actionCreators being bound to dispatch, for example. I don't want to make assumptions about what ""sensible defaults"" are for anyone's usage; instead I'd like an API that's flexible enough so that anyone can wrap `connectAdvanced` in their own method that makes assumptions that work for them. Using function arity is somewhat brittle and is not obvious. I'm sure if the current implementation of connect was modified to use hierarchical subscriptions, it could gain a lot of the same perf improvements. If someone else wants to take that approach, they're more than welcome to copy any of my code/ideas. But to me the performance is just a bonus, because what I really wanted was a more flexible API. Sepcifically, I'm interested in defining my selector using Reselect's `createStructuredSelector` function. I still think the `connect` API should be the official API for 99% of use cases, and then `connectAdvanced` is there when you want to get clever, eek out performance, or want to use it to integrate with another library.

@jonkelling That's great. I'm encouraged by your positive feedback. Test cases are certainly welcome.
",jimbolla,gnoff
407,2016-06-23 20:14:57,"@markerikson Thank you for your all your help. Your participation has helped me flesh out my ideas and force me to critically think about what I'm trying to do and how to do it. I understand the potential impact of such a large change, and therefore the need to make a strong justification for it. I'm working on that ""justification"" doc now, and even as I'm writing it, I'm tweaking my design to make the explanation less awkward. I'm still hoping to get it done by this weekend.

@gnoff `connectAdvanced` appears simpler than `connect` because it does less for you. But the responsibility to memoize intermediate results is now on the caller. This is especially important for any actionCreators being bound to dispatch, for example. I don't want to make assumptions about what ""sensible defaults"" are for anyone's usage; instead I'd like an API that's flexible enough so that anyone can wrap `connectAdvanced` in their own method that makes assumptions that work for them. Using function arity is somewhat brittle and is not obvious. I'm sure if the current implementation of connect was modified to use hierarchical subscriptions, it could gain a lot of the same perf improvements. If someone else wants to take that approach, they're more than welcome to copy any of my code/ideas. But to me the performance is just a bonus, because what I really wanted was a more flexible API. Sepcifically, I'm interested in defining my selector using Reselect's `createStructuredSelector` function. I still think the `connect` API should be the official API for 99% of use cases, and then `connectAdvanced` is there when you want to get clever, eek out performance, or want to use it to integrate with another library.

@jonkelling That's great. I'm encouraged by your positive feedback. Test cases are certainly welcome.
",jimbolla,markerikson
407,2016-06-26 22:18:36,"I was about to write an RFC issue to discuss rewriting `connect()` to provide more functionality. Given how healthy this discussion has been I think this is the best place to post it.

My approach was going to be a bit different than @jimbolla's. My inspiration came from wanting to write a lightweight version of [`apollo-client`](https://github.com/apollostack/apollo-client), call it `react-redux-graphql`, and to avoid having to do something like this:



Ideally it would be something like this: (inspired by redux store enhancers)



Or something similar (this doesn't have to be the final signature).

Now, I could just use another higher order component and do:



You can basically do anything you want with higher order components but I thought that maybe baking that functionality into `connect()` out of the box would leave room for anybody to write componentEnhancers, be consistent with Redux, and bend `connect()`'s functionality to do whatever you want, more so than `advancedConnect()`.

So should we leave it for other developers to create higher order components or should we bake in functionality to enhance `connect()` out of the box. Thoughts?
",migueloller,jimbolla
407,2016-06-27 00:21:37,"Sounds good. And thanks for the prompt replies @markerikson!

Here's the change https://github.com/migueloller/react-redux/commit/1c8d940b945d519f32011e1359bd65c42e5f83b1

All tests are passing. Just wanted to get some comments on what people thought.

The change now allows for enhancing connect (if you want to) in any way you want, allowing for what I mentioned above.

If this ends up being ignored in the end that's ok. Just thought that this would be a good improvement. 😁
",migueloller,markerikson
407,2016-06-28 04:36:05,"@jimbolla That would be an option but it's not much different from wrapping `connect` because the library would still have `react-redux` as a dependency. It would be nice to simply export a function that takes in `connect` as a parameter and outputs a new version of connect. This is how store enhancers work (Redux libraries don't normally have Redux as a dependency).

It doesn't look like there is interest to mirror store enhancer functionality for `react-redux`, though.

**EDIT**: It's probably worth mentioning that all the benefits that you get from `advancedConnect` can be achieved with my implementation simply by doing:


",migueloller,jimbolla
405,2016-06-15 15:03:33,"@markerikson In addition to what you mentioned, the other issue I started running into was when I was using createSelector in mapStateToProps, mapDispatchToProps and mergeProps, because they each have different parameters, I had to organize my selectors by which method they aligned with. (Using createSelector to memoize my functions is useful for partially applying args from state/props, so that a new function isn't created every time an unrelated prop is changed.) It also looks like mergeProps doesn't have the same ""advanced"" option like the other two, so any selectors I want to use in there have to be singletons instead of being bound to the lifetime of the component instance.

So I started looking at the source for connect() to see if it would be possible to modify it to just supply dispatch as a 3rd param to mapStateToProps, but I found the source for connect() to be very difficult to mentally parse. There's a lot of magic in there to track all the various moving parts. I don't think I could make the changes I'd like to connect() without breaking something. There's 10 ""cache"" fields on the component and another 5 temp variables in the render() method mixed inside a lot of if/else blocks.

That's why I decided to create my own implementation using reselect to track all those moving parts instead. 
",jimbolla,markerikson
405,2016-06-16 03:28:17,"@markerikson So I wrote a version of `connect()` that builds a selector from its args and passes along to `connectToStore()`. All react-redux tests pass with 1 breaking change for when `mapStateToProps` / `mapDispatchToProps` are factory methods and a couple tweaks to some spy counts because my implementation does things slightly different behind the scenes.

[Fork is here](https://github.com/jimbolla/react-redux/tree/connect-rewrite/)
",jimbolla,markerikson
403,2016-06-08 22:49:37,"@markerikson Well basically, because what action gets returned to the component needs to use state. I don't have access to dispatch in `mapStateToProps` to fully bind the method, and I don't have access to state in `mapDispatchToProps` to do so, so I have to do it after both have run, either in `mergeProps`, or using recompose's `withProps`. In an ideal case, I'd have access to state, dispatch, and ownProps in a single pass.

In this case, the state is the current user's authorization. The result is either the real action, or nothing. Our app has role based authentication (details stored in state.auth) where employees in the admin role can can perform write actions from a screen where other users can only get a readonly version. The components key off whether the event handler functions are null or not to make that determination.
",jimbolla,markerikson
403,2016-06-09 16:36:01,"@jimbolla Your use of dispatch in this way does feel a bit awkward to me but I can see why having dispatch available in the selector can be useful if you want to keep all this kind of thing in selectors exclusively.

`connect` doesn't add much overhead beyond what any HOC would if you aren't subscribing to anything so the double connect isn't really an issue per se. If you want to make your intent more clear to others I might suggest doing something like this though



this way you can swap out the implementation for `provideDispatch` in the future without finding every place you happened to do the double connect.
",gnoff,jimbolla
403,2016-06-10 22:11:50,"@gnoff That's a good idea. If I don't end up using my own implementation of `connect` I would do that.

@markerikson Partly stylistic and syntactical preference, partly being able to leverage the abilities of `reselect`. It's still in flux (no pun intended), but my current syntax looks like this for a simple use case:



Now I have both state and bound action creators available so I can build my props object in a single pass.  
",jimbolla,gnoff
403,2016-06-10 22:11:50,"@gnoff That's a good idea. If I don't end up using my own implementation of `connect` I would do that.

@markerikson Partly stylistic and syntactical preference, partly being able to leverage the abilities of `reselect`. It's still in flux (no pun intended), but my current syntax looks like this for a simple use case:



Now I have both state and bound action creators available so I can build my props object in a single pass.  
",jimbolla,markerikson
397,2016-06-02 02:11:47,"@gaearon You are right！
Last night，I solved the problem！
I was so careless... 
Thank you very much!
",kissyRui,gaearon
396,2016-05-30 06:51:47,"I get the point @gaearon.

I had been playing with the idea of exposing a way to disconnect.

I got the idea while making some tests by doing this from my connected container:



Of course the code above uses undocumented APIs and there are many things that could go wrong.

Also, there's no way to reconnect later. That's why I thought that it might be a nice addition to expose somehow a (dis/re)connect / (un/re)subscribe methods.

I guess I'll need to create my own connect wrapper or simply call (un)subscribe as you suggested.

Thanks!
",landabaso,gaearon
396,2016-05-30 15:14:06,"Thanks @gaearon!

I decided NOT TO use the approach of (un)subscribe anyway since it also makes the App slow.

I'll explain it in case some other people read this issue in the future:

I worked a bit more on the idea. I passed a prop from the parent though intermediate components to the final subscribed list Items: `pauseSubscriptions = true/false`. Then the list items unsubscribed and resubscribed when it's parent Page was hidden or shown.

The problem is that passing that prop triggers a chain of renders which would not have happened without it. I guess there are ways to directly (un)subscribe the children items not passing props but I have the feeling I was over-engineering the problem.

I'll try different approaches to avoid having thousands of connected components. Maybe connecting only from the parent and passing props to the children. This will make the program a bit verbose (lots of props-passing) but may do the trick!

Thanks again @gaeron for such great tools and support!
",landabaso,gaearon
388,2016-05-22 23:06:26,"@gaearon thanks. Upgrading to React Router `3.0.0-alpha.1` doesn't appear to have fixed the problem :(

Got this warning though: 


",olalonde,gaearon
388,2016-05-23 00:12:45,"@gaearon ah ok thanks. Any idea why `withRouter()` fixed the problem anyway?
",olalonde,gaearon
384,2016-05-18 20:14:52,"Looks like this was actually an issue in a different part of my code (a faulty `onEnter` hook in my routes). Figured that out when other parts of the app started misbehaving in the same fashion after five route changes 😄 

Thanks anyway for the quick response and all your hard work on redux, @gaearon!
",vitosamson,gaearon
380,2016-05-16 14:02:15,"@gaearon  Thanks of your kind reply! I already got your answer in stackoverflow. maybe I should not separate partial app from the whole web app in iframe, it was not allowed in redux structure?
",sevenLee,gaearon
380,2016-05-17 18:30:19,"The package works so great! I don't need to use react-router to decide iframe source any more, I directly put the component I want to display inner < Frame > , the component will render in iframe, like so:



The most awesome feature is the state is synchronous ! the inner component works the same as outer component. Now I can dynamically change inline style in inner component. That is big present for me, @gaearon very much appreciated ! :D
",sevenLee,gaearon
376,2016-05-09 19:18:31,"@gaearon First of all thank for the impressively quick response (and overall great work).
Sorry I missed #165. 

IMHO saying pure imperative methods is not idiomatic React is incorrect. A way of communicating with components through exposing a component function is part of the React docs:
https://facebook.github.io/react/tips/expose-component-functions.html

It even states at the end, that passing props for animations might get messy, or in other words, there are some situations a component interface is a better solution. 

In our case, we have a generic wizard component, and each step in the wizard is a react component, that must implement a certain interface in order for it to work in the wizard.
",omerts,gaearon
372,2016-05-12 09:23:56,"> Context updates are notoriously broken with shouldComponentUpdate (facebook/react#2517). If a library you use relies on them, you should be using impure version of connect(). We can’t protect against random breakage in patch versions here because you are essentially relying on known buggy behavior.

@gaearon, AFAIK react-redux also relies on the context feature of React. So does that quote above also apply to react-redux itself? Say, for instance:



a) The parent's `shouldComponentUpdate` returns `false`.
b) Child is connected to some part of the `state` that changes.

Will the Child re-render when that part of the state changes? Do we need to pass `{ pure: false }`?
",landabaso,gaearon
368,2016-04-26 01:39:55,"https://github.com/amccloud/react-redux/commit/d2a1fe3bc317e39ed49ffedb53a9835896a5015b

@gaearon  Now i'm stuck! I've gotten all but 3 test to pass:



I had to update one test now that re-rendering is now driven by setState. I think test failures 2 and 3 are similar issues. Test failure 1 is a bit different and @gaearon I was hoping you can look at it for me.

My notes: https://gist.github.com/amccloud/327a9d7b7dc97eaf6bb3f1f3da9e2d5e
",amccloud,gaearon
368,2016-05-01 00:27:11,"@gaearon is there a reason why the test `calls mapState and mapDispatch for impure components` expect 2 calls to mapState/mapDispatch on mount? For me only one should be required.
",slorber,gaearon
368,2016-05-01 01:51:22,"@gaearon it was quite hard and the code is not clean yet but I made all tests pass!

You can take a look at [#373]

At first I thought that I would never be able to make pass the last test related to the stale props when both parent/child are connected, because the transactionnal setState callback can be called multiple times in a single batch.

I had to use a trick like that:



@tgriesser I also succeeded make all the tests pass without using `checkMergedEquals`. Do you think there might be a missing test case?
",slorber,gaearon
359,2016-04-20 02:17:34,"@gaearon Thanks.

Is it a problem of `react-native` hot reloading? I found no problem in some `react-redux` hot reloading examples likes https://github.com/erikras/react-redux-universal-hot-example/blob/master/src/client.js#L46
",cpunion,gaearon
355,2016-10-17 18:32:39,"@jimbolla thanks thats what it was. I created a variable for the store and now it works.

just in case someone one sees this and it's going through the same thing.


",jaysg,jimbolla
351,2016-06-10 06:40:46,"I don't understand what was changed but 4.4.4 and 4.4.5 breaks my current solution :)
The render function is calling and locale is fine when i dispatch **setLocale**, but **FormattedMessage** doesn't change the message. Looks like FormattedMessage doesn't get new props or something. It works on previous releases, and i did double check that issue reproduces only with react-redux 4.4.4 and 4.4.5
I will investigate the bug late, but for now here is my component



@gaearon thx
",DmitryAuine,gaearon
348,2016-04-12 23:07:55,"@gaearon this is great news that connect not using component's props get faster :)

However I'm not sure the current implementation is the best we could do:
- The factory method works but is kind of unintuitive API at first
- If a connected component do care about ownProps, and these props can change (ie can't use the factory), then the component will setState even if the props don't change often

Instead of 



I would rather have something like:



(this is probably not the best API but you get the idea)

What it permits here is to make it clear on what the mapping function has to rely on to do its job, so you can more easily detect when props needed for the mapping have changed and run the mapper only when needed

And I think, by default, not providing any ownProps to the mapping function (ie no selector provided) would actually encourage people to write more optimized code by default (unlike factories which would be opt-in optimization), but it would be a breaking change

(This is related to my proposal  for more flexible subscriptions here: https://github.com/reactjs/react-redux/issues/269#issuecomment-175904958)
",slorber,gaearon
348,2016-04-13 09:51:59,"> I’m confused: how does accepting a selector for props solve the problem of setState()? As soon as something depends on ownProps, due to #99, we are forced to delay its calls until render() at which point we have already paid the price of setState().

@gaearon sorry it's hard to think well on such code late in the night :) My proposal may not prevent the `setState` cost finally.

The problem I see with current code is that for example if this component changes from



 to 



then yes we necessarily have to do a `setState` because ownProps have changed and we must render the child. The problem is that here our `mapStateToProps` is relying on ownProps but actually does only care about the `id`, and not `className`.

This line:



it will make `mapStateToProps` be run in such a case, while it could have been avoided if we could have known that `mapStateToProps` is not interested to receive the `className` property but only the Todo id.

Also, not a big deal, but not sure `this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1` is relyable if someone writes mapStateToProps with `arguments[0]` (yes it is unlikely... :p). It would become more relyable if that wish to depend on ownProps was more explicit

---

This is only what I can say for now, I have to study the code a bit more to say anything else :) (ie #99)
",slorber,gaearon
348,2016-04-25 04:57:08,"@gaearon Here is [my use case](https://github.com/yelouafi/redux-saga/issues/241#issuecomment-207202589), in which early bailout yields significant performance boost.

With regards to @slorber's concern that props _can_ change, I encountered a similar issue, and I did this hack to get around it.

Let's say we have:



Of course, userID isn't expected to change, but there may be some cases where it does. For example, the above component may be a react-router route component, which gets its userID from the pathname: `http://example.com/userpage/cat`. When the path changes to `http://example.com/userpage/dog` the component holds on to stale userID (cat) and this causes problems. (because react router doesn't re-mount for the same route)

I _could_ revert back to `mapStateToProps (state, ownProps)`, but I would loose the performance boost gained from the early bailout. So instead, I do this:



Because of key, when userID is changed, the old component is completely unmounted, and new one is mounted instead, with the updated props. It's a bit hacky, but I think this is an acceptable trade-off. I guess for multiple props that aren't expected to change often I can stringify as a key:



but that .. is beyond ugly. It does bother me there are so many different steps within different levels involved in simply invalidating and updating a component, but was the only way I could make this work.
",joonhyublee,gaearon
347,2016-09-14 15:34:55,"@gaearon Does this mean that I just have to accept that I won't be able to hot-reload when working on my flow-control logic (thunks, sagas)? 
",Thorbenandresen,gaearon
345,2016-08-14 15:33:46,"lol @timdorr, no worries :)
",jisaacks,timdorr
330,2016-04-02 19:29:17,"Note that this is a Redux-specific question, and not a React-Redux concern.

@joshwcomeau's example is good.  There's also utilities out there that make that approach easier, such as https://github.com/omnidan/redux-recycle.  There are a number of Redux-related libs listed over at https://github.com/markerikson/redux-ecosystem-links , and some of them might also help with this.
",markerikson,joshwcomeau
330,2016-07-11 18:05:13,"Thank @joshwcomeau for that. It's working for me.
",gaastonsr,joshwcomeau
329,2016-06-13 18:45:46,"I disagree, `WrappedComponent` is not a perfect solution.

> @ianobermiller (FormidableLabs/radium#271 on [Jul 17, 2015](https://github.com/FormidableLabs/radium/issues/271#issuecomment-122227566))
> Can you imagine if every decorator did the same thing? `Radium(Relay(autobound(Button)))` 👎 

Or are you suggesting that `react-redux` is the king of React standards and every HOC project out there should adopt the `WrappedComponent` standard?  What if other HOCs provided `InnerComponent` or `BaseComponent` as their standard method?  What we end up with is chaos.

> @gaearon
> Display name is meant for debug purposes and tooling like React DevTools. Why do you rely on it?

No matter how you slice it, the wrapped component appears to be a change in the display name to the consuming developer(s).  So I ask, why does `react-redux` modify `displayName` in the first place?  If it's something that is expected for people not to rely on, why does `react-redux` rely on changing the `displayName` at all?  If `displayName` is truly inconsequential - then the `react-redux` team should have no problem removing their reliance on the ""change"" of the `displayName`.
",TigerC10,gaearon
329,2016-06-14 19:48:21,"@gnoff My apologies, the ""please don't patronize me"" remark wasn't intended to suggest that I felt like you were personally patronizing me - just expressing the fact that I don't expect that developers feel like `displayName` is truly educational.
",TigerC10,gnoff
328,2016-03-24 10:35:38,"@tgriesser  Thanks a lot, seems it is a common JavaScript gotcha, and I have to learn more about JS :100:  

Thank you a lot for your help!  ^_^.  
",Lucas-Qi,tgriesser
325,2016-03-22 01:03:49,"BOOM! :boom: :dancers: 

Thanks @gaearon!
",renanvalentin,gaearon
325,2016-10-24 20:13:34,"@gaearon How do you test that the state tree looks like you expect?

e.g. I change the structure of the state tree by changing the reducer and make sure to change the tests there. Now all my tests pass, but the connected component is broken since it's not mapping the state correctly, anymore.
",flushentitypacket,gaearon
323,2016-03-20 22:53:13,"@tgriesser thanks for your feedback.

Yes it looks like passing props too does not cost much :)

Also I'm surprised that you comment positively on this because I've just discovered ""structured selectors"" of Reselect. I don't find the name very good but it was built after your [issue](https://github.com/reactjs/reselect/issues/42) and seems to almost do what I propose here...

What would my PR help you solve that you can't already with:
`connect(createStructuredSelector({selector1, selector2}))`

Not sure to understand your comment about using a factory. Is this the little thing added recently that almost nobody has to use but that can leverage better performances? ^^
",slorber,tgriesser
323,2016-03-23 09:20:52,"thanks for your feedback @tgriesser 

I have no strong opinion on this as the `createStructuredSelector` is already in Reselect and I already use it, but being directly inside Redux would be a bonus.

@gaearon tell me when you have decided, I may rework a little my PR with some code of @tgriesser before merge.

@tgriesser btw, now that you removed your optimisation that finally does not work (don't know why but I trust you), couldn't we just use `mapValues(mapStateToProps, val => val(state, props))` in all cases?
",slorber,gaearon
323,2016-03-23 09:20:52,"thanks for your feedback @tgriesser 

I have no strong opinion on this as the `createStructuredSelector` is already in Reselect and I already use it, but being directly inside Redux would be a bonus.

@gaearon tell me when you have decided, I may rework a little my PR with some code of @tgriesser before merge.

@tgriesser btw, now that you removed your optimisation that finally does not work (don't know why but I trust you), couldn't we just use `mapValues(mapStateToProps, val => val(state, props))` in all cases?
",slorber,tgriesser
323,2016-04-15 10:05:48,"@gaearon are you still interested by this PR? 

Tell me and I'll update my PR (because with recent optims I now understand better code suggested by @tgriesser )
",slorber,gaearon
323,2016-04-15 10:05:48,"@gaearon are you still interested by this PR? 

Tell me and I'll update my PR (because with recent optims I now understand better code suggested by @tgriesser )
",slorber,tgriesser
323,2016-04-23 13:37:34,"@gaearon I've updated my PR with @tgriesser suggestions
",slorber,gaearon
323,2016-04-23 13:37:34,"@gaearon I've updated my PR with @tgriesser suggestions
",slorber,tgriesser
323,2016-10-04 09:19:02,"@jimbolla @gaearon @timdorr I suspect this will be doable in userland with `connectAdvanced` no?
",slorber,gaearon
323,2017-01-12 16:56:39,"@gaearon @jimbolla @tgriesser it's been a while that this PR is open and it seems I'm not the only one wanting this

Would this get merged if I port the PR to work on master, polish it a bit and add better documentation?",slorber,gaearon
323,2017-01-12 16:56:39,"@gaearon @jimbolla @tgriesser it's been a while that this PR is open and it seems I'm not the only one wanting this

Would this get merged if I port the PR to work on master, polish it a bit and add better documentation?",slorber,tgriesser
323,2017-01-12 16:56:39,"@gaearon @jimbolla @tgriesser it's been a while that this PR is open and it seems I'm not the only one wanting this

Would this get merged if I port the PR to work on master, polish it a bit and add better documentation?",slorber,jimbolla
323,2017-01-13 10:09:12,"Hi @jimbolla

For now I've not really used these factories, do you refer to [this](https://github.com/reactjs/react-redux/blob/master/docs/api.md#examples-1)? 

Because what I see as signature in doc is `(dispatch => (nextState, nextOwnProps) => stateProps` which does not really look like your example signature. Can you give me a doc reference? It seems to me only connectAdvanced takes a factory, and only one while your exemple assume we can provide as many factories as props we want. Can you give me a unit test that showcase this feature?

Also could we mix both styles?



I'm not sure it would be easy to detect weither makeGetSometThing is a normal selector or a factory as both are functions


",slorber,jimbolla
323,2017-01-13 23:39:36,"@markerikson I see your example but still it's different from what @jimbolla show in his code snipped



VS

 


Maybe I'm missing something, but can you give me the verbose version of the following snippet?

",slorber,jimbolla
323,2017-01-13 23:39:36,"@markerikson I see your example but still it's different from what @jimbolla show in his code snipped



VS

 


Maybe I'm missing something, but can you give me the verbose version of the following snippet?

",slorber,markerikson
323,2017-03-08 06:26:28,"Hi @slorber @markerikson and @jimbolla ,

I wasn't aware that this PR was here and I opened a similar PR that -obviously- got immediately closed by @markerikson. Sorry about that, I did check in the opened issues if there was a feature request for this and I saw nothing. I should have also checked in the opened PRs... my bad!

I would really like to see this enhancement shipped and I'm pretty sure that I know how to solve the ""factory style"" issue that seems to be blocking this PR. Is it cool if I solve that issue in my branch? Or should I try to add a commit to this branch?

",josepot,jimbolla
323,2017-03-08 06:26:28,"Hi @slorber @markerikson and @jimbolla ,

I wasn't aware that this PR was here and I opened a similar PR that -obviously- got immediately closed by @markerikson. Sorry about that, I did check in the opened issues if there was a feature request for this and I saw nothing. I should have also checked in the opened PRs... my bad!

I would really like to see this enhancement shipped and I'm pretty sure that I know how to solve the ""factory style"" issue that seems to be blocking this PR. Is it cool if I solve that issue in my branch? Or should I try to add a commit to this branch?

",josepot,markerikson
323,2017-03-08 09:37:06,"Hi again @slorber @markerikson and @jimbolla !

I've added the [following commit into my branch](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758) which makes the `mapStateToProps` object argument compatible with factory selectors as [@jimbolla suggested](https://github.com/reactjs/react-redux/pull/323#issuecomment-272251764).

I've also added [the following test](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758#diff-b5fd7a42ea1b8efa382416b4a323003cR1951) to make sure that it works... and it does 😄 

Since this PR seems to be stale, would it be ok for me to suggest that I make the PR from my branch which also has no conflicts with master?",josepot,jimbolla
323,2017-03-08 09:37:06,"Hi again @slorber @markerikson and @jimbolla !

I've added the [following commit into my branch](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758) which makes the `mapStateToProps` object argument compatible with factory selectors as [@jimbolla suggested](https://github.com/reactjs/react-redux/pull/323#issuecomment-272251764).

I've also added [the following test](https://github.com/reactjs/react-redux/commit/7d21e7beaeab2da0a94c1f3158e95ceae1771758#diff-b5fd7a42ea1b8efa382416b4a323003cR1951) to make sure that it works... and it does 😄 

Since this PR seems to be stale, would it be ok for me to suggest that I make the PR from my branch which also has no conflicts with master?",josepot,markerikson
322,2016-03-21 21:02:20,"Yes, Dan @gaearon,
This is the [repo](https://github.com/srlopez/rntest), and in the [src/pages/TestForm.js](https://github.com/srlopez/rntest/blob/master/src/pages/TetsForm.js) you can see:



Direct dispatching in point 1, does not reflect in screen (the field name remains empty), but delayed dispatching as in point 2, reflect the mutation in field URL (and in NAME  too if both lines of code are executed, without comment marks)

Talking about Redux, the 'scene' is connected in [App.js](https://github.com/srlopez/rntest/blob/master/src/App.js) lines 55-67



And the `App` is on lines 21-53 of the same file, as a typical `Navigator` component, so all the scenes are 'connected' and the connectComponent is the typical  react-redux '`connect`' function in [AppContainer.js](https://github.com/srlopez/rntest/blob/master/src/AppContainer.js), just few lines ...



There is no doubt, the component is '`connect'ed` and Redux is well working, the trace display all the actions are dispatched. 

To test the behavior we are talking about, you know, clone the repo, run it (you can run using `npm run nurse`), next on first screen, press 'Go to Form' and ... you pass throw the `componentWillMount()` above.

If you need some help, this Form is inspired by @kasprownik and his code in this [repo](https://github.com/kasprownik/react-forms-tutorial) write in ReactJS and well explained in this [http://x-team.com/2016/02/tutorial-forms-in-react-and-redux/](blog)
",srlopez,gaearon
313,2016-04-14 17:29:34,"Thank you @gaearon!! It's nice to be able to still have `routes` in a separated file. 

BTW, I really like your Redux training on egghead.io. I really enjoy the way you describe the idea, then do a simple implementation, and then finally add layers of abstractions at the end. It's the best training video I've seen in the last several years. Thank you!
",jungejason,gaearon
313,2016-04-15 13:11:06,"The ability to abstract `routes.js` is super helpful. 

On another note, I side with @jungejason -- thank you for all that you do @gaearon, your egghead videos are the reason I decided to migrate our web stack to React + Redux and away from Angular. I'm a much happier person now :)
",Robinnnnn,gaearon
309,2016-03-22 16:58:12,"Hey @BerkeleyTrue, @gaearon, is anyone working on this currently? 
Would love to take a look and see if I can work on this if no one is. :smiley: 
Cheers!
",moaazsidat,gaearon
307,2016-03-05 05:56:21,"@iamakulov  Thanks lot for your answer. I understood how to dispatch for initial loading.

> The dispatching can take place in any appropriate part of your app. If the app is small, I’d do it right where the store is created.

Now, my application wouldn't be small. I have scenario where I need to initialize a component with fresh data whenever it gets called. 

Now, I have three case where my component gets called.

1). When I simply click on link to go to ""home"". `<Link to=""/home"">Home</Link>`

2). When I do dynamic routing to ""home"". `store.dispatch(push(""/home"");`

3). When user sometimes directly change URL in brwoser and hit ""Enter"". `http://localhost:8080/myapp/home`

> The dispatching can take place in any appropriate part of your app

So, I actually don't know what is appropriate part of my app where I can handle fresh data loading in all three scenarios?

@gaearon Can you please reopen the issue? Because I still confused and my closed issue might not get any attention.

Thanks again
Manan V. Panchal
",mananvpanchal,gaearon
306,2016-03-05 08:42:31,"@gaearon sorry, maybe I said it wrong. The ""problem"" is that I don't want the store to be overridden. The point is to have **both** stores in the `contex`:



Besides those technical details, how do you see this approach? Does it make sense for you?

Thanks.
",emmenko,gaearon
301,2016-09-15 14:54:17,"Hi @gaearon , thanks for your answer. I am having a similar problem (check http://stackoverflow.com/questions/39513753/how-can-i-force-re-rendering-when-redux-state-is-changed-but-react-does-not-trig).

As far as I understand, React will re-render a component if nextProps and actual props differ. Why is it then needed to call the componentWillReceiveProps(nextProps) method, should the component do this automatically?

Thanks again!
",nicmesan,gaearon
300,2016-03-04 23:33:26,"@markerikson i already made sure that my stateToProps does not do funny things. 

I discovered that my purely functional component only re-renders if i fire an action that changes the query params using redux-router `replaceState`. If i fire another action the store does change but my component does not actually rerender (which is good). There must be something that react-router does which is unrelated to redux. As you explained it the connect wrapping element should be able to prevent the normal 'react' way of updating the components, but it's not
",davibe,markerikson
294,2016-02-23 18:19:48,"I agree with what you are saying. @gaearon `react-css-modules` is invasive and @FredyC you are correct you _can_ go very far with vanilla css modules, but dasherized css class names i.e. `my-css-class-name` is a very common use case it supports. To me it felt like the lesser of two evils. I mean what if you want to include third party css? Was thinking about writing a postcss plugin that rewrites the class names to camel case to fix this the 'easy' way, but realized that React looks for dasherized class names when adding CSS transitions :/ . cc @gajus
",kristoferjoseph,gaearon
292,2016-02-18 02:21:57,"@gaearon We encountered this same issue early on in development of Relay and are using `unstable_batchedUpdates` to prevent such discrepancies at the framework level. We have a `relayUnstableBatchedUpdates` module that is forked to use the appropriate version depending on web/native - see the two versions at https://github.com/facebook/relay/tree/master/src/tools.
",josephsavona,gaearon
292,2016-02-18 05:07:50,"Thanks everyone for taking a look and weighing in! I'm very interested if you find out more details about incorporating `unstable_batchedUdpates` @gaearon 
",chandlerprall,gaearon
292,2016-02-18 15:38:32,"@gaearon yup!
",josephsavona,gaearon
292,2016-02-26 13:26:28,"@gaearon 

If 

1) only root component subscribe to redux store.
2) all component passing store to all children in JSX, something like:



3) all container components do `this.setState({ store: nextprops.store, ... })` in `componentWillReceiveProps(nextprops)`

Do you think the problem will be solved?

This is basically the React way. I think react-redux should NOT `setState()` outside the React work flow (reconciliation). Store state should only be passed by props in top-down manner, and `setState()` should only be called in componentWillReceiveProps(). The root cause of the problem could be considered that redux uses a single JavaScript object, and redux emit change events too early.

Besides, the reference equality check, the gem of redux, could be done in shouldComponentUpdate(). Here, both store state and props is synchronized, and unnecessary render() can be prevented.

If this works, it looks much cleaner than current implementation in react-redux.
",matianfu,gaearon
292,2016-04-30 14:33:09,"@tappleby 

> My only idea is having each connected component being responsible for notifying its own children instead of subscribing directly to the store, this would end up with only the root connected component being subscribed to redux.

I agree with that.

It looks to me an antipattern to have `Parent > Child`, both using `connect`, and parent passing down props to child. If Child has to receive props from Parent, the parent could pass as props everything the child needs. I don't really see any advantage of the child receiving state from both props and connect at the same time and it's probably better to choose one or the other but not both at the same time.

@epeli 

> But the biggest argument for enabling it by default in my opinion is that it makes dispatch() consistent. Currently by default dispatch() can surprise you because it works differently depending on when you happen to call it. Ex. onClick vs. setTimeout.

Do you mean that dispatches from event handlers are batched automatically? If that's the case yes it's probably worth batching automatically on dispatches to have a consistent behavior, even if I still think the issue described here can be avoided in the first place.
",slorber,epeli
290,2016-02-17 04:53:42,"@mikekidder I'm not aware of it, could you please point to some examples?
",aikoven,mikekidder
290,2016-02-17 07:28:17,"@gaearon - I also had this problem, but did not found any good solution. It's actually problem of how `.tsx` understands component class.

@mikekidder - Angular2 decorators are not useful here. Their way is binding a property of a class to input attr. If something similar was made for react it would look like this:



and now `render(…, <App/>)` would compile, because binding of `title=""…""` property to component attribute `appTitle` is done under the hood and `.tsx` compiler thinks that `App` does not have any props. And this of course will work well if we omit using of regular `props`…
",ulfryk,mikekidder
290,2016-02-17 07:28:17,"@gaearon - I also had this problem, but did not found any good solution. It's actually problem of how `.tsx` understands component class.

@mikekidder - Angular2 decorators are not useful here. Their way is binding a property of a class to input attr. If something similar was made for react it would look like this:



and now `render(…, <App/>)` would compile, because binding of `title=""…""` property to component attribute `appTitle` is done under the hood and `.tsx` compiler thinks that `App` does not have any props. And this of course will work well if we omit using of regular `props`…
",ulfryk,gaearon
289,2016-03-01 18:18:32,"Hi @gaearon 

Since React-Router allows you get access to the router, history, location etc.... via the context, how can you get access to the context from mapStateToProps() ?

Since its now a documented feature of React, react-redux should expose context in the public api, right ?

Best regards ?
",lauterry,gaearon
289,2017-01-18 02:08:07,"@jimbolla By only injecting it into `connectAdvanced`, we're limiting the arity problem. You don't have to worry about how many args `mapStateToProps` or `mapDispatchToProps` take because the user is now in control of that.

Whether or not the context is passed to the inner function of `selectorFactory` could be a factory option; perhaps `{contextTypes: xxx}`, same as what the React Component and `recompose` accept.

`reselect` is a separate package; `react-redux` isn't responsible for that. Regardless, I think most of us are just going to copy the relevant context into the props, and then `reselect` will be able to handle it just fine. That's exactly what I've done, and it's working great so far.

I did manage to get [`getContext`](https://github.com/acdlite/recompose/blob/master/docs/API.md#getcontext) working though, so thank you for that! This would have been a big pain without it. I suppose I'm less concerned about this now that you've posted a reasonable workaround, but it doesn't sound like it would be that difficult to add. I think the lifecycle problem can just be ignored -- context updates simply won't be propagated since React doesn't really support it anyway.",mnpenner,jimbolla
285,2016-02-12 17:07:23,"@gaearon thanks for the quick feedback. I'm really interested in getting something that works for this, but it seems you have pretty specific ideas about how it should work. Would you mind giving a little bit more guidance on how you'd like to see this structured? Happy to put the work in to get to something useful. I'm struggling to see how to get a clean API here without inheritance when so many lifecycle methods are involved. We could double wrap the component but that seems even worse to me.
",mhodgson,gaearon
281,2016-02-05 14:55:45,"Thanks @gaearon.  This was extremely helpful. Have a nice weekend.
",TomiS,gaearon
279,2016-02-09 22:06:51,"@tgriesser I have started to update the Reselect docs to reflect this change. If you haven't started on this already, would you like me to carry on and document it?
",ellbee,tgriesser
270,2016-01-27 00:02:04,"@gaearon:
Currently, `static` methods are hoisted, why not `prototype` methods? What's the difference? Current implementation just seems incomplete.
With this functionality, `@connect` can be added or removed without caring about changing how `refs` are managed from containers.
I integrated this into my app and it works flawlessly.

A. Can you think of a scenario where it wouldn't be desired?
B. If I change the code to hoist methods optionally, e.g. `{ withRef: true, hoistMethods: /* whitelist */ ['focus', 'scrollToBottom'] }` or `{ withRef: true, hoistMethods: /* all methods */ true }` 
would this be merged?
",elado,gaearon
270,2016-09-20 06:19:47,"Dan @gaearon , thanks for your great input!

I'm using your suggestions to implement my wizard. Basically what i'm doing is when clicking the next button in Parent component (the wizard container), I need to call the submit function of Child component (the wizard page).

before I wrap my child component with connect, I was able to call wizard page's submit method by wiring up Parent ->  Child thru ref, i.e   



and it worked fine.

I then found out that I need to wrap my child component to a connect component , and after that, I lost control to the Child component, as the activePage is now pointing to the wrapper component, which doesn't have submit method defined (only static function hoisted, not prototype)

Yes, I can use getWrappedInstance() which I believe will work just fine, but I really like your idea of passing callbacks to child and let child set the value that Parent is interested in, so I decided to give it a go



and this also works fine as well. great! 

my question, is that when passing a callback to child, why can't we name the prop 'ref', i.e. 



won't work and will cause exception at child component, saying this.props.ownProps.ref is undefined, but I have defined it and passed down to child.. don't really understand why I got that error

does this mean that connect component will selectively filter out some props?
",bochen2014,gaearon
269,2016-01-29 17:29:03,"@gaearon a usecase for https://github.com/rackt/react-redux/pull/208 would be to build a React.Perf middleware so that we can take measures for every dispatched action.

If subscription returned a promise resolved on setState callback, then the redux Middleware could be able to know when rendering has ended and measure wasted time that is relative to a given action.
See also this issue that can make it more complicated to build: https://github.com/facebook/react/issues/3611

There's already a not-really advanced middleware that does not take account that renderings can happen in an async way: https://github.com/AvraamMavridis/redux-perf-middleware

---

Also for my initial custom connect proposal I think another usecase is when we want to bind dom inputs to redux state. It might work well with events on a small app but I guess once the app becomes big, on a mobile device typing in an input triggering hundreds of HOC may be a problem?

---

@gaearon yes that would be great to provide full flexibility so that we can compose code in the way we want to use it without rewritting/forking the lib.

Also it can be nice to have an experimental API so that you can eventually change your mind later.

I  don't have an API in mind I'll have to digg deeper in the implementation details of connect :)
",slorber,gaearon
269,2016-02-11 18:26:27,"@gaearon @slorber I have a PR that attempts to address this here: #285. Would be interested in your thoughts. Not ready to merge, but want to know if it is directionally interesting.
",mhodgson,gaearon
269,2016-02-13 12:56:37,"@gaearon also it seems there is a community need to run multiple redux stores (https://github.com/reactjs/redux/issues/1385)

It could be nice if we could also pass to the provider a map of stores and if the connect method was flexible enough to permit to select the appropriate store from context
",slorber,gaearon
269,2016-05-02 09:50:56,"@gaearon @slorber @mhodgson 

Was playing around with one attempt at splitting the core connect features into two different HOC: connector and cacher.

https://github.com/jtadmor/react-redux/commit/b829ece0688f71b0b5acb2ed73233f075487d8d6

The basic idea is that cacher should not know at all about the store or where state comes from. It receives all of the old connect() arguments, but doesn't actually hook up to a store. Instead, it requires the following props:



Instead of a handleChange method, it will now attempt to calculate mapStateFromProps only when storeState changes or if mapStateFromProps depends on props and ownProps changes. Ditto for mapDispatchToProps.

The connector accepts a wide variety of options:



These are designed to give consumers ability to customize the behavior, while falling back to sane default behavior, e.g. `store` falls back to `context.store`, `dispatchFromStore` falls back to `(store) => store.dispatch` and so forth.

You could call `connector()(Component)` and it would work just fine.

Regarding updating the subscription on `componentWillReceiveProps`, I've tried to solve that by allowing the options to specify either `subscribeFromStore` or `subscribeFromStoreAndProps`, and optionally allow a `resubscribeIf` that would look like `(props) => props.node_id`. This forces consumers to be explicit about whether resubscriptions should ever happen while the component is mounted but also provide fine-grained control.

I based this on suggestions [here](https://github.com/reactjs/react-redux/pull/348#issuecomment-214131076).

The major thing I'm not sure on is how to avoid `setState` on Connector when Cacher is not going to end up re-rendering. Right now the `handleChange` default behavior is to do a `setState` whenever the store broadcasts. Although Connector does allow for other optimizations, I'd need to figure out how to keep that one.

What I'm not sure on is the best API for each. Right now they are separate functions, but still very coupled in that Connector passes down storeState, ownProps, dispatch, and Cacher consumes those. One possibly way to make them more re-usable is to allow, e.g. Cacher options argument to let the consumer specify something like `getOwnPropsFromProps = (props) => {}` and `getDispatchFromProps`, `getStoreStateFromProps` likewise.

Also, we now have two wrapper components instead of one to provide the same basic functionality as before. (This could be mitigated by keeping connect as is, but export the two more modular HOC as well, although that leaves future development a pain).

Let me know if this seems like a fruitful avenue.
",jtadmor,gaearon
269,2016-05-02 10:09:47,"At first glance I like the extensibility and decomposition of the problem but I'm not sure it would be nice for performances to have 2 wrappers instead of one, when we already focus on optimizing the single one we currently have. 

I don't know what @gaearon exactly had in mind when saying

> Basically, what if we separated the component in connect from the caching and invalidation logic.

But I guess the idea is that the caching logic would be an utility function instead of a new wrapper, to avoid degrading performances

See also work being done here: https://github.com/reactjs/react-redux/issues/368
",slorber,gaearon
265,2016-01-24 03:15:37,"Hey @gaearon,

Yeah, I guess my question is very specific. So let me generalize it a bit. :)

From your egghead.io Redux tutorial, how would you `connect()` each Todo so that only the changed Todo re-renders (instead of the entire list)?

Here's my [JSBin](https://jsbin.com/lucego/edit?js,console,output) of the Todo example. I've: 
1. set an initial state, 
2. commented out where TodoList is `connect()`-ed, 
3. and `connect()`-ed the Todo component.

In `mapStateToTodoProps`, I don't know which Todo to reference in the Todos array, so I thought `ownProps` was how to do it. If you click on a Todo, the state correctly changes (see the console) but the Todo component does not re-render.

I hope this makes better sense. Thanks!
",gojohnnygo,gaearon
263,2016-01-22 07:13:29,"@epeli not sure I understand the issue, can you please explain with code?

So far it seems that the issue of multiple unnecessary renders is gone, due to debouncing it, and store is filled correctly after every single dispatch action (it doesn't wait for the debouce time to execute a bunch of actions together).
",elado,epeli
255,2016-11-09 19:59:59,"@gaearon , I'm not sure I quite follow, how do we get dispatch passed into our component that also uses the mapDispatchToProps argument?

Thanks!
",tnrich,gaearon
253,2016-10-30 22:23:02,"@markerikson I'm not sure what that means.   Are you saying ""because of the temporal dead zone, we can't do better with an error message for this issue""?
",GreenAsJade,markerikson
237,2016-01-04 23:52:50,"@gaearon Thanks for the info.

With that taken into consideration, I still think having `getState` in `mapDispatchToProps` is an important missing piece. Obviously, not everyone agrees with putting asynchrony downstream of the store. But as long as that's not an _unreasonable_ architectural choice, then the downstream still needs a way to get the state after it may have been updated. As far as I can tell, it would add a possibility that doesn't exist today. I may be missing something, but I don't think the solutions you presented account for this, because I don't think `mergeProps` allows for it. Also, It doesn't seem like having a `getState` callback would ruin performance, as it could be injected once and always work.

react-redux is a _great_ API, and I hope my comments haven't come off to the contrary. But I hope you understand that it makes more sense to try to advocate for ideas in an existing library than to maintain a fork or entirely separate product. I realize that a great deal of thought has been put into this already, so no disrespect intended to the work that's already been done. I haven't read #1 yet, but I definitely will, because I want to present productive ideas that haven't already been beaten to death.
",acjay,gaearon
237,2017-03-16 21:33:19,"@gaearon Dan, I wonder, the default `mergeProps` is `Object.assign({}, ownProps, stateProps, dispatchProps)` as stated in the docs.
Doesn't that also create a new object all the time, just like when one would override `mergeProps` with a custom function for binding action creators?

> Absolutely correct, this is a performance nightmare scenario where nothing really changes but bound functions kill the performance optimizations.

But when nothing really changed, the default `mergeProps` still creates a new object on every render. How does that not matter?
Maybe I'm confused, where the pure-render optimisation kicks in and which props it checks.",pke,gaearon
236,2016-01-07 18:41:35,"Before checking anything I just replaced `import { connect } from 'react-redux/native'` with `import { connect } from 'react-redux'`. Also updated the following:



I use the most recent version of `react-redux`:



I didn't need to change anything in the `react-redux` package. It just works, as expected by a tool from @gaearon ;-)
",Purii,gaearon
236,2016-02-04 16:04:00,"@gaearon Thanks Dan, looks like it's working :)

But, now I get a different error:



Which seems there's [no solution](https://github.com/facebook/react-native/issues/4968) yet :(
",ranyefet,gaearon
236,2016-02-17 15:05:02,"Good! But wasn't it included in 0.20? @gaearon do you recommend reinstalling the modules to make it work right now? 
",Emilios1995,gaearon
236,2016-02-17 17:54:57,"@gaearon working on it :) We'll know by Friday if ""React as as a peer dep"" is going to make it into the 0.21-RC branch cut.

Thanks for the ping. Trust me, we're working hard to get this stuff worked out and make React Native a better member of the general React ecosystem.
",skevy,gaearon
234,2016-02-07 23:48:59,"Hi @gaearon 

I'm not sure to understand your answer to @chrishowes .

Can you provide an example of what you mean by creating a custom higher-order component and how to use it.

Thx

Best regards
",lauterry,gaearon
228,2015-12-26 22:50:57,"@gaearon I share your point that it's fine to copy/paste and fork and really like these posts on the subject:
- http://us3.campaign-archive2.com/?u=1090565ccff48ac602d0a84b4&id=92902a19e4&e=6dbbf45b40
- http://udidahan.com/2009/06/07/the-fallacy-of-reuse/

Here it seems that the API surface to implement the connect feature is very small and that an abstraction make sense (like you probably did for react-hot-api?). Also if it's possible to avoid forking and benefit from further optimizations done by the community without having to backport it's better for me :)

I would be interested to know how you see implementations could diverge because I'm not sure how it could happen unless new redux store methods are added?

---

Anyway I've found another simpler option.



Let's consider the Redux store API as a reference implementation of a ""react connect standart"": I'll wrap my framework so that it exposes the exact same API in react context and it should work. Other frameworks could easily do the same too
",slorber,gaearon
227,2015-12-23 11:36:02,"@gaearon Thanks! Works fine with [v4.0.4](https://github.com/rackt/react-redux/releases/tag/v4.0.4).
",xcatliu,gaearon
223,2015-12-28 10:34:15,"@vsviridov I had the same situation :D, thanks to @gaearon advice, this works for me


",allochi,gaearon
217,2015-12-18 05:42:55,"@alexkuz just to update you, i changed things to look like this:



I am not super content with it and perhaps will visit reselect as @gaearon suggested. What I found is that the router state changes, and that creates many problems with the merge state as the component is still rendered and fails given the params have changed. I found the best solution was using react router's params being passed as props. But i may look to use reselect to clean this up more.
",mmahalwy,gaearon
215,2016-02-11 19:10:03,"Sorry, @gaearon. Wrong thread to discuss the issue. Though I think @ohkaiby was talking about Redux documentation.

I couldn't find anything searching ""site:rackt.org HMR"", which would be useful. I came across this issue searching for ""store.replaceReducer"".
",gajus,gaearon
212,2015-12-12 19:05:59,"@ellbee Any other work there, or can I release 4.0.1 that doesn't have `.babelrc`?
",gaearon,ellbee
212,2015-12-12 19:08:09,"@gaearon Go for it.
",ellbee,gaearon
210,2015-12-18 04:45:15,"@gaearon alright after doing some digging, I found the problem. `connect` doesn't call `trySubscribe` until `componentDidMount`. As such, it doesn't see the dispatch/state change that happens in `componentWillMount`. I'll add a `componentWillMount` and some logic to catch this scenario.
",lsapan,gaearon
210,2016-04-19 22:06:37,"@gaearon would something like Alt.js `componentDidConnect` be applicable to `react-redux`? This seems like a valid case that would be nice to have support for. 

https://github.com/altjs/connect-to-stores/issues/6

https://github.com/altjs/utils/blob/master/src/connectToStores.js#L80-L88
",chrishoage,gaearon
210,2016-05-24 10:37:40,"@chrishoage Did you manage to dispatch actions in the `react-router` event handlers and use the changed data in the component? I'm getting the same results as I would when dispatching in `componentWillMount`.

@gaearon I'm having the issue where I need the changes in my first render because it being on the server side and if it would be picked up later it causes my server side rendered HTML would differ from the HTML on the client. So the changes being ""picked up"" on the next render is not good enough, or am I overseeing a solution to this?
",yn5,gaearon
210,2016-05-24 11:14:29,"> @gaearon I'm having the issue where I need the changes in my first render because it being on the server side and if it would be picked up later it causes my server side rendered HTML would differ from the HTML on the client.

Usually the solution is to _hydrate data first_ and then render. So rather than render in a lifecycle hook, you would get the matched components from the router, call a static method on them which dispatches an action, and wait for the promise to resolve. Does this make sense? https://github.com/markdalgleish/redial is one way of doing it.
",gaearon,gaearon
210,2016-05-24 11:32:12,"> Usually the solution is to hydrate data first and then render. So rather than render in a lifecycle hook, you would get the matched components from the router, call a static method on them which dispatches an action, and wait for the promise to resolve. Does this make sense? https://github.com/markdalgleish/redial is one way of doing it.

Thanks for your response @gaearon! I do hydrate my store before rendering. If I understand correctly that is not the problem. To be a little more specific:
I have a parameter to specify the language in the url. I would like to call an action to set the language with that value and use the newly `selectedLanguage` from the store in my component on the first render in order to render the app with the correct language. So what I tried first is calling the action `setLanguage` in the `componentWillMount` of the highest order component and came to understand the props (which are connected to the redux state_ can not be updated before the component renders. So I went with @chrishoage's suggestion to dispatch the `selectLanguage` action inside the onEnter hook of my highest order route but throughout the first render of the component this newly `selectedLanguage` does not get picked up. 
",yn5,gaearon
210,2016-05-24 11:53:48,"> I think the problem is you’re effectively duplicating the data between the store and the router. Why not just use the router params for this? Is there any particular reason you prefer it coming from the store?

Since there are other ways to change the language than just with the URL I would have to then have to duplicate the state between the store and the router if I understand correctly.

Edit: I think you're right though, I should not try to do this with redux, I'll try to only use the params only. Thanks a lot for your help @gaearon.
",yn5,gaearon
210,2016-06-17 08:27:31,"@gaearon I have sync action which fill up data in store while dispatching action using higher order component `componentWillMount` , but I am facing issue that the values are not defined with the WrappedComponent on the server side rendering. But client side it renders two times and it works. Am I doing something wrong ?


",mihirsoni,gaearon
210,2016-08-24 11:57:53,"@jimbolla a case was provided as a PR further up, #222. The test in the top as well should be good enough to understand the issue. The current test is basically wrong, it doesn't assert what it's supposed to do. 

However, this was closed as working as intended. I'd argue it's not as intended, just a weakness in how connect works and more of a wont-fix.
",Matsemann,jimbolla
210,2016-09-06 22:15:10,"@Matsemann Yes, I think you make a great point!    

You are correct that the React API for `componentWillMount` specifies that state changes will take place before the first render.  It's easy to expect a synchronous dispatch to a Redux store from within `componentWillMount` to behave the same way.

I agree this is confusing, and I think it's worth discussing how (or if) its feasible to improve it.

**To be clear, this is not a Redux issue, it's a ramification of how the `react-redux` bindings are implemented**. 

As @markerikson  said, `react-redux` pushes everything from the store down to connected components via `props`.  This means at the time of mounting, the props have already been pushed down, and there is no way for the component to intercept those props with an immediate state change like you can do with `setState`.

Back to the `isFetching` stuff: I hope you can agree that there _are_ three distinct states --- the question is which of those states `render` needs to be capable of handling?  In vanilla React, you can _ensure_ that `render` never ""sees"" one of those states, by running your `setState({ isFetching: true})` in `componentWillMount` (I believe this is the invariant that @Matsemann is talking about).

The problem in `react-redux` is there is no way _from within the component itself_ to change props; by the time you're inside `componentWillMount`, it's too late.

As far as I know, there are only three ways to remedy this issue:
1. Modify `react-redux` to subscribe to the Redux store from within your component (rather than from within a wrapper around your component). This likely has many ramifications that could lead to different problems, although perhaps it's worth exploring.
2. Modify your application so that your component never sees certain states (i.e. find a different way to ensure that `{ isFetching: true}` is the first state seen by your component).   Ultimately this means putting your fetch dispatch somewhere _outside_ of your component (personally, this is what I do)
3. Modify your application so that `render`  can handle all 3 states (which is what[ I proposed earlier](https://github.com/reactjs/react-redux/issues/210#issuecomment-244774674) to @jordanmkoncz ).

Ultimately (and perhaps unfortunately), it's not as simple as blindly swapping out `setState` for `dispatch`. 

I agree with @markerikson that this is intrinsic to a parent-child props relationship.  However, a potential problem is that **it's not conceptually obvious that `react-redux` _is using_ such a relationship in its implementation of `connect`.**

In other words, we are not encouraged to think of connected components as presentational ""children"" receiving props from a connected wrapper --- instead, we tend to think of the component being connected and the resulting decorated component as one-and-the-same. At least, that's my _perception_.  It's pretty common to see connected components that have data fetching inside of them, which _can_ lead to problems.

Perhaps `react-redux` or Redux needs to clearly delineate suggestions for how you might need to modify your application to handle these subtleties?

One conceptual way to handle these subtleties is to treat your components as _presentation only_ as @markerikson suggested. In other words, force yourself to think of your components as simply receiving state with no ability to change state (as opposed to what you might traditionally do in `componentWillMount`)

Personally I take _presentation only_ to an extreme -- I use a modified version of `connect` that accepts a `componentWillMount` argument that runs in the context of the connected wrapper instead of the underlying wrapped component.  This means the component knows nothing about fetching data. It also means that my `dispatch` occurs _before_ my component is mounted, which means **I actually get the behavior you desire** (i.e. my `render` function _doesn't_ have to deal with the ""not fetching yet"" state).  However, this is not a simple library tweak we could code into `react-redux` -- it's a fundamental shift in how I (or you) think about components.

**TL;DR**

In vanilla React, components are meant to be a mix of state management and presentation.

In vanilla Redux, if you try to mix state management and presentation, you _can_ run into non-obvious problems.

**Ultimately, the switch from `state` to `props` is subtle, but significant**, and you cannot blindly change `setState` to `dispatch`.

Perhaps `react-redux` docs could do a better job at helping people navigate these subtleties?

Perhaps `react-redux` could be rewritten to use `state` instead of `props`? (various difficulties in doing that, I believe).

I appreciate the discussion and would welcome your thoughts.
",naw,markerikson
210,2016-09-07 00:25:23,"Thanks for your perspective and also the link, @markerikson 

For context, let me explain my personal philosophy (just an opinion):

I believe a truly presentational component should:
1. Never fetch data
2. Never use `dispatch`

A presentational component receives props. Those props are generally either a piece of data to render, or a function to call when something interesting (like a click) happens.  These pieces of data generally are slices of Redux state, or at least _derived_ from Redux state.  The functions are often bound-action-creators.  (I know you know this, @markerikson, just trying to be very clear within the discussion)

I don't think a presentational component should ever dispatch something like `dispatch({type: FETCH_RECORDS})` or call a function like `this.props.fetchRecords()` --- if it did that, I wouldn't call it a presentational component.

I suppose you could consider ""I am mounting"" as something interesting, in which case the parent could expose a function through props like`this.props.iAmMounting()`, which could fetch data indirectly.  In this case, it would be very clear that you have to `render()` with your existing props, and patiently wait for your parent to react to your `iAmMounting()` call by delivering new props to you.

If we _did_ think about our components like this, [which I believe was your point farther up](https://github.com/reactjs/react-redux/issues/210#issuecomment-245042597), then the subtleties discussed in this issue could be avoided. I think we're on the same page in this regard. :heart: 

So, one question is whether people generally ""get"" that they need to construct their components differently when they use Redux than when they use vanilla React?  Or, is it trivial to convert an application from vanilla React to Redux?  Can (or should) we make it more trivial to do so?

There are two extremely different conceptual ways to approach this:
1. Encourage a high-level of separation between the wrapped presentational component and the connected wrapper. 
2. Encourage React-like hybrids where state management and presentation are mixed.

**My opinion is that the current `react-redux` implementation falls in the middle somewhere, doing a reasonably good job at both, but not a spectacularly good job at either.**

A better version of (1) would put things like `componentWillMount` _inside_ the wrapper, and explicitly discourage anything but presentation in the wrapped component.

A better version of (2) would subscribe to the Redux store directly inside the component (i.e. no wrapper), so that the component's state can be manipulated directly (e.g. `mapReduxStateToComponentState` instead of `mapStateToProps`)

To be clear, I'm not trying to rag on `react-redux` --- It's great --- I'm just brainstorming some ideas for improvement --- I hope nobody's toes get crunched.
",naw,markerikson
210,2016-09-07 02:12:33,"@jimbolla : dude, you beat me to it by 13 seconds.  :(
",markerikson,jimbolla
210,2016-09-07 02:20:58,"@markerikson 
![frabz-oh-you-almost-had-it-you-gotta-be-quicker-than-that-782d6e](https://cloud.githubusercontent.com/assets/1851364/18297648/29da4282-7480-11e6-90b4-f4de75c3b1d3.jpg)
",jimbolla,markerikson
208,2015-12-13 14:07:17,"@gaearon The macro problem I am trying to solve is simply knowing when react is finished flushing changes to the DOM. Unfortunately the only affordance to do that is through a callback in every call to `setState`. I was hoping it would be ok to try to thread that through redux, but given that you rejected the necessary changes to Redux core I don’t think this PR will help by itself.
",mhodgson,gaearon
208,2015-12-13 14:28:22,"For the purpose of discussion, here’s a more detailed explanation of why this is necessary in some use cases: 

Assume that you are trying to create a WYSIWYG text editor for the browser (fairly common and painful endeavor). The state at any given moment is primarily composed of two things: 
1. The document itself (the thing the user is creating).
2. The current text selection within the document.

At first glance you might wonder why it is important to keep the text selection in state. The answer is simple: undo/redo. When a user triggers an undo or redo action, we not only need to restore the document to the previous state, we also need to restore the text selection to the previous state. 

It is important in this case that we fully restore the document state to the DOM **before** trying to restore the text selection. It should be obvious that trying to restore a selection of something that doesn’t yet exist on the page is problematic. Hence the need to know when the DOM has been fully rendered within the normal action emit/listener/render loop provided by Redux. After the DOM has been fully rendered, we can do the manual task of restoring the selection state on top of the DOM.

As far as I can tell, the current Redux and `connect` implementations do not support this use case. I can’t think of another use case that would require this off the top of my head, but I assume that the callback in React’s `setState` method was added for these types of rare but important edge cases. 

@gaearon do you see a different approach to this that would still allow for using redux and react-redux? Are there other scenarios in React or React-Native or even angular which might require knowing when changes to state have been fully flushed to the UI?
",mhodgson,gaearon
204,2015-11-27 17:32:48,"@gaearon , yeah they did, pretty recently, about a month ago - https://github.com/facebook/react/pull/5185
",conorhastings,gaearon
193,2015-11-24 23:39:12,"Thanks @gaearon 

I get that you should only use `context.store` with really good reason - I'm just wondering if my use case falls into that category.  I'm using [redux-rx's](https://github.com/acdlite/redux-rx) `rx-middleware` and `observableFromStore`, and have something like the following:



Essentially, I watch for any changes to the ccyPair on a tile object, and then subscribe to the price stream each time.  The ccyPair could be changed by the user or programatically in a reducer, so putting this logic in a component handler doesn't quite fit. I'm defining this as a payload on an action, which then gets handled by `rx-middleware` to push the notifications through to my reducers.

Is this a valid use case for observing the store?  If I just use `connect()` and watch for ccyPair changes in `componentWillReceiveProps`, it seems like much more work - I have to cache the last ccyPair to ensure it's changed, then if it has I should clean up the last priceStream subscription, then subscribe to a new one.  It seems much cleaner all being contained within a single observable.
",marcuswhit,gaearon
193,2015-11-29 03:37:47,"Any thoughts on the above @gaearon?
",marcuswhit,gaearon
193,2017-01-23 04:39:57,@gaearon Is there any better way to use store.subscribe other than getting store from context ('connect' doesn't help)? I'm new to Redux but I feel it's quite weird when I try to follow http://redux.js.org/docs/api/Store.html doc to do subscribe but don't know how to get the store object. Searched a long time on the internet and finally get here. I feel there should be a more apparent place to let people know the normal way to get store for store.subscribe().,shlinx,gaearon
193,2017-01-23 05:04:29,@markerikson Thanks.,shlinx,markerikson
193,2017-01-27 12:23:03,"@markerikson What if I want to pass state but don't want to subscribe to store updates? Whenever I pass `mapStateToProps` the component will get subscribed, or is there another way around it?",Damnum,markerikson
185,2016-02-02 11:58:30,"@tgriesser Would you be interested in implementing https://github.com/rackt/react-redux/pull/185#issuecomment-175832321 as an alternative approach? Would it solve your problem?
",gaearon,tgriesser
183,2015-11-11 01:14:51,"@acdlite I believe it's about enabling per-component memoization: #179, #180, #182
",gaearon,acdlite
183,2015-11-11 01:26:01,"I think we've concluded it's actually not possible to do the per-component memoization without a global LRU cache as @ellbee [mentions here](https://github.com/rackt/react-redux/pull/179#issuecomment-155565193), so this would be the next best thing.

@acdlite I typically like to use a one layer deeper shallow `===`. I have a lot of connected components and selectors which have plain Arrays as return values, and so it ends up there's a lot more unnecessary updating going on than there'd need to be if we could just check the returned Array or Object props are themselves shallow equal.

I've found the amount of time it takes to do an extra shallow compare of a few Arrays is virtually nothing compared to the expense of React going through an update cycle.
",tgriesser,acdlite
183,2015-11-11 16:57:42,"@ellbee updated, although before we go with this (although I do think it'd be a nice option to configure), I've got one more idea on an approach for #179 that wouldn't be too intrusive.
",tgriesser,ellbee
183,2015-11-12 19:49:35,"@tgriesser Appreciate the thoroughness of trying out all these approaches! I wish I had some time right now to look at this and give some thoughts, but something's come up and I'm not going to have any 'github time' at all in the next few days :disappointed:
",ellbee,tgriesser
183,2015-11-12 22:24:24,"@ellbee no worries / no rush, whenever you get around to it! I've had the same problem with my own projects lately, have no problem working off of a fork.

I really appreciate a project which takes longer to figure out the simplest solutions rather than to just merge everything - keep up the great work all! :+1:
",tgriesser,ellbee
183,2015-11-24 19:59:49,"@tgriesser Assuming we can think of an acceptable name for the option I think I like this PR the best; it doesn't add to the top level API and changes to existing code are minimal.

Coming at it from the `Reselect` angle, would a selector like the following a) work b) be performant for your use case? It occurs to me that in the common case there is probably a prop (or a few props combined) that will uniquely identify an instance of the component and can therefore be used as a key for the cache (I suppose a key could be purposely added to the props if this is not the case). I have been benchmarking a few different things and this one seems pretty good.





The `hashFn` and ignored parameter in the example is hacky but if this does actually turn out to be a usable solution I will do something with `Reselect` to support this in a nicer way (probably somehow passing the props directly to the `hashFn`).
",ellbee,tgriesser
183,2015-11-25 15:34:11,"> @tgriesser Assuming we can think of an acceptable name for the option I think I like this PR the best; it doesn't add to the top level API and changes to existing code are minimal.

Ah cool, thanks for sharing this does look pretty neat - I'll need to dig in a bit and see how this ends up working in practice.

At first glance I still believe it requires you to know too much about the shape of the component props you're connecting to in order to properly use the cache. If a key is required to make guarantees it seems it'd be leaking the selector implementation details into the component. While it probably works well it, my initial impression is that it's the wrong place to be solving the issue of having every connected component instance share a singleton selector.

Top level API concerns aside (and I'd contend it's not much of an addition since it's really a higher order `connect` - analogous to `createSelectorCreator` in `Reselect`) did you get a chance to look at what all #185 does? It passes `connect` through `connectComponent`, providing an outlet for solving the underlying issue with no change to the current API use.
",tgriesser,tgriesser
183,2015-12-17 04:38:34,"(I am coming from similar issue in `reselect`)

Let me do a recap. In short, all we want is support per-instance memoize function. I think there are few things we could do:
- Per-instance memoize function (cache bound to the instance, not ""global"")
- Per-instance selector function (since memoize function's lifecycle is bound to the selector, i.e. every selector will have their own memoize)
- LRU cache, IMHO, housekeeping and hashing takes too much effort

Since `react-redux` is designed not to expose the component instance (e.g. when `mapStateWithProps` is called, `this` is `undefined`, and, `stateProps` returned from `mapStateWithProps` will not come back again as `ownProps`), it become very difficult to maintain a per-instance selector/memoize.

@tgriesser suggested we could hold something per-instance by either:
- Keep selector as a props (search `__valueSelector` in this thread), but it requires parent component to understand what data to ""bind"", or we need to create another wrapper class
- #185 ""Thunk"" approach, `connectComponent` create the actual selector when the component is created

I like #185 ""thunk"" approach more because ""props"" approach requires another wrapper or knowledge in parent. ""Thunk"" approach is cleaner.

Consider the following nested selector scenario, `quotationSelector` is a selector shared amongst few pages. And `welcomePageSelector` is a selector only used by the welcome page.

In the old days, we write something like this, and this doesn't works well with multiple instances:



This doesn't works very well if there are multiple components on the page and each have different props. The memoize function inside `createSelector` will always cache miss.

Then in the new days (with ""thunk"" approach):



Note that `quotationSelector` is created inside `welcomePageSelectorFactory`. Thus, the top-level selector maintains lifecycle of nested selectors (and memoize functions).

I am almost good with #185, except that the name `connectComponent` and `connect` is a bit confusing. I have no objection if we are going to obsolete `connect`.

Update:

In short, I think what we are doing is:
- In the old days, `ComponentClass` holds a reference to `selectorInstance`, so every `componentInstance` share the same `selectorInstance`
- What we really want, `ComponentClass` holds a reference to `SelectorClass`, so every `componentInstance` could have their own `selectorInstance` (if they really want, they could use singleton pattern to share the instance)

And we are finding ways, either:
- `selectorInstance` could identify independent `componentInstance`, which seems impossible for now
- Every `componentInstance` will create their own `selectorInstance`, which #185 is doing
",compulim,tgriesser
183,2015-12-22 17:44:54,"@tgriesser, thanks so much for your work on this!

> I don't think changing the current connect implementation is the right option here, since it's a very common approach everyone uses
1. Should memoization per component instance not be the default way of implementing or using connect? What would be good reasons to use the default connect method instead?
2. As we go ahead with this, it would be very helpful to have an example in the README that explains how this works and ways to use this.
",oyeanuj,tgriesser
183,2015-12-25 06:12:48,"@oyeanuj, for your question.

> 1. Should memoization per component instance not be the default way of implementing or using connect? What would be good reasons to use the default connect method instead?

I think we should not break existing usages. But I do agree the current implementation is weak.

@tgriesser, I think `connectFactory` is better. But let's wait for @ellbee to make that final call.

Your code is good, I really hope to see it in the official branch sooner.
",compulim,ellbee
183,2015-12-25 06:12:48,"@oyeanuj, for your question.

> 1. Should memoization per component instance not be the default way of implementing or using connect? What would be good reasons to use the default connect method instead?

I think we should not break existing usages. But I do agree the current implementation is weak.

@tgriesser, I think `connectFactory` is better. But let's wait for @ellbee to make that final call.

Your code is good, I really hope to see it in the official branch sooner.
",compulim,tgriesser
183,2016-01-04 19:48:18,"+1 to getting this merged soon! @ellbee? :)

@tgriesser What documentation do you think we need in the guide/docs for this?
",oyeanuj,ellbee
183,2016-01-04 19:48:18,"+1 to getting this merged soon! @ellbee? :)

@tgriesser What documentation do you think we need in the guide/docs for this?
",oyeanuj,tgriesser
183,2016-01-27 17:48:26,"@tgriesser do you need some help to bring this branch up-to-date?
",compulim,tgriesser
183,2016-01-27 19:35:23,"@compulim I am happy to clean this up for this merging if this is the PR we want to use but there is also #185..

@gaearon #185 is another proposal for solving this issue, and although the discussion is happening on this PR, #185 seems to be the preferred proposal of the participants in this thread. #185 is not a breaking change, but it does introduce a new ""connect factory"" function to the API, while this PR only adds an option to `connect`. Is adding a new function to the API a deal breaker for #185? 

Both PRs look fine to me, so I don't have a big preference.
",ellbee,gaearon
179,2015-11-09 11:50:44,"@ellbee Appreciate you taking a look. Thanks. :100: 
",gaearon,ellbee
179,2015-11-09 12:32:34,"I don't understand your latest proposal yet and I'm busy with something else, so I trust @ellbee to make the right call on this.
",gaearon,ellbee
179,2015-11-09 17:46:40,"I have checked out the PR, and the approach looks reasonable but I am concerned that the `memoize` HOC in the tests is accessing private `react-redux` API, and I can't currently see how it would work if you don't access private API.

I was also wondering if we can achieve the same thing without making any changes to `react-redux`? I knocked together the following HOC to be called in place of `connect` that seems to work for a simple test project:



Advantages of the approach above: No changes to `react-redux` needed.
Disadvantages: Creates a new wrapper class for each instantiation of the component

Advantages of the PR: Does not create a new wrapper class for each instantiation of the component
Disadvantages: Changes to `react-redux` needed. Still requires a wrapping HOC to be written. Looks like the wrapping HOC needs to use non-public internal `react-redux` API.

@tgriesser What do you think? Is creating a new wrapper class every time going to be a problem? Have I missed anything?
",ellbee,tgriesser
179,2016-02-04 19:48:39,":tada: Nice work @tgriesser!
",ellbee,tgriesser
175,2015-11-05 16:03:38,"@sirreal thank you :grin: It probably just hasn't been updated to 0.14 yet.
",omnidan,sirreal
174,2015-11-06 18:53:53,"@gaearon do you have a link to the functional component in React 0.14?
",kennetpostigo,gaearon
174,2015-11-06 21:00:30,"Thank you @gaearon !
",kennetpostigo,gaearon
170,2015-11-11 00:03:48,"I agree with @gnoff about using the term ""container."" The terms ""smart"" and ""dumb"" definitely get the point across, but ""container"" is used elsewhere as @gaearon said (I'll throw recompose into the list as well) and does a better job describing the fact that the component is in fact wrapped by a higher-order component.

Personally I think it helps demonstrate the fact that everything is in fact a ""dumb"" component, but some of those are just wrapped in a container.
",davezuko,gaearon
170,2015-11-11 00:03:48,"I agree with @gnoff about using the term ""container."" The terms ""smart"" and ""dumb"" definitely get the point across, but ""container"" is used elsewhere as @gaearon said (I'll throw recompose into the list as well) and does a better job describing the fact that the component is in fact wrapped by a higher-order component.

Personally I think it helps demonstrate the fact that everything is in fact a ""dumb"" component, but some of those are just wrapped in a container.
",davezuko,gnoff
163,2015-11-04 13:31:56,"@gaearon 

Indeed, the problem was actually because (after moving to babel 6) I was loading `babel-plugin-syntax-decorators` but not `babel-plugin-transform-decorators`. This setup doesn't throw any errors/warnings when it comes across a decorator.

For other reasons, it looks like decorators are broken anyway: https://github.com/babel/babel/issues/2702

But as you mentioned this is unrelated. Cheers!
",adamscybot,gaearon
161,2016-08-18 06:46:10,"This solution will only apply on the component dispatch function. if the component uses redux-thunk ( for async functions ) then the dispatch within this functions will not go through the interceptor, so any change/use of the actual payload is impossible.

You may do something like : 



but this will make redux-thunk redundant and will require to duplicate its code. 

In addition, I can't see how to pass getState function (without accessing directly to the store) to pass along to the thunk with this approach, as it is being done when implementing middleware . @gaearon 
",jony89,gaearon
159,2017-01-18 17:59:59,"I started wondering the same thing, whether `connect` was intended to be used on ± every component individually, or only on the top level component. The link @gaearon gives is broken, I think https://github.com/reactjs/redux/issues/419 is the correct thread to refer to for more discussion.",natevw,gaearon
158,2015-10-18 05:38:41,"@gaearon: I have been using a similar solution to this for my tests for quite some time. Recently we have switched to using the [shallow renderer](https://facebook.github.io/react/docs/test-utils.html#shallow-rendering), which has allowed us to remove jsdom from our tests completely. This has given our tests a significant speed boost. Shallow rendering also forces you to keep each component relatively simple since it prevents you from testing heavily nested components. 

Just thought I'd share a tip on something that we've found to be valuable.
",zpratt,gaearon
150,2015-11-18 04:49:17,"@gaearon Sorry to dig up a closed issue - but is the recommended way of accessing the store from descendent components to just pass the store as a prop down through the tree?  I want to subscribe to some state updates, and intend to use [redux-rx](https://github.com/acdlite/redux-rx) to do so, but just not sure on the best way to access the store from descendent components.
",marcuswhit,gaearon
145,2015-10-15 14:03:14,"Thanks for the discussion.

Just one further observation... if you try to force a tree of HOCs to share a top level `<Connect>` then the whole tree gets notified when any of the various HOCs state changes, which becomes pathological in the case of, say, redux-form, where every keystroke updates the store. When you nest `<Connect>`s, each one of them gets separately notified, but they have the very nice property of acting as a guard for their children, and only updating the children if the state they care about has changed. So I see that as another vote for nested  `<Connect>`s.

I agree with @erikras that, even setting aside the question of HOCs, it is just too damn convenient to not have a few nested `<Connects>` in a real app. Threading props through a deep component tree is a PITA and doesn't separate concerns very well. The previous version of my app using vanilla Flux had nested components that individually subscribed to the stores they cared about, so nesting `<Connect>`s is the functional equivalent of that for me. Viva Redux! (and redux-form is awesome too! ;-)
",jdefontes,erikras
145,2016-01-13 04:17:07,"@gaearon

I fiund thus question by you (on S.O.) and another one by @ide (i just commented on that too so i apologize for the inadvertent loop) grappling with the effecf of this same exact issue, which was not satisfied IMO with the batchedupdate answer (you are still going to have overhead that grows with the complexity of the component tree)

https://github.com/rackt/redux/issues/125

http://stackoverflow.com/questions/25701168/at-what-nesting-level-should-components-read-entities-from-stores-in-flux

I think the answer on S.O. is not ideal... leaving it to the programmer is not a comforting solution

have you any updated insight?
",idibidiart,gaearon
138,2015-10-09 14:37:59,"This way you're bundling whole recompose for one method.
The build size increased 4x, it was 2867 before the change.

@acdlite Do you support importing individual files?
",gaearon,acdlite
136,2015-10-28 17:25:32,"@gaearon Just out of interest: Was there any conclusion on this topic?
",aflatter,gaearon
131,2015-09-29 20:32:18,"@gaearon thanks for getting back to me, I will extract it from our production code and get a running example.
",sabeurthabti,gaearon
131,2015-09-29 21:07:56,"@gaearon hi - I pushed similar code to this project: https://github.com/sabeurthabti/redux-friendlist-demo
`DEBUG=true npm start`

click `hello` and i expect the 1 to update into 2. 

I am quite new to react state management. So far I am loving redux, so thank you +1
",sabeurthabti,gaearon
131,2015-09-30 07:31:54,"@gaearon you are amazing, i am trying to get redux adopted by my team (net-a-porter.com/mrporter.com). Thank you so much. 
",sabeurthabti,gaearon
129,2015-10-12 15:48:59,"Tried creating a failing test for this

https://github.com/rackt/react-redux/compare/master...epeli:fail129?expand=1

but it's not failing! I don't know why. Seems like it should because the constructor and dispatch is called between the component render calls which would indicate it's part of the render but I guess it's not...

btw @gaearon I had a weird issue with the testing environment https://github.com/rackt/react-redux/commit/bba883ab347064d5d75c05a222a874fbeda17061
",epeli,gaearon
120,2015-09-26 01:18:01,"@gaearon you were right.

It was the way the new version of react-router handled the history with:



instead of the beta3 way:



It was a bit tricky to troubleshoot. The react-router team is changing the API too much. Thanks for your re-assurance that it was not the cause of the issue, it helped anyways.

Also congrats for react-redux, awesome work.
",pbreah,gaearon
118,2015-09-28 16:59:26,"@epeli it works, thank you
",vslinko,epeli
116,2015-09-24 04:34:03,":+1: Ran into the same thing. Thanks, @gaearon & @theaqua.
",gasi,gaearon
115,2016-04-18 18:58:50,"> This is fixed in React Hot Loader 3.
> It is built with lessons learned from both React Hot Loader and React Transform.
> It’s still in alpha but I encourage you to check it out!

@gaearon Great stuff! ran into this today when teaching redux to someone. I'll give it a whirl :)
",glenjamin,gaearon
111,2016-08-01 15:22:23,"@gaearon shouldn't this be handled by the library? It doesn't feel very intuitive this way (_especially when using decorators and static properties_), and doing the opposite (by requiring to manually `delete` the `defaultProps` from the wrapper element should the forwarding be undesirable) seems a saner default behaviour.
",arcanis,gaearon
108,2015-09-15 16:20:17,"Thanks @gnoff - it looks like it might help, though if I have my dumb components `@connect`-ed then doesn't that make smart by definition? Not that it's necessarily a problem, but I imagine having thousands of store-connected components (i.e. my lists **and** their items) will have a performance impact, I'd guess? I'll have a look into it all the same. Thanks again.
",jamiewinder,gnoff
108,2016-02-10 17:14:44,"Ok, here is the code. I am just pasting the relevant parts (ommitted lots of import calls). Thanks for looking into this @gaearon 

**app.js** (look at the OrderContainer component)



**order-container.jsx**



Feel free to critique anything that you see wrong/unusual :)
",rodryquintero,gaearon
108,2016-02-10 19:46:17,"Thanks for the quick reply @gaearon. At the time I posted my comment I needed access to `getState()` to tell wether there were any changes in the component state and thus prevent/allow navigating away from it.

The code I posted has been refactored and I no longer need the access state within the component (I check if there are changes to be saved in the reducer. So you are right, I don't need access the store from context.

> connect() generates a new component that wraps your component and already has contextTypes specified for you. You never need to specify them explicitly when you use connect().

The weird thing is, I don't have access to the store in a ""connected"" component. Here is the context for the OrderContainer component. 

![image](https://cloud.githubusercontent.com/assets/1271370/12959434/5e75c4e2-d004-11e5-973b-a91b5e1a36ee.png)

I refactored the code and it is now much cleaner. I use the state from the `select` function to check for differences. But if you ever need to access the store within the component, at least in my case, I was not able to.
",rodryquintero,gaearon
105,2015-09-15 03:13:16,"+1 to keeping things simpler

Perhaps it'd be a good idea to explicitly mention that in the Support for Decorators section? @gaearon 
",cesarandreu,gaearon
105,2015-09-16 00:12:51,"@gaearon You're right and it was nothing personal. I could have sworn all your examples used to use it, but that was a few months back - at least I remember going through something which had it. Good to see it's not the case anymore :+1: 
",blakeembrey,gaearon
104,2016-07-10 16:59:37,"@epeli I know it's been a while, but any progress on this?
",timdorr,epeli
103,2016-07-07 04:12:16,"@gaearon Hi I have a question about the way to connect the component.

Here is the code:



so this way, it will connect the component firstly then do the didMount, so what's the different between the 'before' and 'after' connect the component and the cons or pros.

Thanks,
",KaroseLiu,gaearon
102,2016-07-18 20:31:04,"Correct, forgot to update! thanks @markerikson. 
",tomascharad,markerikson
101,2015-09-10 21:14:12,"@gnoff I got it!!! Here is the final Decorator:

https://gist.github.com/duro/0534a9c5fe4bd8b868a8

And here is how it's implemented on a Connected component:


",duro,gnoff
100,2015-09-10 22:37:02,"@gnoff ok, thanks. Could you tag this as a question? Just so it's easier to find if someone else is thinking about a similar problem.
",despairblue,gnoff
99,2015-09-08 22:25:24,"@epeli this brings us back to the way things were before #1 which as @gaearon says makes the worst case performance the default. I'm inclined to leave the existing behavior as is. If we did adopt this form I would hope that it be made optional and opt-in much like the 2nd arg props parameter to the first two connect arguments.
",gnoff,epeli
99,2015-09-10 06:54:40,"@epeli took a better look and you I retract my earlier statements about regressing performance-wise. However regarding the lack of consistent batched updating is it true then that for this PR to not regress in any case one needs to use either the redux-batched-updates middleware or does the lack of that simply return us to the edge-case broken state that we are in with the reported issue #86 ?
",gnoff,epeli
98,2016-05-22 16:44:50,"@gaearon Any thoughts on reopening this now that Redux has an official definition?

There's a really nasty issue right now where the DefinitelyTyped react-redux definition doesn't actually work correctly with the officially-maintained Redux definition, only the DT Redux definition. It'd be nice if there was an official definition for react-redux that was kept in sync with the official Redux definition :)
",thomasboyt,gaearon
95,2015-09-06 22:36:05,"@gaearon ,  i don't think i can, the Reopen Issue button does not show up for me.
",Agamennon,gaearon
95,2015-09-06 23:02:04,"@gaearon   awsome, thank you!
",Agamennon,gaearon
88,2015-09-02 21:34:24,"@dallonf yup this is a tricky situation. My thought is that in keeping with the paradigm that redux assumes state is not mutated we should guide people towards making more pure Components and leave the aggressive `shouldComponentUpdate` as is.

Given that you won't always have control over this situation though i think there are a couple of workarounds that might be worth exploring (some more hack-ish than others). I haven't tried any of these but in theory they should work

~~1) make your `mapStateToProps`, `mapDispatchToProps`, or `mergeProps` arguments return a purposely 'dirty' props object. something like~~



~~This will eliminate all preformance optimizations from shouldComponentUpdate since there will always be a prop that has a new object reference and therefore should fail the shallowEqual test~~
this doesn't work per @dallonf 's testing. 

2) develop your own 'impure' Component decorator that wraps your connected component and have it call forceUpdate on the connected component child whenever it's props change.

maybe something like this



btw, i never actually use forceUpdate so not sure if it would need to go there or in componeDidUpdate or somewhere else but essentially this _should_ force the connected component to update on every prop change

you would use it like this


",gnoff,dallonf
79,2015-09-02 14:46:19,"@gaearon sorry for not closing an issue, I've already find the solution.
",gyzerok,gaearon
79,2015-09-03 12:58:13,"@gaearon I guess here is another problem. I thougt that if I place router variable as and return value from function inside Provider it would be similar to put <Router> tag inside Provider. I think its all about how JSX work. Dont know how to describe it better. Hope you can :)
",gyzerok,gaearon
76,2015-08-27 05:39:52,"@gnoff The issue was more around distributable browser bundle than cdnjs.
Is there a way currently to use it, that I am missing?

cc @gaearon 
",vipulnsward,gnoff
75,2015-11-06 13:52:12,"Sorry to drag this up but i had a similar question. Because the props are passed from the top level root component, i.e the APP itself, it seems that every inherit component will render.
This doesn't seem to be an issue with other flux implementations as you can have the even listener, listening for updates - somewhere deep in the component hierarchy. ShouldComponentUpdate works ok here but where as in Redux components will need to update to pass the props down.

This seems to be conflicting with React fundamentals where a full app render is taking place all the time?
I'm envisaging performance bottlenecks. 

Am i missing something? @gaearon @gnoff 
",farzd,gaearon
75,2015-11-06 13:52:12,"Sorry to drag this up but i had a similar question. Because the props are passed from the top level root component, i.e the APP itself, it seems that every inherit component will render.
This doesn't seem to be an issue with other flux implementations as you can have the even listener, listening for updates - somewhere deep in the component hierarchy. ShouldComponentUpdate works ok here but where as in Redux components will need to update to pass the props down.

This seems to be conflicting with React fundamentals where a full app render is taking place all the time?
I'm envisaging performance bottlenecks. 

Am i missing something? @gaearon @gnoff 
",farzd,gnoff
72,2015-08-25 16:56:29,"@udfalkso since React Native is not using React 0.14 the correct fix would be to change https://github.com/udfalkso/react-redux/blob/console-warn-instead-of-error-for-function-wrap/src/components/createProvider.js#L6 to `return true;`

In fact i believe it is a genuine bug that we are returning false here since the only version of React today not using Parent Context is 0.14 beta.
",gnoff,udfalkso
60,2015-08-17 15:39:46,"Indeed, as @gnoff said above, you can't just return Immutable object because we spread over the values you return, and this wouldn't make sense with Immutable.

> I’m able to do something like @connect(state => {return {state};}), and then unwrap the object in App’s render(), but I get the sense that this is not an ideal solution.

The idiomatic way is to do this:



only for the fields you actually care about, so `@connect` can bail out when the parts the component doesn't need, did not change. I don't suggest using `toJS()` because AFAIK it's deep, but deep conversions won't be as performant as just extracting the stuffy you want.

> I also consider using several @connect() a bit higher up the tree, instead of one at the root component.

This is the way to go, and it's more performant than just one `@connect` at the top.
",gaearon,gnoff
60,2016-01-17 23:41:32,"@gaearon Hey Dan, what are your thoughts of running immutable AND reselect together versus just one or the other?
",thewillhuang,gaearon
58,2015-08-17 19:34:21,"@gaearon Thanks for your quick response, here is an example of the error:

https://github.com/ghondar/reduxExample
",ghondar,gaearon
58,2015-08-17 20:54:47,"oh @gaearon i'm sorry, I forgot to put in the readme that port open in the browser u.u.

open http://localhost:3000/
",ghondar,gaearon
58,2015-08-18 17:16:08,"nice @gaearon it works, thank for all :D 
",ghondar,gaearon
52,2015-08-17 10:41:22,"@PSpSynedra https://github.com/gaearon/react-redux/pull/59#issuecomment-131764832
",evgenyrodionov,PSpSynedra
48,2015-08-11 08:06:02,"@gaearon I got it now. If I pass an object with action creator it will automatically bind them with `bindActionCreators`. In those examples (my bad, didn't read this code right) you are passing a function that returns bound action creators and so `wrapActionCreators` doesn't get called.
",constb,gaearon
45,2015-08-10 08:42:57,"Thank you @gaearon. 
",jptaylor,gaearon
43,2015-08-09 16:49:58,"@gaearon Ok) Here is an [example](https://github.com/smashercosmo/redux-react-router-issue)
",smashercosmo,gaearon
41,2017-03-06 23:55:36,"Thank you for the super fast response @markerikson! I had not yet seen that new FAQ on immutability and looks extensive so that will be helpful. I didn't realize that the copying had to go further down since I wasn't modifying the middle. I'll read the links in detail and see if I can determine the fix. 

This is actually my first coding post: from an etiquette standpoint should I re-post with a solution once I've resolved it? Or is that unnecessary?",gate5th,markerikson
29,2015-08-07 19:52:25,"@af is correct.

@hartzis Master is a bit outdated, I just released `react-redux@0.5.0` so official examples will be updated later. The intermediate component isn't needed anymore! See also https://github.com/gaearon/react-redux/releases/tag/v0.5.0 release notes.
",gaearon,af
29,2015-08-07 20:57:18,"@gaearon That is awesome! I totally see that now.

@af Great catch!
",hartzis,af
29,2015-08-07 20:57:18,"@gaearon That is awesome! I totally see that now.

@af Great catch!
",hartzis,gaearon
16,2015-07-31 07:48:52,"@gaearon mind also checking out this additional PR (currently on my fork only since it looks cleaner comparing to my master)

https://github.com/gnoff/react-redux/pull/1
",gnoff,gaearon
16,2015-07-31 10:26:08,"ok, thank you @gaearon :)
",quirinpa,gaearon
16,2015-08-02 18:03:47,"@quirinpa I'm not the one that did the PR!
It's @gnoff 
",Keats,gnoff
15,2015-07-30 23:56:43,"@Keats Not sure if this will help, but here is the implementation I did as a shim from fluxxor to redux to aid in us converting: https://gist.github.com/aaronjensen/95e505cdcbbe9d46019d

This skips the need for `Connector` and has merge (you can ignore the `subscriptions` parameter, that's fluxxor specific).

@gaearon one thing we noticed is that there are times when we want to pass the props to the selector function. Can you think of any reasons that'd be a bad idea?

Also, it looks like you envisioned not proxying the props along in the default merge, so your default merge would just be `(state, actions) => ({ ...state, ...actions })`. Is that right? Or should it include props? (in my experience, if you include props, state should probably be merged after props or confusing things happen with nested containers and liberal `{...this.props}` passing.
",aaronjensen,gaearon
14,2015-07-31 09:20:03,"@jlogsdon don't forget to look at #1 and #16 so you don't write documentations for something that's going to be removed/changed
",Keats,jlogsdon
14,2015-07-31 09:31:46,"@Keats @jlogsdon 

While #1 and #16 are important, it's more important to document the existing APIs right. I'm releasing Redux 1.0 very soon, and I'm going to have examples using React Redux 0.2.1. When we figure #16 out, we'll rewrite the docs, but it might take another week or so. Documenting 0.2.1 is still very important because lots of projects depend on it.
",gaearon,jlogsdon
14,2015-07-31 13:48:44,"Thanks for pointing those out, but I am going to focus on the existing API for the reasons @gaearon said. The new API isn't quite ready, and having docs of the stable release will be very important for the Redux 1.0 release.

I'm working on expanding some of the sections right now and will have something to push up here today.
",jlogsdon,gaearon
4,2016-04-21 08:24:29,"Hi, @gaearon  In npm3  peerDependencies  will not install in node_modules.
And this will  not transform react in react-redux by browserify-shim.
",Tankpt,gaearon
1,2015-07-12 02:13:49,"@gaearon 

> On the other hand once you start selecting data in a tricky way, you begin to want finer control over perf optimizations, lifecycle hooks and maybe passing data down in a trickier way so it's likely you'll want a component anyway.

I really think accessing props from the owner is a much more common case that using lifecycle hooks. Props passing is the fundamental contract of React. We'll soon live in a world where [pure functions are valid React components](https://github.com/facebook/react/pull/3995). The fewer ""smart"" components the better — creating class components will start to become a low-level implementation detai. Function components will be the new default. (At least that's what _should_ happen. We'll see if the community catches on.)

> However, this forces us to bind on every prop change, which is a perf hit and unfriendly to shouldComponentUpdate optimizations down the rendering chain.

This seems like a micro-optimization but okay. You could get around this by binding once if an object is passed (""bind automatically if an object is passed"") but bind every time if its a function.  Also if an action creator depends on a prop it's going to lead to updates further down the rendering chain, anyway.
",acdlite,gaearon
1,2015-07-12 02:16:44,"@acdlite also, it's easy enough to prevent constant rebinding with memoization. We had explored this a bit in redux#86
",skevy,acdlite
1,2015-07-12 04:25:42,"I like @gaearon's idea of passing action creators as the second param and auto-binding:



That way we only need to bind once, and the user doesn't need to worry about bindActionCreators.

I would amend that proposal to also support a second form, where you pass a function that maps to _unbound_ action creators:



that way you can access the store state and props, if needed. `bindActionCreators()` becomes an implementation detail.
",acdlite,gaearon
1,2015-07-12 04:53:35,"@acdlite I agree with how you explained why `bindActionCreators` is needed, now. I wasn't thinking in terms of smart and dumb components.

Although something about the idea of a tree of components having most of the parent, outer-most components as smart components and then all the edge node components as dumb (this is what I think this smart / dumb component pattern lends itself to) kind of seems like a stink. I don't have an optimal pattern in mind, and I know smart / dumb components are a current popular pattern, but this as a pattern seems like it creates scenarios where if a dumb component is way down the tree you'll have to pass down action methods or dispatch all the way down the tree to get to it, thus making the components on the way to that component possibly carry along unneeded props just to satisfy their children. Maybe this is result of bad component tree design or something, though, on my part.
",ryancole,acdlite
1,2015-07-12 05:39:19,"@acdlite Yep, that's right. We have a system for registering reducers, it didn't seem a long stretch to have one for actions. And you're right re: state not being a plain JS object of course. In that case two arguments could come along: `(state, actions)` or actions could have their own reducer but that seems a little odd.

Tbh, I can't think of a particularly compelling reason for it other than slight convenience at that point at the cost of required registration.
",aaronjensen,acdlite
1,2015-07-12 09:17:51,"> we could drop `<Connector>` altogether and encourage people to use `@connect` decorator

I think it's a good idea, and we can do the same for `Provider`. This will simplify the API and create less confusion.

> This leads to more scalable, maintainable, testable code

@acdlite I was also thinking of dropping `bindActionCreators`, as it's just syntactic sugar for `dispatch(myAction())`, but you make a valid point.

And passing the actions as a second argument of `connect` makes it a good API, given that the binding becomes an implementation detail of the decorator and the user doesn't care about it.

One thing I would also like to have is **namespacing** props. Basically instead of just spreading the actions or whatever to `this.props`, we can have a `actions` object that contains all the actions, and just pass the object to `props`. Same thing could be done for `state`. I think this is important when you start having other data in `props` (e.g.: router) and helps avoiding possible conflicts when merging props.
Here an example:



Thoughts?
",emmenko,acdlite
1,2015-07-12 13:20:36,"@gaearon right, haven't consider this. I guess there's no much way around it then...
",emmenko,gaearon
1,2015-07-12 14:09:34,"@gaearon @acdlite considering another approach, what would be the pros / cons of using `context`?

Currently we have `getState` and `dispatch` there. Would it make sense to have also `getActions`? Then you don't have to pass them around anymore via `props`, you can just get them from the `context`. This would also keep `connect` a simple component that subscribes to changes.

I don't know, just thinking out loud... 
",emmenko,gaearon
1,2015-07-12 14:09:34,"@gaearon @acdlite considering another approach, what would be the pros / cons of using `context`?

Currently we have `getState` and `dispatch` there. Would it make sense to have also `getActions`? Then you don't have to pass them around anymore via `props`, you can just get them from the `context`. This would also keep `connect` a simple component that subscribes to changes.

I don't know, just thinking out loud... 
",emmenko,acdlite
1,2015-07-12 14:40:19,"> But just to understand, if actions were a core concept, would it have been ok to put them into context and just access them wherever I want?

Can you rephrase? I don't understand what exactly you are asking.

> Anyway, are we heading now towards this connect signature and give it more responsibilities, as you said?

This signature is what feels right to me at the moment. Waiting for @acdlite to take a look.
",gaearon,acdlite
1,2015-07-12 16:05:14,"@acdlite 

If we agree on that, what do you think is reasonable release-wise? We could release this version as `react-redux@1.0.0`, or we could release the current version as 1.0 but jump to 2.0 with this proposal.

It probably makes sense to use the new version in new docs..
",gaearon,acdlite
1,2015-07-12 18:29:05,"@gaearon do you think `connect` is still a correct name for the new signature?
",emmenko,gaearon
1,2015-07-12 19:36:54,"@gaearon I think we should hold of moving react-redux to 1.0 for a while until we've settled on the new API. The current API is not a 1.0 in my view, and I don't see any problem in keeping react-redux at 0.12 (or whatever) even while Redux gets a 1.0 release. That's the advantage of separating the projects.
",acdlite,gaearon
1,2015-07-14 15:04:00,"@skevy @gaearon Thanks! I'm rewriting my blog admin to use Redux and finally making time to think through this.

Currently, all my components can define a static method which can fetch data (performed when I resolve all the routes and stuff), and this data is automatically available. Other than data fetching, are there any other use cases? I'm trying to reconcile Relay with this, and I see some opportunities. With Relay that data fetching happens automatically for you. Since Relay isn't released yet, I don't know how you perform updates, but I think the general flux-style flow of actions works for that.

If I solve the data fetching part, are there any other reasons why I'd need redux on the backend?

EDIT: May just have to wait for Relay, and I could just follow the patterns here and use Redux for data fetching too. Still thinking through.
",jlongster,gaearon
1,2015-07-27 12:09:36,"@gaearon Thanks man but i think i still i don't have the knowledge to :P you have developed awesomeness, thanks!
",quirinpa,gaearon
1,2015-07-27 16:25:47,"Just a substitute until Keats solution is merged :P



**Edit**: I've made a few changes. It now supports the following;



@gaearon i'm probably doing something wrong and i'm not very confortable with git, so i'd rather hear from you before i send a PR... Cheers.

**Edit**: Now supports merge :)
",quirinpa,gaearon
1,2015-08-07 10:05:26,"@danmartinez101 @mmerickel 

One of the reasons I don't want to do this is because code splitting will be harder.
People are likely to keep wanting the same structure, and will do hacks to make it work with code splitting.
The current proposal works with code splitting with no modifications.

I feel this is more opinionated than I'm willing to go. I'm happy to see this explored in alternative bindings though!

Everyone, thanks for the discussion, let's continue in #16.
",gaearon,danmartinez101
1,2015-08-07 15:19:32,"@gaearon Can you clarify what you mean by code splitting? My assumption by exposing the `dispatch` to the action getter was that this would help if you didn't want to do `<Provider actions={actions}>`. Maybe exposing a binder instead of dispatch works better which seems quite similar to what your original proposals have been above.
",mmerickel,gaearon
631,2017-03-13 14:37:24,"@data-doge Any chance you can reproduce that error with source maps enabled so we know what line of code is actually causing the problem? That stack trace is from a minified bundle.

@jimbolla Any idea what's up here? ",timdorr,jimbolla
629,2017-02-22 16:19:04,"@jimbolla @timdorr If you plan to cut a new release, could you include this one with it? I could cut it separately myself too if you don't have the time. Thanks!",gaearon,timdorr
629,2017-02-22 16:19:04,"@jimbolla @timdorr If you plan to cut a new release, could you include this one with it? I could cut it separately myself too if you don't have the time. Thanks!",gaearon,jimbolla
589,2016-12-30 02:22:49,@timdorr Thoughts on pushing a patch release for this and the other handful of fixes we have waiting to go out?,jimbolla,timdorr
589,2017-01-31 04:33:55,"@jimbolla , @timdorr : following up on this at @davidkpiano 's request.  It's Jim's code thus far, and Tim's been cutting releases (something I should go figure out for myself at some point, but don't have time to dig into atm).  Are we good to go on this?",markerikson,timdorr
584,2017-01-10 01:05:07,@timdorr Any thoughts on pushing out a patch release?,jimbolla,timdorr
574,2016-12-14 16:58:41,"@btd, Any insight on this?",jimbolla,btd
557,2016-11-30 15:38:46,"Instead of using the `setState` callback, doing `notifyNestedSubs` in `componentDidUpdate` seems to avoid the cursor bug (#525) without the need for the compatibility setting BS. (I swear the first time I tried this, it didn't work; I must've screwed something up. /shruggie) I'll perf test this tonight when I'm at my home PC with all my test projects. Assuming that goes well, this is a much cleaner solution. Thanks @istarkov.

",jimbolla,istarkov
543,2016-11-13 23:15:30,"In order to satisfy a prerelease version, the major/minor/patch versions must match exactly. This change makes `react-redux` `yarn` friendly when used with `react@15.4.0-rc.4`. Without this change, you always fail a `yarn check`.

cc: @gaearon @bestander.

",zertosh,gaearon
541,2016-12-14 14:31:32,@timdorr Why is it closed? Should we stop our effort to release the typings inside react-redux repo?,bbenezech,timdorr
525,2016-10-19 17:26:35,"Hmm.  Pinging @gaearon and @timdorr for thoughts...
",markerikson,gaearon
525,2016-10-19 17:26:35,"Hmm.  Pinging @gaearon and @timdorr for thoughts...
",markerikson,timdorr
523,2017-02-18 08:19:27,@timdorr @jimbolla I've cleaned up the test and memoized the response of the factory. Also updated API docs. Do let me know if there is anything else you'd like me to do. Thanks!,neeharv,jimbolla
517,2016-10-14 02:01:37,"Looks good to me. Second opinion, @markerikson or @timdorr? 
",jimbolla,timdorr
517,2016-10-14 02:01:37,"Looks good to me. Second opinion, @markerikson or @timdorr? 
",jimbolla,markerikson
507,2016-09-28 16:59:52,"There was some [good discussion](https://twitter.com/ryanflorence/status/779320581678174208) on Twitter (between @gaearon, @markerikson, @timdorr, @mjackson, @ryanflorence, et al.) about `connect`'s component implementing `shouldComponentUpdate`.

If I understand correctly, the main issue being that any component wrapped in `connect` then blocks updates related to context changes, and this has an adverse impact on libraries that pass data via context that need to trigger rerenders (such as React Router's Link component.)

The changes in the `next` branch of React Redux make its implementation of `shouldComponentUpdate` much less necessary, mainly because now `setState` is no longer called as a response to every store state change, but only if the final merged props have changed. So now when `shouldComponentUpdate` is called as a result of calling `setState`, it's always going to return true anyways. (The call to setState could probably be replaced with forceUpdate and would work exactly the same.)

In the case of `shouldComponentUpdate` being called after receiving new props from parent, it's effectively just acting like `PureComponent`. That responsibility can be given to the components being wrapped, which would have better knowledge about if/how they should implement `shouldComponentUpdate`. I personally would use recompose and do something like:



An alternative to removing connect's `shouldComponentUpdate` completely would be to make it an another `option` argument, and decide whether it should be opt-in or opt-out.
",jimbolla,gaearon
507,2016-09-28 16:59:52,"There was some [good discussion](https://twitter.com/ryanflorence/status/779320581678174208) on Twitter (between @gaearon, @markerikson, @timdorr, @mjackson, @ryanflorence, et al.) about `connect`'s component implementing `shouldComponentUpdate`.

If I understand correctly, the main issue being that any component wrapped in `connect` then blocks updates related to context changes, and this has an adverse impact on libraries that pass data via context that need to trigger rerenders (such as React Router's Link component.)

The changes in the `next` branch of React Redux make its implementation of `shouldComponentUpdate` much less necessary, mainly because now `setState` is no longer called as a response to every store state change, but only if the final merged props have changed. So now when `shouldComponentUpdate` is called as a result of calling `setState`, it's always going to return true anyways. (The call to setState could probably be replaced with forceUpdate and would work exactly the same.)

In the case of `shouldComponentUpdate` being called after receiving new props from parent, it's effectively just acting like `PureComponent`. That responsibility can be given to the components being wrapped, which would have better knowledge about if/how they should implement `shouldComponentUpdate`. I personally would use recompose and do something like:



An alternative to removing connect's `shouldComponentUpdate` completely would be to make it an another `option` argument, and decide whether it should be opt-in or opt-out.
",jimbolla,timdorr
507,2016-09-28 16:59:52,"There was some [good discussion](https://twitter.com/ryanflorence/status/779320581678174208) on Twitter (between @gaearon, @markerikson, @timdorr, @mjackson, @ryanflorence, et al.) about `connect`'s component implementing `shouldComponentUpdate`.

If I understand correctly, the main issue being that any component wrapped in `connect` then blocks updates related to context changes, and this has an adverse impact on libraries that pass data via context that need to trigger rerenders (such as React Router's Link component.)

The changes in the `next` branch of React Redux make its implementation of `shouldComponentUpdate` much less necessary, mainly because now `setState` is no longer called as a response to every store state change, but only if the final merged props have changed. So now when `shouldComponentUpdate` is called as a result of calling `setState`, it's always going to return true anyways. (The call to setState could probably be replaced with forceUpdate and would work exactly the same.)

In the case of `shouldComponentUpdate` being called after receiving new props from parent, it's effectively just acting like `PureComponent`. That responsibility can be given to the components being wrapped, which would have better knowledge about if/how they should implement `shouldComponentUpdate`. I personally would use recompose and do something like:



An alternative to removing connect's `shouldComponentUpdate` completely would be to make it an another `option` argument, and decide whether it should be opt-in or opt-out.
",jimbolla,markerikson
490,2016-09-17 04:36:10,"@markerikson Hey Mark, thanks for looking over react-redux-blackbox for me. I took a look at the new v5 react-redux, learned a lot about how to do perf testing, and the thought process that goes into accepting a major rewrite on a plugin.

Anyways, before v5 is official rolled out, I thought I would add these minor changes to improve v4 performance (Things that I picked up on while writing blackbox). Actually, if I'm not mistaken, the only real performance boost that v5 delivers is nullified with these changes. The big one is adding the ShouldComponentUpdate component, which stops rerendering if the computed props and own props are the same as their previous versions.
",l2silver,markerikson
490,2016-09-17 04:40:25,"Hmm.  Given the path we're on towards v5, I'm not sure there's much point in changing anything further with v4.

Also, how specifically does this improve perf?  Do you have some benchmarks and comparisons you can provide?  How does this compare with v5?

Tagging @jimbolla and @timdorr .
",markerikson,timdorr
490,2016-09-17 04:40:25,"Hmm.  Given the path we're on towards v5, I'm not sure there's much point in changing anything further with v4.

Also, how specifically does this improve perf?  Do you have some benchmarks and comparisons you can provide?  How does this compare with v5?

Tagging @jimbolla and @timdorr .
",markerikson,jimbolla
473,2016-08-27 14:29:33,"Starting a list of things related getting v5 out the door.
- [x] Unhide new features - currently they are hidden so that nobody starts using them, just in case we roll this back. I'll make a PR (#474) that will unhide them that can be merged in once we're confident that these changes will go live.
- [x] Create release notes - needs to describe: still API compatible, synopsis of internal architectural changes, perf changes, bugs fixed, new features added
- [x] Review/revise [release notes](https://github.com/reactjs/react-redux/issues/473#issuecomment-242927656) @timdorr toughts?
- [x] Write documentation for new features. Need to adequately describe `connectAdvanced`, as well as new options passable to `connect`. PR #480
- [x] Review/revise new docs. @timdorr @markerikson toughts?
- [x] Fix controlled input issues #525
- [x] Release another beta with the new features exposed. Add beta to the github Releases page.
### Nice to Haves:
- Refactor tests? - now that `connect` is split into to conceptual pieces: `connectAdvanced` for store subscription and component lifecycle stuff vs connect's selector functions, many of the tests could be refactored to deal with just one or the other. This would be nice because would split the 2000+ line spec file in two, making it a little easier to work with. Also add new tests for some of the new `connect` options. (I personally need to learn how to run the new test coverage tools so I can see what's not covered.)
",jimbolla,timdorr
473,2016-08-27 14:29:33,"Starting a list of things related getting v5 out the door.
- [x] Unhide new features - currently they are hidden so that nobody starts using them, just in case we roll this back. I'll make a PR (#474) that will unhide them that can be merged in once we're confident that these changes will go live.
- [x] Create release notes - needs to describe: still API compatible, synopsis of internal architectural changes, perf changes, bugs fixed, new features added
- [x] Review/revise [release notes](https://github.com/reactjs/react-redux/issues/473#issuecomment-242927656) @timdorr toughts?
- [x] Write documentation for new features. Need to adequately describe `connectAdvanced`, as well as new options passable to `connect`. PR #480
- [x] Review/revise new docs. @timdorr @markerikson toughts?
- [x] Fix controlled input issues #525
- [x] Release another beta with the new features exposed. Add beta to the github Releases page.
### Nice to Haves:
- Refactor tests? - now that `connect` is split into to conceptual pieces: `connectAdvanced` for store subscription and component lifecycle stuff vs connect's selector functions, many of the tests could be refactored to deal with just one or the other. This would be nice because would split the 2000+ line spec file in two, making it a little easier to work with. Also add new tests for some of the new `connect` options. (I personally need to learn how to run the new test coverage tools so I can see what's not covered.)
",jimbolla,markerikson
448,2016-07-31 01:55:49,"Yeah, `mapState` and `mapDispatch` don't support that scenario directly.  That's actually part of what prompted @jimbolla to start implementing a new approach to `connect()`.  

There are two ways you could do something like that right now:
1. Select the data using `mapState`, and have the component call `this.props.doStateDependentAction(this.props.someValueFromState)`
2. Select the data using `mapState`, and use the third argument to connect (`mergeProps` ) to define the action creator.  Note that this would probably involve re-defining the action creator function every time the state changes, which could be a performance issue.
",markerikson,jimbolla
428,2016-07-06 11:50:26,"Still makes sense to me to fix the current implementation in the short-term even if it ends up getting replaced in a month or so when the next major is released. Plus, the test introduced in #429 is a worthwhile addition to make sure #416 or any future work doesn't create a regression. I guess it's up to @gaearon as to whether #429 is worth merging or not...
",andydavies92,gaearon
416,2016-06-24 03:53:41,"# Update: Released as alpha!

[See below](https://github.com/reactjs/react-redux/pull/416#issuecomment-239678590). You can now install this as `react-redux@next`:



Please test it out!
## TL;DR

Rewrote `connect`, same basic API plus advanced options/API, all tests pass, roughly 8x faster, more modular/extensible design
# Overview

I rewrote `connect` into modular pieces because I wanted to be able to extend with custom behavior in my own projects. Now connect is a facade around `connectAdvanced`, by passing it a compatible `selectorFactory` function.

I also was able to greatly improve performance by changing the store subscriptions to execute top-down to work with React's natural flow of updates; component instances lower in the tree always get updated after those above them, avoiding unnecessary re-renders.
# Design/Architecture

I split the original `connect` into many functions+files to compartmentalize concepts for better readability and extensibility. The important pieces:
- components/
  - `connectAdvanced.js`: the HOC that connects to the store and determines when to re-render
  - `Provider.js`: (hasn't changed)
- selectors/
  - `connect.js`: composes the other functions into a fully-compatible API, by creating a selectorFactory and options object to pass to `connectAdvanced`.
    that performs memoiztion and detects if the first run returns another function, indicating a factory
  - `mapDispatchToProps.js`: used to create a selector factory from the `mapDispatchToProps` parameter, to be passed to `selectorFactory.js` as `initMapDispatchToProps`. Detects whether `mapDispatchToProps` is missing, an object, or a function
  - `mapStateToProps.js`: used to create a selector factory from the `mapStateToProps` parameter, to be passed to `selectorFactory.js` as `initMapStateToProps`. Detects whether `mapStateToProps` is missing or a function
  - `mergeProps.js`: used to create a selector factory from the `mergeProps` parameter, to be passed to `selectorFactory.js` as `initMergeProps`. Detects whether `mergeProps` is missing or a function.
- `selectorFactory.js`: given `dispatch`, `pure`, `initMapStateToProps`, `initMapDispatchToProps`, and `initMergeProps`, creates a `connectAdvanced`-compatible selector
- `wrapMapToProps.js`: helper functions for wrapping values of `mapStateToProps` and `mapDispatchToProps` in compatible selector factories
  - 
- utils/
  - `Subscription.js`: encapsulates the hierachial subscription concept. used by `connectAdvanced.js` to pass a parent's store Subscription to its children via context
  - `verifyPlainObject.js`: used to show a warning if `mapStateToProps`, `mapDispatchToProps`, or `mergeProps` returns something other than a plain object
## file graph

![graph](https://cloud.githubusercontent.com/assets/1851364/16901604/b1426f0c-4c16-11e6-8895-5234885f48b0.png)



The modular structure of all the functions in `connect/` should allow greater reuse for anyone that wants to create their own `connect` variant. For example, one could create a variant that handles when `mapStateToProps` is an object by using reselect's createStructuredSelector:
### customConnect.js:


### ExampleComponent.js



And for scenarios where connect's three-function API is too constrictive, one can directly call, or build a wrapper around, `connectAdvanced` where they have full control over turning `state` + `props` + `dispatch` into a props object.
# Performance

I'm using a [modified version of react-redux-perf](https://github.com/jimbolla/react-redux-perf) to performance test+profile the changes. It's configured to try to fire up to 200 actions per second (but becomes CPU bound), with 301 connected components. There are 2 scenarios being tested:
- NB: a parent component with 300 child components, with no other React components between them.
- WB: the same setup as NB but there's a ""Blocker"" React component between the parent and children that always returns false for `shouldComponentUpdate`.

I measured the milliseconds needed to render a frame using the [stats.js](https://github.com/mrdoob/stats.js/) used by react-redux-perf:

| MS: avg (min-max) | current NB | rewrite NB | current WB | rewrite WB |
| --- | --- | --- | --- | --- |
| Chrome | 170 (159-223) | 20 (17-55) | 170 (167-231) | 17 (15-59) |
| Firefox | 370 (331-567) | 20 (16-51) | 430 (371-606) | 19 (15-60) |
| IE11 | 270 (127-301) | 40 (36-128) | 300 (129-323) | 33 (30-124) |
| Edge | 240 (220-371) | 37 (32-102) | 260 (97-318) | 28 (24-100) |

On the conservitive end, the rewrite is about 8x faster under these circumstances, with Firefox even doubling that improvement. Much of the perf gains are attributed to avoiding calls to `setState()` after a store update unless a re-render is necessary.

In order to make that work with nested connected components, store subscriptions were changed from ""sideways"" to top-down; parent components always update before their child components. Connected components detected whether they are nested by looking for an object of type `Subscription` in the React `context` with the key `storeSubscription`. This allows `Subscription` objects build into a composite pattern.

After that I've used Chrome and Firefox's profilers to watch for functions that could be optimized. At this point, the most expensive method is `shallowEqual`, accounting for 4% and 1.5% CPU in Chrome and Firefox, respectively. 
# connectAdvanced(selectorFactory, options) API

In addition to the changed related to performance, the other key change is an additional API for `connectAdvanced()`. `connectAdvanced` is now the base for `connect` but is less opinionated about how to combine `state`, `props`, and `dispatch`. It makes no assumptions about defaults or intermediate memoization of results, and leaves those concerns up to the caller. It does memoize the inbound and outbound props objects. A full signature for `connectAdvanced` with its `selectorFactory` would look like:



A simple usage may look like:



An example using `reselect` to create a bound actionCreator with a prop partially bound:



An example doing custom memoization with actionCreator with a prop partially bound:



Note these are meant as examples and not necessarily ""best practices.""
# Pros/cons

I understand there is great risk to accepting such drastic changes, that would have to be justified with significant benefits. I'll reiterate the two main benefits I believe these changes offer:
1. Performance: There's potentially huge perf gains in situations where the number of connected components is high, stemming from conceptual changes to subscriptions so they go with the natural flow of events in React vs across them, as well as method profiling+optimizing using Chrome/FF.
2. Extensibility/Maintainability: By splitting the responibilities of connect into many smaller functions, it should be easier both for react-redux contributors to work with the codebase and end users to extend its functionality though the additional APIs. If users can add their desired features in their own projects, that will reduce the number of feature requests to the core project.

Despite passing all the automated tests as well as week of manual testing, there is risk of impacting users dependent on implicit behavior, or that performance is worse in some unexpected circumstances. To minimize risk of impacting end users and downstream library authors, I think it would be wise to pull these changes into a ""next"" branch and first release an alpha package. This would give early adopters a chance to test it and provide feedback
# Thanks

I'd like to thank the other github users who have so far offered feedback on these changes in #407, especially @markerikson who has gone above and beyond.
",jimbolla,markerikson
416,2016-06-24 18:51:44,"Can I ask you to manually test Redux examples in the repo as well as some popular apps?
@markerikson might suggest a few.
",gaearon,markerikson
403,2016-06-09 00:52:50,"Hmm.  A couple thoughts:
- I'm not really following exactly why that ""double-connect"" is necessary, as such.  
  I get that you want state available in `mapDispatch`, and technically `mergeProps` _is_ the escape hatch that allow for that, but why is the ""double-connect"" needed?  Feels like there's got to be some other way to do what you want.
- Is there any reason why the component can't call the action creator with the necessary props, rather than having those pre-bound?
- Seems kinda like what you really need is a Higher-Order Component that is specialized for handling auth stuff somehow.  You might want to watch @acdlite's talk from React Europe: https://youtu.be/zD_judE-bXk.  You're _sorta_ doing that now, but I think it'd be cleaner if you separate that part out.
",markerikson,acdlite
389,2016-05-25 00:35:32,"@gaearon I tried to support the case when `mapDispatchToProps` is an object, but I can't seem to find a way.

So far my entire type definition heavily relies on the magic type `$Diff<A, B>`. It's something flow uses internally to subtract DefaultProps from Props to get the external requirements.

It turns out, that B has to be a strict subset of A for it to work.
So `$Diff<{name: string}, {name: any}>` doesn't work.

But to support `mapDispatchToProps` is an object, I can't just subtract the value returned by `mapDispatchToProps` from props. I need to map into functions somehow, which I can't find any way to do.

I can still fix the type if you're willing to merge this. It's a little more wordy to write out the function version but I think people who use Flow will trade it for the improved type-safety.
",nmn,gaearon
373,2016-05-04 09:07:51,"@gaearon did you have time to check my PR?

I've tried to run benchmarks of @mweststrate . Not sure to have done them correctly, but I actually see increased performances :) It's not huge, and maybe I did something wrong during the benchmark.



Maybe you can run them yourself and confirm?

I've published the benchmark app [before](http://slorber.github.io/connect-refactor/before.html) and [after](http://slorber.github.io/connect-refactor/after.html) so that anyone can take a look
",slorber,gaearon
373,2016-05-05 07:21:59,"thanks :)

I'm going on holiday 2 weeks until the 21 so you will have some time to check the code :)

I'm confident globally but not really about the `checkMergedEquals` attribute that @tgriesser added. Don't really understand the usecase as all my tests are passing without using that, but it has probably be done for a good reason so...
",slorber,tgriesser
368,2016-05-01 01:51:22,"@gaearon it was quite hard and the code is not clean yet but I made all tests pass!

You can take a look at [#373]

At first I thought that I would never be able to make pass the last test related to the stale props when both parent/child are connected, because the transactionnal setState callback can be called multiple times in a single batch.

I had to use a trick like that:



@tgriesser I also succeeded make all the tests pass without using `checkMergedEquals`. Do you think there might be a missing test case?
",slorber,tgriesser
354,2016-04-14 15:20:48,"The new link here is wrong too, the repository simply doesn't exist anymore and we'll switch back to airbnb. See @gaearon's comment in #353 – thanks so much for notifying us of the issue and even submitting this PR though, we appreciate it a lot!
",mxstbr,gaearon
349,2016-04-13 00:50:59,"Hey @gaearon ,
Something I don't understand.
Why the function `e1` and `_.get` are treated differently? Is it also due to different identity of function, or something else?
",haohcraft,gaearon
348,2016-04-12 19:09:29,"cc @slorber, @ellbee, @tgriesser who might be interested in this
",gaearon,ellbee
348,2016-04-12 19:09:29,"cc @slorber, @ellbee, @tgriesser who might be interested in this
",gaearon,tgriesser
323,2016-03-20 18:24:31,"cc @ellbee @faassen @erikras 
",slorber,ellbee
323,2016-03-20 18:24:31,"cc @ellbee @faassen @erikras 
",slorber,erikras
323,2016-10-04 09:19:02,"@jimbolla @gaearon @timdorr I suspect this will be doable in userland with `connectAdvanced` no?
",slorber,timdorr
323,2016-10-04 09:19:02,"@jimbolla @gaearon @timdorr I suspect this will be doable in userland with `connectAdvanced` no?
",slorber,jimbolla
305,2016-03-01 16:27:27,"Clarify that when an object is given, its action creators are automatically wrapped into a dispatch call.

Only managed to figure it out after:
- @gaearon 's twitter response https://twitter.com/dan_abramov/status/696033039953092608
- checking line https://github.com/reactjs/react-redux/blob/v4.4.0/src/components/connect.js#L38
",grifotv,gaearon
292,2016-02-17 20:48:40,"Prompted by https://github.com/reactjs/redux/issues/1415, please read the discussion there. We currently subscribe in `componentDidMount` but it runs from children first. This has a potential of introducing inconsistencies when a child receives some update state earlier than its parent that passes a state-dependent prop to it.

Would subscribing the parents first fix the inconsistencies? Can we do that somehow (e.g. by passing subscribers up via context)?

Alternatively, can/should we wrap `dispatch` into `ReactDOM.unstable_batchedUpdates()` by default like Relay does?

cc @epeli @chandlerprall @tappleby @acdlite 
",gaearon,epeli
292,2016-02-17 20:48:40,"Prompted by https://github.com/reactjs/redux/issues/1415, please read the discussion there. We currently subscribe in `componentDidMount` but it runs from children first. This has a potential of introducing inconsistencies when a child receives some update state earlier than its parent that passes a state-dependent prop to it.

Would subscribing the parents first fix the inconsistencies? Can we do that somehow (e.g. by passing subscribers up via context)?

Alternatively, can/should we wrap `dispatch` into `ReactDOM.unstable_batchedUpdates()` by default like Relay does?

cc @epeli @chandlerprall @tappleby @acdlite 
",gaearon,acdlite
278,2016-02-02 21:54:49,"This post is meant to be a start for a discussion. [Moved from here](https://github.com/rackt/redux/issues/1353#issuecomment-178781992) as @gaearon [suggested here](https://github.com/rackt/redux/issues/1353#issuecomment-178783973).
## Intro

I'm interested in finding best practices on how to architect complex components implemented in React and Redux so that they are reusable as a whole in another app.

Not sure how widespread is the problem, but I encounter it from time to time. I hope the developers from the front-end community encounter similar problems, too.
## Terms and definitions

A **complex component** -- a UI (React, Redux actions), coupled with business logic (Redux reducer), and data access logic (Redux actions' side effects; middleware).

Traits of a complex component:
- can be instantiated more than once, maybe simultaneously (not a singleton)
- each instance can have its own configuration
- can query and manipulate the global environment:
  - the URL and the history (routing, back-forward)
  - network communication (AJAX, WebSockets etc.)
  - storage (cookie, localStorage, sessionStorage etc.)
  - viewport dimensions, global events like viewport scrolling/resizing
- can depend on the app state:
  - query and manipulate other components
  - delegate some functionality, e.g. asset loading, full-screen modal container etc.
- should not pollute the environment
- when used from another app, the component should be reused, not copy-pasted

An **app** -- a UI environment where the components are configured and instantiated.

Traits of an app to consider:
- can be a React + Redux app
- can be a React-only app
- can be a non-React app
## Examples of components
- a [wizard](http://ui-patterns.com/patterns/Wizard), a multi-step form, a [questionnaire](https://en.wikipedia.org/wiki/Questionnaire)
- a complex stateful popup, like a multi-tab settings dialog, or a chat
- a WYSIWYG editor with autocompletion and image uploads

Developing such components with Redux adds the invaluable benefits of predictability and replayability.
## Questions to answer
- How to structure the component code (where to put reducers, actions, UI code)
- How to put a component into a React + Redux app
- How to put a component into an app that has no Redux and/or React
- How to isolate the state of the component instance
- How to configure the component reducers' logic based on the component instance configuration
- How to target actions at specific component instances' state
- How to handle actions of a specific component instance in the app reducers
- How to bridge the component with the global environment (URL and history, network, storage)
- How to bridge the component with the app state
- How to bridge the component with the functionality provided by an app (asset loading, full-screen modal container etc.)

React developers from Facebook answered that I should ""start by reusing React components only"", but having a lot of business logic copied from app to app is not the best way to go.

Elm architecture answers some of the questions, but Redux is quite different (no view+reducer coupling, no explicit serializable side-effects).
## References
- Similar discussion, but not so broad: https://github.com/rackt/react-redux/issues/123
- Similar discussion, but about just actions / reducers / side-effects: https://github.com/rackt/redux/issues/1171
- Similar question: https://github.com/rackt/redux/issues/1314
- Related: https://github.com/yelouafi/redux-saga/issues/62 Though I'd like to avoid sticking to redux-saga until these sagas' state is serializable as well as redux state to at least survive a page reload. ( https://github.com/yelouafi/redux-saga/issues/22, https://github.com/yelouafi/redux-saga/issues/5 )
- Related: https://github.com/rackt/redux/issues/1098
- Related, about action types convention: https://github.com/rackt/redux/issues/786
- Related: https://github.com/rackt/redux/issues/913
- Related: https://github.com/rackt/redux/issues/943#issuecomment-150712338
- Related, reducer logic customization: [BurntCaramel/flambeau reducer props](https://github.com/BurntCaramel/flambeau/blob/master/docs/reducers.md#props)
- https://github.com/erikras/redux-form
- https://github.com/tonyhb/redux-ui
- https://github.com/erikras/multireducer
- https://github.com/acdlite/reduce-reducers
- https://github.com/artsy/react-redux-controller
",sompylasar,gaearon
274,2016-01-28 16:19:18,"@gaearon Thanks!!
",e-jigsaw,gaearon
264,2016-08-15 06:51:55,"@timdorr could you leave a comment why the task was closed? If it's a duplicate / resolved could you link to the related ticket or if it's a ""wont fix"" could you describe why?
",vicapow,timdorr
264,2016-09-07 22:50:54,"@timdorr For future reference, please comment with a reason for closing so we know what the intention was :wink:
",gaearon,timdorr
253,2016-10-31 03:17:38,"Actually, I have good news for you.  Looking at the `next` branch, it seems that @jimbolla has already implemented such a check, here: [connectAdvanced.js#L67-L71](https://github.com/reactjs/react-redux/blob/6cb82a52ee6751f36ef1c2759ca083161ad3f2ff/src/components/connectAdvanced.js#L67-L71)
",markerikson,jimbolla
249,2016-01-14 03:14:35,"First off, thanks so much for Redux and the amazing tooling and introductory content around it. It's been awesome to learn how all of the parts fit together.

I've been running into an issue while building out my first foray into a React/dux app dealing with action creators. I'm having to use `mapDispatch` a ton for just passing the same action creators into the `props` of each of my top-level components (without React Router I end up having around 5 top-level components so far, which I've called ""containers"" following the examples I've seen). 

And the `mapDispatch` that I'm writing is often just a super plain object like `{ loadUser, loadTeam, loadCollection }` that maps keys to keys. It's getting really boilerplate-y to have to keep doing this all the time, when really I'd just like to have all my action creators already bound to my single store.

It would be amazing to be able to pass them into the `<Provider>`:



And be able to use that inside components as:



From looking through the issues, I found that I'm not the first to suggest this, which means others are grappling with this problem too. Here are a few that mention discuss similar things:
- @mmerickel suggested it in https://github.com/rackt/react-redux/issues/1, except with the extra addition of using `mapDispatch` as well, which I think we can eliminate.
- @maxguzenski suggested it in https://github.com/rackt/react-redux/issues/23.
- @gyzerok brought up the same pain point in https://github.com/rackt/redux/issues/231.
- And a few of the [example snippets in the Readme](https://github.com/rackt/react-redux/blob/master/docs/api.md#inject-todos-and-all-action-creators-addtodo-completetodo-) actually mention a similar use case (of binding all action creators easily), but they do it at `connect`-time for each component, instead of at the `Provider` level, which would mean not having to worry about it any more.

One time when it was brought up, it was discarded because of not wanting to pollute `props` with all of the actions, since the ""clobber likelihood"" would be high. I totally get the concern about not wanting to pollute `props` with tons of actions, but we can avoid that by nesting them in `props.actions` instead.

Another time, @gaearon mentioned the (important) needs of code splitting. I think that's definitely a use case to support, but surely we could have a load-later approach that works very similarly to the current `mapDispatch` that would facilitate loading extra modules, while also making it easy for the main use case?

Curious to hear everyone's thoughts.

From my initial use of both React and Redux, this would save me boilerplate code, and make it possible for people to write nicer boilerplate-reducing functionality on top of the base libraries.
",ianstormtaylor,gaearon
236,2016-01-07 17:25:23,"OK, I got `react-redux 4.0.6` to work with `react-native`, it will be available in [example-react-native-redux](https://github.com/alinz/example-react-native-redux).

There are couple of steps need to be done which I hide them at the moment in `package.json`'s `postscript`. Here's the details:
1. `react` module in `react-native/node_module` must be deleted.
2. `fbjs` module in `react-native/node_modules` must be deleted.
3. `fbjs` module in `react/node_modules` must be deleted.
4. `fbjs` module must be added as module to project in main `package.json`
5. `all .babelrc` files must be deleted under node_module folder

There is a discussion here https://github.com/facebook/react-native/issues/2985#issuecomment-168412030 which @spicyj talks about changing fbjs.

Also @gaearon I still need to remove all .babelrc files under node_modules before I can run the [example-react-native-redux](https://github.com/alinz/example-react-native-redux). What is your suggestion?
",alinz,gaearon
236,2016-01-07 17:39:09,"I don't have any suggestions here. Feedback from people more knowledgeable in RN is welcome. 

Perhaps @ide or @spicyj could clarify the situation. 
",gaearon,ide
225,2015-12-22 12:15:39,"This attempts to completely remove any internal side effects from `shouldComponentUpdate()` because is not in line with how React tells us to treat it and [may not even be called in certain cases, e.g. during hot reloading](https://github.com/rackt/react-redux/issues/224).

I didn't touch any tests, and that they pass is a good sign because it means we didn't regress over #99 which is where those side effects were moved to `shouldComponentUpdate()`. Here, instead, I moved them to `render()`, and applied a different optimization (namely, returning a constant element) to achieve the same effect as `shouldComponentUpdate()` did while always calling `mapStateToProps` and `mapDispatchToProps` with up-to-date props.

I confirm this PR fixes #224. It should not regress on performance.

@epeli Would you like to review?
",gaearon,epeli
224,2015-12-21 22:51:44,"So this _is_ a bug. In particular it is caused by us recomputing child props inside `shouldComponentUpdate()` which is not at all guaranteed to run (for example, it won't run if the connect wrapper is `forceUpdate()`d which is exactly what `react-transform-hmr` does). This was introduced in #99.

@epeli Can you look at this? Ideally we shouldn't care if `shouldComponentUpdate()` is called or not. We definitely shouldn't rely on React doing it before every render. Maybe we should move the calculations back into `componentWillReceiveProps` and `handleChange` and solve #99 in some other way.
",gaearon,epeli
212,2015-12-12 18:04:50,"@gaearon Do we want loose mode for IE8? React-Redux previously used it but this PR does not.
",ellbee,gaearon
196,2015-11-24 20:34:00,"This looks good to me.
@epeli What do you think about this change? Any reason `storeState` was initialized to `null` in b6272698d2fc9ff7f67014b3e527579f738cd81d?
",gaearon,epeli
194,2015-11-19 20:20:04,"This started off from a discussion in https://github.com/rackt/redux/issues/980

As far as I can tell there is no way to get the information that I need from listeners using the approach suggested by @gaearon, but if we have the `handleChange` return some data for us then it's straightforward.

The approach I took here is to have `handleChange` take an optional parameter which is a function that should extract the data we need, given the wrapped component's name, the `nextState`, and to leave the door open to other requirements, the instance of the connect component itself.

If this or some variation of this is accepted, it would be great to also do a point release for 3.x in order to support React Native right away (which is the context where I am using this).

An example of how you might use this:



The result:


",brentvatne,gaearon
194,2015-11-30 06:48:20,"@epeli @gaearon - any feedback?
",brentvatne,epeli
194,2015-11-30 06:48:20,"@epeli @gaearon - any feedback?
",brentvatne,gaearon
183,2015-11-11 01:26:01,"I think we've concluded it's actually not possible to do the per-component memoization without a global LRU cache as @ellbee [mentions here](https://github.com/rackt/react-redux/pull/179#issuecomment-155565193), so this would be the next best thing.

@acdlite I typically like to use a one layer deeper shallow `===`. I have a lot of connected components and selectors which have plain Arrays as return values, and so it ends up there's a lot more unnecessary updating going on than there'd need to be if we could just check the returned Array or Object props are themselves shallow equal.

I've found the amount of time it takes to do an extra shallow compare of a few Arrays is virtually nothing compared to the expense of React going through an update cycle.
",tgriesser,ellbee
182,2015-11-11 00:24:53,"Similar to `createSelectorCreator` in reselect, provides `createConnect` to optionally wrap `connect` providing a custom implementation of `shallowEqual`. 

@ellbee thoughts? Are there any other functions that might be worth allowing customization of?
",tgriesser,ellbee
179,2015-11-09 00:00:31,"Can you please elaborate on usage? I don't quite understand this.
@ellbee Is there a way to solve this problem without changing React Redux API? I don't want it to “know” about the fact that user has Reselect, this feels wrong.
",gaearon,ellbee
171,2015-10-30 22:47:09,"Thanks for the report. I'd say you should file this with `redux-router`.

By default it sets `router` state field to `null`, but I think it should have initial value before first change action. The app should never see `null` state there, I think, but `RESET` effectively gets us back to the initial state. The same error will occur if you “toggle” action in DevTools.

@acdlite Ideas?
",gaearon,acdlite
145,2015-10-14 18:30:09,"@erikras Thoughts?
",gaearon,erikras
145,2016-01-13 04:17:07,"@gaearon

I fiund thus question by you (on S.O.) and another one by @ide (i just commented on that too so i apologize for the inadvertent loop) grappling with the effecf of this same exact issue, which was not satisfied IMO with the batchedupdate answer (you are still going to have overhead that grows with the complexity of the component tree)

https://github.com/rackt/redux/issues/125

http://stackoverflow.com/questions/25701168/at-what-nesting-level-should-components-read-entities-from-stores-in-flux

I think the answer on S.O. is not ideal... leaving it to the programmer is not a comforting solution

have you any updated insight?
",idibidiart,ide
138,2015-10-08 23:36:59,"I'm cool with using Recompose's `wrapDisplayName()` — true story, I copied the code for `getDisplayName()` from this repo — though I know Dan likes to keep the dependencies to a minimum. 

@gaearon?
",acdlite,gaearon
123,2015-09-28 12:31:26,"Hey guys,

I'm developing an app with pretty complex form logic. I'm trying to follow the advice of @gaearon about Smart and Dumb components.

My form is dynamic, and is constructed out of several `fieldsets`. The fieldsets that are being displayed are chosen based on user roles.

Each fieldset has it's own validation logic and own actions to retrieve async data based on user input, in order to guide the user towards completion of the form.

Not only that, but the inputs inside each fieldset are dynamic as well. Again, based on user permissions.

I've tried to implement this use case using only one Smart Component (the route handler), however without much success.

As I see it, in such use case, a fieldset is both a smart component and a dumb component. It both `connects` to redux, in order to dispatch some private use case actions and it also acts as a dumb component to bubble up state changes using events.

Am I getting it right?

In your opinion, where does validation should take place? Inside each fieldset or in the route handler?

Basically, I'm planning to use same validation logic both on client and server.

The model that I'm validating on the server, looks something like:



The original way I tried to implement it, is to  is to simply validate in the route handler level, but it got really messy and complex. Basically unmaintainable. Some validation logic needs to be async. 

On the server I prefetch all the validation logic before validating.

On the client, it's a bit harder because the fieldsets are dynamic.

What do you think? How would you approach nested forms with react-redux?

Thanks.
",tounano,gaearon
99,2015-09-08 22:25:24,"@epeli this brings us back to the way things were before #1 which as @gaearon says makes the worst case performance the default. I'm inclined to leave the existing behavior as is. If we did adopt this form I would hope that it be made optional and opt-in much like the 2nd arg props parameter to the first two connect arguments.
",gnoff,gaearon
99,2015-09-08 23:08:29,"> this brings us back to the way things were before #1 which as @gaearon says makes the worst case performance the default

Not able apprehend right away every point made in #1 but I'd like hear why this would be the **worst** case compared to the current implementation because in it `mapState` is also executed always when the store changes. Also note the PureWrap optimization in this PR which prevents any useless renders in the wrapped components if the `mapState` does not produce any changes.
",epeli,gaearon
98,2015-09-13 06:38:17,"PRs are always welcome. I don't use TS, don't think @gaearon does either. Hopefully someone out there using it will contribute
",gnoff,gaearon
97,2015-09-07 11:13:29,"@gaearon  I've already posted a link to my project about a month ago under the Redux repository. That time it was called `redux-graphql`. I've did a lot of work to understand what it should be. Now I think of it as a React binding for Redux with Relay idea behind.
Today I've ended up with some clunky readme, but I suppose it would be enough for you to get an idea
Now its [adrenaline](https://github.com/gyzerok/adrenaline). Can I somehow contact you to get feedback on what I've done?
",gyzerok,gaearon
90,2015-09-03 19:28:53,"This looks good to me.
@gnoff what do you think?
",gaearon,gnoff
76,2015-08-27 05:39:52,"@gnoff The issue was more around distributable browser bundle than cdnjs.
Is there a way currently to use it, that I am missing?

cc @gaearon 
",vipulnsward,gaearon
59,2015-08-16 10:56:39,"@gaearon 
",jhollingworth,gaearon
52,2015-08-11 19:32:02,"cc @jhollingworth, @danharper, @ForbesLindesay who wanted to make this happen
",gaearon,jhollingworth
28,2015-08-07 19:40:27,"OK I introduced this bug while tweaking @gnoff's code. :-(
Will push out a fix soon.
",gaearon,gnoff
25,2015-08-07 11:09:38,"This is based on #16, plus a few style tweaks I want to make + boring stuff like removing dead bones of deprecated APIs. Big thanks to @gnoff!
",gaearon,gnoff
16,2015-07-31 06:38:22,"Alright,

Here's my take on the new connectDecorator API. Normal Args examples should all work from @gaearon 's comment in #1 

https://github.com/gaearon/react-redux/issues/1#issuecomment-120729921
### API



~~I didn't delete createConnector but I did move createConnectDecorator to createConnectDecoratorDeprecated until we can decide if we should just delete these.~~

the old Connector and connect decorator have been deleted

I have tested through mocha only so no guarantees it is 100%

I'm happy to make changes/work on it etc... as opinions change on best api going forward if it's not ready to merge yet.

State is handled like Connector did on any notification from the store. shouldComponentUpdate will bail if the slice is the same

actions are bound using the provided dispatchBinder (2nd arg) only on component mount. Not sure if this is what you were aiming for in the API but it certainly reduces the number of binds to a lot less than every render and it seemed find since the typical use case for dispatchBinder is to simply bind dispatch to the action creator methods

merge is called on every render, reading stateProps and dispatchBinderProps from component state (not store state) and taking whatever current component props as the 3rd argument.

~~finally the decorated component is rendered with this.props, and mergedProps in that order.~~
If you want choose to provide a custom merge function then only the props returned from merge will be added to the underlying component

I also wrote a util for wrapActionCreators that fits the dispatchBinder argument signature and delegates to redux/bindActionCreators. This is called form connectDecorator if the actionCreators argument is a plain object
",gnoff,gaearon
