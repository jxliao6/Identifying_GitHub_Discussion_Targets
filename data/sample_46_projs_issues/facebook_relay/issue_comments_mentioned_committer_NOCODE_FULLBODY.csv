issue_num,datetime,body,login,mention_login
1574,2017-03-21 18:54:59,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4747796).",facebook-github-bot,wincent
1571,2017-03-21 23:44:33,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4750884).",facebook-github-bot,kassens
1566,2017-03-22 20:35:44,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4756931).",facebook-github-bot,wincent
1565,2017-03-22 20:34:37,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4756921).",facebook-github-bot,wincent
1562,2017-03-21 23:50:54,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4750959).",facebook-github-bot,kassens
1560,2017-03-04 21:55:23,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4656348).",facebook-github-bot,kassens
1552,2017-03-04 21:42:55,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4656332).",facebook-github-bot,kassens
1550,2017-03-16 14:50:50,"Hey @wincent, it seems the CI build failed and this PR was never merged by the bot --  is there anything I can do to fix that?",mihai,wincent
1550,2017-03-22 17:53:58,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4755172).",facebook-github-bot,wincent
1549,2017-02-17 15:40:02,Thanks @blaiprat.,wincent,blaiprat
1549,2017-02-17 15:40:37,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4578915).",facebook-github-bot,wincent
1547,2017-02-15 22:27:18,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4568273).",facebook-github-bot,wincent
1545,2017-02-15 06:28:53,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4564255).",facebook-github-bot,wincent
1538,2017-02-09 01:29:36,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4534444).",facebook-github-bot,wincent
1528,2017-02-06 07:29:51,"Thanks @apalm, I think GraphQLMutation.createWithFiles is not covered by the test cases and it should be added as well",AWDGroup,apalm
1528,2017-02-08 07:51:32,Thanks @wincent for the complete & clear explanation. ,AWDGroup,wincent
1526,2017-01-31 18:52:55,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4489196).",facebook-github-bot,wincent
1525,2017-01-31 18:38:37,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4489066).",facebook-github-bot,wincent
1524,2017-01-31 18:28:34,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4488974).",facebook-github-bot,wincent
1523,2017-01-31 18:22:18,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4488927).",facebook-github-bot,wincent
1522,2017-01-31 18:18:12,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4488899).",facebook-github-bot,wincent
1521,2017-01-31 18:08:52,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4488835).",facebook-github-bot,wincent
1519,2017-01-31 18:08:33,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4488833).",facebook-github-bot,wincent
1518,2017-01-31 01:47:30,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4486444).",facebook-github-bot,wincent
1516,2017-01-30 23:31:21,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4485243).",facebook-github-bot,wincent
1515,2017-01-30 23:12:08,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4485070).",facebook-github-bot,wincent
1514,2017-01-30 17:57:22,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4482414).",facebook-github-bot,wincent
1513,2017-01-29 04:58:12,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4480223).",facebook-github-bot,kassens
1511,2017-01-27 21:30:58,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4476956).",facebook-github-bot,wincent
1511,2017-01-28 00:59:01,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4476956).",facebook-github-bot,wincent
1509,2017-01-27 21:01:46,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4476712).",facebook-github-bot,wincent
1509,2017-01-28 00:34:56,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4476712).",facebook-github-bot,wincent
1508,2017-01-28 00:37:45,"Alas @nodkz, that doesn't work, but I have an alternative workaround that does. The Flow team at FB is aware of the bug in the module resolution so it will be fixed, but for now we have a workaround (see my PR).",wincent,nodkz
1506,2017-01-25 17:39:33,Okay then I close this. Thanks for all the great work @wincent ,danez,wincent
1505,2017-01-24 23:18:02,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4458933).",facebook-github-bot,wincent
1504,2017-01-19 09:32:40,@alloy Do you mean canonical as in the main project?,Naoto-Ida,alloy
1504,2017-01-20 03:07:43,"@alloy Thank you so much! I wish I could help out a bit more, as I've only been playing with Relay for the past month or so...",Naoto-Ida,alloy
1502,2017-01-14 05:14:56,"@alloy so good, thank you for taking the time to figure this out! 

Cc @kassens",josephsavona,alloy
1502,2017-01-16 16:40:32,"@colllin Oh, what task was failing?",alloy,colllin
1502,2017-01-16 16:46:16,"@colllin Ah I see, it’s a new requirement since this change that got added after my PR eab5a45b8a648564037e36cdb668abf9154b9ef3. Will add it 👍 ",alloy,colllin
1498,2017-01-12 08:57:22,"@josephsavona has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4409111).",facebook-github-bot,josephsavona
1497,2017-01-16 14:57:00,"It is definitely possible to skip the React API and use the `subscribe` method directly in relay-subscriptions. It's basically `relayEnvironment.subscribe(new Subscription())`.

Another approach which probably is better is to use the React API and mount a component that never unmounts which holds all the subscriptions.

The example app in the repo is built like @josephsavona mentioned, it only listen on data that is currently visible on the page however it doesn't have to be like that. it's up to the developer to make that decision. ",edvinerikson,josephsavona
1497,2017-01-16 16:38:13,"Thanks @edvinerikson for the awesome relay-subscriptions library.   I am using both the subscribe api and containers api.

I have forked and made some modifications to relay-subscriptions createContainer :  https://github.com/reachifyio/relay-subscriptions/blob/master/src/createContainer.js#L53-L97
It isn't perfect but works for our use case.




I thought about it too but the problem is that all the data which should be subscribed too isn't known at one place. Its scattered among different relay containers.


",nikhildaga,edvinerikson
1497,2017-01-17 08:38:59,"@edvinerikson :  Its the variables that aren't known.. Yes, we are removing duplicate requests in network layer. 

But, I agree with you, that ultimately there should be a single place from where we subscribe only once and update the store.  As Joseph mentioned, its possible, will give it a try.",nikhildaga,edvinerikson
1496,2017-01-11 21:41:05,"Thanks for the question and answers.

@josephsavona where does the `nodes` interface come from? I can't find it in the docs: https://facebook.github.io/relay/docs/graphql-relay-specification.html",hkjorgensen,josephsavona
1496,2017-01-12 01:23:32,"> The nodes field isn't documented (yet) but is stable

@josephsavona will current relay try to use this? I.e., if I have a graphql server that supports `node` but not `nodes`, will this potentially break a relay client?",jsdnxx,josephsavona
1494,2017-01-16 07:40:48,"Yeah this sounds like a bug. @colllin your proposed fix sounds right, other than adding a conditional check to only reset `state.relayProp` if the store actually changed. We'd be happy to accept a PR along those lines! :-)",josephsavona,colllin
1489,2016-12-26 01:10:49,"@josephsavona has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.facebook.com/D4366795).",facebook-github-bot,josephsavona
1486,2016-12-22 16:57:03,"@josephsavona has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.facebook.com/D4362322).",facebook-github-bot,josephsavona
1480,2016-12-14 00:50:40,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4324311).",facebook-github-bot,wincent
1477,2016-12-09 19:15:14,"@josephsavona has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4307042).",facebook-github-bot,josephsavona
1476,2016-12-09 19:48:00,"@josephsavona  Sorry for not being clear the first time ( but that was helpful too :D )
What I meant was:

Here's my Route query 


And some component would require data 



How can I fetch more data (invoke `search()` query) in this case   ? 

",shakaIsReal,josephsavona
1476,2016-12-09 23:56:37,"@josephsavona I also looked at https://gist.github.com/vslinko/3f877c2415464ecc7af6. 
Should pagination logic live in the Route? The example cited, uses `viewer` field as the stating point and has fragments such as `search` linked to it. Yet, I hope there's a better way to do it?",shakaIsReal,josephsavona
1476,2016-12-10 00:46:07,"@josephsavona Thanks, so for this kind of cases, you suggest making a `viewer` field that links to `SearchType`, and `SearchType` would have a `search` field? But what if the number of these cases increases, then there must be a union type on `viewer` that resolves to a specific type, right? 
 


",shakaIsReal,josephsavona
1476,2016-12-10 23:26:16,"Thanks, are you going to support ""root fields"" in Relay 2? `viewer` field seems like a remnant (http://stackoverflow.com/questions/39938560/graphql-viewer-for-mutations/39939747#39939747)
I already got authorisation (using `context`), and I'll only need `viewer` field for executing queries (such as `search`). Is this the recommended approach anyway? 

@josephsavona @leebyron ",shakaIsReal,josephsavona
1474,2016-12-08 21:29:16,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4301658).",facebook-github-bot,kassens
1473,2016-12-08 21:11:31,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4301502).",facebook-github-bot,kassens
1471,2016-12-07 02:49:47,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4290330).",facebook-github-bot,kassens
1470,2016-12-06 19:39:36,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4286363).",facebook-github-bot,kassens
1468,2016-12-06 17:36:54,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4285392).",facebook-github-bot,kassens
1466,2016-12-05 09:19:31,"@josephsavona This is exactly what I'm trying to achieve in an issue I opened earlier (delete from a connection with specifics arguments). It might be dead simple but I can't seem to find the syntax ; [related issue](https://github.com/facebook/relay/issues/1462), for when you have some time.",yachaka,josephsavona
1466,2016-12-05 09:44:20,"@josephsavona So if the arguments are correctly inserted, it should update the correct `fragment`? I'll try this out! The other method with local state sounds unfamiliar for me. How would that actually look like?",proProbe,josephsavona
1466,2016-12-11 18:44:09,@josephsavona any information on the question I have above? Sorry for bothering you :) just not sure on how to do the proposed solution,proProbe,josephsavona
1464,2016-12-03 22:25:23,"@josephsavona has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4272048).",facebook-github-bot,josephsavona
1463,2016-12-03 22:00:30,"@josephsavona Thanks for the suggested workaround, but unfortunately using variables results in exactly the same query.",legomind,josephsavona
1461,2016-12-04 19:40:01,"Thanks a lot @yachaka and @josephsavona.

@josephsavona I am trying to understand the second part you mentioned. I read that `applyUpdate` will give me a `RelayMutationTransaction` which can be committed or rollbacked. If I understand you correctly, I will need to use Redux approach (or something similar) to accumulate all the changes along with all the `RelayMutationTransaction` objects that I get by calling `applyUpdate` for changes in each component. Before committing the final mutation with all changes in the parent component, I will need to rollback all the `RelayMutationTransaction` objects.

Is this correct? Does it also mean that I will have to create small mutation types for each component and then combine them in the final mutation type?",nikhilag,josephsavona
1460,2016-12-04 20:55:36,"@yachaka @josephsavona the Relay containers have state variables though. So it's not as simple as calling a static method that returns the entire query, you need to be able to get the tree as a function of the application state. So that's more of my question -- how do the variables work?",ccorcos,josephsavona
1457,2016-11-28 10:59:02,"@josephsavona  Thanks, lets say I want to get users `id, name, age, gender, posts`. 
`posts` will be fetched using a cursor i.e. `posts(first:10)`

 My query type would look like this: 


And nodeDefenitions: 


 And `UserType` will get the posts. 


The problem is that `getUser()` will fetch `name`, `gender` and `age`. So if I want to get more posts from a specific user, I will have to ask for unnecessary information inside `idFetcher()`. When really all I need is user's `id`. 

  
> (i.e. let the executor call your resolve function for each field and load it only then 

Are you saying to query the database inside each field's resolver function. Like this? 



But this would be inefficient for the server.  Sorry if I misunderstand something, I am used to REST...
I feel like I need to create two separate function one for the query `getUser()` and one for idFetcher: `getUserId()` where a new constructor (User) with id will be created. 
",shakaIsReal,josephsavona
1457,2016-11-29 18:47:14,"@josephsavona thank you 
",shakaIsReal,josephsavona
1457,2016-11-30 22:38:42,"@josephsavona What's the motivation of fetching the `id` from the database in `nodeDefenitions`? We already know the `id` from the global object, why not just return it? Here's an example from join-monster https://github.com/stems/join-monster/blob/master/example/schema-relay-paginate-2/Node.js#L18 

Thanks. ",shakaIsReal,josephsavona
1454,2016-11-25 11:19:05,"@josephsavona, thanks for clarification",maxpolski,josephsavona
1453,2016-11-24 07:22:06,"thanks response @josephsavona,
so how can use fragment spreads with `@include`directive in relay createContainer fragment?

i'm use fragment spreads with `@include`like this


then relay change fragment spreads to fragment definitions


then `FRAGMENT_DEFINITION ` error occur


and fragment spreads with `@include`directive work in 
[relay playground](https://facebook.github.io/relay/prototyping/playground.html#source=%2F**%0A%20*%20Copyright%20(c)%202013-present%2C%20Facebook%2C%20Inc.%0A%20*%20All%20rights%20reserved.%0A%20*%0A%20*%20This%20source%20code%20is%20licensed%20under%20the%20BSD-style%20license%20found%20in%20the%0A%20*%20LICENSE%20file%20in%20the%20root%20directory%20of%20this%20source%20tree.%20An%20additional%20grant%0A%20*%20of%20patent%20rights%20can%20be%20found%20in%20the%20PATENTS%20file%20in%20the%20same%20directory.%0A%20*%2F%0A%0A%2F%2F%20Welcome%20to%20Relay.%0A%2F%2F%20Allow%20us%20to%20introduce%20you%20to%20the%20four%20elements.%0A%0Aclass%20Hello%20extends%20React.Component%20%7B%0A%20%20render()%20%7B%0A%20%20%20%20%2F%2F%20Relay%20will%20materialize%20this%20prop%20based%20on%20the%0A%20%20%20%20%2F%2F%20result%20of%20the%20query%20in%20the%20next%20component.%0A%20%20%20%20const%20%7B%20hello%2C%20world%20%7D%20%3D%20this.props.greetings%3B%0A%20%20%20%20if(!hello)%20return%20%3Ch1%3Ehellow%20undefined%3C%2Fh1%3E%0A%20%20%20%20return%20%3Ch1%3E%7Bhello%20%2B'%20'%20%2B%20world%7D%3C%2Fh1%3E%3B%0A%20%20%7D%0A%7D%0AHello%20%3D%20Relay.createContainer(Hello%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20%2F%2F%0A%20%20%20%20%2F%2F%20This%20GraphQL%20query%20executes%20against%0A%20%20%20%20%2F%2F%20the%20schema%20in%20the%20'schema'%20tab%20above.%0A%20%20%20%20%2F%2F%0A%20%20%20%20%2F%2F%20To%20learn%20more%20about%20Relay.QL%2C%20visit%3A%0A%20%20%20%20%2F%2F%20%20%20https%3A%2F%2Ffacebook.github.io%2Frelay%2Fdocs%2Fapi-reference-relay-ql.html%0A%20%20%20%20greetings%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Greetings%20%7B%0A%20%20%20%20%20%20%20%20...%40include(if%3A%20true)%7B%0A%20%20%20%20%20%20%20%20%20%20hello%0A%20%20%20%20%20%20%20%20%20%20world%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%0A%2F**%0A%20*%20%231%20-%20Your%20React%20components%0A%20*%20This%20will%20look%20familiar%20to%20React%20developers.%0A%20*%0A%20*%20To%20learn%20more%20about%20React%2C%20visit%3A%0A%20*%20%20https%3A%2F%2Ffacebook.github.io%2Freact%0A%20*%2F%0Aclass%20HelloApp%20extends%20React.Component%20%7B%0A%20%20render()%20%7B%0A%20%20%20%20%2F%2F%20Relay%20will%20materialize%20this%20prop%20based%20on%20the%0A%20%20%20%20%2F%2F%20result%20of%20the%20query%20in%20the%20next%20component.%0A%20%20%20%20return%20%3CHello%20greetings%3D%7Bthis.props.greetings%7D%2F%3E%0A%20%20%7D%0A%7D%0A%0A%2F**%0A%20*%20%232%20-%20Relay%20containers%0A%20*%20Compose%20your%20React%20components%20with%20a%20declaration%20of%0A%20*%20the%20GraphQL%20query%20fragments%20that%20fetch%20their%20data.%0A%20*%0A%20*%20To%20learn%20more%20about%20Relay%20containers%2C%20visit%3A%0A%20*%20%20%20https%3A%2F%2Ffacebook.github.io%2Frelay%2Fdocs%2Fguides-containers.html%0A%20*%2F%0AHelloApp%20%3D%20Relay.createContainer(HelloApp%2C%20%7B%0A%20%20initialVariables%3A%20%7B%0A%20%20%20%20show%3A%20true%2C%0A%20%20%7D%2C%0A%20%20fragments%3A%20%7B%0A%20%20%20%20%2F%2F%0A%20%20%20%20%2F%2F%20This%20GraphQL%20query%20executes%20against%0A%20%20%20%20%2F%2F%20the%20schema%20in%20the%20'schema'%20tab%20above.%0A%20%20%20%20%2F%2F%0A%20%20%20%20%2F%2F%20To%20learn%20more%20about%20Relay.QL%2C%20visit%3A%0A%20%20%20%20%2F%2F%20%20%20https%3A%2F%2Ffacebook.github.io%2Frelay%2Fdocs%2Fapi-reference-relay-ql.html%0A%20%20%20%20greetings%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Greetings%20%7B%0A%20%20%20%20%20%20%20%20__typename%0A%20%20%20%20%20%20%20%20...%40include(if%3A%20%24show)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%24%7BHello.getFragment('greetings')%7D%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D)%3B%0A%0A%2F**%0A%20*%20%233%20-%20Relay%20routes%0A%20*%20Define%20a%20root%20GraphQL%20query%20into%20which%20your%0A%20*%20containers'%20query%20fragments%20will%20be%20composed.%0A%20*%0A%20*%20To%20learn%20more%20about%20Relay%20routes%2C%20visit%3A%0A%20*%20%20%20https%3A%2F%2Ffacebook.github.io%2Frelay%2Fdocs%2Fguides-routes.html%0A%20*%2F%0Aclass%20HelloRoute%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20'Hello'%3B%20%20%2F%2F%20A%20unique%20name%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20%2F%2F%20Here%2C%20we%20compose%20your%20Relay%20container's%0A%20%20%20%20%2F%2F%20'greetings'%20fragment%20into%20the%20'greetings'%0A%20%20%20%20%2F%2F%20field%20at%20the%20root%20of%20the%20GraphQL%20schema.%0A%20%20%20%20greetings%3A%20(Component)%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20query%20GreetingsQuery%20%7B%0A%20%20%20%20%20%20%20%20greetings%20%7B%0A%20%20%20%20%20%20%20%20%20%20%24%7BComponent.getFragment('greetings')%7D%2C%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%3B%0A%7D%0A%0A%2F**%0A%20*%20%234%20-%20Relay%20root%20containers%0A%20*%20Compose%20a%20Relay%20container%20with%20a%20Relay%20route.%0A%20*%20This%20enables%20Relay%20to%20synthesize%20a%20complete%20query%0A%20*%20to%20fetch%20the%20data%20necessary%20to%20render%20your%20app.%0A%20*%0A%20*%20To%20learn%20more%20about%20Relay%20root%20containers%2C%20visit%3A%0A%20*%20%20%20https%3A%2F%2Ffacebook.github.io%2Frelay%2Fdocs%2Fguides-root-container.html%0A%20*%2F%0AReactDOM.render(%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20Component%3D%7BHelloApp%7D%0A%20%20%20%20route%3D%7Bnew%20HelloRoute()%7D%0A%20%20%2F%3E%2C%0A%20%20mountNode%0A)%3B%0A&schema=%2F**%0A%20*%20Copyright%20(c)%202013-present%2C%20Facebook%2C%20Inc.%0A%20*%20All%20rights%20reserved.%0A%20*%0A%20*%20This%20source%20code%20is%20licensed%20under%20the%20BSD-style%20license%20found%20in%20the%0A%20*%20LICENSE%20file%20in%20the%20root%20directory%20of%20this%20source%20tree.%20An%20additional%20grant%0A%20*%20of%20patent%20rights%20can%20be%20found%20in%20the%20PATENTS%20file%20in%20the%20same%20directory.%0A%20*%2F%0A%0Aimport%20%7B%0A%20%20GraphQLObjectType%2C%0A%20%20GraphQLSchema%2C%0A%20%20GraphQLString%2C%0A%7D%20from%20'graphql'%3B%0A%0Aconst%20GREETINGS%20%3D%20%7B%0A%20%20hello%3A%20'Hello'%2C%0A%20%20world%3A%20'world'%2C%0A%7D%3B%0A%0A%2F**%0A%20*%20Objects.%0A%20*%20Build%20up%20a%20portrait%20of%20your%20data%20universe%0A%20*%20using%20the%20object%20type.%20Here%2C%20we%20define%20a%0A%20*%20type%20of%20object%20that%20has%20a%20'hello'%20field%0A%20*%20that%20is%20of%20the%20string%20type.%0A%20*%2F%0Aconst%20GreetingsType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20'Greetings'%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20hello%3A%20%7Btype%3A%20GraphQLString%7D%2C%0A%20%20%20%20world%3A%20%7Btype%3A%20GraphQLString%7D%2C%0A%20%20%7D)%2C%0A%7D)%3B%0A%0A%2F**%0A%20*%20The%20schema.%0A%20*%20Here%20we%20export%20a%20schema%20that%20offers%20one%20root%0A%20*%20field%20named%20'greetings'%2C%20and%20a%20method%20to%0A%20*%20resolve%20its%20data.%0A%20*%0A%20*%20To%20learn%20more%20about%20writing%20GraphQL%20schemas%20for%20Relay%2C%20visit%3A%0A%20*%20%20%20https%3A%2F%2Fgithub.com%2Fgraphql%2Fgraphql-relay-js%0A%20*%2F%0Aexport%20default%20new%20GraphQLSchema(%7B%0A%20%20query%3A%20new%20GraphQLObjectType(%7B%0A%20%20%20%20name%3A%20'Query'%2C%0A%20%20%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20%20%20greetings%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20GreetingsType%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20Here%20we%20define%20a%20resolver%20that%20returns%0A%20%20%20%20%20%20%20%20%2F%2F%20the%20data%20defined%20above.%20Were%20this%20schema%0A%20%20%20%20%20%20%20%20%2F%2F%20executing%20on%20the%20server%20side%2C%20you%20could%0A%20%20%20%20%20%20%20%20%2F%2F%20write%20a%20resolve%20method%20that%20fetches%0A%20%20%20%20%20%20%20%20%2F%2F%20live%20data%20from%20a%20database.%0A%20%20%20%20%20%20%20%20resolve%3A%20()%20%3D%3E%20GREETINGS%2C%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%7D)%2C%0A%20%20%7D)%2C%0A%7D)%3B%0A)",jeongsd,josephsavona
1450,2016-12-01 14:27:33,@josephsavona I have the same problem here. `pendingVariables` are never set for me. I'm using relay 0.9.3 and developing on react-native 0.37.,yachaka,josephsavona
1448,2016-12-09 18:14:58,"@josephsavona I'm trying to figure out something in the same vein here. `setVariables` forces a refetch if the specific combination of variables hasn't been fetched before.

Curious if you have any thoughts; I tried to fully articulate my question here:
http://stackoverflow.com/questions/41051401/graphql-relay-filtering-ui
",voxmatt,josephsavona
1448,2016-12-22 17:30:25,@josephsavona thanks!,voxmatt,josephsavona
1446,2016-11-16 02:15:38,"Thanks @josephsavona 👍 
",gauravtiwari,josephsavona
1445,2016-11-28 17:34:51,"@josephsavona after sitting with it today, I actually realised that it was a bad implementation on the backend. It basically went like this:
1. user sends a query with `first: 10`
2. backend receives it and start the db-query
3. the db-query had a `limit( args(""first"") )` (for avoiding fetching the whole db)
4. the cursor and node resolvers interpreted this as `the db only has 10 entries`
5. user tries to fetch more and does a setvariables with `first: relay.variables.first + 10`
6. relay is smart and puts `after: id_of_entry_10`
7. but after only receiving `10 entries` from the db, relay knows that there is no more data to fetch
8. relay skips the fetch as there is no more data to fetch.

I realised that this was actually the problem. Im trying to go around it right now but Im not actually sure what ""the way to go"" is",proProbe,josephsavona
1445,2016-11-28 17:51:37,@josephsavona you are certainly correct. Im trying to read more about this to get a better grasp of it. Im currently looking through https://facebook.github.io/relay/graphql/connections.htm#sec-Reserved-Types. Are there other good sources for this?,proProbe,josephsavona
1442,2016-12-14 06:23:16,"Thanks, @chentsulin. Merged!",wincent,chentsulin
1441,2016-12-14 06:33:31,"Thanks @lucasbento, will merge.",wincent,lucasbento
1440,2016-12-14 06:34:58,"Thanks, @ctavan! Will merge.",wincent,ctavan
1438,2016-11-06 20:43:32,"@josephsavona thanks! it solved my situation. is this how you usually do it with `node(id: $id)`? Is this because Im using two different calls?
",proProbe,josephsavona
1438,2016-11-06 21:25:28,"@josephsavona Im not sure where to read about this. I totally missed the section in https://facebook.github.io/relay/docs/graphql-object-identification.html#content which would probably help most people with this problem. If anything, maybe some more documentation about using multiple relay.renderers in the same app. 
",proProbe,josephsavona
1436,2016-11-07 21:53:21,"@nodkz Thanks for the PR. I understand the use-case and that it is helpful to have the plugin reflect schema changes without completely restarting. However, this seems like something that should be achievable via plugin composition. My first thought would be to create a wrapper plugin that delegates all transform functions to an instance returned by `getBabelRelayPlugin`. Each time the schema changes, the wrapper would update that instance with a new Relay plugin.
",josephsavona,nodkz
1436,2016-11-10 12:48:45,"@josephsavona yep, plugin composition is the better way. But I did not do that cause: 
- don't know how to write babel plugin wrapper (and have no time right now for reading docs)
- I saw code that moves this plugin to first place in babel's plugin list (so wrapper should has same functionality).

So both of this causes brings me to current more simple solution ;) Will be cool if you accept this PR as intermediate solution.",nodkz,josephsavona
1434,2016-11-03 13:54:12,"@wincent Would be great to see a tool that would actually generate the flowtypes based on fragments. Our project is currently doing this by hand and sure, it makes understanding the code a bit better but takes time when creating the types and when updating the schema. Hopefully generating the flowtypes would lessen the time needed on this!
",proProbe,wincent
1427,2017-01-06 14:52:18,"Any update on merging this? 🎉 

Thanks for the PR @dminkovsky!",schickling,dminkovsky
1427,2017-01-12 00:37:01,"Maybe Johannes can update my PR? I don't have time right now unfortunately.
Thank you.

On Wed, Jan 11, 2017 at 4:17 PM, Joseph Savona <notifications@github.com>
wrote:

> *@josephsavona* commented on this pull request.
> ------------------------------
>
> In README.md <https://github.com/facebook/relay/pull/1427>:
>
> > @@ -6,7 +6,7 @@ Relay is a JavaScript framework for building data-driven React applications.
>  * **Colocation:** Queries live next to the views that rely on them, so you can easily reason about your app. Relay aggregates queries into efficient network requests to fetch only what you need.
>  * **Mutations:** Relay lets you mutate data on the client and server using GraphQL mutations, and offers automatic data consistency, optimistic updates, and error handling.
>
> -[Learn how to use Relay in your own project.](https://facebook.github.io/relay/docs/getting-started.html)
> +[Learn how to use Relay in your own project](https://facebook.github.io/relay/docs/getting-started.html) or read a [comprehensive introduction](https://learnrelay.org).
>
> Would be easiest if @dminkovsky <https://github.com/dminkovsky> can
> update the PR directly.
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/facebook/relay/pull/1427>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AANWZdnxZ6f4mn6t9scQnF0TZMDl2zggks5rRUbwgaJpZM4KfN1S>
> .
>
",dminkovsky,dminkovsky
1426,2016-12-14 06:53:35,"Thanks for this, @dminkovsky. Will merge.",wincent,dminkovsky
1426,2016-12-14 06:53:47,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4325951).",facebook-github-bot,wincent
1425,2016-12-14 06:45:01,"Thanks, @DanielRHayes! Will merge.",wincent,DanielRHayes
1422,2016-10-21 18:57:45,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4059829).
",facebook-github-bot,wincent
1421,2017-01-30 19:24:05,"Well spotted! Thanks for bringing this up @dmnd.

Some dev dependencies (like `react`, `react-dom`) end up depending on a non-alpha version of `fbjs`. I know they're just dev dependencies, but I'm inclined to wait until the next major updates there as well and do it all in one fell swoop. What do you think?",wincent,dmnd
1421,2017-01-31 19:10:58,Yep @YasserKaddour. I'd like to see more granular modular imports moving forward too. Let's make it happen.,wincent,YasserKaddour
1421,2017-01-31 20:06:28,:tada: @wincent good to hear. Can I know what `babel-polyfill` is used for exactly ? Thanks ,YasserKaddour,wincent
1421,2017-02-01 01:39:30,"@YasserKaddour, I believe it provides the regenerator runtime (which we're not currently using, but could use in the future for `async` support) and the so-called `core-js` package, which has a broad set of ES5/ES6 polyfills. At some point it would be desirable to make it possible to bring-your-own-polyfill, so that if users knew they only had to support modern environments they could just drop the polyfill altogether.",wincent,YasserKaddour
1411,2016-10-17 04:39:11,"@josephsavona Great! Thank you so much.
",Naoto-Ida,josephsavona
1410,2016-10-07 06:32:37,"@josephsavona  i have tried that but then the mutation query generated doesn't include data at all and still the onSuccess doesn't fire so the only data returned from the server is clientMutationId the mutation does happen but nothing happens on the client side
",amgadserry,josephsavona
1409,2016-10-06 19:44:10,"Thanks for the answer @akre54! That looks like the problem, so I'll close this out. 
",josephsavona,akre54
1409,2016-10-06 22:21:24,"@akre54  that was it thank you 
",amgadserry,akre54
1406,2016-12-22 17:01:57,"@josephsavona has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.facebook.com/D4362329).",facebook-github-bot,josephsavona
1404,2017-01-31 00:26:16,"Thanks for bringing this up @taion.

My reading of this is that the behavior is as intended, so we shouldn't change that, but the naming has caused confusion, which suggests that there might be a better name for this.

The intent here is that we should consider the props equal if they are identical (`===`) and have the same contents. Because values which are ""containers"" (things like objects, and arrays, for which `typeof` is going to be `'object'`) can retain their identity (`===`) but actually have their contents changed, we want to exclude those from the check. Functions, on the other hand, are seldom treated as ""containers"" (even though, sure, you can mutate them by changing their properties), so we want to allow the common case (people passing callback functions as props) to not trigger any unnecessary operations, provided the same functions (`===`) continue to be passed in.

So, I'm going to close this in the interests of keeping the issue tracker clean, but if you can come up with a better name for `isScalarAndEqual` that doesn't lead to confusion, please do submit a PR and we'd be happy to look at it. Naming is hard, so in thinking about this for a few seconds, all that comes to my mind is `isNonObjectAndEqual` or `isEqualAndNonObject`. Even those have some conceptual muddiness, because there is a number of JS types that return `'object'` for `typeof`, but it may still be an improvement. I guess if all else fails and we can't solve this with a better name, we could add a comment above the function as a last resort.

Thanks once again for your contribution!",wincent,taion
1403,2016-11-07 12:57:24,"@sibelius I did not try it this way.. But the idea looks promising. I've solved my problem with graphql subscriptions that prepend a bunch of new edges after the network reconnect.
",GrigoryPtashko,sibelius
1401,2016-11-03 21:08:56,"@josephsavona has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4126973).
",facebook-github-bot,josephsavona
1401,2016-11-04 20:38:19,"@tomconroy thanks for this!
",josephsavona,tomconroy
1399,2016-09-30 07:59:23,"@josephsavona I am sorry, but I am using [graphql-relay-js](https://github.com/graphql/graphql-relay-js), but it only provides `nodeField` not `nodesField`, am I missing something?
",joonhocho,josephsavona
1392,2016-12-06 02:20:44,"@sibelius  I have a similar problem, but it also happens on `onSuccess`.
Could you possibly post part of the RelayContainer as an example?",Naoto-Ida,sibelius
1381,2016-09-13 06:26:04,"Thanks @pyros2097.
",wincent,pyros2097
1378,2016-09-09 15:36:27,"@josephsavona Thank you for the quick response. If it is possible with Relay2 than I am happy to wait and just work around it for now :).
",Globegitter,josephsavona
1377,2016-09-15 05:38:23,"@josephsavona  thanks for your reply. Right now I'm not ready to get such deep dive. Maybe in October or even November. Absolutely have not free time, should launch our commercial app in next month and needs time for my OSS graphql-compose.

Dear community, maybe somebody interested in implementing this HOC for RelayConnection? 
",nodkz,josephsavona
1377,2016-09-19 06:37:50,"@nodkz It's funny, I was just blogging about this :) , we have used a roughly similar abstraction for months now in my company: http://greweb.me/2016/09/relay-scrolling-connections/ .
In this implementation I have not used HOC but just a simple component that renders children, and I figured out the only prop it needs is `relay` (it assumes you have a variable called `first` but there is another prop to customise it).
What I liked in using component instead of HOC is it remains separated of the component, you might not always want to make your ""list of thing"" component strongly coupled with the scroll mechanism (but maybe you want?). The component solution also have the advantage you can use it in various ""inline"" use case, for instance using material-ui List here: `<InfiniteScrollable><List>{data.map(...)}</List></InfiniteScrollable>`. Not sure how HOC would work here (List is not a Relay container).

Anyway, for the various use-cases we can have, I'm not so sure if this problem can easily abstracted out: for sure we can provide a solution for 90% users, but there also might be specific parts. (like implementing `<Loader/>`, if you really want to have a generic lib, this implementation needs to be externalised e.g. via prop).

What I think is important, (but I guess we all agree on this), is for Relay to continue focusing on solving the generic part which is not providing an implementation for this ""how to handle pulling data when I scroll"" problem.
",gre,nodkz
1369,2016-09-22 03:26:27,"@iamchenxin You shouldn't need to restructure your data model; the whole point of GraphQL is to _abstract away_ implementation details of data storage and express it in a natural, expressive, product-centric way. 
",wincent,iamchenxin
1369,2016-09-22 07:54:48,"@wincent Im referring to Client side.(Data fetched by Relay.QL, forgive my poor english). I saw the video, but not sure if it will need some restruction for the old React Data Flow to take advantage of Relay 2. (ex: the new RelayConnection seems need to separate some data logic between parent and its children )
Hope the beta version will come soon.
Thanks for your hard working.
",iamchenxin,wincent
1369,2016-09-28 20:37:30,"Looking forward to it @josephsavona @wincent et al. Let me know if there's something we can help with.
",NevilleS,wincent
1369,2016-09-28 20:37:30,"Looking forward to it @josephsavona @wincent et al. Let me know if there's something we can help with.
",NevilleS,josephsavona
1369,2016-10-29 11:54:20,"@wincent: Thanks for your quick response! Looking forward to the update. I am sure lots of people are excited and eager to use the next version of Relay!
",nikhilag,wincent
1369,2016-11-02 15:54:51,"@sgwilym: status update is drafted. Gathering feedback on it before publishing. I feel pretty confident that we'll be able to share the update some time between `Date.now()` and `Date.now() + Infinity`. Thanks for your patience in the meantime.
",wincent,sgwilym
1369,2016-11-07 14:02:44,"@wincent Sorry to bother you again but just wanted to check if you have a rough timeline on when relay 2 might be ready. It's just that Relay 2 solves a bunch of problems including client side state management and so I really hope to start using it soon instead of a mix of Redux and Relay.  
",nikhilag,wincent
1369,2016-11-25 10:38:06,@wincent Is there any update on Relay 2?,nikhilag,wincent
1369,2016-11-27 05:36:36,"@josephsavona or @wincent, I was wondering what happened to the meetings notes. They used to be published every week or so, now it's been 2 months. Does the relay team still meet and develop? Is Relay still alive and well? Is Relay 2 still a thing? I understand the difficultly with timelines, but just a simple pulse to help us know that this is still an active project would be great. Is facebook moving on to something else? Thanks for all the hard work and pioneering!",sonnetflowers,wincent
1369,2016-11-27 05:36:36,"@josephsavona or @wincent, I was wondering what happened to the meetings notes. They used to be published every week or so, now it's been 2 months. Does the relay team still meet and develop? Is Relay still alive and well? Is Relay 2 still a thing? I understand the difficultly with timelines, but just a simple pulse to help us know that this is still an active project would be great. Is facebook moving on to something else? Thanks for all the hard work and pioneering!",sonnetflowers,josephsavona
1369,2016-11-28 04:16:34,"@josephsavona Its so happy to hear from you. I firmly believe Relay2 is the right way, and worth to wait. I temporarily block some part of my project for waiting Relay2.",iamchenxin,josephsavona
1369,2016-12-12 06:41:36,"@josephsavona based on [2016-12-09-update.md](https://github.com/facebook/relay/blob/master/meta/meeting-notes/2016-12-09-update.md),  seems the only things will be changed are some kind of APIs? Will the [graphql relay specification](https://facebook.github.io/relay/docs/graphql-relay-specification.html#content) be the same between `v1` and `v2`? ",iamchenxin,josephsavona
1369,2016-12-13 05:31:04,@iamchenxin : The GraphQL specification doesn't change. We'll have this new API that enables the faster and simpler core if used throughout an app.,kassens,iamchenxin
1369,2016-12-20 17:10:11,"@josephsavona Thank you.

I hope to get my hands on persisted queries in near future (it's not in ""Relay 2"" as far as I know), static queries should be the key part to add this feature to Relay core. 
This would fix the biggest and most complicated problem with GraphQL (for me at least): it's hard to distinguish normal (but deep and complex) queries from just malicious queries from _e.g_ attackers.

Every solution today (depth limit, adding cost to operations, query whitelist _etc_) is kind of tricky to pull off. ",unirey,josephsavona
1369,2017-01-20 08:50:09,"@josephsavona Looking on the high-level tasks on top and wondering if support for local schema is included there and in which step - ""Introduce static query APIs"" or ""Introduce the new core."" ? Thanks for hint. Basically wondering if its behind the corner.. or still far away.. Thanks!",jardakotesovec,josephsavona
1369,2017-01-20 20:04:54,@josephsavona  That's awesome. We're excited for the new core. Thanks for all your hard work!,tslater,josephsavona
1369,2017-01-20 22:46:04,"@josephsavona Can you confirm if the new core is likely to support ""offline"" or if this will be easy to build with a community addition? Is there a plan for the new core's client side schema to provide any form of compatibility with redux-devtools, or would that not make sense? Oh and finally I have to ask, but do you have any more ideas on when it may be released :)

Massive thanks for relay! Its had a massive impact on our team productivity and how we're building the next iteration of Mixcloud!",matclayton,josephsavona
1369,2017-02-04 17:56:05,"@wincent So hypothetically, if someone adopted Relay 1 now and then wanted to migrate to Relay 2 at a later date, I think it would be really useful to know really roughly how much work might be involved based on the migrations that you've been involved with to date at FB ('and we've personally migrated large product surfaces areas to the new API to get a feel for the amount of work required to convert.') Ofc, looking for an estimate here rather than an exact figure.",robrobkay51,wincent
1369,2017-02-06 16:49:44,"@robrobkay51 We're adopting Relay 1 with the new GraphQLMutation interface.  The learning curve is more severe than anything I've ever worked with.  I think a big part of this is b/c Facebook hasn't been incentivized at all to continue investing in documentation and examples for the last year or so, with Relay 2 coming up.

From our experience I'd still advise Relay 1 if you're building a big, long-term project; FB has promised a smooth migration path to Relay 2.  However if you only plan to spend 1-2 months coding your project or it won't be in use in 3 years, I wouldn't recommend it as you'll spend a lot of time tweaking to try and get things working.

@wincent I agree that it would be nice to have an idea of how much work we may want to plan for to migrate to Relay 2.",lukecwilliams,wincent
1369,2017-02-06 18:46:31,"@wincent That's helpful - at least in this example, there's a relatively straightforward mapping between the old and new way.",lukecwilliams,wincent
1369,2017-02-15 18:56:35,"@josephsavona Yes, soon. Thanks.

Edit:
https://github.com/facebook/relay/issues/1546",mattferrin,josephsavona
1369,2017-03-14 04:34:49,"@josephsavona  any news on this.., i am going to start a new project on monday can we expect new core beta  meantime ? ",chandu0101,josephsavona
1369,2017-03-14 19:12:05,@chandu0101 see @wincent's [comment on this thread](https://github.com/facebook/relay/issues/1369#issuecomment-277407081).,josephsavona,wincent
1369,2017-03-14 19:12:05,@chandu0101 see @wincent's [comment on this thread](https://github.com/facebook/relay/issues/1369#issuecomment-277407081).,josephsavona,chandu0101
1369,2017-03-14 21:02:36,@josephsavona  thank you :) ,chandu0101,josephsavona
1362,2016-08-30 15:50:23,"Thanks @josercruz01. I have a couple of minor formatting nits but I'll just import this and patch them.
",wincent,josercruz01
1362,2016-08-30 17:31:42,"Hey @wincent I pushed one commit to resolve some of the comments made by Joseph and while doing so I noticed a couple of linter warnings on the new test code. Are those the formatting bits you are taking care of in your patch or should I go ahead and push a commit for those?
",josercruz01,wincent
1353,2016-09-06 18:47:30,"Thanks for the context @josephsavona! I'll put together a PR to facilitate benchmarking.
",samn,josephsavona
1353,2016-09-21 20:13:57,"@josephsavona I'm interested in this also: I want to be able to cache validated queries on the server side, which we can do easily if all of the variables are properly extracted.

I am able to get the non-inlined behavior by changing the https://github.com/facebook/relay/blob/master/scripts/babel-relay-plugin/src/RelayQLPrinter.js#L687-L701 method that @samn pointed out.

Are there benchmarks in the open source repo that I could run during development? Or is the best workflow just to open a PR and wait for a response from the team?
",jsdnxx,josephsavona
1345,2016-11-28 10:39:23,"@nodkz Did you ever get anywhere with this? I'm running into the same issues as well myself and would love to be able to hot patch the schema stored in BabelRelayPlugin without restarting webpack, as that's the only thing holding me back from getting at least some basic semblance of automatic schema generation working.",PawkaHub,nodkz
1345,2016-11-29 06:28:11,That worked great @josephsavona! Thanks for the suggestion. I'm gonna do a bit more testing with it just to make sure there's no hidden kinks in usage and then I'll look into releasing it as an NPM module for people to make use of.,PawkaHub,josephsavona
1341,2016-08-17 08:44:11,"@jardakotesovec 

It works on the [playground](https://facebook.github.io/relay/prototyping/playground.html#schema=%2F**%0A%20*%20Copyright%20%28c%29%202013-present%2C%20Facebook%2C%20Inc.%0A%20*%20All%20rights%20reserved.%0A%20*%0A%20*%20This%20source%20code%20is%20licensed%20under%20the%20BSD-style%20license%20found%20in%20the%0A%20*%20LICENSE%20file%20in%20the%20root%20directory%20of%20this%20source%20tree.%20An%20additional%20grant%0A%20*%20of%20patent%20rights%20can%20be%20found%20in%20the%20PATENTS%20file%20in%20the%20same%20directory.%0A%20*%2F%0Avar%20graphql%20%3D%20require%28'graphql'%29%3B%0Avar%20relayql%20%3D%20require%28'graphql-relay'%29%3B%0A%0Aconst%20data%20%3D%20%7B%0A%20%20users%3A%20%7B%0A%20%20%20%201%3A%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%22id%22%3A%20%221%22%2C%0A%20%20%20%20%20%20%22name%22%3A%20%22James%22%2C%0A%20%20%20%20%20%20%22applications%22%3A%20%5B%0A%20%20%20%20%20%20%20%201%0A%20%20%20%20%20%20%5D%0A%20%20%20%20%7D%0A%20%20%7D%2C%0A%20%20%22applications%22%3A%20%7B%0A%20%20%20%201%3A%20%7B%0A%20%20%20%20%20%20%22id%22%3A%20%221%22%2C%0A%20%20%20%20%20%20%22name%22%3A%20%22EchoBot%22%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%3B%0A%0Afunction%20getApplication%28id%29%20%7B%0A%20%20return%20data.applications%5Bid%5D%3B%0A%7D%0A%0A%2F%2F%20Define%20the%20Application%20type%20with%20two%20string%20fields%3A%20%60id%60%20and%20%60name%60.%0A%2F%2F%20The%20type%20of%20User%20is%20GraphQLObjectType%2C%20which%20has%20child%20fields%0A%2F%2F%20with%20their%20own%20types%20%28in%20this%20case%2C%20GraphQLString%29.%0Avar%20Application%20%3D%20new%20graphql.GraphQLObjectType%28%7B%0A%20%20name%3A%20'Application'%2C%0A%20%20fields%3A%20%7B%0A%20%20%20%20id%3A%20relayql.globalIdField%28'Application'%29%2C%0A%20%20%20%20name%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%2C%0A%20%20%7D%0A%7D%29%3B%0A%0A%2F%2F%20Define%20the%20User%20type%20with%20two%20string%20fields%3A%20%60id%60%20and%20%60name%60.%0A%2F%2F%20The%20type%20of%20User%20is%20GraphQLObjectType%2C%20which%20has%20child%20fields%0A%2F%2F%20with%20their%20own%20types%20%28in%20this%20case%2C%20GraphQLString%29.%0Avar%20User%20%3D%20new%20graphql.GraphQLObjectType%28%7B%0A%20%20name%3A%20'User'%2C%0A%20%20fields%3A%20%7B%0A%20%20%20%20id%3A%20relayql.globalIdField%28'User'%29%2C%0A%20%20%20%20name%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%2C%0A%20%20%20%20applications%3A%20%7B%20type%3A%20new%20graphql.GraphQLList%28Application%29%2C%20resolve%3A%20function%28user%29%20%7B%0A%20%20%20%20%20%20return%20user.applications.map%28function%28id%29%20%7B%0A%20%20%20%20%20%20%20%20return%20getApplication%28id%29%0A%20%20%20%20%20%20%7D%29%0A%20%20%20%20%7D%7D%0A%20%20%7D%0A%7D%29%3B%0A%0A%2F%2F%20Define%20the%20schema%20with%20one%20top-level%20field%2C%20%60user%60%2C%20that%0A%2F%2F%20takes%20an%20%60id%60%20argument%20and%20returns%20the%20User%20with%20that%20ID.%0A%2F%2F%20Note%20that%20the%20%60query%60%20is%20a%20GraphQLObjectType%2C%20just%20like%20User.%0A%2F%2F%20The%20%60user%60%20field%2C%20however%2C%20is%20a%20userType%2C%20which%20we%20defined%20above.%0Aconst%20Schema%20%3D%20new%20graphql.GraphQLSchema%28%7B%0A%20%20query%3A%20new%20graphql.GraphQLObjectType%28%7B%0A%20%20%20%20name%3A%20'Query'%2C%0A%20%20%20%20fields%3A%20%7B%0A%20%20%20%20%20%20user%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20User%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20%60args%60%20describes%20the%20arguments%20that%20the%20%60user%60%20query%20accepts%0A%20%20%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20The%20resolve%20function%20describes%20how%20to%20%22resolve%22%20or%20fulfill%0A%20%20%20%20%20%20%20%20%2F%2F%20the%20incoming%20query.%0A%20%20%20%20%20%20%20%20%2F%2F%20In%20this%20case%20we%20use%20the%20%60id%60%20argument%20from%20above%20as%20a%20key%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20get%20the%20User%20from%20%60data%60%0A%20%20%20%20%20%20%20%20resolve%3A%20function%20%28_%2C%20args%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20data.users%5Bargs.id%5D%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20application%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20Application%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20%60args%60%20describes%20the%20arguments%20that%20the%20%60application%60%20query%20accepts%0A%20%20%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20The%20resolve%20function%20describes%20how%20to%20%22resolve%22%20or%20fulfill%0A%20%20%20%20%20%20%20%20%2F%2F%20the%20incoming%20query.%0A%20%20%20%20%20%20%20%20%2F%2F%20In%20this%20case%20we%20use%20the%20%60id%60%20argument%20from%20above%20as%20a%20key%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20get%20the%20Application%20from%20%60data%60%0A%20%20%20%20%20%20%20%20resolve%3A%20function%20%28_%2C%20args%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20getApplication%28args.id%29%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%29%0A%7D%29%3B%0A%0Amodule.exports%20%3D%20Schema%0A%0A&source=%2F**%0A%20*%20Copyright%20%28c%29%202013-present%2C%20Facebook%2C%20Inc.%0A%20*%20All%20rights%20reserved.%0A%20*%0A%20*%20This%20source%20code%20is%20licensed%20under%20the%20BSD-style%20license%20found%20in%20the%0A%20*%20LICENSE%20file%20in%20the%20root%20directory%20of%20this%20source%20tree.%20An%20additional%20grant%0A%20*%20of%20patent%20rights%20can%20be%20found%20in%20the%20PATENTS%20file%20in%20the%20same%20directory.%0A%20*%2F%0A%0Aclass%20Application%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20application%20%3D%20this.props.application%0A%20%20%20%20return%20%3Cli%3E%7Bapplication.name%7D%3C%2Fli%3E%0A%20%20%7D%0A%7D%0A%0AApplication%20%3D%20Relay.createContainer%28Application%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20application%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Application%20%7B%0A%20%20%20%20%20%20%20%20id%2C%0A%20%20%20%20%20%20%20%20name%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%0Aclass%20ApplicationList%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20user%20%3D%20this.props.user%0A%20%20%20%20var%20applications%20%3D%20user.applications%0A%20%20%20%20return%20%3Cul%3E%0A%20%20%20%20%7Bapplications.map%28application%20%3D%3E%20%28%0A%20%20%20%20%20%20%3CApplication%20key%3D%7Bapplication.id%7D%20application%3D%7Bapplication%7D%20%2F%3E%0A%20%20%20%20%29%29%7D%0A%20%20%20%20%3C%2Ful%3E%0A%20%20%7D%0A%7D%0A%0AApplicationList%20%3D%20Relay.createContainer%28ApplicationList%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20user%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20User%20%7B%0A%20%20%20%20%20%20%20%20applications%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%2C%0A%20%20%20%20%20%20%20%20%20%20%24%7BApplication.getFragment%28'application'%29%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%0Aclass%20Applications%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20user%20%3D%20this.props.user%0A%20%20%20%20return%20%28%0A%20%20%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Ch1%3EApplications%3C%2Fh1%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Ca%20onClick%3D%7Bthis.handleClick.bind%28this%29%7D%3ENew%20%2B%3C%2Fa%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3CApplicationList%20user%3D%7Buser%7D%2F%3E%0A%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%29%3B%0A%20%20%7D%0A%0A%20%20handleClick%28%29%20%7B%0A%0A%20%20%7D%0A%7D%0A%0AApplications%20%3D%20Relay.createContainer%28Applications%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20user%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20User%20%7B%0A%20%20%20%20%20%20%20%20%24%7BApplicationList.getFragment%28'user'%29%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%0Aclass%20App%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20user%20%3D%20this.props.user%0A%20%20%20%20return%20%3CApplications%20user%3D%7Buser%7D%2F%3E%0A%20%20%7D%0A%7D%0A%0AApp%20%3D%20Relay.createContainer%28App%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20user%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20User%20%7B%0A%20%20%20%20%20%20%20%20%24%7BApplications.getFragment%28'user'%29%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%20%20%0Aclass%20AppRoute%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20'AppRoute'%3B%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20user%3A%20%28Component%29%20%3D%3E%20%7B%0A%20%20%20%20%20%20return%20Relay.QL%60query%20%7B%20user%28id%3A%20%221%22%29%20%7B%0A%20%20%20%20%20%20%20%20%24%7BComponent.getFragment%28'user'%29%7D%0A%20%20%20%20%20%20%7D%7D%60%0A%20%20%20%20%7D%2C%0A%20%20%7D%3B%0A%7D%0A%0A%0A%0AReactDOM.render%28%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20%20%20%20%20%20%20%20Component%3D%7BApp%7D%0A%20%20%20%20%20%20%20%20%20%20%20route%3D%7Bnew%20AppRoute%28%29%7D%20%2F%3E%2C%0A%20%20mountBode%0A%29%3B%0A%0A)

However if I don't use global IDs it throws an [error](https://facebook.github.io/relay/prototyping/playground.html#schema=%2F**%0A%20*%20Copyright%20%28c%29%202013-present%2C%20Facebook%2C%20Inc.%0A%20*%20All%20rights%20reserved.%0A%20*%0A%20*%20This%20source%20code%20is%20licensed%20under%20the%20BSD-style%20license%20found%20in%20the%0A%20*%20LICENSE%20file%20in%20the%20root%20directory%20of%20this%20source%20tree.%20An%20additional%20grant%0A%20*%20of%20patent%20rights%20can%20be%20found%20in%20the%20PATENTS%20file%20in%20the%20same%20directory.%0A%20*%2F%0Avar%20graphql%20%3D%20require%28'graphql'%29%3B%0Avar%20relayql%20%3D%20require%28'graphql-relay'%29%3B%0A%0Aconst%20data%20%3D%20%7B%0A%20%20users%3A%20%7B%0A%20%20%20%201%3A%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%22id%22%3A%20%221%22%2C%0A%20%20%20%20%20%20%22name%22%3A%20%22James%22%2C%0A%20%20%20%20%20%20%22applications%22%3A%20%5B%0A%20%20%20%20%20%20%20%201%0A%20%20%20%20%20%20%5D%0A%20%20%20%20%7D%0A%20%20%7D%2C%0A%20%20%22applications%22%3A%20%7B%0A%20%20%20%201%3A%20%7B%0A%20%20%20%20%20%20%22id%22%3A%20%221%22%2C%0A%20%20%20%20%20%20%22name%22%3A%20%22EchoBot%22%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%3B%0A%0Afunction%20getApplication%28id%29%20%7B%0A%20%20return%20data.applications%5Bid%5D%3B%0A%7D%0A%0A%2F%2F%20Define%20the%20Application%20type%20with%20two%20string%20fields%3A%20%60id%60%20and%20%60name%60.%0A%2F%2F%20The%20type%20of%20User%20is%20GraphQLObjectType%2C%20which%20has%20child%20fields%0A%2F%2F%20with%20their%20own%20types%20%28in%20this%20case%2C%20GraphQLString%29.%0Avar%20Application%20%3D%20new%20graphql.GraphQLObjectType%28%7B%0A%20%20name%3A%20'Application'%2C%0A%20%20fields%3A%20%7B%0A%20%20%20%20id%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%2C%0A%20%20%20%20name%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%2C%0A%20%20%7D%0A%7D%29%3B%0A%0A%2F%2F%20Define%20the%20User%20type%20with%20two%20string%20fields%3A%20%60id%60%20and%20%60name%60.%0A%2F%2F%20The%20type%20of%20User%20is%20GraphQLObjectType%2C%20which%20has%20child%20fields%0A%2F%2F%20with%20their%20own%20types%20%28in%20this%20case%2C%20GraphQLString%29.%0Avar%20User%20%3D%20new%20graphql.GraphQLObjectType%28%7B%0A%20%20name%3A%20'User'%2C%0A%20%20fields%3A%20%7B%0A%20%20%20%20id%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%2C%0A%20%20%20%20name%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%2C%0A%20%20%20%20applications%3A%20%7B%20type%3A%20new%20graphql.GraphQLList%28Application%29%2C%20resolve%3A%20function%28user%29%20%7B%0A%20%20%20%20%20%20return%20user.applications.map%28function%28id%29%20%7B%0A%20%20%20%20%20%20%20%20return%20getApplication%28id%29%0A%20%20%20%20%20%20%7D%29%0A%20%20%20%20%7D%7D%0A%20%20%7D%0A%7D%29%3B%0A%0A%2F%2F%20Define%20the%20schema%20with%20one%20top-level%20field%2C%20%60user%60%2C%20that%0A%2F%2F%20takes%20an%20%60id%60%20argument%20and%20returns%20the%20User%20with%20that%20ID.%0A%2F%2F%20Note%20that%20the%20%60query%60%20is%20a%20GraphQLObjectType%2C%20just%20like%20User.%0A%2F%2F%20The%20%60user%60%20field%2C%20however%2C%20is%20a%20userType%2C%20which%20we%20defined%20above.%0Aconst%20Schema%20%3D%20new%20graphql.GraphQLSchema%28%7B%0A%20%20query%3A%20new%20graphql.GraphQLObjectType%28%7B%0A%20%20%20%20name%3A%20'Query'%2C%0A%20%20%20%20fields%3A%20%7B%0A%20%20%20%20%20%20user%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20User%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20%60args%60%20describes%20the%20arguments%20that%20the%20%60user%60%20query%20accepts%0A%20%20%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20The%20resolve%20function%20describes%20how%20to%20%22resolve%22%20or%20fulfill%0A%20%20%20%20%20%20%20%20%2F%2F%20the%20incoming%20query.%0A%20%20%20%20%20%20%20%20%2F%2F%20In%20this%20case%20we%20use%20the%20%60id%60%20argument%20from%20above%20as%20a%20key%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20get%20the%20User%20from%20%60data%60%0A%20%20%20%20%20%20%20%20resolve%3A%20function%20%28_%2C%20args%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20data.users%5Bargs.id%5D%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20application%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20Application%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20%60args%60%20describes%20the%20arguments%20that%20the%20%60application%60%20query%20accepts%0A%20%20%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%3A%20%7B%20type%3A%20graphql.GraphQLString%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20The%20resolve%20function%20describes%20how%20to%20%22resolve%22%20or%20fulfill%0A%20%20%20%20%20%20%20%20%2F%2F%20the%20incoming%20query.%0A%20%20%20%20%20%20%20%20%2F%2F%20In%20this%20case%20we%20use%20the%20%60id%60%20argument%20from%20above%20as%20a%20key%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20get%20the%20Application%20from%20%60data%60%0A%20%20%20%20%20%20%20%20resolve%3A%20function%20%28_%2C%20args%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20getApplication%28args.id%29%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%29%0A%7D%29%3B%0A%0Amodule.exports%20%3D%20Schema%0A%0A&source=%2F**%0A%20*%20Copyright%20%28c%29%202013-present%2C%20Facebook%2C%20Inc.%0A%20*%20All%20rights%20reserved.%0A%20*%0A%20*%20This%20source%20code%20is%20licensed%20under%20the%20BSD-style%20license%20found%20in%20the%0A%20*%20LICENSE%20file%20in%20the%20root%20directory%20of%20this%20source%20tree.%20An%20additional%20grant%0A%20*%20of%20patent%20rights%20can%20be%20found%20in%20the%20PATENTS%20file%20in%20the%20same%20directory.%0A%20*%2F%0A%0Aclass%20Application%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20application%20%3D%20this.props.application%0A%20%20%20%20return%20%3Cli%3E%7Bapplication.name%7D%3C%2Fli%3E%0A%20%20%7D%0A%7D%0A%0AApplication%20%3D%20Relay.createContainer%28Application%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20application%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Application%20%7B%0A%20%20%20%20%20%20%20%20id%2C%0A%20%20%20%20%20%20%20%20name%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%0Aclass%20ApplicationList%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20user%20%3D%20this.props.user%0A%20%20%20%20var%20applications%20%3D%20user.applications%0A%20%20%20%20return%20%3Cul%3E%0A%20%20%20%20%7Bapplications.map%28application%20%3D%3E%20%28%0A%20%20%20%20%20%20%3CApplication%20key%3D%7Bapplication.id%7D%20application%3D%7Bapplication%7D%20%2F%3E%0A%20%20%20%20%29%29%7D%0A%20%20%20%20%3C%2Ful%3E%0A%20%20%7D%0A%7D%0A%0AApplicationList%20%3D%20Relay.createContainer%28ApplicationList%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20user%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20User%20%7B%0A%20%20%20%20%20%20%20%20applications%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%2C%0A%20%20%20%20%20%20%20%20%20%20%24%7BApplication.getFragment%28'application'%29%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%0Aclass%20Applications%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20user%20%3D%20this.props.user%0A%20%20%20%20return%20%28%0A%20%20%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Ch1%3EApplications%3C%2Fh1%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Ca%20onClick%3D%7Bthis.handleClick.bind%28this%29%7D%3ENew%20%2B%3C%2Fa%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3CApplicationList%20user%3D%7Buser%7D%2F%3E%0A%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%29%3B%0A%20%20%7D%0A%0A%20%20handleClick%28%29%20%7B%0A%0A%20%20%7D%0A%7D%0A%0AApplications%20%3D%20Relay.createContainer%28Applications%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20user%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20User%20%7B%0A%20%20%20%20%20%20%20%20%24%7BApplicationList.getFragment%28'user'%29%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%0Aclass%20App%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20user%20%3D%20this.props.user%0A%20%20%20%20return%20%3CApplications%20user%3D%7Buser%7D%2F%3E%0A%20%20%7D%0A%7D%0A%0AApp%20%3D%20Relay.createContainer%28App%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20user%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20User%20%7B%0A%20%20%20%20%20%20%20%20%24%7BApplications.getFragment%28'user'%29%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%20%20%0Aclass%20AppRoute%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20'AppRoute'%3B%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20user%3A%20%28Component%29%20%3D%3E%20%7B%0A%20%20%20%20%20%20return%20Relay.QL%60query%20%7B%20user%28id%3A%20%221%22%29%20%7B%0A%20%20%20%20%20%20%20%20%24%7BComponent.getFragment%28'user'%29%7D%0A%20%20%20%20%20%20%7D%7D%60%0A%20%20%20%20%7D%2C%0A%20%20%7D%3B%0A%7D%0A%0A%0A%0AReactDOM.render%28%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20%20%20%20%20%20%20%20Component%3D%7BApp%7D%0A%20%20%20%20%20%20%20%20%20%20%20route%3D%7Bnew%20AppRoute%28%29%7D%20%2F%3E%2C%0A%20%20mountBode%0A%29%3B%0A%0A)

I guess I need to adopt the Global IDs for Relay to work? I've discovered your blog about converting a REST API to GraphQL which was super helpful (please make this the introduction tutorial, it was the moment where GraphQL and Relay clicked for me)
",jcampbell05,jardakotesovec
1341,2016-08-17 09:00:43,"@jardakotesovec Cool, the error on the playground was super helpful !
",jcampbell05,jardakotesovec
1338,2016-08-30 17:49:53,"Thanks @xuorig. Sorry for the delay in getting to this. Aiming to cut a release this week so just going through and looking at PRs to merge now. Will queue this one up.
",wincent,xuorig
1336,2016-08-13 23:23:03,"@papigers thanks for getting this started, and thanks @denvned for finishing! yay team ;-)
",josephsavona,denvned
1334,2016-12-13 14:54:50,"Hey @miracle2k and @psalz, did you manage to fix it somehow?

Same thing happening here with Relay 0.9.3, I still don't know how to reproduce it and also happens only sometimes.",lucasbento,psalz
1328,2016-08-10 08:35:24,"Thank you @josephsavona! 
It's so good to finally get an answer, I've been trying to get it for a week or so in stackoverflow.com

I still have one big question about `node`: if I could query all different single items (`post`, `user` _etc_) _via_ `node`, why do I even need `post(args)`, `user(args)` in queries? All the examples I've seen online, have them. 
Only because I can't use other arguments besides `id` in `node` (as far as I know)? That would mean that if I needed to add arguments, I would still not be able to benefit from query optimization?
",unirey,josephsavona
1326,2016-08-14 15:51:35,"@jardakotesovec ya, I think falls into the ""manually rescoping"" which only sometimes is feasible, it also requires that parents query enough of the object to be able to do that. It's also not super helpful when you are trying to validate record creation,often just saving the id of an object is not enough.
",jquense,jardakotesovec
1326,2016-08-14 19:41:58,"@jquense Thanks for filing this issue, this is an interesting use case. We'll keep it in mind and would appreciate your feedback about the API.

In the short-term, I agree with @jardakotesovec's suggestion. The parent component should be responsible for fetching the fields it needs to access on an object, and it can pass a callback to the child to allow the child to interact with the parent object. Something like:



This way the child doesn't what fields the parent fetched and vice-versa.
",josephsavona,jardakotesovec
1321,2016-08-04 18:54:24,"Thanks for the context, it makes sense.

A very naive alternative for lazy module loading that would improve the perf for us is something like:



(via the `inline-requires`babel plugin)
But I guess Facebook optimized `require` implementation does lot of others stuff (optimize amount of loaded modules for mobile maybe?)

---

@josephsavona, the two build setup would work for us. 
But it might add complexity for new users as I assume will require some change on the bundler.

@cpojer, we are using node (5.12.0) default implementation. 
Is Facebook implementation opensource? I'd love to see how it works.
",rodrigopr,cpojer
1321,2016-08-04 18:54:24,"Thanks for the context, it makes sense.

A very naive alternative for lazy module loading that would improve the perf for us is something like:



(via the `inline-requires`babel plugin)
But I guess Facebook optimized `require` implementation does lot of others stuff (optimize amount of loaded modules for mobile maybe?)

---

@josephsavona, the two build setup would work for us. 
But it might add complexity for new users as I assume will require some change on the bundler.

@cpojer, we are using node (5.12.0) default implementation. 
Is Facebook implementation opensource? I'd love to see how it works.
",rodrigopr,josephsavona
1321,2016-08-04 19:24:38,"@rodrigopr: You can see our implementation for React Native [here](https://github.com/facebook/react-native/blob/master/packager/react-packager/src/Resolver/polyfills/require.js). As @zpao mentioned though, you probably won't be able to drop in and replace node's implementation (all modules must be `define`-ed before they can be `require`-ed, relative paths are not supported since [we rewrite relative paths to canonical ids](https://github.com/facebook/react-native/blob/master/packager/react-packager/src/Resolver/index.js#L194-L229)).

The naive alternative that you suggested is actually [what Nuclide does](https://github.com/facebook/nuclide/blob/master/pkg/nuclide-node-transpiler/lib/inline-imports-tr.js) for converting `import` statements to `require`s. I don't think it's too farfetched to make the inline-requires babel-plugin do something similar (as an optional feature that can be turned on by modifying babelOptions).
",voideanvalue,zpao
1321,2016-08-05 18:14:39,"Thanks @zpao, @voideanvalue. 

As @voideanvalue said, we can add an option to `inline-requires` behave like implemented on `Nuclide`, seems this might work well for both client and node. 
Do you all agree? If yes, I can send a PR to fbjs and update usage here.
",rodrigopr,voideanvalue
1321,2016-08-05 18:14:39,"Thanks @zpao, @voideanvalue. 

As @voideanvalue said, we can add an option to `inline-requires` behave like implemented on `Nuclide`, seems this might work well for both client and node. 
Do you all agree? If yes, I can send a PR to fbjs and update usage here.
",rodrigopr,zpao
1321,2016-08-05 19:12:10,"@voideanvalue How much value do we think inline requires actually provides for the final builds? I understand it's a divergence from our internal pattern so there's a possibility of subtle differences, but I think the likelihood is low (we saw issues going the other way but I don't expect the same problems this way).
",zpao,voideanvalue
1321,2016-08-07 16:30:28,"> Do you all agree? If yes, I can send a PR to fbjs and update usage here.

@rodrigopr: I'd be fine with that as long as we're not changing the default option. What do you think, @josephsavona @zpao @cpojer?

@zpao: Apart from a potentially slowed down initialization, circular dependencies might become unsafe without inline requires. We could probably write a test to guard against that though...
",voideanvalue,cpojer
1321,2016-08-07 16:30:28,"> Do you all agree? If yes, I can send a PR to fbjs and update usage here.

@rodrigopr: I'd be fine with that as long as we're not changing the default option. What do you think, @josephsavona @zpao @cpojer?

@zpao: Apart from a potentially slowed down initialization, circular dependencies might become unsafe without inline requires. We could probably write a test to guard against that though...
",voideanvalue,josephsavona
1321,2016-08-07 16:30:28,"> Do you all agree? If yes, I can send a PR to fbjs and update usage here.

@rodrigopr: I'd be fine with that as long as we're not changing the default option. What do you think, @josephsavona @zpao @cpojer?

@zpao: Apart from a potentially slowed down initialization, circular dependencies might become unsafe without inline requires. We could probably write a test to guard against that though...
",voideanvalue,zpao
1321,2016-09-05 19:43:51,"@josephsavona we're using a custom build of relay 0.9.2 with `inlineRequire` disabled, it solved the problem. Didn't have an opportunity to contribute with a definitive solution (PR) for it yet.
",rodrigopr,josephsavona
1317,2016-09-05 17:56:22,"@taion see #1369 (Relay 2 meta task) - one of the things that static queries enables is to prefetch the data for a route without having to download and execute the code for that route. Given that the framework will provide core support for prefetching, we'd be happy to support you and the community in integrating prefetching into popular bundling tools. 
",josephsavona,taion
1316,2016-08-02 14:43:03,"@taion my guess is the two are related since there is a common code path for `setVariables` and `forceFetch`. I don't understand the internals yet so i might be completely wrong.
",chirag04,taion
1300,2016-08-04 22:10:56,"@josephsavona Are you sure that `@relay(pattern: true)` works on any fields? It didn't work for me when I tried as it caused validation error. I think it only works for relay connection fields.
",joonhocho,josephsavona
1300,2016-08-23 00:41:04,"I'm assuming in your example the arguments are required and you're (like me) expecting that `fieldWithArguments @relay(pattern: true)` will make those arguments not required.  This [errors out in GraphQL](https://github.com/graphql/graphql-js/blob/3083fc5743ef228326588f0d1c6b1ebcdf0c4a52/src/validation/rules/ProvidedNonNullArguments.js#L23) before it even gets to Relay.  

In a relay ConnectionType all the arguments `before`, `after`, etc are optional.  Omitting them passes GraphQL validation, but is caught at Relay validation time which checks that [at least one exists](https://github.com/facebook/relay/blob/master/scripts/babel-relay-plugin/src/RelayQLPrinter.js#L798) or the pattern directive was provided.   The validation happens in Relay so its pretty easy for Relay to get around it.

So to make this work, I think you'd have to override the `ProvidedNonNullArguments` validation [here](https://github.com/facebook/relay/blob/master/scripts/babel-relay-plugin/src/RelayQLTransformer.js#L276).  Just a guess though.  Does any of that make sense @josephsavona?
",ddgromit,josephsavona
1300,2016-09-15 00:13:23,"@josephsavona created a PR, would love some feedback https://github.com/facebook/relay/pull/1376
",ddgromit,josephsavona
1299,2016-07-26 08:09:04,"I will not rubber stamp and land your change for you @spicyj!  I can import it for you and you can get your change reviewed by someone though :)
",ghost,spicyj
1297,2016-07-26 15:44:16,"Thanks @sampepose!
",pvolok,sampepose
1296,2016-07-22 17:29:28,"@josephsavona here's a gist with the current implementation: https://gist.github.com/Aweary/a84664713a6b465c72cd572dc39e698b

Just keep in mind that this a very rough draft. I've implemented a `CacheManager` and `CacheWriter` per the spec defined in `RelayTypes`. 

The fact that `readNode` is only ever invoked for the root node seems like the main problem, maybe I'm returning/storing incomplete data for the record.

Could it be that I'm not returning a `__path__` on my cached records? I wasn't able to figure out how to build a `QueryPath` from the serialized record data.
",aweary,josephsavona
1296,2016-07-22 18:29:24,"@josephsavona here are some potentially useful logs. I'm building Relay from my fork (up to date master) and using that here, so I injected some log into the codepath that seems to be important to restoring cached data. Maybe it will help you more than it's helping me 😄 

![screen shot 2016-07-22 at 1 27 01 pm](https://cloud.githubusercontent.com/assets/6886061/17067184/3668a208-5010-11e6-8e70-16cadfec86f7.png)

`readNode` is the `cacheManager.readNode` method, you'll see it only ever reads the root node.
",aweary,josephsavona
1296,2016-07-23 03:03:30,"@josephsavona in the simple app I'm testing with the `callValue` is always an empty string, so I didn't setup a map for them. `readRootCall` just asks that a `dataID` be passed to the callback and it does that successfully, so I don't think that's it. I'll try and get you a repo reproducing this issue, I know it's hard to diagnose with a cursory glance.
",aweary,josephsavona
1296,2016-07-25 14:29:45,"@josephsavona here's a repo forked from the relay-starter-kit that demonstrates the issue I'm having: https://github.com/Aweary/relay-cache-manager-issue

I'm pretty sure my `CacheManager` implementation implements the basic interface correctly, according to `RelayTypes` but I could be wrong.
",aweary,josephsavona
1296,2016-07-25 16:39:30,"> The remaining thing that stands out is that record values aren't being serialized with JSON.stringify

@josephsavona the individual records aren't serialized with `JSON.stringify`, but they do get serialized when the `cacheWriter` is serialized, unless I'm misunderstanding you. It does successfully de/serialize the records from what I can see.

The node that's being read from the `cacheManager` **seems** to have the correct shape:

<img width=""334"" alt=""screen shot 2016-07-25 at 11 34 03 am"" src=""https://cloud.githubusercontent.com/assets/6886061/17109070/097e3dea-525c-11e6-8f32-77f42a773ef2.png"">

I'll try to dig into `findRelayQueryLeaves` to see why it seems to return early as far as reading from the cache goes.
",aweary,josephsavona
1296,2016-08-01 14:29:13,"@josephsavona quick question, is the `cachedRecords` object passed to `findRelayQueryLeaves` expected to be fully populated when it's passed to `findRelayQueryLeaves`, and subsequently `RelayQueryLeavesFinder`? Or is that done based on the `rangeCalls` array passed in as well (or somewhere else)?

![screen shot 2016-08-01 at 9 24 40 am](https://cloud.githubusercontent.com/assets/6886061/17297103/d8bd48ae-57c9-11e6-9938-d052290c7bf2.png)
",aweary,josephsavona
1296,2016-08-02 15:01:56,"Narrowing down the issue a bit more, it seems that `RelayCachedDataRestorator` is not iterating over all the `pendingNodeStates` returned from `findRelayQueryLeaves`. 

`this._state` is marked as `""COMPLETED""` after visiting only the first node state, meaning the `RelayQueryFragment` that is queued up at index `1` is ignored. So now it's matter of identifying why it completes early.

**edit:** 

So what seems to be happening is that `pendingNextStates` in `RelayCacheProcessor` is being cleared before another state is queued.

[`visitNode`](https://github.com/facebook/relay/blob/master/src/store/RelayCacheProcessor.js#L199-L204) adds the `nextState` to a queue scoped by dataID



But that first `if` block checking if a pending state queue exists is never run, because [`queueNode` deletes it](https://github.com/facebook/relay/blob/master/src/store/RelayCacheProcessor.js#L164-L165):



and this is running **BEFORE** the next node is visited. So when `queueNode` checks [if `_isDone()` is `true`](https://github.com/facebook/relay/blob/master/src/store/RelayCacheProcessor.js#L172-L174)



It ends up calling `_handleSuccess()` which marks `_state` as `""COMPLETED""` which causes the  [`for` loop in `RelayCachedDataRestorer.traverse()` to exit early](https://github.com/facebook/relay/blob/master/src/store/restoreRelayCacheData.js#L243-L245)



@josephsavona can you review this and let me know what you think? It seems like its assumed that `visitNode` will be called for every node before `queueNode` processes them?
",aweary,josephsavona
1296,2016-08-02 16:10:49,"Not sure how to fix it, maybe @josephsavona has an idea? Maybe `RelayCachedDataRestorator` should spin up an instance of `RelayCacheProcessor` for each traversal of each `pendingNodeState`?
",marcinbunsch,josephsavona
1296,2016-08-02 16:12:10,"Thanks @josephsavona! Really appreciate it 👍 
",aweary,josephsavona
1296,2016-08-02 16:29:21,"Awesome! Thanks, @josephsavona!
",marcinbunsch,josephsavona
1296,2016-08-03 14:15:37,"I haven't done much work towards actually fixing this, so @marcinbunsch feel free to open a PR to address this! @yuzhi can we re-open this issue, since it turns out that it was a Relay issue?

Thanks for all the help with this everyone 😄 
",aweary,yuzhi
1294,2016-07-20 21:45:29,"@josephsavona I was actually using `RelayEnvironmentSerializer` when I ran into this issue. 

> Note that placing all of the serialization logic in RelayEnvironmentSerializer decouples values serialization from the logic that operates on those values.

I agree, that seems ideal. I didn't do it this way because that would require `RelayEnvironmentSerializer` to transverse the parsed `StoreData` instance, which it doesn't currently do, so I was hesitant. I could update this PR to do just that and also expose `RelayEnvironmentSerializer` if you'd like!
",aweary,josephsavona
1294,2016-07-20 22:38:18,"@josephsavona awesome, glad we are on the same page. I updated the PR so that `RelayStoreData` iterates through `records` and deserializes all `__range__` instances before it creates and returns the new `RelayStoreData` instance.

Let me know what you think about this approach, and any changes you'd like.

I can also add some tests for `RelayEnvironmentSerializer` and add it to `RelayPublic` if you'd like, or I can do that in another PR 😄 
",aweary,josephsavona
1294,2016-07-21 19:22:01,"@josephsavona I implemented a `deserializeRecordRanges` helper at the bottom of the file and updated `toJSON` to call it for each set of records.
",aweary,josephsavona
1292,2016-07-22 02:05:15,"@Globegitter Thanks for such a detailed and extensive PR. We really appreciate all the effort you put into this and other PRs!

Unfortunately the timing of this is not ideal. The team is actively working on some major improvements to Relay core, and among these is a more flexible mutation API that will support effectively arbitrary modification of lists. We're still iterating on the details, but we'll be sharing more about this in the next few weeks.

Given the timing, the fact that the new mutations API would be even more flexible than simple append/prepend, and the complexity involved in testing & shipping this implementation, we're inclined to hold off on accepting this PR. If you have an immediate need for this, we'd be happy to work with you to come up with a workaround (perhaps by manually writing a new list into the store via low-level methods).

I know this can be frustrating, but we're trying to optimize for getting the new version out as soon as possible. What do you think about going with a workaround for now?
",josephsavona,Globegitter
1292,2016-07-25 13:40:57,"@josephsavona Thank you for that detailed response and it does make sense to not merge this PR if the new and improved API is just a few weeks ahead. Looking forward to seeing arbitrary modifications to lists.

In terms of solutions to our problems, I will have to check with one of our developers first what we currently do there as a work-around before getting back here. But in one of the affected apps that I am directly working on (a non-consumer facing admin-panel) we just decided to force-fetch 100% of the time for now. This decision was also affected by the fact that this app often needs its cache updated with new data from the backend but we have no websockets yet. In the consumer facing app we fortunately could use ConnectionFields everywhere where we needed list mutations. The offer is very much appreciated.

Either way, I will close this PR.
",Globegitter,josephsavona
1292,2016-07-25 15:43:49,"@Globegitter Thanks for understanding. An internal admin panel seems like a good use case for always-fresh data, so force-fetching almost seems like a good tradeoff there anyway. Definitely reach out though if you still need a workaround and we'd be happy to help!
",josephsavona,Globegitter
1292,2016-08-07 19:30:03,"> perhaps by manually writing a new list into the store via low-level methods

Can you elaborate @josephsavona? It would be extremely handy to have a reference implementation of the workaround while waiting for the major improvements.
",mattecapu,josephsavona
1291,2016-08-01 16:06:47,"@josephsavona  Sorry i took so long to respond i got sidetracked with other tasks. at work. I am still having this issue.  I ended up putting in a shim that hardcoded the url within relay to make sure the rest of my code was working correctly. 

When i log out my network layer i see below. Below is what prints out in terminal from the backend. 



<img width=""605"" alt=""screen shot 2016-08-01 at 12 08 03 pm"" src=""https://cloud.githubusercontent.com/assets/17296866/17300513/b229084c-57e0-11e6-84ac-617d75a98c66.png"">

below is what prints out in console on the web browser. 



![screen shot 2016-08-01 at 12 04 37 pm](https://cloud.githubusercontent.com/assets/17296866/17300392/37393b02-57e0-11e6-96d7-a1778d6df018.png)

I pass this into the router like so 



Thanks for all of your help!! i am sorry for the delayed response. 
",rterysen-openroad,josephsavona
1291,2016-08-08 18:49:49,"Thank you @josephsavona,  for your help!!  I am still learning this whole environment but I really don't believe it would be related to the server render.  Of course I could be wrong.  After the initial load the mutations would triggered off form submissions. I believe that relay would look directly at the graphql server at that point and not be interactive with the express instances serving it.   

I have Graphql  set up in a separate code source.  Also it doesn't spin up as part of the same project hence the issue with it not being a relative path.  The only thing that blows my mind is that my read queries work fine. No matter where I click or what I do I never have a issue grabbing data.  It is only the mutations.  I already troubleshooted this but my guess was the client.js file that has the routing it in it. All my logs show the correct url. 

I added a shim on line 120 of the default network layer that concats the url to the ""/graphql"" path to get the app working for the mean time. With that in place it works fine.  It keeps me up at night though :) ! 

I dont see it making any calls to the node instance that is performing the isomorphic render.  I only see the call on the graphql server.  

Thanks for helping me out with this. I know it has got to be really hard to figure out what is wrong over a conversation of comments.  My team and I are really loving relay beside this bug that we cant seem to fix.  
",rterysen-openroad,josephsavona
1288,2016-09-02 23:59:37,"Going to close this out because we will be rebuilding the website/playground experience for the release of [Relay 2](https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable). 

Thanks for the report @fadils, and sorry that we never got to this!
",wincent,fadils
1281,2016-07-21 12:04:38,"@josephsavona 

After adding the `fbjs` preset to babel I've managed to get `printedQuery` to work but
there is one ""but""..
Long story short: I've got a strange behaviour of Jest when it is lanuched
with and without test path reg ex. My setup is very simple: the `__tests__`
folder contains two tests - `SignIn-test.js` and `Me-test.js` (in
`SignIn-test.js` I changed `describe` to `xdescribe`).

Here's the output when I run Jest without test path reg ex:



As you see the `printQuery` is executed as expected.

And here's the output when I specify the test path reg ex to execute only the `Me-test.js`:



See? Why? What changes inside Jest that causes the exception?

It is this line in transpiled code (I've added the `console.log`s):



To make things worse I can tell you that the same behaviour as in the second case I see when
I launch Jest with the `-i` (`--runInBand`) switch.

PS I also removed `babel-jest` from dev dependencies and specified my own preprocessor:



Any ideas?
",GrigoryPtashko,josephsavona
1281,2016-08-05 15:51:52,"@josephsavona I finally got some results but there're not solving the issue tho. I'm just asking for an advice. Long story short is that I could not debug my test because jest has some kind of issue when  the OSS Relay is built with `inlineRequires` set to `true`. But thanks to this topic [jest#1321](https://github.com/facebook/relay/issues/1321) (listening to all of the updates to Relay's repo turned out to be a great source of information) I found out that I can build Relay with different options. I've re-built it with `inlineRequires` set to `false` and was able to run a single test `Me-test.js` with jest.

And here's what I've got at the moment. Relay makes the query!! I can see it in my backend server log. But. The `render()` is never get called. And here's why. In this `Me-test.js` in the `Relay.Renderer` in the `render` callback the `done` arg is always `false` and `props` is always `null`. I see that Relay makes exactly 3 tries and then quits. So my `AppContainer` is never get created and thus its `render()` method is never get called.

Can you give my some further direction on how can I debug this?

Thanks!
",GrigoryPtashko,josephsavona
1281,2016-11-07 12:51:05,"@sibelius @lucasbento sorry for keeping silence. My macbook was in the service. I'm glad I'm not alone in this question.. I guess you've already guessed that I have a working solution for Jest 14 but not for Jest >= 15. Here's the issue with the repro and the example for Jest 14 https://github.com/facebook/jest/issues/1898. Guys from the Jest team do not answer it unfortunately. 
",GrigoryPtashko,sibelius
1279,2016-07-18 15:05:41,"Thanks for the PR @washt. Just trying to understand the intent here. Do you have some context that you can link to here for why you want to do this? `RelayQueryConfig` itself doesn't really do anything at all, so I am not sure of the value of exposing it. The rest of Relay really only cares about the interface, `RelayQueryConfigInterface`.
",wincent,washt
1271,2016-07-13 00:34:43,"@jardakotesovec Here's the whole mutation. I'll try adding the cursor for each edge in the response to see if that works.


",rgovindji,jardakotesovec
1269,2016-07-12 18:11:28,"@sibelius Have any of these suggestions helped? We can help debug more effectively if you're able to provide a sample mutation response. 
",josephsavona,sibelius
1269,2016-07-12 21:27:13,"@sibelius sorry, but could you include the query with the response :blush:. There are some subtle differences in the query you initially posted and the response, so Relay has likely created a different query (this maybe intended).

Also, were some of the ideas mentioned in this thread effective?
",calebmer,sibelius
1269,2016-07-15 03:41:08,"@nikhildaga can you provide a bit more detail about what was wrong, and how you fixed it? This might help @sibelius find the problem.
",josephsavona,sibelius
1269,2016-07-15 03:57:55,"@josephsavona : Sure.

@sibelius :  
Earlier, I didn't have edge field in my fat query and on server mutation. I added those. From your code, it looks like you already have them.

Things to note:
in fat query, I use @relay(pattern: true)
`fragment on saveCommentPayload @relay(pattern: true) {
`
And rangeBeviors in getConfigs is 
`rangeBehaviors: () => 'prepend',
`
",nikhildaga,sibelius
1269,2016-07-15 03:57:55,"@josephsavona : Sure.

@sibelius :  
Earlier, I didn't have edge field in my fat query and on server mutation. I added those. From your code, it looks like you already have them.

Things to note:
in fat query, I use @relay(pattern: true)
`fragment on saveCommentPayload @relay(pattern: true) {
`
And rangeBeviors in getConfigs is 
`rangeBehaviors: () => 'prepend',
`
",nikhildaga,josephsavona
1266,2016-07-09 20:15:55,"FYI, I've created a full example just to try to reproduce what I thought was the bug, with what I initially described. It's here: https://github.com/gre/relay-examples/tree/master/cars

But I can't reproduce the bug I experienced at work...
So, i'll close this issue and if someone find something then we can discuss. But maybe it's one of this hard-to-figure-out backend bug on our side.

thanks for your help @NevilleS 
",gre,NevilleS
1265,2016-07-11 21:23:24,"@steveluscher yes, sure. Here is the question https://stackoverflow.com/questions/38316444/recursive-fetching-of-a-connection-is-rejected-by-relay-reproducible-on-the-rel
",GrigoryPtashko,steveluscher
1262,2016-07-08 15:14:18,"@NevilleS, when I prepared that commit I basically went through and analyzed all the code paths and came to the conclusion that everything was required except for `parentName`. So, I think the examples in the docs are most likely incomplete and should be updated. It's complicated, however, so there is a chance that I got it wrong too.
",wincent,NevilleS
1261,2016-07-22 07:47:27,"Yep that's what I've been doing. Was just under the impression that `RelayContainer` was supposed to support immutable data to make it a bit less manual in optimising components for efficient re-rendering. Thanks for your reply @josephsavona.
",nthtran,josephsavona
1261,2016-07-22 08:18:32,"@josephsavona Lets say that it would do === comparison on all props including objects, not just scalar - what would be the down side?  Currently its not useful for mutable nor immutable object props.  Using === for all props would make it at least useful for immutable use case. And docs would just say it does '===' comparison instead of comparison for scalar values, suggesting you either treat structures immutably or do your own shouldComponentUpdate.

I actually think it would be more intuitive than current behavior..  I know that it can be found in docs.. but in practice I also end up reading the code to find out what 'breaks' shouldComponentUpdate in relay container as I expected shallow compare by default. Majority devs seems [to also aim](https://twitter.com/reactjs/status/736412808372314114) for shallow compares in shouldComponentUpdate in react
",jardakotesovec,josephsavona
1261,2016-07-22 08:31:09,"@josephsavona Down side is that someone with mutable data would be prevented from re-renders, right? So probably until react would decide to go with this default shallow compare (if ever) it makes sense to let optimization (via shouldComponentUpdate) on user same way as react does. Ok :-).
",jardakotesovec,josephsavona
1261,2016-07-22 16:05:26,"> Was just under the impression that RelayContainer was supposed to support immutable data

@nthtran I see. Yeah, Relay can't assume that props you give it are immutable, but it does guarantee that the props it provides to you can be treated as such. `RelayContainer` reuses any portion of the previous results that are deep equal to the new results [via a helper](https://github.com/facebook/relay/blob/master/src/legacy/store/GraphQLStoreQueryResolver.js#L269). The [tests](https://github.com/facebook/relay/blob/master/src/legacy/store/__tests__/recycleNodesInto-test.js#L89-L96) help to clarify the behavior a bit more.

> Down side is that someone with mutable data would be prevented from re-renders, right?

@jardakotesovec Right. Mutability is the default in JS, so the current behavior was chosen as being the least surprising overall while still allowing developers to use the standard approach to React optimization if necessary.
",josephsavona,jardakotesovec
1255,2016-07-03 02:00:11,"Thanks @josephsavona. Here is the [question](https://stackoverflow.com/questions/38166072/would-it-be-possible-to-do-lazy-loading-in-relay) on Stack Overflow
",lvarayut,josephsavona
1252,2016-07-03 19:35:02,"@jardakotesovec Thoughts?
",josephsavona,jardakotesovec
1252,2016-07-11 05:40:27,"@josephsavona Thanks, sounds good! Can you please point me where in relay is done the filtering? Just wondering if would be feasible for me to override that behavior for time being..

And what do you think about my second point - does it make sense to bring this up in graphql-js? We don't have currently such use case, but it seems to me as better option than allow null in list and filter them later on clients.
",jardakotesovec,josephsavona
1252,2016-07-28 15:57:43,"@jardakotesovec This is definitely worth asking about in `graphql-js`. Note that the filtering logic is primarily in [`RelayQueryWriter`](MTQ2NzkxNTE5NA==).

I'm going to close this since it's working as designed. We are, however, taking this feedback into account for the upcoming changes to Relay core, which will not filter nulls by default. Thanks for raising this issue!
",josephsavona,jardakotesovec
1246,2016-06-28 16:22:53,"@alloy Awesome, thanks! This is exactly what I was thinking.
",josephsavona,alloy
1244,2016-06-28 21:02:51,"@yuzhi I can submit a fix for it if you'd like!
",xuorig,yuzhi
1244,2016-06-28 21:13:28,"@xuorig That would be awesome! Please also add a unit test so we catch this in the future.
",yuzhi,xuorig
1243,2016-06-27 16:39:11,"@steveluscher  yes, sure. I've crossposted it on SO. Here it is https://stackoverflow.com/questions/38059070/recursive-fetching-of-a-connection-is-rejected-by-relay-possibly-another-reason
",GrigoryPtashko,steveluscher
1243,2016-06-27 21:08:19,"Awesome job debugging, @steveluscher!
",josephsavona,steveluscher
1243,2016-06-28 07:35:36,"@steveluscher can you, please, look at my comment here http://stackoverflow.com/questions/38059070/recursive-fetching-of-a-connection-is-rejected-by-relay-possibly-another-reason/38065217#comment63570782_38065217 ?
In short - nothing changed. I've tried both ways - recursion on connection and on list field. I still don't know what to do.
",GrigoryPtashko,steveluscher
1242,2016-10-21 14:00:49,"Hey @wincent just put up a PR for this. I placed it under the `Relay.QL` section ([here](http://facebook.github.io/relay/docs/api-reference-relay-ql.html#content)) for now since I saw some of the other directives there already (like `@include`) but I saw you mentioned it would most likely go in [this section](http://facebook.github.io/relay/docs/graphql-relay-specification.html). Is there a particular place you would recommend on that section for this documentation or is the `Relay.QL` ok?
",josercruz01,wincent
1242,2016-10-21 14:44:26,"@josercruz01 : Thanks for the PR, I'll comment on that instead of here.
",wincent,josercruz01
1241,2016-07-27 05:21:22,"@Globegitter `RANGE_ADD` has `parentName` https://facebook.github.io/relay/docs/guides-mutations.html#range-add

`parentName` - is the fieldname in your mutation payload (response)
`parentId` - is `id` in Relay's flat objects cache (store)
So these two fields need for making a relation between your graphql response and relay store. So this relation makes possible to merge data from a typed object in response with an object in relay's store. 

This article will be quite useful for understanding internal implementation of Relay's store http://hueypetersen.com/posts/2015/09/30/quick-look-at-the-relay-store/

Your suggestion in the last paragraph is awesome! Added under number **# 4** in the list of desirable features.
",nodkz,Globegitter
1241,2016-07-27 06:58:39,"@nodkz yes I know that RANGE_ADD has parentName but it is an optional config field for this where-as for NODE_DELETE it is required. I don't understand that difference of it being optional for one and required for the other. And looking at tests e.g. here: https://github.com/facebook/relay/blob/master/src/traversal/__tests__/writeRelayUpdatePayload-test.js#L1363 shows that it is indeed not needed for RANGE_ADD.

 Thank you for posting that article, will have a read. 
",Globegitter,nodkz
1232,2016-06-23 21:52:27,"@josephsavona Hmm, bear with me, when you refer to the runtime not supporting it, do you mean functionality like refetching? The de-duplication works for me, but as I have not yet been able to use the Node based functionality I haven't been able to test this yet.
",alloy,josephsavona
1221,2016-06-20 15:41:05,"Yep, agreed on the size, good point.

Thanks for the answer @wincent, I'll take a look at having it written on the Transaction. Not a small fix indeed!
",xuorig,wincent
1221,2016-07-05 22:08:36,"Running into this issue. How's it looking @xuorig?
",grydstedt,xuorig
1218,2016-06-21 07:20:42,"@josephsavona I have added those changes @skosch proposed and i have the same thing/problem ... You can take a look at my repo from last post... I dont see why passing variables from parent to child container should work, beacuse they are using different set of initial variables to render the container.. Store container has only `id` but ticket container has `filter, first, last, after and before`. so those are tied to ticket container. 

initially ticket container is renderd with `filter: null` the you update it with:



on second render when filter is `this.props.relay.variables.filter = { subject: { __e: 'something' }` relay dosen't complain but when you update the filter variable second time it is.
",mario-jerkovic,josephsavona
1218,2016-06-28 15:14:16,"I did get a chance to look at @mario-jerkovic's repo and while I didn't have a chance to take a closer look at it (let alone find a solution) I did confirm that my original suggestion didn't help, because the issue is caused by `setVariables` (unlike mine, which wasn't). Sorry!

@jardakotesovec sounds like you've come exactly to the right place – hopefully someone can help you guys out!
",skosch,jardakotesovec
1218,2016-06-28 16:24:30,"@jardakotesovec Do you have an isolated repro that would help us debug?
",josephsavona,jardakotesovec
1218,2016-06-28 16:30:14,"@josephsavona Nope.. but I can attempt to create repro in relay playground tomorrow if that would help.
",jardakotesovec,josephsavona
1218,2016-06-28 16:51:34,"@jardakotesovec That would be _super_ helpful in diagnosing this.
",josephsavona,jardakotesovec
1218,2016-06-28 19:33:22,"@josephsavona I will recreate my repo in playground if the repo by itself wasent helpful 
",mario-jerkovic,josephsavona
1218,2016-06-29 08:09:11,"@josephsavona Here is the Relay Playground link (sorry for just copy and pasting, I have tried to use many link shortners but it always says that it's invalid :smile: )

https://facebook.github.io/relay/prototyping/playground.html#source=%0Aclass%20TicketList%20extends%20React.Component%20%7B%0A%20%20constructor(props)%20%7B%0A%20%20%20%20super(props)%3B%0A%20%20%7D%0A%0A%20%20filterHandler%20%3D%20()%20%3D%3E%20%7B%0A%20%20%20%20const%20%7Brelay%7D%20%3D%20this.props%3B%0A%0A%20%20%20%20relay.setVariables(%7B%0A%20%20%20%20%20%20filter%3A%20%7B%0A%20%20%20%20%20%20%20%20subject%3A%20!relay.variables.filter%20%3F%20%7B%20__e%3A%20'something'%20%7D%20%3A%20%7B%20__ne%3A%20'else'%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D)%0A%20%20%7D%3B%0A%0A%20%20render()%20%7B%0A%20%20%20%20return%20(%0A%20%20%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%20%20%3Ch1%3ETickets%3C%2Fh1%3E%0A%20%20%20%20%20%20%20%20%3Cbutton%20onClick%3D%7Bthis.filterHandler%7D%3EChange%20filter%3C%2Fbutton%3E%0A%20%20%20%20%20%20%20%20%3Cdiv%3E%7B%60Active%20filters%3A%20%24%7BJSON.stringify(this.props.relay.variables.filter%2C%20null%2C%202)%7D%60%7D%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%3Cul%3E%0A%20%20%20%20%20%20%20%20%20%20%7Bthis.props.store.ticketConnection.edges.map(edge%20%3D%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cli%20key%3D%7Bedge.node.id%7D%3E%7Bedge.node.title%20%2B%20'%20'%20%2B%20edge.node.subject%7D%20(ID%3A%20%7Bedge.node.id%7D)%3C%2Fli%3E%0A%20%20%20%20%20%20%20%20%20%20)%7D%0A%20%20%20%20%20%20%20%20%3C%2Ful%3E%0A%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20)%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20StoreListTickets%20%3D%20Relay.createContainer(TicketList%2C%20%7B%0A%20%20initialVariables%3A%20%7B%0A%20%20%20%20first%3A%205%2C%0A%20%20%20%20after%3A%20null%2C%0A%20%20%20%20last%3A%20null%2C%0A%20%20%20%20before%3A%20null%2C%0A%20%20%20%20filter%3A%20null%0A%20%20%7D%2C%0A%20%20fragments%3A%20%7B%0A%20%20%20%20store%3A%20(variables)%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Store%20%7B%0A%20%20%20%20%20%20%20%20ticketConnection(first%3A%20%24first%2C%20last%3A%20%24last%2C%20before%3A%20%24before%2C%20after%3A%20%24after%2C%20filter%3A%20%24filter%20)%20%7B%0A%20%20%20%20%20%20%20%20%20%20edges%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20node%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20id%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20title%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20subject%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%0A%20%20%7D%0A%7D)%3B%0A%0Aclass%20StoreForm%20extends%20React.Component%20%7B%0A%20%20%0A%20%20constructor(props)%20%7B%0A%20%20%20%20super(props)%3B%0A%20%20%20%20this.state%20%3D%20%7B%0A%20%20%20%20%20%20clickMe%3A%20false%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20render()%20%7B%0A%20%20%20%20return%20(%0A%20%20%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%20%20%3Cbutton%20onClick%3D%7B()%20%3D%3E%20%7Bthis.setState(%7B%20clickMe%3A%20!this.state.clickMe%20%7D)%7D%7D%3E%0A%20%20%20%20%20%20%20%20%20%20First%20click%20%22change%20filter%22%20than%20ME%20%3A)%0A%20%20%20%20%20%20%20%20%3C%2Fbutton%3E%0A%20%20%20%20%20%20%20%20%3Ch1%3EStore%20-%20tickets%3C%2Fh1%3E%0A%20%20%20%20%20%20%20%20%3Cdiv%3E%7Bthis.props.viewer.store.name%7D%20(ID%3A%20%7Bthis.props.viewer.store.id%7D)%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%3CStoreListTickets%20store%3D%7Bthis.props.viewer.store%7D%20%2F%3E%0A%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20)%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20App%20%3D%20Relay.createContainer(StoreForm%2C%20%7B%0A%20%20initialVariables%3A%20%7B%0A%20%20%20%20id%3A%20%22c3RvcmU6MQ%3D%3D%22%0A%20%20%7D%2C%0A%20%20fragments%3A%20%7B%0A%20%20%20%20viewer%3A%20(variables)%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Viewer%20%7B%0A%20%20%20%20%20%20%20%20store(id%3A%20%24id)%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%2C%0A%20%20%20%20%20%20%20%20%20%20name%2C%0A%20%20%20%20%20%20%20%20%20%20%24%7BStoreListTickets.getFragment('store')%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%0A%20%20%7D%0A%7D)%3B%0A%0Aclass%20AppHomeRoute%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20'AppHomeRoute'%3B%0A%20%20%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20viewer%3A%20()%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20query%20%7B%0A%20%20%20%20%20%20%20%20viewer%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%3B%0A%7D%0A%0AReactDOM.render(%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20Component%3D%7BApp%7D%0A%20%20%20%20route%3D%7Bnew%20AppHomeRoute()%7D%0A%20%20%2F%3E%2C%0A%20%20mountNode%0A)%3B%0A&schema=import%20%7B%0A%20%20GraphQLID%2C%0A%20%20GraphQLInt%2C%0A%20%20GraphQLObjectType%2C%0A%20%20GraphQLSchema%2C%0A%20%20GraphQLString%2C%0A%20%20GraphQLInputObjectType%0A%7D%20from%20'graphql'%3B%0A%0Aimport%20%7B%0A%20%20connectionArgs%2C%0A%20%20connectionDefinitions%2C%0A%20%20connectionFromArray%2C%0A%20%20fromGlobalId%2C%0A%20%20globalIdField%2C%0A%20%20nodeDefinitions%2C%0A%7D%20from%20'graphql-relay'%3B%0A%0A%2F%2F%20Model%20types%0Aclass%20Root%20%7B%7D%0Aclass%20Store%20%7B%7D%0Aclass%20Ticket%20%7B%7D%0A%0A%2F%2F%20Mock%20data%0Aconst%20viewer%20%3D%20new%20Root()%3B%0A%20%20%20%20%20%20viewer.id%20%3D%20'1'%3B%0A%20%20%20%20%20%20viewer.name%20%3D%20'Anonymous'%3B%0A%0Aconst%20stores%20%3D%20%5B%0A%20%20%7B%20name%3A%20'Store-1'%2C%20ticket%3A%20%5B1%2C2%2C3%5D%20%7D%2C%0A%20%20%7B%20name%3A%20'Store-2'%2C%20ticket%3A%20%5B2%2C4%2C3%5D%20%7D%2C%0A%20%20%7B%20name%3A%20'Store-3'%2C%20ticket%3A%20%5B2%2C%205%5D%20%7D%0A%5D.map((%7B%20name%2C%20ticket%20%7D%2C%20i)%20%3D%3E%20%7B%0A%20%20const%20a%20%3D%20new%20Store()%3B%0A%0A%20%20a.name%20%3D%20name%3B%0A%20%20a.ticket%20%3D%20ticket%3B%0A%20%20a.number%20%3D%20i%3B%0A%20%20a.id%20%3D%20%60%24%7Bi%7D%60%3B%0A%0A%20%20return%20a%3B%0A%7D)%3B%0A%0Aconst%20tickets%20%3D%20%5B%0A%20%20%7B%20title%3A%20'Test-1'%2C%20subject%3A%20'Subject-1'%20%7D%2C%0A%20%20%7B%20title%3A%20'Test-2'%2C%20subject%3A%20'Subject-2'%20%7D%2C%0A%20%20%7B%20title%3A%20'Test-3'%2C%20subject%3A%20'Subject-3'%20%7D%2C%0A%20%20%7B%20title%3A%20'Test-4'%2C%20subject%3A%20'Subject-4'%20%7D%2C%0A%20%20%7B%20title%3A%20'Test-5'%2C%20subject%3A%20'Subject-5'%20%7D%2C%0A%20%20%7B%20title%3A%20'Test-6'%2C%20subject%3A%20'Subject-6'%20%7D%0A%5D.map((%7B%20title%2C%20subject%20%7D%2C%20i)%20%3D%3E%20%7B%0A%20%20const%20a%20%3D%20new%20Ticket()%3B%0A%0A%20%20a.title%20%3D%20title%3B%0A%20%20a.subject%20%3D%20subject%3B%0A%20%20a.id%20%3D%20%60%24%7Bi%7D%60%3B%0A%0A%20%20return%20a%3B%0A%7D)%3B%0A%0Aconst%20exportObject%3D%20%7B%0A%20%20getRoot%3A%20(id)%20%3D%3E%20id%20%3D%3D%3D%20viewer.id%20%3F%20viewer%20%3A%20null%2C%0A%20%20getViewer%3A%20()%20%3D%3E%20viewer%2C%0A%20%20getStore%3A%20(id)%20%3D%3E%20stores.find(w%20%3D%3E%20w.id%20%3D%3D%3D%20id)%2C%0A%20%20getStores%3A%20()%20%3D%3E%20stores%2C%0A%20%20getConnectedTickets%3A%20(array)%20%3D%3E%20(array.map(id%20%3D%3E%20(tickets.find(w%20%3D%3E%20parseInt(w.id)%20%3D%3D%3D%20id))))%2C%0A%20%20getTicket%3A%20(id)%20%3D%3E%20tickets.find(w%20%3D%3E%20w.id%20%3D%3D%3D%20id)%2C%0A%20%20getTickets%3A%20()%20%3D%3E%20tickets%2C%0A%20%20Root%2C%0A%20%20Store%2C%0A%20%20Ticket%0A%7D%3B%0A%0Aconst%20%7BnodeInterface%2C%20nodeField%7D%20%3D%20nodeDefinitions(%0A%20%20(globalId)%20%3D%3E%20%7B%0A%20%20%20%20const%20%7Btype%2C%20id%7D%20%3D%20fromGlobalId(globalId)%3B%0A%20%20%20%20if%20(type%20%3D%3D%3D%20'Viewer')%20%7B%0A%20%20%20%20%20%20return%20exportObject.getRoot(id)%3B%0A%20%20%20%20%7D%20else%20if%20(type%20%3D%3D%3D%20'store')%20%7B%0A%20%20%20%20%20%20return%20exportObject.getStore(id)%3B%0A%20%20%20%20%7D%20else%20if%20(type%20%3D%3D%3D%20'ticket')%20%7B%0A%20%20%20%20%20%20return%20exportObject.getTicket(id)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20return%20null%3B%0A%20%20%20%20%7D%0A%20%20%7D%2C%0A%20%20(obj)%20%3D%3E%20%7B%0A%20%20%20%20if%20(obj%20instanceof%20exportObject.Root)%20%7B%0A%20%20%20%20%20%20return%20viewerType%3B%0A%20%20%20%20%7D%20else%20if%20(obj%20instanceof%20exportObject.Store)%20%20%7B%0A%20%20%20%20%20%20return%20storeType%3B%0A%20%20%20%20%7D%20else%20if%20(obj%20instanceof%20exportObject.Ticket)%20%20%7B%0A%20%20%20%20%20%20return%20ticketType%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20return%20null%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A)%3B%0A%0Aconst%20ticketType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20'Ticket'%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20id%3A%20globalIdField('ticket'%2C%20(%7B%20id%20%7D)%20%3D%3E%20id)%2C%0A%20%20%20%20title%3A%20%7B%0A%20%20%20%20%20%20type%3A%20GraphQLString%2C%0A%20%20%20%20%20%20resolve%3A%20(%7B%20title%20%7D)%20%3D%3E%20title%0A%20%20%20%20%7D%2C%0A%20%20%20%20subject%3A%20%7B%0A%20%20%20%20%20%20type%3A%20GraphQLString%2C%0A%20%20%20%20%20%20resolve%3A%20(%7B%20subject%20%7D)%20%3D%3E%20subject%0A%20%20%20%20%7D%0A%20%20%7D)%2C%0A%20%20interfaces%3A%20()%20%3D%3E%20%5BnodeInterface%5D%0A%7D)%3B%0A%0Aconst%20%7B%20connectionType%3A%20ticketConnection%2C%20edgeType%20%3A%20graphQLTicketEdge%2C%20%7D%20%3D%20connectionDefinitions(%7B%20name%3A%20'Ticket'%2C%20nodeType%3A%20ticketType%20%7D)%3B%0A%0Aconst%20FilterObject%20%3D%20new%20GraphQLInputObjectType(%7B%0A%20%20name%3A%20'FilterObject'%2C%0A%20%20fields%3A%20%7B%0A%20%20%20%20__e%3A%20%7B%20type%3A%20GraphQLString%20%7D%2C%0A%20%20%20%20__ne%3A%20%7B%20type%3A%20GraphQLString%20%7D%0A%20%20%7D%0A%7D)%3B%0A%0Aconst%20storeType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20'Store'%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20id%3A%20globalIdField('store'%2C%20(%7B%20id%20%7D)%20%3D%3E%20id)%2C%0A%20%20%20%20number%3A%20%7B%0A%20%20%20%20%20%20type%3A%20GraphQLInt%2C%0A%20%20%20%20%20%20resolve%3A%20(%7B%20number%20%7D)%20%3D%3E%20number%0A%20%20%20%20%7D%2C%0A%20%20%20%20name%3A%20%7B%0A%20%20%20%20%20%20type%3A%20GraphQLString%2C%0A%20%20%20%20%20%20resolve%3A%20(%7B%20name%20%7D)%20%3D%3E%20name%0A%20%20%20%20%7D%2C%0A%20%20%20%20ticketConnection%3A%20%7B%0A%20%20%20%20%20%20type%3A%20ticketConnection%2C%0A%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20filter%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20type%3A%20new%20GraphQLInputObjectType(%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20'Filter'%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20fields%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20title%3A%20%7B%20type%3A%20FilterObject%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20subject%3A%20%7B%20type%3A%20FilterObject%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20...connectionArgs%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20resolve%3A%20(%7B%20ticket%20%7D%2Cargs)%20%3D%3E%20connectionFromArray(exportObject.getConnectedTickets(ticket)%2C%20args)%0A%20%20%20%20%7D%0A%20%20%7D)%2C%0A%20%20interfaces%3A%20()%20%3D%3E%20%5BnodeInterface%5D%0A%7D)%3B%0A%0Aconst%20%7B%20connectionType%3A%20storeConnection%2C%20edgeType%20%3A%20graphQLStoreEdge%2C%20%7D%20%3D%20connectionDefinitions(%7B%20name%3A%20'Store'%2C%20nodeType%3A%20storeType%20%7D)%3B%0A%0Aconst%20viewerType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20'Viewer'%2C%0A%20%20description%3A%20'Viewer'%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20id%3A%20globalIdField('Viewer')%2C%0A%20%20%20%20store%3A%20%7B%0A%20%20%20%20%20%20type%3A%20storeType%2C%0A%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20id%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20type%3A%20GraphQLID%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20resolve%3A%20(_%2C%20%7B%20id%20%7D)%20%3D%3E%20exportObject.getStore(fromGlobalId(id).id)%0A%20%20%20%20%7D%2C%0A%20%20%20%20storeConnection%3A%20%7B%0A%20%20%20%20%20%20type%3A%20storeConnection%2C%0A%20%20%20%20%20%20args%3A%20connectionArgs%2C%0A%20%20%20%20%20%20resolve%3A%20(_%2C%20args)%20%3D%3E%20connectionFromArray(exportObject.getStores()%2C%20args)%0A%20%20%20%20%7D%2C%0A%20%20%20%20ticket%3A%20%7B%0A%20%20%20%20%20%20type%3A%20ticketType%2C%0A%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20id%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20type%3A%20GraphQLID%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20resolve%3A%20(_%2C%20%7B%20id%20%7D)%20%3D%3E%20exportObject.getTicket(fromGlobalId(id).id)%0A%20%20%20%20%7D%2C%0A%20%20%20%20ticketConnection%3A%20%7B%0A%20%20%20%20%20%20type%3A%20ticketConnection%2C%0A%20%20%20%20%20%20args%3A%20connectionArgs%2C%0A%20%20%20%20%20%20resolve%3A%20(_%2C%20args)%20%3D%3E%20connectionFromArray(exportObject.getTickets()%2C%20args)%0A%20%20%20%20%7D%0A%20%20%7D)%2C%0A%20%20interfaces%3A%20%5BnodeInterface%5D%0A%7D)%3B%0A%0Aconst%20queryType%20%3D%20new%20GraphQLObjectType(%7B%0A%20%20name%3A%20'Query'%2C%0A%20%20fields%3A%20()%20%3D%3E%20(%7B%0A%20%20%20%20node%3A%20nodeField%2C%0A%20%20%20%20viewer%3A%20%7B%0A%20%20%20%20%20%20type%3A%20viewerType%2C%0A%20%20%20%20%20%20resolve%3A%20()%20%3D%3E%20exportObject.getViewer()%0A%20%20%20%20%7D%0A%20%20%7D)%0A%7D)%3B%0A%0Aexport%20default%20new%20GraphQLSchema(%7B%0A%20%20query%3A%20queryType%0A%7D)%3B%0A
",mario-jerkovic,josephsavona
1218,2016-07-01 22:41:22,"Thank goodness I found this page. I have the same scenario as @jardakotesovec and get the same warnings. It took me days to suspect that I used Relay wrongly.
",philiptzou,jardakotesovec
1216,2016-06-15 17:47:32,"Added a regression test @kassens !
",xuorig,kassens
1216,2016-06-15 21:40:15,"@xuorig see comment about the return type
",josephsavona,xuorig
1215,2016-06-15 11:27:46,"I already in 0.9.0, I am sure when calling injectNetworkLayer second time, it will cause an exception.

@nodkz, thanks for your powerful library, I will use it soon. 
",ron-liu,nodkz
1215,2016-06-15 18:12:51,"I'd recommend using @nodkz's layer like he describes. The intention is to not inject new network layers all the time, but rather inject a single layer that is flexible enough to embody your desired behavior. (We made this stricter in response to bugs that cropped up internally in large apps where we were trying to update the layer in multiple places and unknowingly clobbering previous adjustments.)

As I think this is now resolved, going to mark it as closed.
",wincent,nodkz
1210,2016-06-15 18:37:53,"Yeah, I think there are probably two appropriate forums for this kind of question:
1. Stack Overflow for concrete technical questions about _how_ to make architect an app using Relay and Redux (or any other local state management solution, Flux-like or otherwise).
2. [relay-future](https://github.com/relayjs/relay-future) For forward-looking discussion of possible directions for integrated local state management in Relay.

On that latter subject, we're not actively working on it right now — we're currently focused on getting the core abstractions solid and performant on potentially low-power, network-poor mobile devices — but we thin that problems like tackling local state will be good goals to focus on next.

In the meantime going to mark this one as closed. Thanks for your quesion @CoericK, and for your input @NevilleS.
",wincent,NevilleS
1208,2016-06-16 07:04:32,"@josephsavona: @xuorig has submitted a fix yesterday (#1216)
",ooflorent,josephsavona
1208,2016-06-16 07:04:32,"@josephsavona: @xuorig has submitted a fix yesterday (#1216)
",ooflorent,xuorig
1203,2016-06-09 02:40:13,"@josephsavona Turns out in this instance `A` does implement `Node`. Didn’t know that was important. I’ve updated the schema.

That still shouldn’t be correct though right?
",calebmer,josephsavona
1203,2016-06-09 05:31:48,"What @NevilleS said :-)
",josephsavona,NevilleS
1201,2016-06-08 00:55:22,"I tried to find a previous issue where we discussed this previously but I couldn't (looked here and in the GraphQL repos + Stack Overflow), but I am pretty sure there is some discussion of it _somewhere_.

Connections pretty much _only_ exist to enable pagination, and you generally want pagination in order to work with datasets that are too expensive to fetch in their entirety, or infeasible to process or display on the client due to the volume of data. As such, the ""fetch all pages"" scenario isn't really core, which is why it is possible but not necessarily beautiful (because you have to do something like `first: $maximumSafeInt`).

In that other issue that I can't find right now, we've recommended to do exactly that (see the [TODO example](https://github.com/facebook/relay/blob/9631b1222834f77b636b47d4a11ab5ead79f04aa/examples/todo/js/components/TodoListFooter.js#L66), for example), or use a plural like @kassens says.
",wincent,kassens
1201,2016-06-08 09:40:12,"@kassens In our use case the end-user does not have direct control over the objects that will be displayed for them (that is handled by certain enterprise users), so we know that the number will be relatively stable (it could grow or shrink by a few numbers though). In fact we are not showing the list of objects directly, but each object belongs to a category and we are showing it grouped by that category. So again, while the number of categories can change, they are not controlled by the end-user and we know they will stay relatively stable (at least following our current business requirements). The main reasons for me choosing `ConnectionField` was because the list does have some metadata on it and also what I am writing below.

@wincent We where using a list originally but after reading more about `ConnectionFields` (https://github.com/graphql/graphql-relay-js/issues/27#issuecomment-142421989, https://github.com/facebook/relay/issues/444#issuecomment-146907987, https://github.com/facebook/relay/issues/444#issuecomment-192034175) I wanted to try and embrace them to the fullest: e.g. not just use them for pagination but for lists that just have some metadata, like total_count or extra information about each node and also use them for lists where we do not need pagination but proper mutation support. Having started to go down that road maybe it is better to just use `ConnectionFields` for pagination and Lists for everything else. 

I suppose it would just be great to have one clear message, e.g. Only use `ConnectionFields` when you need the pagination future otherwise use `Lists` and Relay can handle both fully. Or 'always' use `ConnectionFields` but they are flexible enough to support a variety of use-cases.

Slightly OT: I actually paused my work on fixing #444 because right now I tried to go down the second path (i.e. 'always' use `ConnectionFields`) but maybe it would just be better to have Relay properly support `Lists` (happy to finish up my work on that and make a PR) and people can then pick and choose what to use themselves. 

That are just my thoughts on that overall topic based on my current understanding of the situation.

In any case thanks for getting back so quickly it is appreciated.
",Globegitter,wincent
1201,2016-06-08 09:40:12,"@kassens In our use case the end-user does not have direct control over the objects that will be displayed for them (that is handled by certain enterprise users), so we know that the number will be relatively stable (it could grow or shrink by a few numbers though). In fact we are not showing the list of objects directly, but each object belongs to a category and we are showing it grouped by that category. So again, while the number of categories can change, they are not controlled by the end-user and we know they will stay relatively stable (at least following our current business requirements). The main reasons for me choosing `ConnectionField` was because the list does have some metadata on it and also what I am writing below.

@wincent We where using a list originally but after reading more about `ConnectionFields` (https://github.com/graphql/graphql-relay-js/issues/27#issuecomment-142421989, https://github.com/facebook/relay/issues/444#issuecomment-146907987, https://github.com/facebook/relay/issues/444#issuecomment-192034175) I wanted to try and embrace them to the fullest: e.g. not just use them for pagination but for lists that just have some metadata, like total_count or extra information about each node and also use them for lists where we do not need pagination but proper mutation support. Having started to go down that road maybe it is better to just use `ConnectionFields` for pagination and Lists for everything else. 

I suppose it would just be great to have one clear message, e.g. Only use `ConnectionFields` when you need the pagination future otherwise use `Lists` and Relay can handle both fully. Or 'always' use `ConnectionFields` but they are flexible enough to support a variety of use-cases.

Slightly OT: I actually paused my work on fixing #444 because right now I tried to go down the second path (i.e. 'always' use `ConnectionFields`) but maybe it would just be better to have Relay properly support `Lists` (happy to finish up my work on that and make a PR) and people can then pick and choose what to use themselves. 

That are just my thoughts on that overall topic based on my current understanding of the situation.

In any case thanks for getting back so quickly it is appreciated.
",Globegitter,kassens
1201,2016-06-08 23:24:41,"@Globegitter: So, if I am understanding you correctly, you are saying that lists are like an iPad, connections are like a Mac Pro, and there is room for an iMac model somewhere in the middle. It is hard to strip away complexity from connections, but more straightforward to add power to lists, I think (the #444 approach).
",wincent,Globegitter
1201,2016-06-08 23:35:37,"@yuzhi: That's the comment I was looking for!
",wincent,yuzhi
1201,2016-06-08 23:53:33,"@wincent @yuzhi Thank you for the comments and yes I think the iPad/Mac Pro/iMac analogy is quite spot on.

I can see the point that @dschafer is making and that clarifies the `ConnectionField` use-case fully and this can be closed. I would agree then that it makes most sense to add more power to lists, which then gives users full flexibility. Will try and finish the work on that soon.
",Globegitter,yuzhi
1201,2016-06-08 23:53:33,"@wincent @yuzhi Thank you for the comments and yes I think the iPad/Mac Pro/iMac analogy is quite spot on.

I can see the point that @dschafer is making and that clarifies the `ConnectionField` use-case fully and this can be closed. I would agree then that it makes most sense to add more power to lists, which then gives users full flexibility. Will try and finish the work on that soon.
",Globegitter,wincent
1200,2016-06-07 20:20:17,"I'll try to come up with something this week @josephsavona 
",xuorig,josephsavona
1198,2016-06-03 07:50:16,"Thank @nodkz , adding REQUIRED_CHILDREN does indeed add the fields to the mutations onSuccess result, however the store is still not updated correctly, and the Intersected Fragment Query still does not include the `user { color }` field. Hmm
",dguillamot,nodkz
1196,2016-06-23 01:45:53,"> My english right now is to bad to write articles, and I hate to do it, cause spent a lot of time. I prefer to write some code.

This is a legit stance!

Is anybody else able to whip up a PR? I'm cleaning house trying to prepare the next release this week, so I can't promise getting to it myself, but a ""Debugging"" page in the docs would be great.

Thanks for bringing this up @nodkz, and thanks @BlooJeans for the PSA.
",wincent,nodkz
1192,2016-06-01 16:16:53,"@nodkz, @steveluscher, @edvinerikson, @alexhawkins  Thank you for your suggestions!

I asked this question in SO, you can find it [here](http://stackoverflow.com/questions/37550035/connection-error-with-relay). Im sorry for trashing the issue tracker, I just didn't know where to go after messing with this for several days. It's sometimes tricky to get answer for Relay because there aren't that many users yet. But I know better next time.

Feel free to provide your own answer and it would be awesome if you explained pros and cons that your suggestion has (if it has) with few sentences or if there's a suggested way to do this with Relay and Node.

The current answer to my question in SO was very eye-opening, I spent whole day in YT watching videos and reading articles - I finally discovered and wrapped my head around async JavaScript.
",unirey,edvinerikson
1192,2016-06-01 16:16:53,"@nodkz, @steveluscher, @edvinerikson, @alexhawkins  Thank you for your suggestions!

I asked this question in SO, you can find it [here](http://stackoverflow.com/questions/37550035/connection-error-with-relay). Im sorry for trashing the issue tracker, I just didn't know where to go after messing with this for several days. It's sometimes tricky to get answer for Relay because there aren't that many users yet. But I know better next time.

Feel free to provide your own answer and it would be awesome if you explained pros and cons that your suggestion has (if it has) with few sentences or if there's a suggested way to do this with Relay and Node.

The current answer to my question in SO was very eye-opening, I spent whole day in YT watching videos and reading articles - I finally discovered and wrapped my head around async JavaScript.
",unirey,steveluscher
1192,2016-06-01 16:16:53,"@nodkz, @steveluscher, @edvinerikson, @alexhawkins  Thank you for your suggestions!

I asked this question in SO, you can find it [here](http://stackoverflow.com/questions/37550035/connection-error-with-relay). Im sorry for trashing the issue tracker, I just didn't know where to go after messing with this for several days. It's sometimes tricky to get answer for Relay because there aren't that many users yet. But I know better next time.

Feel free to provide your own answer and it would be awesome if you explained pros and cons that your suggestion has (if it has) with few sentences or if there's a suggested way to do this with Relay and Node.

The current answer to my question in SO was very eye-opening, I spent whole day in YT watching videos and reading articles - I finally discovered and wrapped my head around async JavaScript.
",unirey,nodkz
1192,2016-06-01 18:24:45,"…although I'd love to see @edvinerikson's answer up there too :)
",steveluscher,edvinerikson
1190,2016-07-01 22:07:29,"@josephsavona FWIW, after you added `prepareParams` to react-router-relay, I've actually never had to use `prepareVariables`. I wonder just how useful `prepareVariables` on containers still is these days.
",taion,josephsavona
1190,2016-07-01 23:25:45,"@taion Thanks for the feedback. We have a few use-cases internally but I believe that we could find alternative approaches for those.
",josephsavona,taion
1188,2016-06-28 09:35:17,"@steveluscher is that private repo? I've got 404 page not found
",Dielz98,steveluscher
1177,2016-05-27 22:51:09,"@steveluscher After i knew Relay 0.9 was released i made a fresh clone, then i made npm install on the root of the relay repo, and then moved to the todo example and didnt work.
node: v6.2.0
npm: 3.8.9

I made a pull request https://github.com/facebook/relay/pull/1178
",CoericK,steveluscher
1177,2016-05-28 00:35:30,"Oh glad that my report helped to make that improvement @steveluscher, let me know if there is anything else that I can test and give feedback.
",CoericK,steveluscher
1167,2016-11-28 18:02:30,"@josephsavona This PR should have allowed both use-cases you described. We have the same case in our app, sometimes we might want to show a partial UI and sometimes not (i.e. keep the old behaviour).

Why can there not be a behaviour to have both? It seems to me also the most correct thing to do (as this is graphql default), you got some data but also some error, figure out what you want to do with it . And right now with relay we have the data striped out so can not do anything with it.

The problem with stripping out the errors field would be that we would loose any specific error details.

Maybe the cache should not be populated, but some access to the successful data and the error would be useful. Maybe even as a setting/prop in the root container or something.",Globegitter,josephsavona
1166,2016-05-26 00:47:12,"Thanks for the clarification @josephsavona! If the subscription API is the same as the mutation API, then why a separate Subscription Type just for the sake of it? Why not something like Relay.Store.commitUpdateLocal(Mutation, Payload)? This way, you can reuse your mutations when data is pushed from the server as well as support client state if you wanted to right?
",zuhair-naqvi,josephsavona
1163,2016-05-24 17:01:23,"Thanks @Globegitter. This looks pretty good to me. One comment inline though, otherwise looks good to import.
",wincent,Globegitter
1163,2016-05-24 22:57:07," @wincent Oh yeah sorry forgot to remove that again. Just rebased.
",Globegitter,wincent
1162,2016-05-22 17:54:35,"@jardakotesovec thanks for the answer ... i did not knew that connectionFromPromisedArray assumes u give it all the data ... honestly i do not use mongodb but in the video tutorail i ma following the trainer is using it and for him it worked ... maybe the specs changed since he did the video ... :) ... in any case i will plan to use it with Amazon RDS on MySQL or MariaDB ... do not know which one yet ... probably mysql :) 
",wowzaaa,jardakotesovec
1162,2016-05-22 23:19:16,"@jardakotesovec thanks for answering!

I'm going to close this as it isn't an issue per-se, but please feel free to continue discussing approaches. We'll keep this in mind as it isn't very intuitive why pagination wasn't working in this case. 
",josephsavona,jardakotesovec
1160,2016-05-21 14:40:37,"@wincent Thanks. I was not sure if that would also cover cases like queued mutations (mutations with same collision key), but I think its correct to assume if such network request resolves - Relay will send next network request in queue within one event loop (assuming I am using default task scheduler), so there should not be gap for race conditions.

Feel free to close it if you don't see this as common use case which would make sense to add to core.
",jardakotesovec,wincent
1160,2016-05-22 13:49:58,"Sure thing @jardakotesovec. In general we like to keep the core API as small as possible, so l will close this. Let us know, however, if you run into any roadblocks that prevent you from implementing this ""in userland"" and we can consider other options.
",wincent,jardakotesovec
1159,2016-05-20 22:55:35,"(@taion and I talked about this today ;) ).
",cpojer,taion
1150,2016-05-19 13:46:23,"Thanks for the question, @ashah888, and for the amazing answer @nodkz.
",wincent,nodkz
1148,2016-05-18 08:10:02,"Thanks to everybody for chiming in on this thread. We'd definitely like to improve the documentation, and do what we can to make Relay easier to understand. Like @KyleAMathews said, however, in order to be most useful, we need the feedback to be a little more concrete, focused and actionable. I'm going to close this one for now, and I encourage you to open narrower issues for specific problems that you find with the documentation or the concepts in the framework. The more detail, the better, and best of all is if you can incorporate a concrete suggestion for how something could be changed into a format that would be more understandable and useful to you.

(Also feel free to comment on this issue, even though I am going to close it. I'm just closing it because it is not specific enough to be actionable, not because I want to silence the discussion.)
",wincent,KyleAMathews
1148,2016-05-18 09:11:21,"@KyleAMathews nobody say that doc is terrible. Just say that it is ""hard to understand"". And it really such is. Because Relay has huge amount of abstractions/logic/relations and especially in conjunction with graphQL, so brains should hard strained to catch all aspects and principles how Relay works. So I can not imagine examples, which can give easy dive to Relay. 

I found doc very condensed (absent vacuity). So need read every topic attentively, cause every paragraph contain concentrated (high amount) information. And I spent seconds to find needed information. So for me at now doc is very good, for me at past doc was how @ashah888 wrote above.

Framework is too fresh, and of course is written low amount tutorials for newbies. Just need wait a critical mass of audience and success projects outside facebook.

PS. I am spent 7 months to study from scratch NodeJS + ES6 + Webpack + React + Relay + GraphQL + and tons of other modules (after Dan's talk at React Europe 2015 about hot-reload). So beautiful and simplicity have hight price. BTW I'm very glad that I ran away from RoR. Glad that choose Relay, not Redux. Glad how FB invested resources to open source and what amazing peoples maintains it. Especially inspired by eminence grises - Sebastian Markbage and Lee Byron.
",nodkz,KyleAMathews
1147,2016-05-18 09:08:00,"@wincent Yes, I'm able to connect and load data from GraphQL with web version of my code. But, I'm not sure what's wrong with React Native code. 
",BilalBudhani,wincent
1146,2016-05-17 16:35:59,"Thanks @Yaxian.

I'm totally unqualified to review this. Help, @yuzhi!
",wincent,Yaxian
1146,2016-05-18 02:09:22,"Ok, I got it. @yuzhi you can close it. Thanks.
",Yaxian,yuzhi
1145,2016-09-03 00:31:13,"Thanks for this suggestion, @akre54.

With [Relay 2](https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable), we'll have a very different (better) way of constructing optimistic updates, so we are unlikely to work on implementing this suggestion against the old API. So I'm going to close this. Thanks once again for you suggestion though!
",wincent,akre54
1138,2017-03-06 06:05:41,"@josephsavona  your reply makes perfect sense to me. I just ran into another scenario that is caused by the same nature. 
given


if `Child` implements `componentDidMount` and does a `setVarialbes({some_var: newValue})` there, `Parent` won't be able to know what child's new variables are.
This will cause an issue that, if `Parent` later on decides to refresh itself (e.g. call `setState`), relay will re-render  `Relay(Child)` and gives a 


the warning makes perfect sense to me --  `Parent` only knows about the `Child`'s static default variables, which `Child` has overridden in its `cdm`.  Due to
>If a child changes its variables, and then a parent changes its variables, the child will retain the changed variables so long as the parent doesn't override the child's variables (with getFragment('...', vars) + passing variables as props).

`Child` component's variables won't be overridden by `Parent` and can be resolved from `Relay Store` correctly, so everything works as expected. That said, the warning is a bit annoying, any idea how I can get rid of the warning without marking node_env as 'production'?

",bochen2014,josephsavona
1138,2017-03-17 03:48:18,"a follow up on my last comment
>If a child changes its variables, and then a parent changes its variables, the child will retain the changed variables so long as the parent doesn't override the child's variables (with getFragment('...', vars) + passing variables as props).

I have


can someone tell me what is the expected `var1` and `var2` in different renders?
and what is the updated value after I click the `refetch` button?
my understanding of correct behavior is:
Nil, Nil -> Nil, var2 (after `child cdm`) -> var1, var2 (after `parent refetch`)
what is happending is 
Nil, Nil -> Nil, var2 (after `child cdm`) -> var1, Nil(after `parent refetch`)

which means child variables are **not kept** event without parent explicitly overridding them. This conflicts with what @josephsavona  said before",bochen2014,josephsavona
1136,2016-05-13 09:10:05,"@IwanKaramazow what you're experiencing is the exact problem I was trying to solve when opening this issue. The global `Relay.Store` won't work for mutations if you're using a custom environment, it won't have access to the data in the store, and it won't have any custom network layers.  The solution @wincent has proposed should fix the problem.
",AndrewIngram,wincent
1123,2016-05-06 18:02:40,"Thanks @wincent for pointing me in that direction.  The idea of using middleware within the network layer is an interesting one that might work out well for us, or at least we can get some good ideas from that implementation.  I'll go ahead and close this since it sounds like a custom layer is the way to go.  Thanks again!
",03eltond,wincent
1122,2016-10-25 14:30:28,"@wincent I still see this warning when using `Relay.injectNetworkLayer(new Relay.DefaultNetworkLayer(url, options))` with `react-relay@0.9.3`.
",sedubois,wincent
1122,2016-10-25 15:05:58,"@wincent Yes, a layer was already injected, but I want to update the headers after user authentication. The code is [here](https://github.com/sedubois/belong/blob/gql-auth/app/relay/index.js).
",sedubois,wincent
1122,2016-10-25 15:26:33,"> This is why this is a warning and not an error

@wincent It's actually an error (red and still appears when filtering only for Errors in chrome console):

<img width=""1258"" alt=""screen shot 2016-10-25 at 18 22 33"" src=""https://cloud.githubusercontent.com/assets/4217871/19692298/1767389a-9ae0-11e6-9f41-c4992f3f9bce.png"">

> If the warning is truly obnoxious to you then we could look at adding a force kind of flag to effectively suppress the warning.

That would be really welcome, yes 😊 I believe the scenario I described is valid and common, and should therefore not pollute the console.
",sedubois,wincent
1111,2016-05-04 13:58:41,"Hi @wincent, I really wouldn't want to waste your time with unreleased bugs! This (or something like it) really seems to have shipped with 0.8.1. I definitely have 0.8.1 installed from npm, and when I look in node_modules/react-relay/lib/Relay.js has the following on line 31:


",sgwilym,wincent
1111,2016-11-15 18:47:11,"@sibelius thank you once again!
",voxmatt,sibelius
1104,2016-05-27 15:58:14,"@Globegitter see my comment about the extraneous `limit` argument
",josephsavona,Globegitter
1104,2016-06-24 23:42:24,"Going to pick this up and polish off any pending details necessary to get this through internal code-review. Thanks, @Globegitter.
",wincent,Globegitter
1103,2016-04-29 20:15:51,"Great, thanks @josephsavona. Safe to assume the fix will make it in the next minor release?
",liorrm,josephsavona
1101,2016-04-29 15:56:42,"@Globegitter Can you paste the route queries as well? Anything else interesting between the route and the top fragment given above?
",josephsavona,Globegitter
1101,2016-04-29 16:49:34,"@Globegitter Hmm. Should those `viewer` fragments be `fragment on Viewer` instead of `fragment on Query`?
",josephsavona,Globegitter
1101,2016-04-29 17:29:44,"@josephsavona This is a more a graphql python convention: http://graphene-python.org/docs/relay/

Under `Node Root field` you see that it is defined as `class Query` which automatically creates it as `type Query`. There is an example of it: https://github.com/graphql-python/swapi-graphene/blob/master/starwars/schema.py#L147

It has been working fine for us so far for quite a few other queries and we are getting the expected response back from the server (even `RelayNetworkDebug` is printing that response). 
",Globegitter,josephsavona
1101,2016-04-29 20:08:18,"Thanks for the reminder, @NevilleS. 

@Globegitter Be sure to pass any overridden variables down in props, so `<Child customerId={this.props.relay.variables.customerId} ... />`. Does that help?
",josephsavona,Globegitter
1101,2016-04-29 20:08:18,"Thanks for the reminder, @NevilleS. 

@Globegitter Be sure to pass any overridden variables down in props, so `<Child customerId={this.props.relay.variables.customerId} ... />`. Does that help?
",josephsavona,NevilleS
1101,2016-04-29 21:38:31,"I got the same issue. I don't understand  @josephsavona, he is passing the parameter through the container, so if he were to pass the changed relay variables down he would have to manually pass child relay context from the parent?
",sboutzen,josephsavona
1101,2016-04-30 09:36:12,"@josephsavona Yeah that 'double' syntax does initially feel a bit unnatural and verbose. It has tripped up a few people in our office in the past that you need to define `Child.getFragment('name')` and then also pass down `<Child name={this.props.name} ... />`. 

Couldn't the `getFragment` syntax be enough so the `RelayContainer` can inject the necessary props?

> @Globegitter Be sure to pass any overridden variables down in props, so `<Child customerId={this.props.relay.variables.customerId} ... />.` Does that help?

Thank you for that answer we did indeed not do that. Will try that asap.
",Globegitter,Globegitter
1101,2016-04-30 09:36:12,"@josephsavona Yeah that 'double' syntax does initially feel a bit unnatural and verbose. It has tripped up a few people in our office in the past that you need to define `Child.getFragment('name')` and then also pass down `<Child name={this.props.name} ... />`. 

Couldn't the `getFragment` syntax be enough so the `RelayContainer` can inject the necessary props?

> @Globegitter Be sure to pass any overridden variables down in props, so `<Child customerId={this.props.relay.variables.customerId} ... />.` Does that help?

Thank you for that answer we did indeed not do that. Will try that asap.
",Globegitter,josephsavona
1101,2016-04-30 16:58:22,"@josephsavona That worked, thank you for the clarification
",sboutzen,josephsavona
1101,2016-04-30 18:31:43,"Added some docs around that in #1104 which should hopefully make this easier for others in the future.

@josephsavona There is clearly something I do not fully understand then. I thought that all variables are being passed down from the `Route`. So looking at my example https://github.com/facebook/relay/pull/1104/files#diff-fbdd57764a52a0f91f0970024af6e714R87 it would seem that the only variable that ever could be passed down as `limit` is 10 even if we would specify the `Child` fragment multiple times (given it is hardcoded in the `Route`). 

So is the value defined in the `Route` ignored then? Or can it simply be overridden? And why do we have to specify `${Child.getFragment('viewer', {limit})}`, which implies that limit will be passed down from the `Route`, if we can pass down whatever we want from the actual component anyway? My apologies for these all these questions, but the semantics around passing down variables the container chain still seems a bit mysterious to me. 
",Globegitter,josephsavona
1101,2016-05-01 05:55:03,"@Globegitter I think this [example](https://github.com/facebook/relay/issues/309#issuecomment-140485321) nicely illustrates the ambiguity issue.
",jardakotesovec,Globegitter
1101,2016-05-01 08:09:29,"@josephsavona  Ah yeah of course the container can pass its own variables down, that makes total sense. Hmm, but you are saying that route params are being passed down automatically, when we tested it that was not the case. But maybe that is also because `https://github.com/relay-tools/react-router-relay` does not actually create a `Relay.Route` under the hood, or maybe it was because it was at the end of a long day. Either way, I will do some more testing understand the principle now. Thank you for the clarification though.

@jardakotesovec Thank you for the example, yep that clears it up completely.

(that basically resolves the issue, I will close it once I got to test it out.)
",Globegitter,jardakotesovec
1101,2016-05-01 08:09:29,"@josephsavona  Ah yeah of course the container can pass its own variables down, that makes total sense. Hmm, but you are saying that route params are being passed down automatically, when we tested it that was not the case. But maybe that is also because `https://github.com/relay-tools/react-router-relay` does not actually create a `Relay.Route` under the hood, or maybe it was because it was at the end of a long day. Either way, I will do some more testing understand the principle now. Thank you for the clarification though.

@jardakotesovec Thank you for the example, yep that clears it up completely.

(that basically resolves the issue, I will close it once I got to test it out.)
",Globegitter,josephsavona
1101,2016-05-12 17:03:37,"@Globegitter were you able to resolve this?
",josephsavona,Globegitter
1101,2016-05-12 20:17:45,"@josephsavona Thanks for checking in on that. We had in the meantime re-written how the query is structured, which solved this problem as well. There is another part in one of our apps though that I wanted to look into where we are also passing down variables in a similar way. Back when we implemented this I was not aware that we had to pass down the variables as props but we still managed to get it to work somehow. So wanted to verify again what we were doing there. That aside this can be closed and thank you for the quick response and good explanation. Has been very educational.

> Do you have a repro for this? RelayReadyStateRenderer always passes the route params to the root container. If you use the short query format that I gave above, Relay passes all variables to getFragment. If you manually call ${Container.getFragment()}, only the variables that you specify are passed.

We have needed Route params again and I can confirm that they are being passed down automatically as expected, so that must have just been something on our side then.
",Globegitter,josephsavona
1101,2016-05-13 08:03:59,"Yeah @josephsavona in our other usage we where actually passing down the variable as prop. I was just not consciously aware of that. That completely resolves this then. Thanks again.
",Globegitter,josephsavona
1099,2016-04-29 11:43:18,"@wincent thanks for quick fix
",mailaneel,wincent
1098,2016-04-28 19:14:43,"@josephsavona Thanks for the tip on that approach. It looks like `handleQueryPayload` still causes the tracker to grow, though, due (at least) to creating the `RelayQueryWriter` with `updateTrackedQueries: true`.

One thing I seem to be noticing is that fragment references are not subject to the duplication at least in the mutation’s query, but the field is. Does that match with the behavior you're expecting? Is there a chance that whatever might be preventing duplicate fragment references could be applied to fields?

(In the fragment below, the `forceFetch`’d component is responsible either F1 or F2, and then the duplicate IDs.)



That being said, preventing the query from being silly large is our immediate goal, but if our use of `forceFetch` is leaking too much memory over time we'd want to address that problem in a different place.

I think I want to investigate periodically deduping in the `RelayQueryTracker`, which I think could be done outside of Relay by finding its reference off of a `RelayStoreData` if you think that's not a good match for what should be in the framework itself.
",finneganh,josephsavona
1098,2016-05-04 03:59:12,"That's probably a good idea. That said, it looks like @josephsavona's code fragment lets me address the issue on my end. I adapted it (hopefully not too incorrectly) to fix the call to `RelayQuery.Fragment.build` as:



I'm going to take a look at integrating something like your deduping query tracker next, for the reasons you mentioned, but this patch is enough to get things in a working state for me.
",taion,josephsavona
1098,2016-07-26 18:46:55,"@taion Thanks for the reminder, this is fixed in v0.9.2.
",josephsavona,taion
1097,2016-04-28 13:46:23,"Thanks, @Globegitter!

This was added to support `RelayNetworkDebug` in v0.8.1. `RelayNetworkDebug` was itself added in v0.8.0. As such, it's recently been in a state of flux, which is why we didn't rush to document it. I think for now we should let this bake at least a couple more releases to be sure it won't need to change before mentioning it in any public docs.
",wincent,Globegitter
1091,2016-04-27 06:08:46,"Thanks for this, @chentsulin. Looks like we might have some work to do to make things pass before we can merge this. Want to take a look at those failures?
",wincent,chentsulin
1091,2016-04-28 13:47:37,"@chentsulin: check out @kassens diff links above. That _might_ fix it, and is _at least_ related.
",wincent,chentsulin
1086,2016-05-11 01:15:31,"Awesome! Thanks for the update @wincent.
",nareshbhatia,wincent
1083,2016-04-25 23:50:40,"Thanks for the PR, @dylanahsmith.

The use of client mutation IDs comes from their extraction from Facebook's internal implementation, where they have existed for years (perhaps since the original implementation of mutations, although my memory doesn't extend back that far). Perhaps @dschafer can speak to why/how they arose in the design.

The deal-breaker here, however, is that Relay internals themselves assume a client mutation ID, so this would be a breaking change (as you note), and I am not sure we want to do that. Disclaimer: I haven't fully read #825 yet so I am not sure whether there is a rationale in there strong enough to overturn whatever reasons Dan (or somebody else) can share with us for why things currently are the way they are.

Adding the discussion label for now so we can get some more opinions on this.
",wincent,dylanahsmith
1083,2016-09-21 16:42:21,"@dschafer Can you elaborate on how that ""own mutation"" association works? Generated `clientMutationId`s aren't unique across clients, so it doesn't seem like I can use the ID by itself to figure out whether a mutation was my own.
",taion,dschafer
1080,2016-04-26 17:07:40,"@schickling Application code source code would typically be compiled against a specific schema. Can you provide a bit more info on why the need for multiple schemas?

In general, we'd prefer to keep the plugin itself simple since most apps fall into the category of one app + one schema. Rather than change the plugin interface, we're open to making the plugin internals accessible as public API. The `RelayQLTransformer` class, for example, is given a schema in the constructor and has methods to convert GraphQL documents into code that can be used with Relay. I wrote about this [on a related issue](https://github.com/facebook/relay/issues/828#issuecomment-187569836) - would this approach help?
",josephsavona,schickling
1080,2016-04-26 18:39:48,"You are right @josephsavona - in our case the second schema is not known at compile time, so clearly the babel transform is of no use. Sorry for using an unclear example.

In the general case though I think it might make sense for one react/relay application to work with multiple backends and schemas and I'm curious to hear your thoughts on this. 

The main use case would be consuming third party GraphQL apis as well as your internal api. If pinterest for example exposed a public relay compatible GraphQL endpoint you would need support for two different schemas to integrate it directly in your application
",sorenbs,josephsavona
1079,2017-01-30 22:29:30,"Thanks for this report, @BarakChamo, and sorry for leaving it without a response for so long.

I'm going to close it as it is likely stale at this point, and you did find a way to get things working. The API you're referring to above is now considered ""legacy"", so we're unlikely to work on it further in the future (although we'd be happy to entertain PRs that fix bugs). Moving forward we're recommending that people use the newer, static mutation API (`Relay.GraphQLMutaton`) and we'll soon be rolling out a new core and new APIs in any case: pieces of this have already landed on the master branch and will continue to do so, but in the meantime, moving to `Relay.GraphQLMutation` will get you as close as possible to the new modern API which is coming out.

Thanks once again for your input!",wincent,BarakChamo
1076,2016-04-22 15:56:23,"@wincent Good point about the `RelayRootContainer`, removed its reference. And the comments make sense, is also updated.

Yeah it would be good to good to deprecate `RelayRootContainer` before the `0.9.0` release once some docs for its replacement have been added :)
",Globegitter,wincent
1076,2016-04-25 18:52:25,"Thanks for this @Globegitter. This is landing internally and will get synced out soon. I made a couple of tweaks which you'll see reflected when it lands on master:
- Fixed whitespace errors (trailing whitespace).
- Missing backticks.
- Route -> Relay.Route.
- Killed off some excess blank lines.
- Wrapped long line in comment sample.
- Reworded Relay.Environment mention based on feedback.
- Removed reference to `onForceFetch` and `onPrimeCache`, which only exist to support an experimental internal feature (persisted queries), and we're not ready to publicly support yet.
",wincent,Globegitter
1076,2016-04-26 06:40:39,"> Removed reference to `onForceFetch` and `onPrimeCache`, which only exist to support an experimental internal feature (persisted queries), and we're not ready to publicly support yet.

@wincent, I guess, since introduction of the `environment` prop to `RelayRenderer` there should be no need for `onForceFetch` and `onPrimeCache` extra props at all anymore, as now we can pass an `environment` with custom `forceFetch` and `primeCache`.
",denvned,wincent
1070,2016-04-26 14:26:17,"Thanks for bringing this up @alejandromaka, and thanks @edvinerikson for providing the answer. Going to mark this one as resolved.
",wincent,edvinerikson
1067,2016-04-25 18:27:44,"Thanks for this, @Globegitter. I'm not actually sure that we do want to document all of these options, as that would mean supporting them going forward. `inputArgumentName` and `snakeCase`, for example, might only exist because we needed to distinguish internally between open source GraphQL conventions and our preexisting internal ones.

@josephsavona, @yuzhi, @steveluscher. Any thoughts on which, if any of these options you'd prefer to remain undocumented?
",wincent,Globegitter
1067,2016-04-25 19:41:23,"I agree with @wincent - `inputArgumentName`, `snakeCase`, and _especially_ `substituteVariables` exist only to support switching between FB and OSS configuration. We'd prefer that people avoid relying on them and it probably would be better to simply not document them. Especially `substituteVariables`, which we're working to deprecate.
",josephsavona,wincent
1064,2016-05-11 02:24:01,"I closed the linked issue out of frustration. sorry.

@wincent does the file
https://github.com/facebook/relay/blob/master/src/tools/RelayTypes.js
exports all the types. I was looking for the type of a connection query, which I think is defined at 
https://github.com/facebook/relay/blob/master/src/interface/RelayOSSConnectionInterface.js
But I don't see a type for it in the `RelayTypes.js`. How can I get the type of a query response. Thanks.
",bsr203,wincent
1064,2016-05-20 05:25:57,"@wincent Since flow prefers `.flow` files anyway, if you just publish the original source files to npm along with the transpiled files with the `.flow` extension, flow will just pick the types up anyway.

So if `lib/Relay.js` is the transpiled file, `lib/Relay.js.flow` is the original source file.
You don't have to do any extra work. Just change the build process to copy the original files with the added extension and you're done. You may of course want to make exceptions for certain files, where you may want to manually override the type definitions so that it makes more sense for external use.

Would you please consider doing that?
",nmn,wincent
1061,2016-04-30 11:44:30,"@josephsavona it would break down at automatic generation for fields. I agree that schema would be the ideal, however I don't have the luxury to hide the primary key fields (I can't make assumptions about the data the schema is being generated from).

Would a solution like the following work with Relay, an `id` field with the following signature:



Where `global` defaults to `true`? Then we could have a query like:



---

As a side note, I've opened sourced the project I'm working on so we can talk in more specifics if you want. Its here at [PostGraphQL](https://github.com/calebmer/postgraphql).
",calebmer,josephsavona
1061,2016-05-31 21:32:33,"While making the name of the field (id) configurable might be complicated, choosing a better name for it (relay_id) so that it does not collide with just about every project schema naming convention would not be that complicated.
The problem is that users already using relay would need to rewrite their schema.
@wincent can you point out the places in the code where the ""id"" is hardcoded?
",ruslantalpa,wincent
1061,2016-06-14 16:37:59,"@wincent After code-spelunking a bit more, my thoughts are slightly different. Namely that Relay infers the primary key from the `Node` interface in the given GraphQL schema by looking for a field with type `ID!`.

With this traditional interface, Relay would use `id` as the primary key:



But with this interface it would be `relayID`:



---

I had wanted to provide a prototype patch, but after code-spelunking a full day I have to admit I’m slightly out of my depth with the code-base. My thoughts were:
- Add an optional primary key name parameter to [the `nodeDefinitions` helper](https://github.com/graphql/graphql-relay-js/blob/f1dfe502cfeccf80deadce3ce2cfde618a8acb36/src/node/node.js#L46-L76).
- `babel-relay-plugin` infers the primary key name by checking the `Node` interface in the given schema for a field that has the `ID!` type and attaches that field name as [the `inferredPrimaryKey` metadata](https://github.com/facebook/relay/blob/829450ab74aa5c6b0cdb453cb76b1fbc45f16687/scripts/babel-relay-plugin/src/RelayQLPrinter.js#L476-L479) to the generated fields of types that have the `Node` interface.
- Relay uses the inferred primary key, but right now I’m not even sure what Relay uses that information for and it also doesn’t yet solve the hardcoded `id` value that @ruslantalpa linked to above.
",alloy,wincent
1061,2016-06-22 19:16:36,"@alloy relay needs the id on everything, that's how it caches locally.
For a GraphQL schema to be relay compatible, all types need to implement the node interface (at least that's what i got so far)
",ruslantalpa,alloy
1061,2016-06-22 19:54:16,"@alloy To be consistent with the current behavior, it's probably best to infer the name of the id field from the schema's `Node` interface, but keep the rest of the logic for adding this field unchanged. In other words, if the schema's `Node` interface has an `_id` field, then always add `_id` on any type that has that field, even if it doesn't implement `Node`.
",josephsavona,alloy
1061,2016-06-23 17:21:49,"Created a PR https://github.com/facebook/relay/pull/1232

@josephsavona Thanks for the feedback!
",alloy,josephsavona
1060,2016-04-18 21:44:01,"@josephsavona Thanks, will take a look at RelayRenderer instead of RootContainer.
",dguillamot,josephsavona
1059,2016-04-19 15:26:31,"Thanks for the question, @wieseljonas. I think @NevilleS's answer is on point.

Right now you can do pretty much anything via a network layer, but depending on the complexity of your integration it may be a non-trivial amount of work.

We've extensively discussed making it easier to use Relay for this use case, but we're not actively working on it right now. We are, however, taking steps towards making Relay more modular (splitting the low-level core from the high-level React integration); this will make building arbitrary integrations more straightforward. We're definitely open to facilitating community contributions on these fronts if you are interested in helping out.

See #114 and #559 for more context on local data and the core split, respectively.
",wincent,NevilleS
1058,2016-04-20 06:13:19,"@wincent I just want to have another implementation, and also the documentation for the v 0.8.0 is not published yet , so an example will be the only thing we have other than the release Note.
",AhmadEl-Banna,wincent
1058,2016-04-20 19:35:08,"I have created a PR (https://github.com/denvned/isomorphic-relay/pull/33) on the isomorphic-relay repo however I can't get the client fetching working.. I am prompted with `RelayQueryWriter: Could not find a type name for record RmFjdGlvbjoy.` when I try to fetch from the server (server data works fine).
The error is caused because the `__typename` field is not queried and I can probably solve it by adding it manually.. but I think Relay should add that field for me when it needs it. @wincent Do you have any suggestions?
",edvinerikson,wincent
1058,2016-04-21 09:10:10,"Thanks @wincent!
It works fine when I add the `__typename` field into the query. Can you point me to the code where it checks whenever it needs the `__typename` field? 

Another question: Relay is splitting my query into multiple requests instead of batching them into one when I use arguments on the route. Is this desired behaviour? 
https://github.com/edvinerikson/isomorphic-relay/blob/relay-08-support/examples/star-wars/src/routes/StarWarsAppHomeRoute.js#L17
",edvinerikson,wincent
1058,2016-04-21 13:11:24,"@edvinerikson this is task of `RelayNetworkLayer` to combine multiple queries.
Firstly I try to combine queries into one in my own `NetworkLayer`, but it is to hacky to merge `RelayQueryRoot`s, there can be same variables names in different queries. 

And Joseph advised another solution https://github.com/facebook/relay/issues/520#issuecomment-212742629

So I implement it in https://gist.github.com/nodkz/d9a6380d55067192295382e8e490f39f
Also I was forced to write wrapper for `express-graphql` middleware. You can found it by the link above. 
",nodkz,edvinerikson
1058,2016-04-21 13:55:54,"Thanks for the info @nodkz, but do you think this still apply when you only have one query?
To be more clear, I only have one root query that gets splitted into two network requests.
e.g `factions(names: [""rebels"", ""empire""])` creates two network requests, one for each name (`rebels` and `empire`)
",edvinerikson,nodkz
1058,2016-04-22 21:04:13,"@edvinerikson spent all current day for this writing RelayNetworkLayer with middlewares https://github.com/nodkz/react-relay-network-layer
So my updating to 0.8 will be at next week. 
",nodkz,edvinerikson
1058,2016-04-22 21:19:26,"> `factions(names: [""rebels"", ""empire""])` creates two network requests, one for each name 

@edvinerikson For legacy reasons, Relay splits ""plural"" root queries into individual queries. In general we want to diff each root value separately, since different fields may be missing for different root values.
",josephsavona,edvinerikson
1057,2016-04-18 04:54:28,"Thanks @josephsavona. I currently do as your suggestion. But this introduces another problem about Data masking. Actually, City and Country contain their own fragments. Trip is currently using `City.getFragment('city')` and `Country.getFragment('country')` to combine all the fragments and send them for retrieving data. Since, Trip can't directly access to the returned data of City/Country, I have no way to send the entire structure to the back-end. The returned object is shown as following:



If I added a new country, I would like to update the countries array and send the updated one back to the database. However, I couldn't do that since the Trip can't access the countries array. What I can do is to send just the `id` of the trip and the new country name and let the back-end retrieve the Trip object by using the id, add the new country to the array, and persist it to the database. In this situation, I have to write another mutation for adding a city, and also another one for updating other properties. Am I doing it right? Should it be just simply one mutation for updating the whole trip object?

I feel like I'm doing something in the wrong way. Your advice would be really appreciated. 
",lvarayut,josephsavona
1057,2016-09-16 03:22:45,"@josephsavona I guess another alternative could be to have relay mutations do the filtering out of it's metadata before sending the result. For simple mutations this isn't really an issue but for mutations with deep nested objects it becomes annoying. For now I ended up writing a clone function that removes `__dataID__` but I feel like it could be handled by relay as some more people might hit this problem.
",janicduplessis,josephsavona
1054,2016-04-21 02:08:12,"@xuorig sorry for the delay in review. this looks pretty solid, just a few nits and we should be good to go.
",josephsavona,xuorig
1054,2016-04-21 17:29:40,"addressed your comments @josephsavona :)
",xuorig,josephsavona
1054,2016-04-28 22:10:10,"@xuorig thanks for this!
",josephsavona,xuorig
1053,2016-04-15 18:18:48,"@Globegitter We agree. One of our ideas here was to have a Relay ""debugger"" - something that optionally prints information about what Relay is doing in order to make it more obvious what's happening (diffing a query, writing data into the store, constructing a mutation query, etc). The aim would be to both help people debug when issues do occur as well as to help people learn about all the things Relay is doing behind the scenes. 

@yuzhi has been focused on this lately, but there's plenty of room for contributions here. I'd encourage you to send a PR with changes that you think would be helpful and we can discuss from there.
",josephsavona,Globegitter
1053,2016-04-18 20:35:19,"@Globegitter I agree that we definitely need something like that. As far as making it easier to debug, we can use a lot of help from the community. I haven't started working on making it easier to inspect the data Relay has cached yet. If you have time and ideas, we would love to see an PR!
",yuzhi,Globegitter
1053,2016-05-02 15:47:22,"Having worked a bit now with https://github.com/facebook/react-devtools the developer experience is currently not that great as there is no simple relay app that can just run in the iframe that they provide. And if you don't use the iframe setup you can not inspect the inspector.

So I thought @yuzhi as a first step I would make another todo app using https://github.com/relay-tools/relay-local-schema to add here as an example which can then be used for easier react devtools development.
",Globegitter,yuzhi
1052,2016-04-15 18:15:12,"@Globegitter Also, thanks for taking the time to provide such a clearly written and well-documented issue. 
",josephsavona,Globegitter
1052,2016-04-16 15:32:51,"@josephsavona Thank you for providing such a clear answer, that does make sense. Intuitively yes, it does feel a bit cumbersome but I am also really just starting to understand how all the different pieces within Relay work under the hood. 

You are saying the server can tell Relay how to update the cache? How is that possible? I haven't seen any docs about that.
",Globegitter,josephsavona
1050,2016-04-27 06:10:23,"I think we can close this out now that @yuzhi's new take on `RelayNetworkDebug` has landed in 85158ce9f88cf3c93015106e1d1df64b64b49d85. Let me know if I'm mistaken @finneganh, and thanks for contributing!
",wincent,yuzhi
1050,2016-04-27 14:18:04,"Cool, looking forward to that getting in a release.

On Wed, Apr 27, 2016 at 2:10 AM, Greg Hurrell notifications@github.com
wrote:

> I think we can close this out now that @yuzhi https://github.com/yuzhi's
> new take on RelayNetworkDebug has landed in 85158ce
> https://github.com/facebook/relay/commit/85158ce9f88cf3c93015106e1d1df64b64b49d85.
> Let me know if I'm mistaken @finneganh https://github.com/finneganh,
> and thanks for contributing!
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/pull/1050#issuecomment-214980499
",finneganh,yuzhi
1049,2016-07-29 22:31:55,"@Globegitter you're right, thanks for the reminder. This is done!
",josephsavona,Globegitter
1048,2016-04-21 17:22:27,"@jardakotesovec Thanks for providing more detail here. This came up again in #1063 (see my [comment](https://github.com/facebook/relay/issues/1063#issuecomment-213025165)). It sounds like we need to adjust RelayContainer such that it's safe to call `setVariables` from within the child's `componentWillReceiveProps` call. 

We'll look at this as time permits, but are definitely open to PRs to help here.
",josephsavona,jardakotesovec
1048,2016-04-22 02:34:07,"@jardakotesovec I think you can check your `props` before `setVariables` is called in `componentWillReceiveProps` to break the loop. For example:


",mickeyinfoshan,jardakotesovec
1048,2016-04-27 14:08:10,"@josephsavona Just wanted to drop in our solution here to show what we ended up going with, in case it might be informative for future Relay features: https://gist.github.com/finneganh/c81bd1167a07306eba7365f8e123ccfb

One note about the suggestion that you put above is that at the time of the `setVariables` callback’s ready state being “done,” the component’s props haven’t been updated and so `fetchMore` wouldn’t see the right view of the world.

We ended up putting things through `componentDidUpdate`, with some checks to both prevent double-fetching and also a backoff if the fetches are failing or otherwise not making progress (so as not to fetch on an infinite loop, especially during prod issues).

One curiosity we had was that for our prod component, `componentWillReceiveProps` was consistently called (twice actually) after the `setVariables` call errored out. In a smaller test component, it wasn’t called. I don’t know if there’s an explanation for that behavior (the prod component had sub-containers, maybe that was it?) but we ended up working around it with the `forceUpdate`.

At any rate, I found this an interesting case where we seemed to be running at odds with how Relay wants to do data access. I don’t know if that means we’re doing something particularly wrong, or just running into the law of leaky abstractions.
",finneganh,josephsavona
1047,2016-04-19 16:14:29,"Also note that we're in the process of adding a low-level mutations API based on static queries (no tracked/fat query magic by default) which you may be able to use in future to get at least part of what you want (ie. not fetching the `comments`). But as @NevilleS says, if you want consistency (and you probably do), we'll need something more.
",wincent,NevilleS
1046,2016-08-19 16:57:03,"@josercruz01  What you are doing with `previousStageId` (setting a local variable) is what I did for my fatQueries, but as I mentioned before it doesn't seem to work everytime. I honestly don't know why. I also got the same error as yours when I used the interpolation trick in other places than `getFatQuery`. At this point, I feel like it should always not work, even in `getFatQuery`. 
",joonhocho,josercruz01
1046,2017-01-13 08:50:57,"@nodkz Thanks for that information 👍  In your mutations above you have `(input: $input)` in all of them, but only one of them defines `input` as in `variables` - was that a typo or does `$input` mean something different than a thing from `variables`?",benjie,nodkz
1046,2017-01-13 11:05:02,"@nodkz 
Thanks a lot for this example. ",nikolal,nodkz
1046,2017-03-14 14:56:43,"@nodkz Hey, thanks for a great example! I'm using this approach but still there're some cases where it's not clear how to configure mutation. I've created [stackoverflow question](http://stackoverflow.com/questions/42789001/relay-range-add-queryconfig-on-searchtype), would really appreciate help with it.",valerybugakov,nodkz
1046,2017-03-14 18:29:45,"@nodkz huh, kinda solution :)",valerybugakov,nodkz
1045,2016-04-13 14:27:32,"@xuorig  I am planning on adding a way to enable a mutation debugger that will print out debug info as Relay go through each mutation config for a mutation. The plan is to print out things like the tracked query, the fat query and the resulting intersected query for `FIELDS_CHANGED` config. It will also print out  things like what connections we are prepending and appending to for `RANGE_ADD`. The goal is to make it easier to figure out what Relay is doing with the input so it's easier to debug and update mutation configs. 
",yuzhi,xuorig
1045,2016-12-20 17:51:05,@yuzhi implemented this :-),josephsavona,yuzhi
1044,2016-04-13 02:50:40,"@KyleAMathews The logic for checking Relay variables is at https://github.com/facebook/relay/blob/master/src/container/RelayContainerComparators.js#L116-L121
",josephsavona,KyleAMathews
1039,2016-04-26 14:00:37,"Going to close this for now. @vslinko, let us know if watching for updates on twitter doesn't work for you.

Generally, [one](https://twitter.com/wincent) [of](https://twitter.com/en_JS) [us](https://twitter.com/steveluscher) will announce the publication of new notes, and the others will retweet them.

If the signal-to-noise isn't high enough there, we can consider making a Relay-specific Twitter handle that would publish only Relay-specific stuff (as opposed to Relay-stuff plus tweets-about-what-we-just-ate-for-lunch).
",wincent,vslinko
1036,2016-04-08 19:05:50,"@kassens 

> Thanks!

You're welcome!
",justinanastos,kassens
1035,2016-04-08 20:10:06,"@zjlovezj: Thanks for asking!

You can expect a release soon. @steveluscher was talking about preparing one as early as today, but as you know, sometimes things come up so it could end up sliding to next week, so we'll see exactly when it falls.

As for the meeting notes, I believe @josephsavona was going to publish them, but he's been busy with other work so I think I'll just go ahead and do it now.
",wincent,zjlovezj
1035,2016-04-09 19:46:56,"Thanks @wincent!
",josephsavona,wincent
1033,2016-08-30 11:53:29,"@sibelius I am facing this issue intermittently - it's completely random and when I hit the issue the graphql server is not reachable from my device. Something weird is going on in the network (Surprising as it is the private network in my home). Is there a way to catch this error on the react native side so I can display the flaky network error, rather than a blank screen - as this could happen in production too.
",Jaikant,sibelius
1033,2016-08-31 04:23:22,"@sibelius thx! NetInfo is cool. I think I am tending towards using the render of Relay.Renderer it is kind of more abstracted.
",Jaikant,sibelius
1030,2016-06-22 21:23:21,"We're using a cache manager internally in our React Native apps, but the cache is external to Relay itself and very specific to our native FB product infrastructure, so we don't have much we can say about that. There is some evidence in Relay of the hooks that we've built in to enable that integration (and the reference to `injectCacheManager` is one of those), but given that we haven't provided (and probably can't meaningfully provide) an example, it's not something that we've emphasized in the docs.

In fact, the mention of the ""configurable cache manager"" is probably unintentional in the `RelayEnvironment` docs, because as @tlvenn points out, no `injectCacheManager` is declared in the `RelayEnvironment` class. (But you can see one on the `RelayStoreData` class, which is an `@internal` implementation detail.)

If you look in `RelayTypes`, you can see what a `CacheManager` would need to implement:



It has fire-and-forget methods for writing to the cache, and async methods for reading from it. I'd consider all of this to be subject to change, so I am reluctant to expose any of it on `RelayEnvironment` itself. If anything, we should remove that reference from the doc comment so that it doesn't cause more confusion.
",wincent,tlvenn
1030,2016-06-22 23:52:59,"As @wincent said, our plan here is to make it easier to build things like offline caching in user space, and I agree that we'd prefer not to expose the `injectCacheManager` API publicly.

If you're trying to implement it anyway though - for connections you'll notice that the `__range__` property is an instance of a `GraphQLRange`. To serialize this you can call `toJSON` on the range instance. When you load it back from disk, you may have to call `new GraphQLRange(cachedData.__range__)` - I don't remember offhand whether we do that within the cache reader or if the cache implementation has to do that.
",josephsavona,wincent
1028,2016-07-05 00:10:38,"@sibelius Yes, your answer worked for me!
",joonhocho,sibelius
1028,2016-11-22 06:49:09,@sibelius You're awesome!,Naoto-Ida,sibelius
1025,2016-04-08 00:49:08,"My use case for Relay.Environment is to be able to set a new environment (e.g. when logging out and the back in as another user).

Is it expected that eventually we'll be able to set `Relay.Environment = new Environment()`?

I'm trying to make such an amend at the moment. It requires that anywhere that uses RelayStore to be updated to use RelayPublic.Environment. I've ran into a problem in that RelayInternals is required by RelayPublic and so can't use RelayPublic.Environment as it's not been set yet.

It'd be great to get your thoughts on it @josephsavona 
",lprhodes,josephsavona
1025,2016-04-08 01:29:12,"@lprhodes The intention is that an application would maintain a reference to a single instance of `Relay.Environment`, and pass that `environment` to each root container (`Relay.Renderer`, which replaces RelayRootContainer). 

To ""reset"" on user logout, you would simply create a new environment instance (`environment = new Relay.Environment()`).

Once @tlvenn's PR lands (with the changes described above), this will be something like:


",josephsavona,tlvenn
1025,2016-04-08 01:29:48,"Good to hear @josephsavona !

I initially focused solely on the `RelayEnvironment` because that is the only one which is currently totally out of reach because it is not exported to the `lib` folder. For reference, the other 2 can be imported as such:



I will add those 2 to the API.
",tlvenn,josephsavona
1025,2016-04-08 01:42:38,"@lprhodes to handle the login/logout scenario and keep the convenience of the RelayStore singleton, you can roll your own version which is a wrapper around `RelayEnvironment`.

https://gist.github.com/tlvenn/9c468a5b50e0497bd319bfa0ab8b6c7f

@josephsavona Is it safe to actually replace the current environment without any check ? Such as:


",tlvenn,josephsavona
1025,2016-04-08 03:22:24,"@tlvenn It's obviously safe to _create_ a new `RelayEnvironment` instance at any time, since it just creates a new object that is independent of any previous environments that may already exist. Whether you want to add the additional checks is up to you (though certainly safer to check).
",josephsavona,tlvenn
1018,2016-04-05 03:32:01,"Hi @wincent 

Thanks for the update and looking forward to latest meeting notes.

We're making an attempt at a major adoption of GraphQL/Relay across our products, web and mobile, and I'm trying to find out if the ideas listed below regarding support of local/client state are still part of the plan? Are they still justified in your view? @wincent @josephsavona

API for resolving fields locally: #431.
Support querying & compiling client-only fields by extending the server schema, and a means for writing data for these fields into the cache: #114.

?
",idibidiart,wincent
1012,2016-03-31 22:30:10,"@josephsavona
Btw, my original question still sort of stands. If the schema isn't formed to Relay's expectations, is Relay totally unusable or does it mean you must manually implement paging etc? For example, could I use simple offset/limit based pagination instead of cursor based one, and still use Relay on the front-end?
",kaqqao,josephsavona
1007,2016-04-05 14:55:11,"I don't have any really good reasons other than 1) to be consistent with React's `setState` and 2) easier access to the existing `variables` (you don't have to do `this.props.relay.variables`)

If it's not already possible or (very) easily implemented then, yeah, I don't think it's worth the effort. Thanks @josephsavona 
",aweary,josephsavona
1005,2016-04-04 21:27:48,"Thanks a lot for this @alex-cory. If you can get the CLA signed I'll go and get this merged.
",wincent,alex-cory
1002,2016-03-30 05:57:24,"@josephsavona 
in the example above, `RelayContainer(MyList)` only have one fragment named `connection`, the `ChangeUserNameMutation` will change `viewer.username` (`viewer.connection` actually won't change)
",filod,josephsavona
1001,2016-03-29 17:33:18,"Seems like @xuorig already answered your question.

That callback is the called when RelayContainer is notified about the data being ready, but before the container has a chance to read all the new data from the RelayStore. You should be able to check access the props when the variables is updated.
",yuzhi,xuorig
1000,2016-08-30 23:09:13,"> Did you guys ever get a chance to think about this? We've got several places in our codebase with `// TODO: https://github.com/facebook/relay/issues/782` and hoping there'd be a better solution than the indirection layers...

I think there are a couple of main alternatives here:
1. Switch to Relay 2 when it comes out (""soon"", watch our meeting sync notes to get the latest status on our progress towards being able to push a preview to a branch on GitHub); here all queries, including mutations, are entirely static, and there is no dynamic runtime query generation (no tracked queries, no fat queries, no intersection), so this issue just goes away.
2. Use the existing low-level mutation API, `RelayGraphQLMutation` (shipped, but not documented, as it was really just a step towards what we wanted to build in Relay 2): this is also an entirely static mutation API, where you supply your own query and there are no fat/tracked queries or intersection involved. This is still somewhat of a rough API, and because it sits on top of all the ""legacy"" underpinnings in terms of mutation queues, transactions etc it does have some limitations that make it not as flexible or powerful as what we'll have in Relay 2.

In the meantime, @NevilleS, what do you want to do with this PR? I see two options: either abandon it or update it. What do you think?
",wincent,NevilleS
993,2016-06-07 04:58:41,"@josephsavona In practice, sometimes we don't need a RelayContainer for declarative data fetching, instead of we might just need ad-hoc data fetching or mutations, in this case, a contextual relay will be required. Since it throws errors when creating RelayContainer without specs, I ended up writing a simple provider. I wonder if I am missing anything.
",aihornmac,josephsavona
993,2016-11-01 00:55:06,"@taion good call, the use-case for a separate context-setter isn't really clear. Thanks for starting the discussion, @aihornmac!
",josephsavona,taion
978,2016-09-03 00:33:30,"Thanks for (another!) high-quality mutations suggestion, @NevilleS. I'm doing some spring cleaning seeing as [Relay 2](https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable) is under preparation now, and it will have a much more expressive, powerful API for expressing mutations. As such, I think it's best to close this for now. Thanks once again though!
",wincent,NevilleS
973,2016-03-22 13:45:15,"@eyston if I follow this correctly, @wincent is saying that the query resolvers (basically Relay Containers, and Relay Routes, I think?) would take over from what the current query tracker does. This wouldn't change the behaviour of intersection since the query tracker essentially just stores the fragments registered by those containers/routes. So even in the case of a `null` record, those resolvers are still observing that node, so when asked to do so they could return the same fragments a query tracker would have.

My main question about the implications of this would be related to the ""query resolver"" lifecycle. As I understand it, those observers register/deregister when the containers mount/unmount. Therefore, it's quite likely that a container would mount, fetch a node, then unmount. The node remains in the store, and then is mutated later. In this scenario, this mutation wouldn't have access to the container's query, right? So in theory the node might not be refetched; how does the store ""remember"" that the node data might be stale and should be refetched before another container attempts to render it?
",NevilleS,wincent
973,2016-03-22 15:54:09,"Hi @NevilleS ... I didn't want to tag you because I'm unsure if that is rude or not (I felt bad tagging en_js for example) but clearly I should have :)

And yah, your second paragraph is exactly my question.
",eyston,NevilleS
973,2016-03-22 16:13:46,"Phenomenal questions! 

>  If in (1) you are intersecting the fat query I'm not sure what (2) does 

@eyston Step 1 ensures that records in the store that _could_ be affected by the mutation are marked as stale (regardless of whether they will be refetched in step 2). Step 2 ensures that records affected by the mutation that are _actively being viewed_ are refetched immediately. 

> So in theory the node might not be refetched; how does the store ""remember"" that the node data might be stale and should be refetched before another container attempts to render it?

@NevilleS This gets at the same thing @eyston is wondering about with step 1 - how do we _know_ to mark something as stale without a query resolver? There are a few options that we're still exploring: changing the diff algorithm to be more conservative (perhaps diffing at a more coarse-grained level) or requiring that fat queries be specific enough that intersecting the fat query with the store would invalidate all possibly-changed records. 
",josephsavona,NevilleS
972,2016-03-22 17:47:23,"Thanks, @taion. Looks reasonable. Will import.
",wincent,taion
968,2016-03-31 23:18:23,"This is a bug - the plugin is intended to work in older environments without a polyfill. We should be using the `find` helper (required at the top of the file) instead of calling `arr.find`. 

cc @kassens 
",josephsavona,kassens
965,2016-03-18 15:44:54,"@josephsavona thanks for the response! You are right, I was missing the RootContainer and the Route at the top of the component tree, I just forgot to include them in the gist (I've updated the gist to include these files now). 

I've followed your advice and have Relay + RN Navigators working! I've updated the Gist I linked to above in case anyone is curious how how I got it to work.
",ericallam,josephsavona
955,2016-03-16 22:10:12,"Thanks for this, @everdimension!
",wincent,everdimension
949,2016-03-14 20:35:58,"Thanks for this, @sgwilym!

Related: #783 (multi-insert support) and #766 (mutations limited by only returning a single edge and cursor).

I think #538 will be the imminent relief for you here. I am currently implementing a lower-level mutations API that can be used to manually force the desired updates to take place when the current vanilla/auto-magic approach falls down. The idea is that the current API can be placed as a layer on top of the low-level API, but that you will also have the option of accessing the low-level API yourself to do any stuff that doesn't fall into the standard patterns that the high-level API supports.

Going to close this one for now as I think the need you've expressed here is already covered in those other issues.
",wincent,sgwilym
946,2016-03-14 20:26:06,"Thanks for this @everdimension. Can you resubmit please against [this file](https://github.com/facebook/relay/blob/master/website/src/relay/css/relay.css) in the master branch? The website files get generated from that.

Also, any chance of a before/after screenshot, to make this easier to review?
",wincent,everdimension
946,2016-03-16 07:37:19,"@wincent 
Ok, thanks for advice! I've resubmitted the PR here: https://github.com/facebook/relay/pull/955
",everdimension,wincent
945,2016-03-11 19:44:03,"Looks pretty good @xuorig. Thanks for this!

I'll let it sit here for couple of days to give others a chance to comment before importing.
",wincent,xuorig
945,2016-03-11 21:13:24,"thanks for the quick review @wincent! I addressed your comments.
",xuorig,wincent
945,2016-03-21 15:47:00,"@wincent anything I can do to see this merged :) ?
",xuorig,wincent
945,2016-03-28 20:52:11,"I don't know if that worked @wincent :panda_face:
",xuorig,wincent
944,2016-03-14 11:43:49,"@yungsters is this blocked on something? I need it to solve https://github.com/facebook/relay/pull/943#issuecomment-195069985 - just setting `compact: false` doesn't seem to be enough.
",josephsavona,yungsters
943,2016-03-10 20:56:36,"@yungsters i completely removed both node_modules directories and reinstalled - this is what i'm getting after `npm run update-fixtures`. Maybe a default setting changed in babel?
",josephsavona,yungsters
942,2016-03-10 21:01:06,"@yungsters Of couse you are right! And actually I also knew it when did refactoring. I don't know why I wrote ""with truthy `ready` flag"" in the description. :smile: Corrected the description. The actual implementation is correct, I believe.
",denvned,yungsters
935,2016-07-07 00:53:41,"@gre class properties after babel-core 6.5 does not work with passPerPreset.(https://phabricator.babeljs.io/T7274)

@steveluscher wondering if `passPerPreset` is required now.
",chirag04,steveluscher
929,2016-03-09 04:41:18,"Awesome stuff @steveluscher 
",skevy,steveluscher
921,2016-03-08 19:15:20,"@denvned Can you provide an example of how this would be used to implement server rendering? Would the new `initialReadyState` prop be used on the server, client, or both? It isn't obvious how this prop would be sufficient to render on the client given that data was fetched on the server. Data would have to be provided to the store from the server regardless. 

As an alternative to this approach, how about creating an ""isomorphic"" RelayEnvironment implementation to be used as below. You could compose environment instances and override the implementation of key methods - forceFetch, primeCache - to skip work when data was already fetched:


",josephsavona,denvned
921,2016-03-08 20:32:46,"@josephsavona 

> Can you provide an example of how this would be used to implement server rendering?

Sure, it mostly follows your recommendations in https://github.com/facebook/relay/issues/589#issuecomment-156169239, and https://github.com/facebook/relay/issues/589#issuecomment-156195977:



In both cases `props` are `{Container, environment, initialReadyState, queryConfig}`.

> Would the new `initialReadyState` prop be used on the server, client, or both?

We need it on both, because the data should be ready on the client during the initial render, otherwise React wouldn't reuse server-side rendered markup.

> override the implementation of key methods - forceFetch, primeCache - to skip work when data was already fetched

Actually, I have already tried that approach but unsuccessfully: https://github.com/facebook/relay/pull/625#issuecomment-185375491. Also I think passing `initialReadyState` is more clean solution.
",denvned,josephsavona
921,2016-03-09 15:28:10,"I see, thanks for clarifying. You're referring to your [comment](https://github.com/facebook/relay/pull/625#issuecomment-185375491):

> ...React throws an error because onReadyStateChange calls setState, and React does not allow calling setState before mount.

This makes sense - `RelayRenderer` currently assumes rendering will be asynchronous, but if we're rendering on the client with data from the server it needs to be synchronous.

My concern here is that the shape and value of `initialReadyState` is an implementation detail that users shouldn't have to know about. However, exposing it as a prop makes it part of the public API and requires us to continue supporting it which we'd prefer to avoid.

I'd like to see a proposal that uses some form of composition in order to avoid the need to change the `RelayRenderer` API. For example, the API I proposed above could be achieved by creating an `<IsomorphicRelayRenderer>` that uses RelayRenderer internally _except_ for the first render on the client (add whatever prop you need to indicate that the first render should resolve synchronously from pre-populated data). In general, we'd like to move towards providing lower level primitives (#559) and encourage composition over a monolithic core.

To summarize, rather than proceed with this PR I propose that we:
- Implement an IsomorphicRelayRenderer outside of `react-relay` so that users can do server rendering today
- Provide lower-level primitives to make `isomorphic-relay` easier to implement via all public methods.

@denvned what do you think?
",josephsavona,denvned
921,2016-03-09 16:50:07,"I have also been working on a lower-level component that RelayRenderer would compose. I came to the same conclusion as @denvned that feeding in a `readyState` object was sufficient. Where my line of thinking differed was that I was thinking of building a lower level `RelayReadyStateRenderer` that always synchronously rendered the supplied `readyState`.

@denvned Do you want to take a stab at this? Or want me to go ahead and build it (which is what I was planning on doing today)?
",yungsters,denvned
921,2016-03-09 17:38:52,"> My concern here is that the shape and value of `initialReadyState` is an implementation detail that users shouldn't have to know about. However, exposing it as a prop makes it part of the public API and requires us to continue supporting it which we'd prefer to avoid.

I thought that it could be an undocumented, internals only prop that is passed exclusively as a part of opaque `props` returned by `prepareData` and `injectData` (as in my example above).

> creating an <IsomorphicRelayRenderer> that uses RelayRenderer internally _except_ for the first render on the client

Nice idea! I think I even see all the details of a possible implementation (probably the trickiest part is to not allow `RelayRenderer` to destroy DOM tree on the second render on the client). But we need to make a public API in Relay that will allow to get `props` (containing fragment pointers) by a given `Container` and `queryConfig` that we then would pass to `Container` during the first render, or alternatively we probably can use `RelayReadyStateRenderer` proposed above by @yungsters to solve this.

> Do you want to take a stab at this? Or want me to go ahead and build it (which is what I was planning on doing today)?

@yungsters, I can not wait to see it, but would not be able to build it myself today. So please do it! :+1: 

> To summarize, rather than proceed with this PR

@josephsavona, I think the first commit of this PR is still useful, it cleans up `RelayRenderer` a lot without changing API or behaviour. Maybe you can cherry-pick it?
",denvned,yungsters
921,2016-03-09 17:38:52,"> My concern here is that the shape and value of `initialReadyState` is an implementation detail that users shouldn't have to know about. However, exposing it as a prop makes it part of the public API and requires us to continue supporting it which we'd prefer to avoid.

I thought that it could be an undocumented, internals only prop that is passed exclusively as a part of opaque `props` returned by `prepareData` and `injectData` (as in my example above).

> creating an <IsomorphicRelayRenderer> that uses RelayRenderer internally _except_ for the first render on the client

Nice idea! I think I even see all the details of a possible implementation (probably the trickiest part is to not allow `RelayRenderer` to destroy DOM tree on the second render on the client). But we need to make a public API in Relay that will allow to get `props` (containing fragment pointers) by a given `Container` and `queryConfig` that we then would pass to `Container` during the first render, or alternatively we probably can use `RelayReadyStateRenderer` proposed above by @yungsters to solve this.

> Do you want to take a stab at this? Or want me to go ahead and build it (which is what I was planning on doing today)?

@yungsters, I can not wait to see it, but would not be able to build it myself today. So please do it! :+1: 

> To summarize, rather than proceed with this PR

@josephsavona, I think the first commit of this PR is still useful, it cleans up `RelayRenderer` a lot without changing API or behaviour. Maybe you can cherry-pick it?
",denvned,josephsavona
921,2016-03-09 20:34:55,"> I thought that it could be an undocumented, internals only prop

I understand this line of thinking, and it's really tempting. Unfortunately if someone _can_ pass it as a prop and depend on its behavior, they _will_, and this limits our flexibility. I really like @yungsters idea of a lower-level `RelayReadyStateRenderer` that you can use if you know what you're doing, and keeping a higher-level component that most people will use.

> the trickiest part is to not allow RelayRenderer to destroy DOM tree on the second render on the client

I would imagine that this new component would render the root component directly at first, until the point that the props have changed and data needs to be fetched from the server. At that point you'd render a `RelayRenderer` and let it do the data-fetching (or possibly implement that yourself with other low-level APIs).

> ...Maybe you can cherry-pick it?

Agree that the first commit is worth discussing on its own; no rush, maybe split that off into a separate PR as time permits?
",josephsavona,yungsters
921,2016-03-10 19:47:01,"> Agree that the first commit is worth discussing on its own; no rush, maybe split that off into a separate PR as time permits?

@josephsavona I've made a separate PR, #942.
",denvned,josephsavona
921,2016-03-18 19:06:03,"@denvned Does 8074aa0cdc7fb3fb85be9634d1a34d6650dfa307 suit your needs?
",yungsters,denvned
921,2016-03-18 20:27:34,"@yungsters Looks like it should. Thanks!
",denvned,yungsters
916,2016-03-06 13:44:42,"@chandu0101 Thanks for reporting this. It appears the problem is [in `diffRelayQuery`](https://github.com/facebook/relay/blob/master/src/traversal/diffRelayQuery.js#L97-L99) where we assume that a plural root field's argument type is `ID` (this is true for `nodes` but not true in the general case). See #917 for a fix that you can apply locally now if this issue is blocking you.
",josephsavona,chandu0101
916,2016-03-06 15:32:28,"@chandu0101 Can you confirm that this PR fixes your issue?
",josephsavona,chandu0101
916,2016-03-06 22:49:30,"@josephsavona just got the new changes and app is working perfect :) 
",chandu0101,josephsavona
916,2016-03-06 23:50:03,"@josephsavona 

i am seeing these warnings in my console 


",chandu0101,josephsavona
916,2016-09-03 00:42:49,"Doing some cleaning of stale issues, so going to close this one. Original issue seems fixed, and as for the warnings, the write-side implementation is being completely replaced in [Relay 2](https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable), so this is unlikely to remain an issue in the future. Thanks @chandu0101!
",wincent,chandu0101
915,2016-06-24 22:57:48,"Sorry for leaving this one unattended for so long, @xuorig. Going to pull it in and see if it applies, tests pass etc.
",wincent,xuorig
899,2016-03-03 18:10:11,"@schickling Did you resolve this? The error indicates that there is no `viewer` field on the Query type in your schema.
",josephsavona,schickling
898,2016-03-03 18:02:01,"This is great!

_But_ as @josephsavona points out, won't be needed once everything is isolated inside `RelayContext`. The concern that we'll soon delete the `reset()` API is valid, but I actually think there's a deeper reason that even having the API in the first place is a bit wrongful. Being able to reset to a clean state via mutating is a fundamentally brittle design (even if it's right now, what if somebody ends up adding additional global state outside the `RelayStoreData`?) compared to literally replacing the entire context. So, I think we should hold off on this for now and if you need something like this you can run with a patch on top of base Relay. Thoughts?
",wincent,josephsavona
898,2016-03-07 11:46:36,"@Globegitter Thanks for opening this PR - it helps us see what features people are most interested in and moves the discussion forward (even if the PR itself doesn't land). Definitely check out the [help-wanted tag](https://github.com/facebook/relay/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22) for other places to contribute!

Closing per discussion above - there are pending diffs for all the remaining code changes on #558.
",josephsavona,Globegitter
897,2016-03-09 20:11:38,"I agree that this is a valid use-case, but it also seems to be uncommon enough that it would be preferable to avoid increasing the API surface area, as @wincent mentioned. 

Rather than add more API/options, I think we'll make more progress as a community if we focus on low-level primitives that can be composed together. What if it was so easy to build your own Relay Container that you could just do that and write your own `shouldComponentUpdate`?
",josephsavona,wincent
897,2016-03-09 20:13:04,"@KyleAMathews the problem is that Relay will currently act as a static container and block updates, when the OP would prefer that it doesn't (bc data has changed on context).
",josephsavona,KyleAMathews
897,2016-03-09 20:13:56,"@josephsavona ah :) didn't read the OP very closely I guess.
",KyleAMathews,josephsavona
897,2016-04-14 15:47:29,"I'm not crazy about increasing the surface area of RelayContainer, but the workaround (as documented by @taion) is not at all obvious. Let's move forward with this. 
",josephsavona,taion
896,2016-03-27 10:05:48,"@steveluscher Thanks. I guess it won't work for me. I'm using react-router so the given route seems like something that was generated by it. I actually need to choose the component based on a parameter (called 'hash' in my case), but I don't see any way to do it...
",shaimo,steveluscher
896,2016-07-25 17:35:32,"@taion You can define the function wherever you want, as long as you make sure that `variables` are in scope.
",josephsavona,taion
896,2016-07-25 21:21:25,"@taion This is just like any function - if you need access to `variables` in the helper, you have to pass it:


",josephsavona,taion
890,2016-03-01 19:14:19,"Thanks, @chentsulin.
",yungsters,chentsulin
887,2016-03-01 15:14:41,"@kassens `67b6957` fixes the problem for me in react-native.
",chirag04,kassens
887,2016-03-01 17:10:54,"Manually applied the changes from @kassens PR. Works for me. :+1: 
",schickling,kassens
887,2016-03-12 01:27:23,"@schickling what do you think of this https://github.com/relayjs/relay-starter-kit/pull/77 ?
",eugenehp,schickling
885,2016-03-02 17:57:18,"@nodkz Thanks for helping out. Note, however, that `type` is not a reserved fieldname in Relay and that the use of `id` is correct here.
",josephsavona,nodkz
883,2016-02-26 23:40:03,"Super weird - I threw out my node_modules, did npm install again and now it's working! It was also mentioned in the Discord chat that someone had had a similar issue a few weeks back, which was solved by making sure babel-relay-plugin was at the same version as Relay itself. I tried that with no success before posting here, but maybe that was the issue anyway and a fresh npm install fixed it?

Anyway, I'll close this issue now as it's working but I'll keep this fresh in mind if I see anyone else with similar issues. @josephsavona thank you very much for your extremely quick replies and your help!
",zth,josephsavona
880,2016-03-31 22:48:55,"@kassens not sure if I'm missing something but Relay and babel-relay-plugin should be compiled with Babel 6 now? (checking if there's issues that should be closed)

**Edit** 
I see now that only babel-relay-plugin is compiled with babel 6
",edvinerikson,kassens
873,2016-02-24 01:32:27,"@kassens I think it is babel related https://phabricator.babeljs.io/T6964
",r0b1n,kassens
861,2016-02-21 19:00:10,"@ryancole Yeah, I'm always happy to explain more about how Relay works ;-)

In this case, what's happening is that you're fetching some record:



Because everything is a concrete type it's okay to query fields directly w/o conditioning on type (i.e. you don't need to do `viewer { ... on SomeType { session } }`). However when Relay tries to refetch `session`, it doesn't have an id, so it looks up the ""path"" to foo from the nearest node that does have an id, in this case the `viewer` record. It constructs a query:



And fills in everything that was on the path from node 123 down to session:



Every part of this query is valid except the very first field: in the original query `session` was a direct field of a concrete type (so no need to condition), but now it's a direct field of different type, `Node`, which doesn't have a `session` field. Relay should use its knowledge of the type of record 123 to construct the conditioning fragment and generate the correct:



The logic for handling this case is in [RelayQueryPath](https://github.com/facebook/relay/blob/master/src/query/RelayQueryPath.js#L125-L182) - the fix is to wrap the final [set of children](https://github.com/facebook/relay/blob/master/src/query/RelayQueryPath.js#L174-L178) in a fragment whose type is determined by looking it up in the store. 
",josephsavona,ryancole
861,2016-02-21 22:19:56,"@ryancole yeah, an `id` on session is a good workaround.
",josephsavona,ryancole
861,2016-02-25 01:57:34,"@ryancole this is now fixed on master, i'm going to close out the issue. thanks again for reporting this :-)
",josephsavona,ryancole
858,2016-03-03 16:20:04,"@legomind, @schickling - are logged out users able to access _any_ GraphQL data in your apps? An approach we often use is to not even query the GraphQL server until the user is logged in - this avoids having fields start out `null` when they really aren't.

Another approach going forward will be to have one RelayContext (currently not public API yet) before the user logs in to store unauthenticated data, and then create a new context after the user logs in. In the meantime, though, could you work around this by not issuing queries until login?
",josephsavona,schickling
858,2016-03-03 17:40:18,"@schickling Yes, it feels very, very wrong.

@josephsavona Currently, authentication is actually performed using mutations (I just updated the original post), so that approach would not work. Even if I was to move authentication out of graphql, how would I prevent the initial queries? Just avoid rendering a RootContainer?
",legomind,schickling
858,2016-03-03 17:40:18,"@schickling Yes, it feels very, very wrong.

@josephsavona Currently, authentication is actually performed using mutations (I just updated the original post), so that approach would not work. Even if I was to move authentication out of graphql, how would I prevent the initial queries? Just avoid rendering a RootContainer?
",legomind,josephsavona
858,2016-03-03 20:01:59,"Thanks for the clarification @josephsavona! Is there any rough timeline for the multiple RelayContext feature?
",schickling,josephsavona
850,2016-03-01 21:40:04,"@steveluscher i am running the todo example, but this is all i see

![screen shot 2016-03-01 at 4 37 52 pm](https://cloud.githubusercontent.com/assets/1045265/13442808/fe0ab784-dfcb-11e5-912a-555b68646964.png)

the graphql post requests seem to return an error and then the page just reloads. 

the console shows `Warning: fetchWithRetries: HTTP timeout, retrying.` right before the page reloads

however, the webpack server and graphql server are both running...
",gad2103,steveluscher
849,2016-02-18 02:46:26,"Thank you @josephsavona 

[Here is the Question](http://stackoverflow.com/questions/35471836/loading-indicator-after-this-props-relay-setvariables-triggered-fetch) on Stack Overflow.
",BerndWessels,josephsavona
848,2016-02-18 05:40:06,"> or prepareData is somehow transforming it incorrectly.

@josephsavona, `prepareData` just intercepts calls to `RelayStoreData#handleQueryPayload` and convert the query to a plain object using `toGraphQL.Query` from Relay (as you suggested [here](https://github.com/facebook/relay/issues/589#issuecomment-156469672)):
https://github.com/denvned/isomorphic-relay/blob/ac2ce85d48be592f7d735c1849b762f10b3ad72d/src/prepareData.js#L15-L16
",denvned,josephsavona
848,2016-02-18 14:31:30,"@denvned - The only customization to our network layer allows for sending the request to graphql via `get` rather than `post` (for caching reasons). Although I did notice this issue prior to that customization.

The schema for `Image` is [here](https://gist.github.com/jeromecovington/c459f170a1604f74d6cb).
",jeromecovington,denvned
848,2016-02-18 17:28:57,"@denvned Yeah there may be issues with how `Image` is being handled in the data transform layer. Let me sort that out and then we'll see. I do appreciate you and @josephsavona taking the time to help me step through what may have ultimately turned out to be an internal data issue!
",jeromecovington,denvned
848,2016-02-18 17:28:57,"@denvned Yeah there may be issues with how `Image` is being handled in the data transform layer. Let me sort that out and then we'll see. I do appreciate you and @josephsavona taking the time to help me step through what may have ultimately turned out to be an internal data issue!
",jeromecovington,josephsavona
848,2016-02-18 20:17:42,"@denvned I am (seeing)[https://gist.github.com/jeromecovington/4a2058b5f8c18b96a9ef] the `id` field of `Image` to be optional (not `GraphQLNonNull`), should we not be able to query against type `Image` without asking for or needing an `id`? In this query I am not asking for the `id`, yet am still bumping up against the `TypeError` in `isClientID`.
",jeromecovington,denvned
844,2016-02-22 17:25:28,"@josephsavona for `stableStringify` the different is in unit test.
The main need is for query arguments. The old `stableStringify` return a string to `""string""` ( this is caused by JSON.stringify). this will conflict with passed in string arguments (which be treated to raw `string`,in some old code ).

There are two changes in return:
1.  string type old `'""test""'` => `'test'` (This change is required by query arguments)
2.  array `[0:""a"",1:""b""]` =>  `[""a"",""b""]`  (This change is not required,but since the old style is only used by one unit test file, and do not affect old src code, so i change this, to make it simpler ,shorter and Standarder, and,the stringify string can be parsed back to object by JSON.parse.  ).
",iamchenxin,josephsavona
844,2016-02-22 18:49:55,"@josephsavona i havent test this in a real relay project yet. I should test it tomorrow to check if it is all right.
",iamchenxin,josephsavona
844,2016-02-23 07:12:00,"@josephsavona Since Relay  will allow use complex object as Arguments for query later.
Maybe there will be some strange values passed in  by user.
This is one reason i seperated the `type check` and `stringify algorithm` from `stableStringify`. So will be easier to add some relay store type which different from jstype. 



I have a thought about `holes-array`  [stableStringify-test.js#L55](https://github.com/iamchenxin/relay/blob/fixGraphQLFragment/src/query/__tests__/stableStringify-test.js#L55)
Consider this:



Should we treat `[null, undefined, null, 'foo']` and `[null, , null, 'foo']` as a same data or not ?

---

Seems the mostly input values will be passed in is from babel-relay-plugin,i should check all possible passed in values  by `babel-relay-plugin`. But `stableStringify` can also be used by other parts. So the behaviors should keep consistent with each other
",iamchenxin,josephsavona
844,2016-02-24 18:46:05,"@josephsavona @steveluscher I test this fix in real relay project. And find something strange,this is the last point do not support object. [forEachRootCallArg](https://github.com/facebook/relay/commit/425f309e82976b974d291e63b4676ff9d45d4390#diff-41479ecf3670e4e60511fb37625a0e1aR54) 
In this function , i modified the code from old `fn('' + identifyingArgValue)` to fn( identifyingArgValue), but when test with an object arg, the `identifyingArgValue` was still automaticly converted to `[object object]` , im not sure why this will happen, its just a callback (an arrow function from [RelayOSSNodeInterface.js#L83](https://github.com/facebook/relay/blob/425f309e82976b974d291e63b4676ff9d45d4390/src/interface/RelayOSSNodeInterface.js#L83) ),when the `identifyingArgValue` passed in its immediately turned to a `[object object]`
",iamchenxin,josephsavona
844,2016-02-24 19:05:33,"@iamchenxin thanks for working on this. it looks like it's pretty close. Rather than go back and forth here on stylistic concerns and minor functionality details, i'm going to go ahead and import this and make the last few edits necessary to ship it.

@facebook-github-bot import
",josephsavona,iamchenxin
844,2016-02-24 19:09:00,"@josephsavona Its all right now! I find it is some bugger from chrome's debug mode ? maybe from some cached code? when i reflash the `script` many times and shutdown chrome and reopen, the `fn( identifyingArgValue)` suddenly work well. and do not call toString() automaticly.
",iamchenxin,josephsavona
844,2016-02-24 19:22:14,"@josephsavona 
Maybe still have some hidden problem .. `forEachRootCallArg` with `mixed` type the flow result is (i will check them tomorrow as soon as i have my free time)


",iamchenxin,josephsavona
844,2016-02-24 20:00:12,"@iamchenxin That's cool, i can look into it.
",josephsavona,iamchenxin
844,2016-02-25 05:11:38,"@josephsavona Seems , it is finally finished , i test this in some real project. But still need to write more new unit tests for this.I should add the unit test later ,after i learn jest .(at now i have some difficulties to write complex unit test).
",iamchenxin,josephsavona
844,2016-02-25 05:50:16,"@josephsavona Rebased to master,But when i test with the new master.
even in the master branch , i get this error too.


",iamchenxin,josephsavona
844,2016-02-25 21:36:01,"@iamchenxin That should be fixed with #881. Try to rebase on master again.
",kassens,iamchenxin
844,2016-02-26 06:04:03,"@kassens thank you , rebased
",iamchenxin,kassens
844,2016-02-29 05:12:11,"@josephsavona should this need reimport? it rebased after import.
",iamchenxin,josephsavona
844,2016-03-02 23:48:06,"@iamchenxin Thanks so much for working on this. When I imported and reviewed the code, I realized that all of the call sites of `forEachRootCallArg` were actually doing the same logic to convert the value to a key. Normally I'd make edits on the original PR, but in this case the changes ended up being quite extensive. I've created two new PRs that build on your implementation in #894 and #895, so I hope you don't mind if I close this PR and continue discussion there. Thanks again for doing so much work on this!
",josephsavona,iamchenxin
844,2016-03-03 12:57:15,"@josephsavona Its okay. Hope i did not add some hidden bugs  in ,  and will keep a watchful eye on them.
",iamchenxin,josephsavona
843,2016-02-15 20:37:57,"@KyleAMathews Can you paste the relevant portion of the query and schema?
",josephsavona,KyleAMathews
843,2016-02-19 22:50:13,"You're right @wincent - testing in my current app seems to confirm no magic ""Item"".
",jeromecovington,wincent
840,2016-02-20 07:09:47,"OK great! I moved the babel-relay-plugin into devDeps and you were right @kassens!
Also, Travis-CI is failing a test that will be fixed in #810
",raineroviir,kassens
840,2016-02-25 17:16:05,"@raineroviir that's from a commit of mine yesterday, i'm trying to figure out why Set isn't available and will report back here.
",josephsavona,raineroviir
839,2016-02-15 18:06:04,"@F21 @albertstill thanks for the extra information, I see what's going on. This is an inadvertent side-effect of d55b04ebb11a105f7f63eb8a2ce82b782be22d78, which explicitly set all query metadata including the `node` field's argument type. The printer sees this type and prints it as-is - i'll change the type to `ID!`.
",josephsavona,albertstill
836,2016-02-13 19:56:00,"@voideanvalue It looks like `RelayMutationTransaction` does allow you to defer the server request for each item until you actually issue a `commit`, but I don't see a way to batch transactions into a single commit. Without the batching we would still be sending a server request for each commit since [each `RelayMutationTransaction` is bound to a single `ClientMutationId`.](https://github.com/facebook/relay/blob/master/src/mutation/RelayMutationTransaction.js#L26) Maybe batching into a single server request is not possible?
",jurassix,voideanvalue
836,2016-02-14 17:22:34,"@voideanvalue Yeah I was leaning towards _ii_ as a solution as well. Thx for confirming.

I guess I need to build this out as an example to see the complexity involved. It seems that if I'm an _item_ then I will not have context of other _items_, so I would need to move the transaction mgmt to the parent since it would provide visibility to all _children items_. Then from the parent I could map over my children, [using _getPendingTransacitons_ API](https://facebook.github.io/relay/docs/api-reference-relay-container.html#getpendingtransactions), rollback the individual transactions, and consolidate those into a single mutation. There are still some open questions here I'll have to figure out during implementation, like actual _knowing_ what changed from each child, and translating that into a single transaction.

This does seems like something Relay could provide; managing individual transactions and consolidating to a single transaction seems like a lot of responsibility for a React Component. I'll wait to see how it works in practice tough before requesting a change to the Framework ;)
",jurassix,voideanvalue
828,2016-02-12 16:02:42,"Great questions! And thanks, @chandu0101, for following up with your approach.

> It would be great if there were a self-contained Relay package that could run entirely client-side.

This gets at why the plugin is necessary in the first place. Relay needs information from the GraphQL schema in order to interpret queries correctly. Examples include knowing the types of all fragments and fields, and being able to distinguish whether `friends(first: 10)` should return a list or connection. In practice, the schema can be far too large to load in full on the client (encoding bits of the schema in each query also ensures that performance is proportional to the part of the schema you actually use).

That said, we've discussed the idea of a schema-less Relay in which the queries themselves were simple objects, and any schema-level metadata was encoded in a composing layer (technically the queries _are_ simple objects, but there's enough metadata that they aren't fun to write by hand). If that sounds vague, it is. tl;dr we're open to this idea but for the foreseeable future we're likely to continue using the plugin.

> I searched for issues about decoupling Relay from Babel but didn't find any. What is the status of this? Is Relay going to be permanently tied to Babel or is this temporary?

We don't currently use Relay with any compile-to-JS languages internally, so the core team is not likely to work on this directly. However, we are open to making changes to support using Relay in these languages. The best bet might be to submit a PR that changes the plugin to work with your language so we can discuss something concrete.

If you're interested in working on this, note that we've tried to structure the plugin in a way that most of the babel-specific code is in `getBabelRelayPlugin`. The code to compile source string + schema into output code is in [RelayQLTransformer](https://github.com/facebook/relay/blob/master/scripts/babel-relay-plugin/src/RelayQLTransformer.js). This file accepts a babel object as an input and uses it only for constructing JS AST nodes (we used to use string concatenation - not recommended). You might try exporting RelayQLTransformer and modifying it to work with your language - let's go from there.
",josephsavona,chandu0101
828,2016-03-14 19:57:31,"Thanks, @josephsavona. After looking through the code and discussing this with @stubailo in Slack, it seems quite a bit more complicated than I hoped, in large part due to my lack of familiarity with Babel, Flow, and the rest of the modern JS ecosystem. I'll try to get to it eventually, though I hope that someone who is familiar with this and can knock it out it a couple hours will do so. For what it's worth, this seems like a crucial step in growing Relay within the larger community (ClojureScript, TypeScript, etc.), and, if someone does refactor this to support a portable compiler function, I will commit to packaging it for use by the ClojureScript community.
",DomKM,josephsavona
828,2016-03-18 17:33:06,":edit: oops I am dumb @chandu0101 posted this approach as the first comment ;p

I messed with this a month or so ago (just saw this issue).  The thing I was doing, and no idea if it was a good idea or not, was shelling to node.js from clojure.  So you might have something like:



This would call the babel transformer directly with the Relay plugin configured, get the AST, and then execute it (it turns an AST of a function call so you have to eval it), and return a JSON string of the AST.  This json string could then be parsed by clojure.

I am clojurescript dumb so I wasn't sure the best way to do this so it happens in clojure vs clojurescript.  I think a macro would happen in clojure and clojurescript could be left with just a js object?



I also tried a reader literal:



The downside to this whole approach was that I was shelling to node.js per query ... so that is slow.  Ideally nashorn could do this but I read it can't load babel so didn't even try.  I'm sure you could do it so that it fires node.js once and then just streams queries in / out ... but I am not that smart :).

Knowing that the babel stuff is passed as parameters to the Printer sounds rad.  I'd like to give that a try so I wouldn't need babel and could do this all in nashorn.
",eyston,chandu0101
828,2016-03-18 17:57:42,"@eyston That's very similar to what I am currently doing.



I opened https://github.com/facebook/relay/issues/962 specifically because I'd like to switch from shelling out to Node to directly compiling in Nashorn. The only thing stopping us JVM users (CC @chandu0101) from using Relay with Nashorn is that `babel-relay-plugin` and `graphql-js` currently lack UMD builds.
",DomKM,chandu0101
820,2016-03-03 09:52:50,"Great question @ianstormtaylor and thanks for the clarification @wincent.

But am I right with the assumption that as of now (currently version `0.7`) you **have to** use the `viewer` property?
",schickling,wincent
820,2016-03-03 15:06:01,"@schickling: Yeah as of the current version you have to use `viewer` (or some other root field like it) to work around the limitations described in #112. See also [Dan's comment](https://github.com/facebook/relay/issues/112#issuecomment-170648934) on that issue and its predecessors for some caveats about working with `viewer`.
",wincent,schickling
820,2016-03-03 16:05:54,"Thanks @wincent. I guess it would make sense to make this more clear in the docs, at least for now to avoid some confusion for new users :-)
",schickling,wincent
818,2016-02-21 11:21:22,"@josephsavona I like the idea that the GraphQL server exposes the whole schema on an endpoint. Are there any possible downsides to this? I guess this could also be implemented by a external (express) library for now?
",schickling,josephsavona
816,2016-02-11 16:56:45,"@denvned We agree on all counts. One option is to extend GraphQL to allow named fragment references:



This is great for Relay, but could mean that GraphQL response payloads are inflated, as data that would otherwise be available under the same key is now duplicated under each alias:


",josephsavona,denvned
816,2016-09-28 16:26:42,"@josephsavona I have [one more nesting.](https://facebook.github.io/relay/prototyping/playground.html#source=class%20ChildComponent%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20const%20%7Bhello%7D%20%3D%20this.props.greetings%3B%0A%20%20%20%20return%20%3Ch1%3E%7Bhello%7D%3C%2Fh1%3E%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20ChildContainer%20%3D%20Relay.createContainer%28ChildComponent%2C%20%7B%0A%20%20initialVariables%3A%20%7B%0A%20%20%20%20name%3A%20'A'%2C%0A%20%20%7D%2C%0A%20%20fragments%3A%20%7B%0A%20%20%20%20greetings%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Greetings%20%7B%0A%20%20%20%20%20%20%20%20hello%28name%3A%20%24name%29%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%0A%7D%29%3B%0A%20%20%0A%20%20class%20TeenComponent%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20return%20%28%0A%20%20%20%20%20%20%3CChildContainer%20%7B...this.props%7D%20%2F%3E%0A%20%20%20%20%29%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20TeenContainer%20%3D%20Relay.createContainer%28TeenComponent%2C%20%7B%0A%20%20initialVariables%3A%20%7B%0A%20%20%20%20name%3A%20null%2C%0A%20%20%7D%2C%0A%20%20fragments%3A%20%7B%0A%20%20%20%20greetings%3A%20%28%7Bname%7D%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Greetings%20%7B%0A%20%20%20%20%20%20%20%20%24%7BChildContainer.getFragment%28'greetings'%2C%20%7Bname%7D%29%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%0A%7D%29%3B%0A%0Aclass%20ParentComponent%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20%2F%2F%20***%20have%20to%20pass%20%60name%60%20prop%20here%20***%0A%20%20%20%20return%20%28%0A%20%20%20%20%20%20%3CTeenContainer%20%7B...this.props%7D%20%2F%3E%0A%20%20%20%20%29%3B%0A%20%20%7D%0A%7D%0A%0Aconst%20ParentContainer%20%3D%20Relay.createContainer%28ParentComponent%2C%20%7B%0A%20%20initialVariables%3A%20%7B%0A%20%20%20%20name%3A%20null%2C%0A%20%20%7D%2C%0A%20%20fragments%3A%20%7B%0A%20%20%20%20greetings%3A%20%28%7Bname%7D%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Greetings%20%7B%0A%20%20%20%20%20%20%20%20%24%7BChildContainer.getFragment%28'greetings'%2C%20%7Bname%7D%29%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%0A%7D%29%3B%0A%0Aclass%20Route%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20'Hello'%3B%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20greetings%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20query%20GreetingsQuery%20%7B%0A%20%20%20%20%20%20%20%20greetings%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%3B%0A%7D%0A%0AReactDOM.render%28%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20Component%3D%7BParentContainer%7D%0A%20%20%20%20route%3D%7Bnew%20Route%28%7Bname%3A%20'B'%7D%29%7D%0A%20%20%2F%3E%2C%0A%20%20mountNode%0A%29%3B%0A&schema=import%20%7B%0A%20%20GraphQLObjectType%2C%0A%20%20GraphQLSchema%2C%0A%20%20GraphQLString%2C%0A%7D%20from%20'graphql'%3B%0A%0Avar%20GREETINGS%20%3D%20%7B%0A%20%20hello%3A%20'Hello%20world'%2C%0A%7D%3B%0A%0Avar%20GreetingsType%20%3D%20new%20GraphQLObjectType%28%7B%0A%20%20name%3A%20'Greetings'%2C%0A%20%20fields%3A%20%28%29%20%3D%3E%20%28%7B%0A%20%20%20%20hello%3A%20%7B%0A%20%20%20%20%20%20type%3A%20GraphQLString%2C%0A%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20%7B%20type%3A%20GraphQLString%20%7D%2C%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20resolve%3A%20%28%7B%7D%2C%20%7Bname%7D%29%20%3D%3E%20%60Hello%20%24%7Bname%7D!%60%2C%0A%20%20%20%20%7D%2C%0A%20%20%7D%29%2C%0A%7D%29%3B%0A%0Aexport%20default%20new%20GraphQLSchema%28%7B%0A%20%20query%3A%20new%20GraphQLObjectType%28%7B%0A%20%20%20%20name%3A%20'Query'%2C%0A%20%20%20%20fields%3A%20%28%29%20%3D%3E%20%28%7B%0A%20%20%20%20%20%20greetings%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20GreetingsType%2C%0A%20%20%20%20%20%20%20%20resolve%3A%20%28%29%20%3D%3E%20GREETINGS%2C%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%7D%29%2C%0A%20%20%7D%29%2C%0A%7D%29%3B%0A) why error in this case. thanks.

Edit:  I made a mistake. changing line 54 to `TeenContainer.getFragment` made it work
",bsr203,josephsavona
814,2016-02-12 15:15:51,"@josephsavona I just did and the bug is no longer there. Thanks.
",ooflorent,josephsavona
801,2016-02-07 22:48:47,"@ryancole Thanks for working on this! See feedback for how to make this even better :-)
",josephsavona,ryancole
801,2016-02-08 19:04:59,"@josephsavona Alright, I think I've addressed your feedback. The code now uses `Map { value => { type, variableID }}`. Changing it from the previous `Object { variableID: { type, value }}` required a few changes elsewhere, and also removed the usage of a couple imports.
",ryancole,josephsavona
800,2016-02-07 03:55:26,"Thanks for providing the context, @daemonsy, and for the PR! Glad that Relay it working well for you. 
",wincent,daemonsy
798,2016-05-08 19:34:00,"Per @edvinerikson's comment it looks like this isn't sufficient for running the examples. Let's continue discussion in #906 and move forward with a new PR when a full solution is identified.
",josephsavona,edvinerikson
797,2016-02-06 16:17:42,"Thanks @taion!
",wincent,taion
795,2016-02-06 02:50:31,"Thanks @BobertForever! Will merge this a bit later. 
",wincent,BobertForever
794,2016-02-06 01:30:34,"Thanks @KyleAMathews! 

@facebook-github-bot shipit 
",wincent,KyleAMathews
789,2016-02-08 22:24:13,"Thanks for filing this issue @jardakotesovec!

This is important, so I'm going to fold it into #538, which is about overhauling the mutations API. (It will be easier to manage with the various interrelated mutations issues in a single place.)
",wincent,jardakotesovec
789,2016-06-14 06:53:41,"@wincent May I ask whats the status for this feature? I will need it sometime soon, so wondering what route should I take.  Default network layers is using _fetch_, which does not have progress callback, so it basically means using XHR in my custom network layer..  

I could spend some time on PRs if you give me clues what you envision in relay core for that matter.
",jardakotesovec,wincent
789,2016-06-14 14:43:32,"@jardakotesovec I did some work a while back on introducing an [alternative low-level API for mutations](https://github.com/facebook/relay/blob/829450ab74aa5c6b0cdb453cb76b1fbc45f16687/src/mutation/RelayGraphQLMutation.js), but that decidedly doesn't involve any changes at the network layer. We're still working on improving mutations: if you check out [the meeting notes](https://github.com/facebook/relay/tree/master/meta/meeting-notes) you'll see that right now one of the things we're working on is prototyping some new ideas ([context](https://www.youtube.com/watch?v=7TA4T2TJQx0)), and we'll be doing more work on mutations as part of that.

I think it's going to be difficult to change this without going the custom network layer route, as we are not likely to swap out `fetch` in the default layer.
",wincent,jardakotesovec
789,2016-06-16 07:26:33,"@wincent Thanks. Using xhr in custom network layer works just fine. Issue is that in `sendMutation` method I am getting `RelayMutationRequest` where I can't access mutation callbacks nor props, so basically I can pass just one onProgress function to the network layer on initialization. 

So even if I track all file upload progresses in network layer I don't see nice way to match these progresses with particular committed mutations.

Any suggestions?
",jardakotesovec,wincent
788,2016-02-03 02:11:02,"@wincent there are ongoing community efforts to build subscriptions (#411), contextual state (#558), support server rendering, etc. What do you think about including these in the roadmap?
",josephsavona,wincent
788,2016-02-03 02:40:17,"I think we can link to these but it will be most useful to draw a clean
line between what is prioritized internally and what's happening
externally. (Note the old roadmap is still at the bottom of the page and
does link to or mention these issues.)

[typed in my phone; apologies in advance for the errors.]
On Tue, Feb 2, 2016 at 6:11 PM Joseph Savona notifications@github.com
wrote:

> @wincent https://github.com/wincent there are ongoing community efforts
> to build subscriptions (#411
> https://github.com/facebook/relay/issues/411), contextual state (#558
> https://github.com/facebook/relay/issues/558), support server
> rendering, etc. What do you think about including these in the roadmap?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/788#issuecomment-178958404.
",wincent,wincent
786,2016-10-29 13:21:54,"I will not rubber stamp and land your change for you @steveluscher!  I can import it for you and you can get your change reviewed by someone though :)
",facebook-github-bot,steveluscher
785,2016-02-04 00:33:13,"Thanks for the nice feedback, @wincent!
",Kureev,wincent
784,2016-02-03 02:15:21,"@ryancole thanks for the extra info, this is super helpful for debugging!
",josephsavona,ryancole
784,2016-02-05 22:48:30,"There are two basic approaches here:
- Flatten the query prior to printing it.
- Print duplicated fields, but in a way that passes validation. Based on @leebyron's example this would mean printing:
  query ($orderBy: _GroupOrdering) {
    viewer {
      allGroups_...: allGroups(orderBy: $orderBy) { count }
      allGroups_...: allGroups(orderBy: $orderBy) { count } # same variable name when value is same
    }
  }

Flattening the query requires a full extra traversal (O(n) operation), so this isn't tenable from a performance perspective. The simpler solution would be to avoid creating new variables when the values are actually the same. This could be achieved by keeping a map in `printRelayQuery` of serialized value -> variable name, and only generating new variables if the current value is not already a key in the map. This logic would go in [`createVariable`](https://github.com/facebook/relay/blob/master/src/traversal/printRelayOSSQuery.js#L298-L310)

@ryancole or @fson any interest in submitting a PR for this? ;-)
",josephsavona,ryancole
784,2016-02-06 01:37:22,"@ryancole Great, thanks! For a test case, take a look at the [test schema](https://github.com/facebook/relay/blob/master/scripts/jest/testschema.graphql) for fields to use in constructing a repro case - something like



_should_ probably be sufficient (or pretty close).
",josephsavona,ryancole
784,2016-02-07 04:08:20,"@josephsavona I managed to get the tests running. Not sure why they won't run on my other PC. I have a feeling it has something to do with me downgrading to node 4 / npm 2. Something might be cached in the npm 3 format, or something, idk.

Anyways, there's my first stab at the second approach you mentioned yesterday. There already exists a map of created variables, so I'm just checking that and returning the already-created id for it if the `name` and `value` match up.

I also added a test case that initially reproduced the issue, and failed as expected. After adjusting `createVariable` the test case passes. None of the prior existing test cases seem to fail after the change, either.

I don't fully understand all of the possible ramifications of this change, technically, so I just followed your suggestions and went that route.
",ryancole,josephsavona
784,2016-02-07 22:51:07,"@ryancole thanks again for working on this, let's keep discussion of the implementation on the PR.

> I don't fully understand all of the possible ramifications of this change, technically

This is a very localized change, and the file has good test coverage. If you're curious to learn more about the implementation and ramifications of a change, I'd encourage you to experiment with changing things in the file and seeing which tests break and why :-)
",josephsavona,ryancole
783,2016-02-04 19:50:16,"Thanks for posting, @jaredly. Making common operations easy/simple, and harder operations possible/feasible is one of the goals of our current work on mutations (see #538); the surface area and scope of possible changes is huge however, so I am still gathering up all the issues and feedback trying to make a coherent plan. In the meantime please keep the feedback and ideas coming.
",wincent,jaredly
782,2016-02-09 21:31:58,"> ...`intersectRelayQuery` will take the tracked fields for the node with id ""123"", including the two fragments (on User and Blog), and then try to expand them

@NevilleS Thanks for debugging this - it's super helpful to have a repro. Since we know the type of each field/fragment, `intersectRelayQuery` should be able to filter out tracked fragments of a mismatched type. In your example, given a concrete parent field `blog` of type `Blog`, intersection can skip concrete fragments (`!fragment.isAbstract()`) of any other type. If either the parent or child is abstract it _should_ be safe to keep (intersect) the child. Any interest in submitting another great PR? ;-)
",josephsavona,NevilleS
782,2016-02-10 16:23:47,"It looks like the fix here is to wrap all mutation fragments in `... on Node { ... on FieldType { ${originalFragment} } }` - @NevilleS still interested in that PR? :-)
",josephsavona,NevilleS
782,2016-02-22 19:14:42,"Hey @josephsavona, I've been out for a week or so on ""IRL"" stuff, but I hope to pull a PR together this week. Are we in agreement that adding a defensive wrapper like `... on Node { ... on FieldType { ${originalFragment} } }` during the mutation query building step is the best solution today? That'd be pretty easy, but would of course make _all_ mutation queries that much uglier :laughing: 
",NevilleS,josephsavona
782,2016-02-23 06:34:54,"@NevilleS Yes, the general shape of the solution - wrapping tracked fields in conditioning fragments - is correct. It isn't exactly clear what the most efficient way to determine the fragment type to wrap the field in (perhaps we have to store the parent field type of a fragment when we track it?). 

cc @wincent who is focusing on simplifying mutations - he might have more ideas here.
",josephsavona,NevilleS
782,2016-02-23 07:03:44,"Actually, I was thinking I'd be able to just use the type of the node in
the mutation payload, unrelated to the tracked fragments. This means the
query tracking is unaffected and only the mutation query building logic
needs to be aware of this.

I haven't tried anything yet though - is it possible to get the type
information of the mutation payload at runtime? Is that stored at all?

On Tue, Feb 23, 2016, 1:35 AM Joseph Savona notifications@github.com
wrote:

> @NevilleS https://github.com/NevilleS Yes, the general shape of the
> solution - wrapping tracked fields in conditioning fragments - is correct.
> It isn't exactly clear what the most efficient way to determine the
> fragment type to wrap the field in (perhaps we have to store the parent
> field type of a fragment when we track it?).
> 
> cc @wincent https://github.com/wincent who is focusing on simplifying
> mutations - he might have more ideas here.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/782#issuecomment-187568438.
",NevilleS,NevilleS
782,2016-02-27 00:05:29,"Yeah, that doesn't work... Tracked queries aren't always fragments like `...F0`, it seems. When I experiment sometimes the children of the intersected query are fields like `id`, `someFieldName`, etc. That means when you wrap all those tracked children in a `Node` fragment, those fields become invalid :cry:

I guess that means I've caught up to @josephsavona's train of thought - the trouble is figuring out a valid fragment type to wrap each tracked field in...
",NevilleS,josephsavona
782,2016-03-28 20:43:29,"> I believe what needs to happen is some way to carry the ""type"" information through from the babelRelayPlugin so that it is available in the Relay AST when constructing the mutation query,

@NevilleS  `babel-relay-plugin` records the type information for every node, along with whether the type is abstract or concrete - these can be accessed with `getType(): string` and `isAbstract(): boolean` on fields/fragments/queries. Can you put up a PR for your commit that you referenced above? That way we can import it easily and experiment.

cc @wincent this was the issue i mentioned the other day
",josephsavona,NevilleS
782,2016-03-29 01:29:04,"@NevilleS sweet, thanks!
",josephsavona,NevilleS
782,2016-04-21 20:12:06,"@NevilleS I'm facing the same issue with RANGE_ADD right now
",zuker,NevilleS
782,2016-04-21 21:45:18,"@NevilleS Thank you for your clarification! Mutation succeeds now.
",zuker,NevilleS
782,2016-04-22 12:41:29,"@NevilleS I think my problem is related to invalid fragment expansions since in case 1 and 2 `Account` and `PasswordItem` got probably merged (fields `tilte` and `pass` are `PasswordItem`'s fields) and all entire issue is a result of workaround you provided (anyway thanks again for it :).
**UPD**: basically if you could advice me how to wrap the `password_items` connection properly with `... on Node ... on Type` it would be great. Thanks!
",zuker,NevilleS
782,2016-10-12 16:51:38,"Hmm, that's an interesting workaround @tomconroy... it requires schema changes of course, but the alternative (manually wrapping all your fragments in that ""indirection sandwich"" I proposed) is a pretty hideous solution.

We're trying to decide on our preferred solution for this issue and I see four options:
1) Add the ""indirection sandwich"" to the fragments that might lead to invalid expansion
2) Modify your schema to only return `Nodes` in mutations to avoid the invalid expansion
3) Use `Relay.GraphQLMutation` to manually specify the mutation query so it's guaranteed to be valid
4) Change schema to not use interfaces so that invalid expansions are (probably?) not possible

Right now options 1 and 4 are kinda off the table for me - the former is too clumsy and the latter way too extreme.

Option 3 is looking attractive... I haven't used `Relay.GraphQLMutation` much, but I think it might be the right way forward given that Relay 2 is going to ditch a lot of the declarative API. It looks like the Relay team did build out the basic features I'd want in this low-level API: optimistic updates, support for RANGE_ADD configs, etc.

Option 2 (from @tomconroy) requires schema changes and sacrifices type safety on the queries, which I don't like very much... but it could potentially work.

@josephsavona, since we've both had some time to subconsciously think about this one, what do you think are the pro/cons of these options for a Relay app today? I'm leaning towards rewriting most of my problematic mutations using the low-level API, but don't want to overlook things.
",NevilleS,josephsavona
782,2016-10-12 16:51:38,"Hmm, that's an interesting workaround @tomconroy... it requires schema changes of course, but the alternative (manually wrapping all your fragments in that ""indirection sandwich"" I proposed) is a pretty hideous solution.

We're trying to decide on our preferred solution for this issue and I see four options:
1) Add the ""indirection sandwich"" to the fragments that might lead to invalid expansion
2) Modify your schema to only return `Nodes` in mutations to avoid the invalid expansion
3) Use `Relay.GraphQLMutation` to manually specify the mutation query so it's guaranteed to be valid
4) Change schema to not use interfaces so that invalid expansions are (probably?) not possible

Right now options 1 and 4 are kinda off the table for me - the former is too clumsy and the latter way too extreme.

Option 3 is looking attractive... I haven't used `Relay.GraphQLMutation` much, but I think it might be the right way forward given that Relay 2 is going to ditch a lot of the declarative API. It looks like the Relay team did build out the basic features I'd want in this low-level API: optimistic updates, support for RANGE_ADD configs, etc.

Option 2 (from @tomconroy) requires schema changes and sacrifices type safety on the queries, which I don't like very much... but it could potentially work.

@josephsavona, since we've both had some time to subconsciously think about this one, what do you think are the pro/cons of these options for a Relay app today? I'm leaning towards rewriting most of my problematic mutations using the low-level API, but don't want to overlook things.
",NevilleS,tomconroy
782,2016-10-13 16:35:15,"@josephsavona do u have an example of usage of `RelayGraphQLMutation`?
",sibelius,josephsavona
782,2016-10-13 21:52:11,"@sibelius Not yet, the best bet is to look at the [unit tests](https://github.com/facebook/relay/blob/ea03e9ba6bc5763c18b9745eeab375087507307e/src/mutation/__tests__/RelayGraphQLMutation-test.js).
",josephsavona,sibelius
782,2016-10-13 22:27:52,"We've been using the low-level API a bit today, it's working pretty well! Thanks for implementing `RANGE_ADD` in there @josephsavona, it's definitely needed when mutating connections...
",NevilleS,josephsavona
782,2016-11-10 08:54:32,"Hey ! If there any news on this issue? Do you think that a fix is possible on Relay 1 before the release of Relay 2 ?

I'm just wondering how to implement the @tomconroy workaround with [graphql-relay-js](https://github.com/graphql/graphql-relay-js). I mean, is it possible to set a mutation output field type as generic ""Node"" ?
",mrogelja,tomconroy
781,2016-10-29 13:21:51,"I will not rubber stamp and land your change for you @gabelevi!  I can import it for you and you can get your change reviewed by someone though :)
",facebook-github-bot,gabelevi
779,2016-05-18 15:08:59,"@Globegitter check out [this thread](https://github.com/facebook/relay/issues/541#issuecomment-213093469) for more context. 
",josephsavona,Globegitter
779,2016-05-18 15:20:43,"@josephsavona I have seen that, which I understood as, that you (i.e. relay core team are not actively working towards it). But that also means community contributions won't be accepted?

The reason I am pinging on this PR is that we will start adding websocket to one of our apps and I am right now evaluating the best option. If subscriptions are close, then it would of course make most sense to use that. And given these PRs plus https://github.com/eyston/relay-chat-subscriptions it seems the pieces for relay native subscriptions are already here. But if there is no way any of that will make it into core any time soon I will of course use `handleQueryPayload`, `forceFetch`, etc.
",Globegitter,josephsavona
779,2016-05-18 15:53:20,"> which I understood as, that you (i.e. relay core team are not actively working towards it). But that also means community contributions won't be accepted?

@Globegitter In general we're absolutely open to community contributions. In this particular case, @eyston did a ton of amazing work building subscription support, but there's a lot of complexity here and we simply don't have the bandwidth to review, import, and maintain all of this code. Upon further consideration, we realized that there a number of features such as this - server rendering being another one - that ideally could be built in user space instead of within the framework itself. Subscriptions can be implemented via `handleQueryPayload` (with a RelayQuery.Subscription for mutation-like behavior) or `handleQueryPayload` (with a RelayQuery.Root), so we'd like to see what people come up with in user-space and then evaluate again.

See also #559.
",josephsavona,Globegitter
779,2016-05-18 16:01:07,"@eyston thanks for the clarification, that makes sense.

@josephsavona thanks for giving some background and a bot more information on this. That will help quite a bit with our decision on how to implement subscription/subscription-like features in our apps.
",Globegitter,josephsavona
777,2016-05-13 21:22:21,"@dylanahsmith if errors are represented on the payload, wouldn't that imply to Relay that the mutation was successful, though? it seems as though if Relay sees that `errors` array, in the response, it knows that the mutation has failed, and triggers all the expected fail-case actions, such as the `onFailure` callback. if we have ""user errors"" as part of a _successful_ payload then Relay will proceed through it's succeed-case actions, such as `onSuccess` and whatever else it does (run Relay configs, adjust client graph, etc?)

The GraphQL spec says that the `errors` entries may be extended however needed. Despite that one seemingly confusing comment about `errors` being for developer-focused messages, it seems like extending an entry in `errors`, and adding a possible `field` property or something, would be a pretty good approach because it already works so well with Relay.

I'm not opposed to errors as part of the response payload. In fact, I'm currently implementing my errors this way. I just want to be sure that if I do it this way then Relay won't have any unintended side effects thinking that these mutations actually succeeded. @leebyron @josephsavona 
",ryancole,dylanahsmith
777,2016-05-13 21:22:21,"@dylanahsmith if errors are represented on the payload, wouldn't that imply to Relay that the mutation was successful, though? it seems as though if Relay sees that `errors` array, in the response, it knows that the mutation has failed, and triggers all the expected fail-case actions, such as the `onFailure` callback. if we have ""user errors"" as part of a _successful_ payload then Relay will proceed through it's succeed-case actions, such as `onSuccess` and whatever else it does (run Relay configs, adjust client graph, etc?)

The GraphQL spec says that the `errors` entries may be extended however needed. Despite that one seemingly confusing comment about `errors` being for developer-focused messages, it seems like extending an entry in `errors`, and adding a possible `field` property or something, would be a pretty good approach because it already works so well with Relay.

I'm not opposed to errors as part of the response payload. In fact, I'm currently implementing my errors this way. I just want to be sure that if I do it this way then Relay won't have any unintended side effects thinking that these mutations actually succeeded. @leebyron @josephsavona 
",ryancole,josephsavona
776,2016-10-29 13:21:38,"I will not rubber stamp and land your change for you @steveluscher!  I can import it for you and you can get your change reviewed by someone though :)
",facebook-github-bot,steveluscher
775,2016-02-08 03:57:37,"@josephsavona sorry I realized that there is another issue. 

I'm calling the `createWordpressPage` function to create the component using react router. This is what the routes look like:



This works, but I think its creating a new component everytime I switch between :page routes —For example, when I got to '/articles' and then to '/about'. When I switch back I get:


",ramsaylanier,josephsavona
775,2016-02-23 04:22:28,"@josephsavona Basically, the problem I'm running into is that I'm using part of the initial query to determine the layout - so the first time it runs through and renders the correct component, it doesn't pick up the fragment.

In a Page component I do this:



and the Page Container:



But this gives me an 


",ramsaylanier,josephsavona
774,2016-02-04 20:05:33,"@NevilleS its ok, our tool can rebase on import. 
",josephsavona,NevilleS
770,2016-01-27 21:32:19,"Oh, I see @josephsavona.

So there will be a subscription for each connection, since the NODE_DELETE config will act on a node id specific for each connection I guess?

I am keen to see how that feels in reality, especially non-infinite (windowed) connection are still giving me a bit of a headache in relay since I am never sure what the right way is to implement it with all the internal relay mechanisms to consider and now subscriptions coming into play as well.
",BerndWessels,josephsavona
769,2016-02-09 18:22:02,"@wincent Possibly. Here it is:



But how else would you do it? What is the right way to insert to and delete from a connection without mass updates of the relay cache?
",BerndWessels,wincent
767,2016-01-28 21:23:41,"Thanks for these contributions, @iamchenxin!

Instead of warning and documenting (#764) this behavior, how would you feel about fixing it? Here's what needs to happen:

Right now, we use the `identifyingArgValue` as a key in the `rootCallMap` and `cachedRootCallMap` of the `RelayRecordStore`. This is a map from `identifyingArgValue` to `DataID`. Because keys can only be strings, we enforce that every root call's `identifyingArgValue` is a string.

What you could do to fix this would be to modify `getDataID` and `putDataID` ([link](https://github.com/facebook/relay/blob/master/src/legacy/store/GraphQLFragmentPointer.js#L55-L67))to accept `identifyingArgValue`s other than strings, then to stringify them if they are not already a string:
- If `identifyingArgValue` is already a string, use it as the key like normal
- If `identifyingArgValue` is an object, stringify it using `stableStringify` and use the result as the key

Are you up for that?
",steveluscher,iamchenxin
767,2016-02-01 16:46:39,"@steveluscher I am not familiar with Relay yet,and I am learning both Relay and English these days ,So when i make sure i can figure out the meaning of most Relay Store's functions, i should and would do this. Maybe one or two weeks later.
BTW: I thought the string restriction is deliberately designed before . When i first learn to use relay, i tried to pass `Object` and `int` as args to the top-level .But then the string restriction lead me to another design semantic .. keep the top-level fields of query as simple `interfaces`. <br/>
I am learning more about Relay, then i may not be confused with the relationship between each parts.
",iamchenxin,steveluscher
767,2016-02-15 08:06:22,"Someone just hit this restriction internally, where their identifying argument was an integer. Relay, as you've noticed above, turned it into a string. If you have time to open Relay up to objects, integer, and string identifying arguments, that would be a tremendous help, @iamchenxin!
",steveluscher,iamchenxin
767,2016-02-15 10:22:58,"@steveluscher Just back from Chinese new year today, i will try to fix it tomorrow .
",iamchenxin,steveluscher
767,2016-02-16 15:58:23,"Hi @iamchenxin ! I had the same problem when I tried to use an integer identifying argument. If you have the opportunity to look into this issue, it would help a lot! Let us know if you need help!
",vdurmont,iamchenxin
767,2016-03-02 23:45:40,"@iamchenxin Thanks for starting the discussion about this! I've created two new PRs that build on these ideas in #894 and #895, so let's continue discussion there.
",josephsavona,iamchenxin
765,2016-01-25 18:01:27,"@josephsavona - I'm setting category, but I just discovered that the props are being set but some child component is not receiving the updated props. So all is operating well - i guess my only question then is why do these queries seem to take longer... is it because its using the node query to identify the source instead of the viewer query? 

Thanks! 
",brad-decker,josephsavona
764,2016-01-26 07:08:03,"@josephsavona Add some information in `Guides-Routes.md` for this. This part rule for Graph-Relay Data model what i get right now is that,  the top-level interface of query must be used string as params for Relay store to indexed data?Cause im poor at english,there may be some misunderstanding.  
",iamchenxin,josephsavona
761,2016-01-25 19:17:04,"@denvned Thanks for this! I have lots of minor feedback but this is great. I'm going to import now to start testing it out, but feel free to make updates (if you can!) and i'll re-import. 
",josephsavona,denvned
761,2016-01-26 11:27:16,"@josephsavona Thanks for review! I updated PR with all your corrections except the one about the circular dependency (see my [comment](https://github.com/facebook/relay/pull/761#discussion_r50822499)).
",denvned,josephsavona
759,2016-02-03 23:54:39,"Thanks for highlighting this, @taion. Of those, the string check sounds a bit more cumbersome, but it feels like it's technically the more correct fix. Want to submit a PR?
",wincent,taion
754,2016-07-15 17:03:33,"@josephsavona thanks for the quick feedback.

I'll debug it further on that line, but if I understood correctly the `Component` on the line you pointed is an instance of `QueryAggregator`, which are created once per request (on `isomorphic-relay-router/src/prepareData.js` I mentioned).

I'll also investigate how we can avoid creating a QueryAggregator instance per server-side render, but probably will require a big change in react-router-relay.
",rodrigopr,josephsavona
754,2016-07-22 08:01:56,"@tomconroy Are you using `isomorphic-relay-router`? `isomorphic-relay-router` creates a [new `QueryAggregator` for every request](https://github.com/denvned/isomorphic-relay-router/blob/master/src/prepareData.js#L6). Which is later passed to `RelayReadyStateRenderer` where `getRelayQueries` is [called for every `render()`](https://github.com/facebook/relay/blob/master/src/container/RelayReadyStateRenderer.js#L100). Causing the `queryCache` to grow.

Ideally there should be a way for `isomorphic-relay-router` to cache `QueryAggregator` for every possible route combination.
",nthtran,tomconroy
754,2016-07-24 23:56:17,"@josephsavona I've been playing with this and I'm going to comment over on denvned/isomorphic-relay-router#40, but can you confirm for me that `getRelayQueries` is expecting a class/constructor and not an instance of a component?
",KCraw,josephsavona
754,2016-07-25 06:46:01,"@josephsavona Thanks! Any chance of letting it accept either; i.e., check if Component is a function, and if not, use Component.constructor as the key?

The reason I ask is I don't think caching any sort of query config aggregator is going to work for SSR. Otherwise you're bound to have concurrency problems. And any sort of query config aggregator is likely going to have to fake the `RelayContainer` static methods with instance methods, since by definition the fragments on a query aggregator rely on the children it is wrapping. Nor do the `RelayContainer` static methods provide any sort of argument that might allow for a query config aggregator to identify an instance in an internal registry. And turning off caching to avoid the issue is undesirable. Maybe there is some implementation of a query config aggregator that avoids these problems, but if so, it eludes me. 

I'd be a little concerned with an 'accept an instance or a class' solution that there are other internal portions of Relay that rely on the Relay.Renderer Container prop being a class and not an instance. On the other hand, routing and nested routes seems pretty important, and having lots of nested Relay.Renderers sounds bad to me (but maybe I'm wrong on that). So a query aggregator is pretty much a given.
",KCraw,josephsavona
754,2016-07-26 05:28:01,"> It isn't clear why a new aggregator would need to be recreated when re-encountering a previously seen route, as only the params on the Route object change.

@josephsavona The problem was that _react-router-relay_, on which _isomorphic-relay-router_ is based, is designed in such a way that there supposed to be an unique instance of `QueryAggregator` per each `Router` instance, and trying to reuse a `QueryAggregator` concurrently would lead to problems even when the route is absolutely the same.

But I believe I finally managed to solve the issue by refactoring the container responsibility of `QueryAggregator` out to a new class `AggregateContainer`, and reusing instances of this class instead. See https://github.com/denvned/isomorphic-relay-router/commit/9a98a195f7d1287975958528ddf54275e28757d2
",denvned,josephsavona
754,2016-07-26 15:34:38,"I think @denvned's solution fixes the issue with routing and query aggregation, and in a quick test, the cache seems to be building as intended by Relay on both the client and server.

That being said, I think we're still going to need to a way to manually disable Relay's caches on the server as @josephsavona suggested. This is completely independent of routing. 

Relay caches use the params in generating cache keys as well, which would quickly grow out of hand on the server (as @josephsavona stated, the cache was never intended for server use). Just imagine how many cache keys would be generated for a Component if something like a text search string were a param, or even just the ids of nodes for large applications. 
",KCraw,denvned
754,2016-07-26 15:34:38,"I think @denvned's solution fixes the issue with routing and query aggregation, and in a quick test, the cache seems to be building as intended by Relay on both the client and server.

That being said, I think we're still going to need to a way to manually disable Relay's caches on the server as @josephsavona suggested. This is completely independent of routing. 

Relay caches use the params in generating cache keys as well, which would quickly grow out of hand on the server (as @josephsavona stated, the cache was never intended for server use). Just imagine how many cache keys would be generated for a Component if something like a text search string were a param, or even just the ids of nodes for large applications. 
",KCraw,josephsavona
754,2016-08-04 18:51:53,"@josephsavona  Any thoughts on using LRU cache for these two caches? Would you be open to a PR that implemented something like a `RelayLRUCache` module that would abstract all this away, and would allow globally setting the cache size (using `0` to turn them off and setting the default as `Infinity`)?

If so, I'm willing to take a stab at it in the nearish future (I'd have to make time), or maybe @denvned would be willing (he's cleverer than I am anyways).
",KCraw,denvned
754,2016-08-04 18:51:53,"@josephsavona  Any thoughts on using LRU cache for these two caches? Would you be open to a PR that implemented something like a `RelayLRUCache` module that would abstract all this away, and would allow globally setting the cache size (using `0` to turn them off and setting the default as `Infinity`)?

If so, I'm willing to take a stab at it in the nearish future (I'd have to make time), or maybe @denvned would be willing (he's cleverer than I am anyways).
",KCraw,josephsavona
752,2016-10-29 13:21:51,"I will not rubber stamp and land your change for you @gabelevi!  I can import it for you and you can get your change reviewed by someone though :)
",facebook-github-bot,gabelevi
751,2016-01-19 20:57:04,"@vslinko Glad that helped!
",josephsavona,vslinko
750,2016-10-13 21:51:04,"@sibelius The workaround is to use `RelayGraphQLMutation`.
",josephsavona,sibelius
749,2016-01-20 16:57:56,"@steveluscher I have updated the pull request to change all instances to 2016
",pra85,steveluscher
749,2016-01-25 19:20:04,"@pra85 Thanks so much for taking the initiative to do this! @wincent noticed that our other projects are using `-present` to avoid the necessity for yearly updates. What do you think about moving forward with that change (#757) instead?
",josephsavona,pra85
749,2016-01-25 21:13:33,"Also happy to close that one if you prefer to re-roll this one @pra85 (either way, they're both in need of a rebase).
",wincent,pra85
749,2016-01-26 04:06:31,"@wincent I have rebased and updated this pull request to make it `-present` everywhere.
",pra85,wincent
748,2016-10-29 13:20:49,"I will not rubber stamp and land your change for you @cpojer!  I can import it for you and you can get your change reviewed by someone though :)
",facebook-github-bot,cpojer
747,2016-01-23 00:43:23,"Sounds good @josephsavona ! https://stackoverflow.com/questions/34958295/whats-relays-relationship-to-flux
",chrisbolin,josephsavona
745,2016-01-27 22:40:41,"I am also having a having a similar fetching data with relay.
Here are the details:
1. Load initial page
   - queries a field `account` on `viewer` via Relay.Container
   - `account` field comes back `null` (correct behavior)
2. Redirect user to new page to fill out form (as they do not have an account)
   - User correctly fills out form and submits
   - account mutation is fired and completes successfully
3. User gets redirected back to initial page
   - `account` field is now no longer `null` when API is queried, but Relay does not re-fetch data or store user's form data locally
   - page is rendered incorrectly as Relay still thinks `account` is `null`

Problem is that Relay SHOULD refetch or store locally the `account` data since it will no longer be `null`, but it doesn't.

Ex: Mutation code:



**_NOTE**_
@NevilleS's [Patch](https://github.com/NevilleS/relay/commit/c5abe4616fb509d57377e9c14636f0df6b93a9f8) fixes this issue that I'm having.
",larsonjj,NevilleS
745,2016-01-27 22:44:49,"@NevilleS, It definitely fixes the issue I've been having. It would be great if you submitted a PR to see if this gets more attention from the FB team.
",larsonjj,NevilleS
745,2016-01-27 22:45:14,"@NevilleS can you submit a PR with your test and fix?
",josephsavona,NevilleS
745,2016-02-04 04:32:40,"@josephsavona my use case is exactly the same as @larsonjj, except rename `account` to `user` :D 
",dminkovsky,josephsavona
744,2016-01-18 13:38:07,"Thanks @josephsavona, wasn't sure if subscription were the answer to that problem!
",xuorig,josephsavona
742,2016-01-21 10:27:29,"@josephsavona This is actually a bug, so can you please reopen the issue.
",shahankit,josephsavona
742,2016-06-28 06:45:45,"@steveluscher thanks.
",shahankit,steveluscher
740,2016-01-13 16:11:29,"@vslinko thanks for this! No need to squash commits ;-)
",josephsavona,vslinko
740,2016-01-20 17:01:48,"Did we decide to change this to “non-negative integers” to allow for 0 to mean “fetch the first zero” (eg. fetch none)? @josephsavona @kassens 
",steveluscher,josephsavona
740,2016-01-20 17:42:54,"> Did we decide to change this to “non-negative integers” to allow for 0 to mean “fetch the first zero” (eg. fetch none)? 

Yes. @vslinko can you update the PR?
",josephsavona,vslinko
740,2016-03-10 20:23:11,"@vslinko Are you planning on updating this PR to ""non-negative integers""?
",yungsters,vslinko
739,2016-01-15 05:01:15,"@NevilleS Thanks you are right.
",BerndWessels,NevilleS
738,2016-01-14 19:00:05,"@josephsavona Thank you, here's the [question](http://stackoverflow.com/questions/34797581/is-there-a-fetched-callback-to-relay-createcontainer).
",BerndWessels,josephsavona
737,2016-09-03 00:28:03,"Going to close this as we're working on preparing for the release of [Relay 2](https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable), so it is very unlikely that we'll be allocating resources to documenting the old APIs at this time. Like @josephsavona said, however, and we'd be happy to merge in a PR addressing this issue, but I'm still going to close this for now in order to clean out the issue tracker a bit.
",wincent,josephsavona
736,2016-02-26 14:42:30,"@josephsavona Any update on getting this merged? Same for #779.
",Globegitter,josephsavona
735,2016-01-15 08:38:47,"@kassens In current implementation `first: 0` means ""give me them all"".
I think it isn't good decision and I agree with you that `first: 0` could be helpful in some cases, so I can change my PRs.

@josephsavona what are you think?
",vslinko,kassens
735,2016-01-15 08:38:47,"@kassens In current implementation `first: 0` means ""give me them all"".
I think it isn't good decision and I agree with you that `first: 0` could be helpful in some cases, so I can change my PRs.

@josephsavona what are you think?
",vslinko,josephsavona
735,2016-01-15 09:25:36,"I trust @kassens ;-)

My first thought was that `first:0` would be the same as `@include(if:false)`, but there might be fields on the connection that you want to fetch other than `edges`. Changing the semantics of first:0 to return zero edges makes sense, but we should verify that this won't impact products before making the change. Perhaps we could start with a warning in the writer if first is zero but edges are returned. 
",josephsavona,kassens
732,2016-01-10 19:49:58,"@devknoll @steveluscher @josephsavona Will this replace the `babel-relay-plugin` on NPM ?
If so it should still be in sync with the version number of `react-relay` to avoid confusion ?!
But it looks like there is a `1.0.0` published to NPM - but `react-relay` is only `0.6.1`.
Can you please fix this or am I mistaken here?
",BerndWessels,devknoll
732,2016-01-10 20:44:03,"@devknoll OK, but why is there a `babel-plugin-relay` with version `1.0.0` already published to NPM? That seems wrong and might lead to confusion?
",BerndWessels,devknoll
732,2016-01-10 20:45:49,"@devknoll Oh, I see - just for holding on to the name on NPM - so you will delete the `1.0.0` later I guess.
",BerndWessels,devknoll
732,2016-01-19 21:38:18,"@devknoll import this!
",josephsavona,devknoll
724,2016-01-07 00:21:03,"Thanks @josephsavona 

As per your comment even implementing `Connection Interface` will not solve issue of sending n requests.

I agree with you on the edge cases, but sending 300 requests(in my case) instead of sending one request for list does not make sense(especially if this is on mobile), Temporary solution on my for now is to use arbitrary param(ex: limit as per your suggestion with different values), this way relay will treat them as different queries.

How does FB/Instagram/AdsManager get around this problem(if you guys hit the same)?
",mailaneel,josephsavona
722,2016-01-28 03:54:27,"@josephsavona I'm not sure why the test is failing now.
",andimarek,josephsavona
722,2016-01-29 13:25:07,"@josephsavona Anything else here I can do/should do? Thanks!
",andimarek,josephsavona
722,2016-02-03 22:20:07,"@andimarek Your PR has been imported into our internal Phabricator instance, but I see @josephsavona marked it as ""Changes planned"". Can you chime in on what you're wanting Joe?
",wincent,josephsavona
722,2016-02-03 23:15:32,"@wincent @yuzhi Thoughts on this approach? Note that the equivalent function for reading range data returns both a filtered and unfiltered list of edges, but `getLinkedRecordID` returns the id regardless of the linked record's status. I'm torn about whether the filtering really belongs in the store or if it should happen at a higher level (such as the reader). Thoughts?
",josephsavona,wincent
722,2016-02-08 22:12:40,"Just adding to what @josephsavona already mentioned. The similar problem can also occur when we GC the linked nodes but not the parent. Filtering out at the RelayRecordStore level can cause us to think there are no linked nodes when in reality, these nodes just got temporarily cleared by GC. We won't be able to tell the difference between the node is null vs node is node missing there due to GC or DiskCache since many of our internal functions depend on this function.
",yuzhi,josephsavona
722,2016-02-16 02:31:43,"@josephsavona  @yuzhi  Thanks for the background infos. I'm closing this PR, because as you explained it's the wrong approach.
",andimarek,yuzhi
722,2016-02-16 02:31:43,"@josephsavona  @yuzhi  Thanks for the background infos. I'm closing this PR, because as you explained it's the wrong approach.
",andimarek,josephsavona
720,2016-01-24 17:01:22,"thanks a lot @josephsavona 

> Currently, Relay does not evict data from its (in-memory) cache under the default configuration. This means that memory usage may grow during the course of a session, and that all data is cleared e.g. when the user closes the browser tab.
> 
> In practice, we've found that this isn't a problem for most apps. Because of the cyclic nature of social graphs there's a often significant amount of overlap in content, and as a result memory usage can grow more slowly than one might intuitively expect.

So I guess I could simply stop worrying and start coding :) My app is not particularly different from other social apps so it should be ok for my usecase too!

Also happy to hear about that GC system :)
",slorber,josephsavona
720,2016-02-27 06:12:25,"@josephsavona I am about to start coding on a new project that is very different from a social app. (first Relay one!). Query level TTLs would solve almost all of my problems and make it workable. I can't think of any problem that wouldn't be solved completely or partially by that. 

Showing stale data while refetching is perfect.
",evanderkoogh,josephsavona
720,2016-07-27 09:43:54,"@josephsavona is there any update on this? The biggest issue i'm seeing in practice is related to mutations refetching everything in the cache. Whilst a better approach might be to do the fat query intersection twice; once with the ""active"" data (ie the store that matches currently rendered components) and once against the inactive data (everything else). The active match would be used to refetch as part of the mutation query, and everything in the inactive match would be evicted from the cache.
",AndrewIngram,josephsavona
719,2016-01-05 17:32:11,"@ryancole There's a few other threads floating around in regards to this and I can't find them right now, but essentially, if that data has never been requested by Relay before, then it doesn't know about it and won't request it by itself. I.E. if your query doesn't request `teams` explicitly somewhere, then Relay is not tracking it. In this case, you have to explicitly accompany it with the `REQUIRED_CHILDREN` config type. 
",dphaener,ryancole
714,2016-01-26 16:32:07,"@skevy thanks!
",josephsavona,skevy
714,2016-01-26 16:37:52,"@josephsavona woot! one step closer. :)
",skevy,josephsavona
714,2016-01-31 20:55:21,"@skevy Since we ended up [having to revert](https://github.com/facebook/relay/commit/c0e6da5cca5ea71dd739f5200da2e6c0cd4a95b5#commitcomment-15737021) due to a conflict with an internal transform, let's reopen this to continue iterating - i'll follow-up hopefully tomorrow with more feedback about direction.
",josephsavona,skevy
714,2016-02-01 23:08:03,"@skevy We resolved the conflict with our internal plugin, so we could proceed with reimporting this. However, @DmitrySoshnikov has recently added [an option to control plugin ordering](https://github.com/babel/babel/pull/3281#issuecomment-173684655) in babel. I haven't dug into the React Native OSS setup in a while, but I'm wondering if that same type of configuration would allow the Relay plugin to run before the default RN transforms?
",josephsavona,skevy
714,2016-02-02 04:09:57,"This may not necessarily be needed anymore actually, with some changes that we've done on the RN side (we're going to use a preset now, which plays into taking advantage of @DmitrySoshnikov's changes). 

Will test when that gets merged in (should be tomorrow or so) and I'll report back. :-)

Thanks @josephsavona!
",skevy,josephsavona
714,2016-02-05 18:53:45,"@josephsavona so as it turns out...presets still run before things defined in plugins...so really, @DmitrySoshnikov's doesn't help if we want to do this in babelrc:



This will still let `babel-plugin-transform-es2015-template-literals` (which is present in the preset) run before the Relay plugin, and thus still cause breakage.

The only way we'd be able to take advantage of `passPerPreset` is to actually create a `./babelRelayPlugin` preset. I guess you'd make it do something like:



And then do this in your .babelrc:



It would work...doesn't seem ideal though and seems kind of confusing. Thoughts?
",skevy,josephsavona
714,2016-02-05 20:50:08,"@skevy i agree that isn't ideal, but it's not magic and makes it clear to users that the Relay plugin will run first. This means no code changes are required (right?) In that case, would you mind updating the plugin docs to describe how to configure for React Native? :-)
",josephsavona,skevy
714,2016-02-06 18:27:36,"@skevy sounds great, thanks again for following up on this :-)
",josephsavona,skevy
714,2016-02-08 05:35:09,"@josephsavona I can confirm that doing:



works as we discussed.

Sometimes, interestingly, this is not necessary, and you can do the more normal:



However, I think the fact that it works sometimes is just a fluke in how Babel runs the transforms. Therefore, I think from a documentation perspective, we should recommend `passPerPreset` (despite it's status as an experimental option, I think it (or some version of it) will stick around)...
",skevy,josephsavona
714,2016-03-02 19:11:06,"Ok, so the next steps here are:
- Document how to configure the Relay plugin to run before the default React Native plugins
- Work with @DmitrySoshnikov and Babel folks to make it easier to set up plugin/preset ordering.

I'm going to close this PR since we will make a documentation change instead of a code change.
",josephsavona,DmitrySoshnikov
713,2016-01-25 22:09:56,"@skevy this is now blocked only on https://github.com/facebook/react-native/pull/5084, right?
",josephsavona,skevy
713,2016-01-25 22:23:01,"@josephsavona yah. Hopefully being merged soon! :)
",skevy,josephsavona
713,2016-01-27 22:42:42,"Fyi @josephsavona, fbjs 0.7.0 is now released, so presuming you don't have any changes on this PR, it can be merged :)
",skevy,josephsavona
710,2015-12-30 05:44:20,"@josephsavona I'm not sure, but I don't think so. The memoization that happens in `printRelayQuery` occurs using `getFragmentID()` which takes into account variable values. [There is a test case demonstrates this.](https://github.com/facebook/relay/blob/master/src/traversal/__tests__/printRelayOSSQuery-test.js#L341-L375)

I'll have to create a test case to debug this further.
",yungsters,josephsavona
710,2015-12-30 14:38:10,"@yungsters Yes, that's correct. It's null and there's no way for the setVariables path to recover.

I've been attempting to understand how an empty record could be dropped in instead since I assume there'd be some sort of response like that if the @include made it to the server with it's condition false and the server returned an empty response.

Thanks for your help.
",mrogg,yungsters
709,2015-12-29 21:42:49,"@josephsavona, is it possible to change this behavior? 
",ziflex,josephsavona
709,2015-12-30 13:26:51,"@josephsavona I need these values before data resolving in schema.
So, what can I do to change it?
",ziflex,josephsavona
709,2015-12-31 08:32:49,"@josephsavona no, I need it outside of GraphQL pipeline, before it reaches it, in a middleware. The thing is that I use dynamically generated schemas for some forms and based on root query I need to define which schema I should use for particular request.
Therefore, I need to be able to get these values from request's body.
",ziflex,josephsavona
709,2015-12-31 12:04:45,"@josephsavona custom NetworkLayer is not an option, because during single session there might different forms which require different GraphQL schemas.
So, that's why I wanted to pass data with query in order to define proper schema.
",ziflex,josephsavona
709,2015-12-31 19:10:52,"@josephsavona let me explain what app does.
We have 2 services: Composer and Renderer.
Composer creates form definitions with fields, data sources for them and validation rules. During composing the form, we generate schemas and compile queries for dta fetching and mutation and store them as a part of definition.

Renderer is supposed to render form based on this definition. 
Here Relay comes. 
We have 2 root containers (agreed, probably it's bad), first root query fetch the form definition - here we have statically defined query, and once we got it, execute 2nd root query for data fetching using dynamically compiled query from fetched definition. And here, we've got a problem. On server side, we need to know, which schema should be used, since every form have it's own schema. That's why I need to have these variables in request body.
",ziflex,josephsavona
709,2016-01-02 18:01:54,"@josephsavona ok, thanks for help!
",ziflex,josephsavona
708,2016-03-10 20:22:25,"Thanks for your contribution, @NevilleS. I apologize that it's taken this long for someone to review this. Are you interested in rebasing the changes? And if not, do you mind if someone on the team does?
",yungsters,NevilleS
708,2016-03-10 22:29:27,"Alright @yungsters I rebased to latest master, and fixed up some things in my changes. It looks like there was a decent amount of refactoring in the relay plugin code, but I think I'm following the new behaviours correctly.

For the ""happy path"" tests, I still feel a little weird just basically copying & pasting the generated code into the test fixture expected output, but I assume that's what you do too :smile:

Note that when I initially wrote this PR I tested that the change worked in a ""real"" app too, but in this case I'm just trusting the unit tests...
",NevilleS,yungsters
708,2016-03-11 19:00:43,"Thanks for rebasing, @NevilleS. This is great.

Currently, `npm run update-fixtures` is a bit borked due to dependency hell, but #944 will fix it.

Just one nit before I import this.
",yungsters,NevilleS
708,2016-03-11 19:16:18,"@NevilleS Haha, I generally only use **shipit** if the change is documentation-only. For everything else, I run through tests internally to triple-check that nothing breaks.
",yungsters,NevilleS
708,2016-03-11 19:19:41,"@NevilleS Haha, yup. **import** will create an internal Phabricator revision that we can then land internally (which will get automatically sync'd out to GitHub and close this PR). It has something to do with unidirectional data flow or something like that. ಠ◡ಠ

On the other hand, **shipit** will automatically land the revision internally.
",yungsters,NevilleS
708,2016-03-15 20:17:10,"@NevilleS thanks for this!
",josephsavona,NevilleS
708,2016-03-15 20:52:20,"No problem! What else do you have for me @josephsavona? Or are we going to figure out what to do with #782?
",NevilleS,josephsavona
707,2015-12-29 21:37:53,"Hi @josephsavona, thanks for response!
On route level I have such query:
`query GetFormContent($params: QueryParams!) { getModel(params: $params)}'`

and on container level:

`fragment on Model {...poperties...}`

The problem is that I'm getting an error: 

> Expected arguments to root field `getModel` to each be strings/numbers, got `{""id"":""a670f711"",""formId"":""app-10""}`.

Then I had taken a look at the code which is throwing the error (`forEachRootCallArg.js`) and found that there is no option for objects. It supports only scalar values (and array of them).
",ziflex,josephsavona
707,2016-01-04 08:54:29,"@josephsavona any updates?
",ziflex,josephsavona
706,2015-12-28 16:15:33,"thanks @josephsavona ,  meanwhile i'll try to use in one isomorphic project
",kasselTrankos,josephsavona
706,2015-12-28 23:00:15,"hi @zpao, i put the error code.



 :(, so if npm requirement Flow change will be usefull, 
",kasselTrankos,zpao
706,2016-03-30 23:55:31,"As @edvinerikson noted this should now be resolved.
",josephsavona,edvinerikson
706,2016-03-31 00:35:40,"Fwiw, bumping the npm version there is probably not right. Flow likely
won't work (because of nested node_modules in flowconfig)

On Wednesday, March 30, 2016, Joseph Savona notifications@github.com
wrote:

> As @edvinerikson https://github.com/edvinerikson noted this should now
> be resolved.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/706#issuecomment-203689486
",zpao,edvinerikson
706,2016-03-31 01:02:06,"Reopening per @zpao 
",josephsavona,zpao
706,2016-03-31 01:27:56,"**Edit**
Node v5.0.0
NPM 3.3.6

---

@zpao can you elaborate a little bit more? I ran `flow check src/` and got `Found 0 errors` back.
When I added a type error I got:



and the code:


",edvinerikson,zpao
706,2016-03-31 04:39:13,"Hmm, I guess it's ok then. I was only looking at the previously linked
commit where there was still a nested node_modules reference, not master.
Looks like master is free :). Sorry for the poorly informed noise!

On Wednesday, March 30, 2016, Edvin Erikson notifications@github.com
wrote:

> @zpao https://github.com/zpao can you elaborate a little bit more? I
> ran flow check src/ and got Found 0 errors back.
> When I added a type error I got:
> 
> ~/code/relay(master ✗) flow check src/
> src/RelayPublic.js:39
>  39:   return 1 \* 1;
>               ^^^^^ number. This type is incompatible with
>  38: function bar(): React$Element {
>                      ^^^^^^^^^^^^^ React$Element
> 
> src/RelayPublic.js:42
>  42: foo('string');
>      ^^^^^^^^^^^^^ function call
>  42: foo('string');
>          ^^^^^^^^ string. This type is incompatible with
>  34: function foo(a: number): React$Element {
>                      ^^^^^^ number
> 
> Found 2 errors
> 
> and the code:
> 
> function foo(a: number): React$Element {  return <span />;
> }
> function bar(): React$Element {  return 1 \* 1;
> }
> foo('string');bar();
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/706#issuecomment-203707541
",zpao,zpao
704,2016-03-03 01:35:03,"@denvned @salbito I'll be working on the react-relay / Relay core split over the next couple of months, starting with landing the remaining ""Contextualize ..."" PRs within the next week or so.
",josephsavona,denvned
704,2016-03-03 13:48:53,"@josephsavona Really nice to hear! The global network layer is the last thing that blocks many projects from using Relay isomorphically.

I've just resolved the conflicts with the master, and added an ability to inject a network layer to `RelayContext`, with `RelayDefaultNetworkLayer` injected by default. Hope this will help.
",denvned,josephsavona
704,2016-03-03 15:38:11,"@denvned awesome, quick turnaround as always! I'll import the latest version. 
",josephsavona,denvned
703,2016-03-03 18:08:36,"@josephsavona I will ... one day a PR will go through :-) 
",andimarek,josephsavona
702,2015-12-24 15:06:09,"Thank you @josephsavona
I use veawer in #112, but still get do not get errors, please tell me in what is wrong.
GraphQl



The server returns the



Schema.js
https://gist.github.com/z81/39db6f188087f6ad726f
Client.js
https://gist.github.com/z81/47ad0a57ce9c527c2f0a
Sorry for bad english.
",z81,josephsavona
701,2016-03-08 01:21:18,"Thanks @yungsters 
",RavenHursT,yungsters
700,2016-01-11 19:55:27,"@devknoll : Server-side rendering.. if I go to `www.mysite.com/widgets?pageNumber=5` then we need a way to initialize what will be rendered when using https://github.com/denvned/isomorphic-relay
",RavenHursT,devknoll
699,2015-12-22 18:04:41,"@yungsters Yes, I thought about that, but came to a conclusion that it might _silently_ break existing mutations that might expect that props are resolved in the constructor and never changed after that. So, probably, explicitly changing the API here is the lesser of two evils, because it will break existing mutations _loudly_. :smile: By passing props as an argument to the methods we make it more clear that the props are not permanent, and that the mutation instance must not keep any state derived from the props.

But maybe I am exaggerating the problem too much, and we actually can do it. You decide.
",denvned,yungsters
699,2015-12-23 15:51:54,"@josephsavona Done. This is much cleaner indeed.
",denvned,josephsavona
699,2016-02-08 21:13:47,"@denvned nice. i'll import this week.
",josephsavona,denvned
698,2015-12-22 19:23:02,"@josephsavona Committed your suggestions. Did I understand everything right?
",denvned,josephsavona
697,2016-01-04 18:49:46,"@josephsavona Happy New Year
I posted it on StackOverflow [here](http://stackoverflow.com/questions/34597773/error-field-type-must-be-input-type-cannot-pass-qltype-into-mutation)
Thank you
",BerndWessels,josephsavona
695,2015-12-23 19:15:27,"OK @josephsavona I took a quick look at `writeRelayUpdatePayload` to see how I might go about adding a warning for this. It seems like it'd be relatively trivial to test the record status in `handleNodeDelete` just before the `deleteRecrod` method is invoked (i.e. lines 128 & 131 [here](https://github.com/facebook/relay/blob/master/src/traversal/writeRelayUpdatePayload.js#L131)). Alternatively, I could throw a warning in the existing check within `deleteRecord` although that seems a bit too ""low-level"" to trigger warnings to me since it is used in lots of other contexts (but it could be done [here](https://github.com/facebook/relay/blob/master/src/traversal/writeRelayUpdatePayload.js#L147))

Both of those implementations would be trivial, but my question is whether or not a warning whenever the given node ID's status is `RelayRecordState.NONEXISTENT` is a fair warning, since the way it is written now it just silently skips the operation assuming the record had already been deleted. I get the sense that it might be annoying to users to see this warning for mutations when they weren't explicitly tracking the node already, which would be common...

In my case, a more useful warning would be something like ""The given node ID doesn't appear to be a Relay GUID; are you sure you didn't mess that up?"". So I'd rather add a check like `isValidRecordID` to the mutation code to guard against that kind of user error... but I'm not sure it's possible. I think Relay GUIDs might be opaque to Relay, but I'm not sure since I haven't messed with the source code much before.

What do you think? Would a warning for NONEXISTANT records be annoying? Alternatively, is there a way to validate a record ID?
",NevilleS,josephsavona
694,2015-12-21 23:57:29,"@josephsavona I maintain the `babel-relay-plugin-loader` module and regularly check for new versions of the `babel-relay-plugin`. This morning I noticed that somebody released `0.6.1` of the `babel-relay-plugin`. So I updated and published a matching version of the `babel-relay-plugin-loader`.

Maybe others want get it yet as long as they target a specific version of the plugin, but if you use `^0.6.0` then you get `0.6.1` automatically with the next fresh `npm install`.
And since `react-relay` has a `babel-relay-plugin` dependency targeting `0.6.0` it shows that warning.

It is not a real problem, I just thought I mentioned it here, since you said that `react-relay` and `babel-relay-plugin` should be in sync.
",BerndWessels,josephsavona
694,2015-12-22 00:09:18,"@kassens It doesn't really break anything, at least for me it only gives a `npm` warning `npm WARN react-relay@0.6.0 requires a peer of babel-relay-plugin@0.6.0 but none was installed.`

But having matching clean releases would be nice anyways ;)
",BerndWessels,kassens
694,2015-12-22 00:35:06,"@kassens thanks for confirming, and @BerndWessels for pointing this out. 

We'll go forward with a `0.7.0` release this week.
",josephsavona,kassens
694,2016-03-31 00:21:52,"Thanks @edvinerikson :-)
",josephsavona,edvinerikson
693,2015-12-21 22:38:16,"@oguzbilgic Yeah `NODE_DELETE` mainly support nodes and nodes in connections since we do keep some extra metadata about each connection. If you want to update `viewer {cars}` and you know that can change as a part of this mutation, you can add another `FIELDS_CHANGE` config.



@josephsavona  We can probably do some filtering, although I don't know if there are legit cases for having nulls in plural fields. 
",yuzhi,josephsavona
693,2015-12-21 23:01:29,"@yuzhi Thank you. Thats exactly how I got around. However It's really pita at the moment. Basically `NODE_DELETE` doesn't do what its suppose to, and we need to find every list that may include this , get their ids in `getFragment`, and maybe add to `payload` ...
",oguzbilgic,yuzhi
693,2015-12-21 23:14:01,"@josephsavona :+1: I have no experience, but It says 'good first bug', I can give it a try this weekend. :) 
",oguzbilgic,josephsavona
691,2015-12-19 22:49:43,"thanks @josephsavona 

Yes comment implements node interface and has unique global id
I did not implement connection interface though
",mailaneel,josephsavona
690,2016-04-01 00:38:27,"@edvinerikson the best place is [Relay.js](https://github.com/facebook/relay/blob/master/src/__forks__/Relay.js). The check should likely use `if (__DEV__) { ... }`, which i think we transform appropriately (probably easiest to just try that and see what it builds to).
",josephsavona,edvinerikson
689,2015-12-21 23:14:29,"@kassens should we have bumped `react-relay` to 0.6.1 for this?
",josephsavona,kassens
688,2015-12-22 05:51:20,"Sounds good @josephsavona 

http://stackoverflow.com/questions/34409268/relay-cache-with-flux-pattern
",ccorcos,josephsavona
688,2015-12-27 06:10:02,"@josephsavona I'd love an answer to this too, please do respond – I've been looking at http://github.com/gyzerok/adrenaline for this exact purpose, but I don't think it's quite up to snuff yet.
",skosch,josephsavona
688,2015-12-28 01:08:58,"@skosch @ccorcos @dminkovsky I answered on Stack Overflow.
",josephsavona,dminkovsky
685,2016-01-26 17:02:42,"@josephsavona Thanks for explanation! PR is updated with your code.
",jardakotesovec,josephsavona
685,2016-03-01 00:56:06,"@josephsavona Hmm... looks like the bot failed.
",yungsters,josephsavona
683,2015-12-21 03:34:06,"@denvned My apologies for the delay in reviewing this. I'll write up more detailed thoughts in the morning, but for now I just wanted to thank you for your contribution :-)
",josephsavona,denvned
683,2015-12-21 20:11:16,"@josephsavona Thanks for the great review! I have started working on splitting this. Hope to submit the ""prepare the big change"" PR tomorrow.
",denvned,josephsavona
683,2016-01-03 20:45:32,"@josephsavona Should I submit the PR making `RelayContainer` access Relay data via `context.relay` now, or is it better to wait until the `RelayContext` PR (#698) is merged?
",denvned,josephsavona
678,2016-01-07 12:16:51,"@kassens any update on this?
",hannesj,kassens
677,2015-12-29 14:54:36,"I was looking for a good way to poke around the internals of the babel-relay-plugin so I've prepared a quick PR to fix this! @josephsavona, you're correct that GraphQLRange does validate the arguments it is given at runtime, so the plugin's static validation can be loosened a bit.

I didn't end up removing the validation entirely, I just added an check to see if the arguments are variables. That means @BerndWessels's query will now be supported, but other invalid combinations using hardcoded values will still be rejected. 
",NevilleS,josephsavona
676,2015-12-12 01:10:43,"@josephsavona I'll post any how to's on StackOverflow moving forward but offline support is an enhancement right?

Thanks :100: for your answers   

Ultimately we want to contribute the work on offline sync back to upstream so wondering if anyone at Facebook's working on this / planning to work on this in near term? If so, might make sense to join efforts rather than potentially go in different directions.
",zuhair-naqvi,josephsavona
676,2015-12-19 07:31:39,"@josephsavona @eyston 

Let me know if the below makes sense:

We've got relay working with React Native, the next challenge is to offer an offline first experience. To do this one approach I've been thinking of is to bundle the schema with the app using https://github.com/relay-tools/relay-local-schema and back it up with https://github.com/facebook/dataloader persisting the cache to disk. The trade off is you'll still be making multiple requests from the client however majority of the requests will be resolved locally through data loader and the few that do go over the network will be asynchronous as far as the app is concerned as Relay abstracts these for us. So this drawback may not be so much of an issue depending on your use case.

There will also be a pub/sub mechanism on top of the dataloader that can selectively invalidate the cache when the data changes on the server.

The business logic and communication with the database will be kept outside of the resolvers and loaders (in a persistence API on the server) which is good practice anyway.

This way, with minimal change you might be able to build offline native apps using Relay - unless I'm missing something obvious, keen to hear your thoughts!
",zuhair-naqvi,josephsavona
676,2015-12-22 19:04:10,"@josephsavona 

Thanks for linking me here. That makes a lot of sense, and it's a really neat implementation. I'll update the README on relay-local-schema appropriately.

In a perfect world, I'd like to be able to entirely avoid the waterfalls and send un-cached GraphQL queries wholesale to the master (especially in a mobile context), but just using DataLoader sounds like a really neat implementation.
",taion,josephsavona
676,2015-12-23 05:57:54,"@skevy thanks for the suggestion. @josephsavona thanks for your help so far, you've been great!

At this stage, we've decided to use Redux for our project given the timelines we're working with but I'd be keenly watching how the Relay and React Native communities toy with this idea as it could potentially kill three very hairy birds (i.e. Offline, Real-time and Local state) with one teeny-tiny stone (if it works). 
",zuhair-naqvi,skevy
676,2015-12-23 05:57:54,"@skevy thanks for the suggestion. @josephsavona thanks for your help so far, you've been great!

At this stage, we've decided to use Redux for our project given the timelines we're working with but I'd be keenly watching how the Relay and React Native communities toy with this idea as it could potentially kill three very hairy birds (i.e. Offline, Real-time and Local state) with one teeny-tiny stone (if it works). 
",zuhair-naqvi,josephsavona
676,2015-12-23 15:12:12,"@amasad I'm almost positive all the issues @zuhair-naqvi described above have to do with https://github.com/facebook/react-native/issues/4062
",skevy,amasad
676,2016-07-06 10:30:43,"@josephsavona I'm trying to make relay offline using relam db and relay-local-schema. I want to update relay store manually where I have a query and payload from my custom network layer. I have used `Relay.Store.getStoreData().handleQueryPayload(query, payload)`. where query is created using `Relay.createQuery(relayQueryQL, variables)` where relayQueryQL is create using `Relay.QL `${queryString}``

When I try to provide queryString like this:



similar to one that goes over network it throws error. Can you suggest how to use `handleQueryPayload` using such type of query strings. I tried looking in RelayRenderer.js to check how query and data are written `RelayStore`.
",shahankit,josephsavona
676,2016-07-07 01:08:13,"@josephsavona I have created a stackoverflow thread here: http://stackoverflow.com/questions/38236178/updating-relay-store-for-queries-with-multiple-definitions. I would be very nice if you could answer it there or here if possible.
",shahankit,josephsavona
676,2017-03-05 03:24:45,"@josephsavona I also created a SO question: http://stackoverflow.com/questions/42604115/use-relay-cache-data-on-react-native-app-while-fresh-data-is-being-fetched
I would appreciate if you share some thoughts there.
Thanks in advance.",helielson,josephsavona
674,2016-05-05 16:23:08,"@taion thanks for the follow-up. We'd be happy to remove the sCU option, we'll probably wait until `react-router` and other popular libraries using context have updated with the approach you described.
",josephsavona,taion
674,2016-05-05 16:58:17,"@josephsavona Our current tentative plan is to cut a React Router v3.0.0-pre.0 (or some other prerelease tag) within the next day or two, with the live links.
",taion,josephsavona
674,2017-02-01 06:17:27,"@taion @devknoll @josephsavona   the current replay container allows user to specify its own implementation of scu. 
so if you pass a `()=>true`, you effectively disabled RelayContainer SCU

what I'm interested in, is to integrate default SCU with customer provided SCU together. something like this:

there are 2 main changes in above code
1. if relay thinks it should re-render the component, then do it
2. if relay thinks it doesn't need to re-render the component, then asks the user's opinion
3. when calling customer provided SCU, **please bind `this` and pass along props, state and context** as the current implementation pass nothing

Please suggest if the idea makes sense and I can create a PR for it once confirmed.",bochen2014,taion
674,2017-02-01 06:17:27,"@taion @devknoll @josephsavona   the current replay container allows user to specify its own implementation of scu. 
so if you pass a `()=>true`, you effectively disabled RelayContainer SCU

what I'm interested in, is to integrate default SCU with customer provided SCU together. something like this:

there are 2 main changes in above code
1. if relay thinks it should re-render the component, then do it
2. if relay thinks it doesn't need to re-render the component, then asks the user's opinion
3. when calling customer provided SCU, **please bind `this` and pass along props, state and context** as the current implementation pass nothing

Please suggest if the idea makes sense and I can create a PR for it once confirmed.",bochen2014,josephsavona
674,2017-02-01 06:17:27,"@taion @devknoll @josephsavona   the current replay container allows user to specify its own implementation of scu. 
so if you pass a `()=>true`, you effectively disabled RelayContainer SCU

what I'm interested in, is to integrate default SCU with customer provided SCU together. something like this:

there are 2 main changes in above code
1. if relay thinks it should re-render the component, then do it
2. if relay thinks it doesn't need to re-render the component, then asks the user's opinion
3. when calling customer provided SCU, **please bind `this` and pass along props, state and context** as the current implementation pass nothing

Please suggest if the idea makes sense and I can create a PR for it once confirmed.",bochen2014,devknoll
670,2015-12-10 02:15:58,"Thank you @wincent 

I asked 2 questions on Stackoverflow. Please have a look [here](http://stackoverflow.com/questions/34192507/how-to-pass-total-count-to-the-client-in-pageinfo) and [here](http://stackoverflow.com/questions/34192587/how-to-navigate-without-cursors-in-a-connection)
",BerndWessels,wincent
670,2015-12-10 02:18:18,"@josephsavona OK, no worries. Was just thinking that this was a missing feature.
",BerndWessels,josephsavona
668,2015-12-09 22:13:34,"@josephsavona It might be it. However, my configurations is as simple as possible, I just used what relay starter kit offers. I wonder if others experienced this behavior. And if this happens on a slight configuration change, which I am not sure 100%, then since this is a huge behavior that is totally unexpected and and affects developer experience, my guess is that it should better be documented here and after a confirmation, it should be considered as a bug. Lets wait if this incidence really limited to my case. Thanks. I am opening that Stack Overflow thread.
",cettox,josephsavona
666,2016-01-10 20:21:57,"@Globegitter Is there a reason why something like the following wouldn't work:
1. Keep track of all of the `RelayMutationTransaction`'s you generate with `applyUpdate`
2. After `onSuccess` of your actual mutation, call `rollback` on the list

This assumes that your actual mutation's fat query includes the changed fields.

FWIW in a past project of mine with a similar UI, I decided to send off incremental updates like this for UX and analytics, e.g. in the case the browser was closed without submitting. 
",devknoll,Globegitter
666,2017-01-30 19:11:40,"(Spring-cleaning). Going to close this one out due to inactivity, and given that a workaround like the one recommended by @devknoll is likely to be viable. Sorry for letting this one sit stale for so long!",wincent,devknoll
664,2015-12-08 00:27:54,"@josephsavona 
Ok, I posted the question on [Stack Overflow here](http://stackoverflow.com/questions/34145915/how-to-accumulate-resolve-calls-for-a-single-request).
Cheers
",BerndWessels,josephsavona
664,2015-12-08 00:56:54,"@josephsavona Thanks, added a comment to your answer, please check.
",BerndWessels,josephsavona
663,2016-11-24 02:42:05,"@josephsavona Ok, thank you for pointing that out. I'll see if I can submit a PR this week.",Naoto-Ida,josephsavona
662,2016-01-28 16:27:30,"This is fantastic, @plievone. I've wanted to get rid of those workarounds for the longest time!

Sorry that we let this one get stale; since you pushed this we already updated (to an even later version of Flow) and fixed some of the issues independently. I've gone through and picked out the changes that are still relevant, so I am going to mark this one as closed. Thanks once again for your contribution!
",wincent,plievone
661,2015-12-14 17:39:10,"Hi @plievone, sorry for letting this sit for a while. We've had some bigger updates to the codebase. I see you're change consists of a codemod diff and some manual changes. Would you mind redoing the automated part on master? This should reduce the work required to rebase the manual part.
",kassens,plievone
661,2015-12-15 20:09:59,"> I would also update all the lint deps here to make sure you have latest eslint, babel-eslint (and then fix the version numbers - the ranges have been annoying in other projects as rules change).

@kassens One could also pin some devDependencies here to a point version as zpao suggested.
",plievone,kassens
660,2015-12-11 03:19:04,"@josephsavona Thanks for the answers.

I think #114 will address the use-cases I was getting at!
",zuhair-naqvi,josephsavona
658,2015-12-07 12:49:40,"@josephsavona  adding a direct explanation for how to generate Schema JSON.(the old docs do not explain how to generate Schema JSON ,but give a link to the code of starter kit )

The example code in `starter kit` is too long for illustration ( await just one function does not make sense there ).  So i modified that codes from async/await to directly promise.
The original code in start kit is



be simplified to 



as the code is short enough,so it maybe suit for putting in the .MD file directly to illuminate how to generate Schema JSON.
",iamchenxin,josephsavona
658,2016-03-08 10:03:59,"@yungsters Im so sorry, just saw this yet . modified them by review.
",iamchenxin,yungsters
658,2016-03-08 10:05:21,"@yungsters never mind , thank you! its my fault.
",iamchenxin,yungsters
656,2015-12-06 20:34:50,"@josephsavona was right - the problem was that I use webpack and have react and relay as external dependencies rather than compiling it into the application bundle - and the external dependency to react-relay was not updated.
Thanks again Joseph - sometimes it helps if somebody else just points out the obvious, especially when you work alone on a project.
Cheers
Bernd
",BerndWessels,josephsavona
655,2016-01-16 20:02:01,"@steveluscher Should we open up a new issue for this query building problem? I checked via the debugger and am pretty sure the refetching (in terms of building the fragment pointer object) is now successful.
",thebritican,steveluscher
655,2016-03-06 05:26:08,"Have you had any luck with this @josephsavona?
",thebritican,josephsavona
651,2016-01-10 20:40:03,"@vslinko Do you mean that you don't want to pass the userId as an input argument (in the GraphQL sense) or as an argument to the mutation?

The only requirement is having the ID passed as a prop to the mutation. If you can pass it as a _mutation prop_, you can reference it with e.g. `this.props.user_id` _without_ including it in `getVariables()` and passing it as a GraphQL input argument.
",devknoll,vslinko
647,2016-02-08 22:57:22,"This is important, so I'm going to fold it into #538, which is about overhauling the mutations API. (It will be easier to manage with the various interrelated mutations issues in a single place.)

Thanks once again for filing the report, @jardakotesovec!
",wincent,jardakotesovec
646,2016-03-02 21:01:24,"@jardakotesovec Thanks for your contribution. I definitely want to see this fix land, but I have some feedback.
",yungsters,jardakotesovec
646,2016-03-07 23:08:03,"@yungsters Thanks a lot. Do you have some thoughts on getStatus issue I mentioned in my initial comment?  Would be handy if getStatus would return something when its processed instead of exception.
",jardakotesovec,yungsters
644,2016-09-12 15:33:45,"@wincent React has dropped IE8 support but still supports IE9, is Relay going to support IE9 as well? If it is then I have to mention that IE9 doesn't support FormData nor FileReader API which means the only way to send file from front-end is to send it using hidden iframe. So if Relay intends to support IE9 fully is it going to support fallback for IE9 to support file upload?

Second thing is CORS. If API and web application are not on the same domain IE9 will have CORS issue. In this case, if GraphQL server is on one domain and client side Relay app is on another does this mean Relay will still be able to support xDomain object workarounds to support IE9 CORS? This problem was somewhat fixed for our Angular apps using https://github.com/jpillora/xdomain module.
",niksajanjic,wincent
642,2017-02-13 03:20:23,@wincent is this currently achievable with Relay 2's GraphQLMutation today?,juhaelee,wincent
639,2016-04-14 15:52:03,"@xuorig This is great! We should definitely move in this direction. However a codemod seems to be non-trivial to write, and either way we'd ideally have at least one release that supports both the old and new behaviors. How about instead of immediately _replacing_ ``rangeBehaviors` with a function, we instead add the option of defining a `getRangeBehaviors` function. Only one or the other can be provided, and internally RelayMutationQuery can use `getRangeBehaviors` to construct the `rangeBehaviors` object.
",josephsavona,xuorig
636,2015-11-30 12:22:04,"@josephsavona The issue is that `npm view babel-relay-plugin` shows that latest is still `0.4.1`, so the plugin releases haven't been published to npm for a while. (Also it seems that `react-relay` 0.5.0 package has peerDependency to babel-relay-plugin 0.4.x)
",plievone,josephsavona
636,2015-11-30 18:41:09,"@josephsavona Would be good if with the upcoming `react-relay` `0.6.0` release you could bump the `babel-relay-plugin` version to `0.6.0` too. Especially since they are tightly related anyway. That would stop all the confusion and lots of unnecessary git issues.
",BerndWessels,josephsavona
635,2015-11-29 19:54:56,"Thank you @josephsavona , but it looks like that there is no `babel-relay-plugin` with version `0.5.0` on npm.

Can you please publish it?

Thank you
Bernd
",BerndWessels,josephsavona
635,2015-11-29 21:25:41,"@josephsavona I am already referencing `react-relay` in version `0.5.0`:



But that doesn't solve the problem. The problem must be with the `babel-relay-plugin` itself?
",BerndWessels,josephsavona
635,2015-11-29 22:02:54,"@josephsavona OK, thank you. I will wait for that then and let you know if that fixes it.

I am still confused about if there needs to be a `babel-relay-plugin`  release in sync with the `react-relay` releases?

Thanks
Bernd
",BerndWessels,josephsavona
635,2015-12-06 19:54:06,"Hi @josephsavona 
I upgraded to `0.6.0` but unfortunately the error is still present. Can you please have a look at it again if  it is really fixed?
Updated details can be found [here](https://github.com/facebook/relay/issues/656)
Thank you
Bernd
",BerndWessels,josephsavona
631,2015-11-25 05:20:06,"Whoa, nice. First item on the wiki, too. Thanks @josephsavona! 
",kevinSuttle,josephsavona
626,2016-03-11 16:59:28,"@sahrens Nice to know it was so helpful for you!
",denvned,sahrens
625,2015-12-06 09:16:04,"@steveluscher Thanks for feedback!
Applied all of your corrections.
",denvned,steveluscher
625,2016-02-17 18:41:07,"@denvned I recently committed f1373602073972ffa06854c676cf61f79c4fa3cc which introduces two new props to `RelayRenderer` — `onPrimeCache` and `onForceFetch` — that allow you to supply the behavior when a set of queries is to be fetched. If instead of reordering when queries are run, you simply supplied dummy functions into these props, would that solve your use case?
",yungsters,denvned
625,2016-02-17 19:54:12,"@yungsters Actually, when upgrading [isomorphic-relay](https://github.com/denvned/isomorphic-relay/) to Relay 0.7, I tried to make use of these new props, but it didn't work out. Not running the queries on the server is only part of the deal, we also need to initialize the state with preloaded data before the first render, i.e. before mount. But if pass prepared ready state to `onReadyStateChange` callback before render, React throws an error because  `onReadyStateChange` calls `setState`, and React does not allow calling `setState` before mount.

So, to make these props useful for isomorphic rendering we probably have to allow calling `onReadyStateChange` callback synchronously, before render.
",denvned,yungsters
624,2015-11-25 16:26:09,"I was intrigued and got Star Wars example working in IE8 with a couple of changes:
- You can get rid of infinite recursion by renaming `createNode` in [RelayQuery.js](https://github.com/facebook/relay/blob/f7c61d8/src/query/RelayQuery.js#L1274). You can see the problem in built file, where [the other `createNode`](https://github.com/facebook/relay/blob/f7c61d8/src/query/RelayQuery.js#L338) has also a local function name `createNode` (to be displayed in stack traces), confusing IE8 scopes. @josephsavona You may want to rename the outer `createNode` helper to avoid confusion?
- You can use some IE8-compatible fetch polyfill instead of whatwg-fetch, such as `fetch-polyfill`, otherwise the data won't be available and only a blank page renders.

Haven't tested it further, but the example renders fine. There are proptype and contexttype validation warnings due to shims adding extra Symbol-related properties to `RelayPropTypes.QueryConfig`, and React shape validator doesn't check the hasOwnProperty. But they won't kill the page. There may well be other errors yet uncovered, though.
",plievone,josephsavona
623,2015-11-25 20:47:26,"Closing as @plievone's suggestion should solve this. 
",josephsavona,plievone
622,2015-11-21 00:46:18,"@plievone thanks!!!!
",josephsavona,plievone
621,2015-11-20 17:05:45,"Thanks for the quick fix @josephsavona !
",Globegitter,josephsavona
620,2015-11-20 16:49:39,"@josephsavona I have posted this question to Stack Overflow. Here is the link

https://stackoverflow.com/questions/33831911/cannot-set-property-clientmutationid-of-undefined
",ansarizafar,josephsavona
618,2015-11-20 15:55:28,"@Globegitter thanks for filing this, see #621 for a fix
",josephsavona,Globegitter
618,2015-11-23 17:59:44,"@Globegitter thanks again for bringing this up!
",josephsavona,Globegitter
616,2015-11-23 15:41:36,"@xuorig did you resolve this?
",josephsavona,xuorig
616,2015-11-23 15:55:44,"@josephsavona yes I forgot to add a script tag for react-dom :facepalm:
",xuorig,josephsavona
615,2015-11-29 19:06:03,"> First, since rangeBehaviors wont be an object anymore, these lines here wont work as expected.

@xuorig Good point. It's possible to list all combinations of fetched connection calls given the parent id of the connection. For example, given `viewer { friends(...) }`, if we know the `viewer` id then we can list out all the combinations of arguments on `friends` that have been fetched. That's available as [`RelayRecordStore#getConnectionIDsForField`](https://github.com/facebook/relay/blob/master/src/store/RelayRecordStore.js#L571-L595). That will give you a list of connection IDs which you can then use to call [`RelayRecordStore#getRangeFilterCalls`](https://github.com/facebook/relay/blob/master/src/store/RelayRecordStore.js#L611-L620). Together this should give you all the sets of calls needed to replace the check you mentioned in [RelayMutationQuery](https://github.com/facebook/relay/blob/master/src/mutation/RelayMutationQuery.js#L211).

> To be able to receive argument as an object like this: ... It means we'll need to transform the RangeFilterCalls

Yup, we'll have to map the array into an object for convenience.
",josephsavona,xuorig
615,2015-11-30 16:06:25,"@josephsavona good to know! 

I'm trying to get the recordStore by requiring `RelayStoreData` and getting the record store like this `RelayStoreData.getDefaultInstance().getRecordStore()`. It works in tests but somehow when I test it with the todo example, `RelayStoreData` is an empty object and `getDefaultInstance` is `undefined`... Any idea what's going on ?
",xuorig,josephsavona
615,2015-11-30 16:41:08,"@xuorig are you trying to require `RelayStoreData` from outside of Relay? If so, you'll have to use `require('react-relay/path/to/RelaySoreData')` - individual files from npm packages aren't publicly available via `require('<name>')` so you have to require by path.
",josephsavona,xuorig
615,2015-11-30 16:42:42,"@josephsavona Not even, I'm requiring it inside `RelayMutationQuery`, the require throws no errors either, just returns an empty object!
",xuorig,josephsavona
615,2016-05-10 15:56:49,"@xuorig implemented this in 56e52d3
",josephsavona,xuorig
615,2016-06-15 21:40:55,"@brysgo Good catch, @xuorig has put up #1216 to address this.
",josephsavona,xuorig
611,2015-11-19 06:28:32,"@devknoll With the additional `FIELDS_CHANGE` config, the unexpected behaviour indeed disappears (thanks!). @yuzhi Here is the complete `getConfigs()`:



However, two things remain unclear to me:
1. Relay _does_ already have the information on the `viewer`'s ID (from the `NODE_DELETE` config). It could already use this information to perform a more complete intersection.
2. Why did the workaround work? I mean, this fat query without the additional `FIELDS_CHANGE` config:


",guigrpa,yuzhi
611,2015-11-19 06:28:32,"@devknoll With the additional `FIELDS_CHANGE` config, the unexpected behaviour indeed disappears (thanks!). @yuzhi Here is the complete `getConfigs()`:



However, two things remain unclear to me:
1. Relay _does_ already have the information on the `viewer`'s ID (from the `NODE_DELETE` config). It could already use this information to perform a more complete intersection.
2. Why did the workaround work? I mean, this fat query without the additional `FIELDS_CHANGE` config:


",guigrpa,devknoll
611,2015-11-19 18:47:38,"Awesome, thanks for the clarification @yuzhi :smile: I was kinda hoping that it would be garbage collected at that point...
",devknoll,yuzhi
611,2015-11-19 19:07:58,"@yuzhi: just a final question: if the node is removed ""from all known connections"", why do you need to specify a particular one in the `NODE_DELETE` config?
",guigrpa,yuzhi
610,2015-11-20 07:35:18,"@yuzhi  also i have a question is that how should i generate cursor of a connection which could present a dynamic list (like some answers of a question, the list will resort after user like one of them or as time pass by)
",filod,yuzhi
608,2015-11-20 03:09:37,"@steveluscher 
Thanks, that makes sense. I will break this out as an independent example.
",rojobuffalo,steveluscher
607,2015-11-19 15:03:23,"@xuorig we'll land this as time permits - shipping it requires a codemod bc we don't want warnings everywhere we call `update`.
",josephsavona,xuorig
607,2015-12-01 15:11:57,"@josephsavona @xuorig What do you think? Should I provide another PR that adjust `rollback` function that can rollback also transactions with status `COMMIT_QUEUED`?  
",jardakotesovec,josephsavona
607,2015-12-01 15:11:57,"@josephsavona @xuorig What do you think? Should I provide another PR that adjust `rollback` function that can rollback also transactions with status `COMMIT_QUEUED`?  
",jardakotesovec,xuorig
607,2015-12-01 17:18:22,"> Should I provide another PR that adjust rollback function that can rollback also transactions with status COMMIT_QUEUED?

@jardakotesovec That would be great - all that should be required is updating the status check in `RelayMutationTransaction` to allow calling `rollback` when the transaction is queued. The actual logic for the rollback in `RelayMutationQueue` should already handle this case.
",josephsavona,jardakotesovec
607,2015-12-04 14:44:12,"@Globegitter It does not..   as decided in #550,  control of transaction handling is given to the programmer. So with this PR, you have to keep track of the transactions on your own. 

But api could be extended for example to either provide function that commit all uncommited transactions as you suggested, or just provide you list of uncommited transactions so you can commit them.
",jardakotesovec,Globegitter
607,2015-12-08 21:19:49,"@jardakotesovec So right now we would have to manually keep track of each transaction that is being returned by `applyUpdate` (and e.g. store them in an array). Then at some point just go through all the transactions and commit them? Would this then make an individual request for each committed transaction or is there a way to commit all transactions in one HTTP request? 

But yeah for our use-case it would be useful to have an API to commit all uncommitted transactions (in one request).
",Globegitter,jardakotesovec
607,2015-12-09 06:33:55,"@Globegitter I think you should open new issue/PR to keep track of this use case and discuss potential improvements.

Relay currently sends [one](https://github.com/facebook/relay/issues/205) http request per mutation.

What you have described is correct (keeping list of transaction and committing all of them individually)
",jardakotesovec,Globegitter
606,2015-11-18 07:35:38,"@josephsavona I extended the PR by replacing `fromGraphQL` with `fromJSON` (in a separate commit).
",denvned,josephsavona
606,2015-11-19 15:09:39,"@denvned Thanks again for working on this. Thinking about the implications of landing this, though, there are really two aspects to this change:
- Change query serialization to stop modifying `__concreteNode__` - this is a simple change to make `getConcreteQueryNode` just return the concrete node and not support overwriting it. The results of `toGraphQL` no longer need to be cached.
- Changing the internal API from `to/fromGraphQL` to `to/fromJSON` and rewriting the modules.

The former has immediate value for server rendering and requires minimal API changes (only affects RelayQuery and toGraphQL) - we're happy to support and land this. The latter is aesthetic and requires updating a bunch of APIs internally - we don't have the time to support this second change for now. Would you mind splitting this PR along those lines?
",josephsavona,denvned
605,2015-11-16 19:28:54,"Hi, @xuorig 

Thanks for a bump in the right direction! The error was on my part: The server was only passing on the `query` part of the JSON to `graphql()`, missing the `variables` part. The problem was completely resolved using `express-graphql` instead of ""manually"" parsing the body and passing it on.

Thank you!
",mikberg,xuorig
604,2015-11-17 23:23:21,"> Just to be sure, can you check the query variables inside the container with the query of the connection where it includes dates as the variables?

The variables are correct as far as I can see (I console.log'd them in `prepareVariables`). Also, when I mean navigate back it doesn't have to be using the back button. Simply pressing a navigation arrow in my calendar ui does the same thing.

@taion I am using `prepareVariables` on the relay container to compute the relay variables `startDate` and `endDate` from the url query params `date` and `mode`. Not using `prepareParams` though.
",johanobergman,taion
604,2015-11-19 10:59:44,"@steveluscher Great!

I'm still not sure if the cache issue is caused by `relay` or `react-router-relay`. I changed my implementation to use `relay.setVariables` instead of query params with `react-router-relay`, but the result was still the same.
",johanobergman,steveluscher
604,2015-11-19 22:05:41,"That sounds super weird.  @taion could react-router-relay be doing any weird caching?
@johanobergman do you think you can make minimal repro case for the `setVariables` problem?
",yuzhi,taion
604,2015-11-19 22:28:57,"@taion It made no difference, sadly. When you say drop - `react-router-relay` is still around, I've just replaced my `<Link>`s with `relay.setVariables`. 
",johanobergman,taion
604,2015-11-19 23:01:19,"@yuzhi I made some digging starting from `RelayContainer@componentWillReceiveProps`. In `_getQueryData()`, the `fragmentPointer` appears to be correct, and `queryResolver.resolve(fragmentPointer)` returns an object where the `__dataID__` property corresponds to the connection I want to load, but the `edges` property contain the wrong edges.

Is it possible to set a breakpoint somewhere to see all cached connections keyed by `__dataID__`? I'm curious if my mutation overwrites all caches with the first (or second or whatever) cache.
",johanobergman,yuzhi
601,2015-11-16 03:52:59,"@dminkovsky We previously referred to field arguments as calls and it looks like we slipped up and used the old terminology in places. We'll fix it as time permits, but we're always happy to receive PRs to make the documentation more clear.
",josephsavona,dminkovsky
599,2015-11-16 18:49:36,"@xuorig thanks for your patience. We chatted offline and came up with the following API:
1. `Relay.Store.applyUpdate(mutation, callbacks): RelayMutationTransaction` - does not commit the mutation immediately (e.g: rename `updateLocal` to `applyUpdate`)
2. `Relay.Store.commitUpdate(mutation, callbacks): RelayMutationTransaction` - commits the mutation immediately (this replaces the existing `update`)
3. `Relay.Store.update(...): void` - mark this as deprecated and suggest using `commitUpdate`.

Would you mind changing `updateLocal` -> `applyUpdate` and adding docs for this method (item 1)? We can address 2 & 3 separately (of course you're welcome to do these too if you have time). Thanks!
",josephsavona,xuorig
599,2015-11-16 23:26:57,"@xuorig awesome, thanks! just two minor nits, otherwise this looks good to go.
",josephsavona,xuorig
598,2016-01-20 15:54:46,"@jardakotesovec I'm only closing the PR, we're still thinking about ways to address the growth of tracked queries on connections.
",josephsavona,jardakotesovec
598,2016-01-20 16:14:23,"@josephsavona ok.. but all related issues are also closed.. so there is nothing to track..  This was last opened piece :-)...
",jardakotesovec,josephsavona
598,2016-01-20 17:59:46,"@jardakotesovec good call! I created https://github.com/facebook/relay/issues/756 to track the issue itself as opposed to this specific approach to solving it.
",josephsavona,jardakotesovec
594,2015-11-17 01:20:03,"@devknoll I see what you mean, I guess this solution would make errors inaccessible for anybody wanting to use them when there is data. @josephsavona what do you think ?
",xuorig,devknoll
594,2015-12-06 04:23:57,"@devknoll or @josephsavona, can you give this one last look, then close if you decide we should leave the current behavior as it is?
",steveluscher,devknoll
594,2016-01-04 23:34:52,"Ping @devknoll. Do we have other ideas, or shall we close this up?
",steveluscher,devknoll
594,2016-01-05 01:04:30,"@steveluscher I'm no longer maintaining code that relies on this (hooray for objective opinions!) but still stand by my previous thoughts. 

I think that any errors should also be passed to the success callback (could just be sibling to `response`) and this documented as a breaking change.

My reasoning is: A) this matches the GraphQL behavior and B) an invariant of ""errors from the server are always passed to application code"" just seems nicer for the developer
",devknoll,steveluscher
594,2016-01-08 23:11:23,"Thanks for the contribution @xuorig! I'm going to close this up. Feel free to open it again if any new information comes up that might change things.
",steveluscher,xuorig
593,2015-11-13 18:06:11,"@josephsavona Something else is amiss here, as the parent does not use the `name` property and should not need to know about it?

Does it need `@relay(plural:true)` on the parent? Or perhaps the `{...child}` spread  in `children.map( )` acts funnily? 

Also speaking about data masking, todo example manages to depend on [`viewer.todos`](https://github.com/facebook/relay/blob/7e96455/examples/todo/js/components/TodoApp.js#L47)  in quite an implicit way without declaring it?
",plievone,josephsavona
593,2015-11-13 18:56:33,"@plievone Can you clarify what is different than you expected? It would be helpful to see:
- the component definition with fragments, for the component that is receiving unexpected data
- the actual data received by that component
- the expected data that you thought it would receive

Note that in the above example, the actual data received by the `Parent` component seems to be:



Which is correct per `Parent`'s fragment definition and Relay's data-masking.
",josephsavona,plievone
593,2015-11-13 19:20:45,"@josephsavona Can I declare in Parent component what should be fetched for Child via `Child.getFragment('child')`?

I have a Parent, where I described what should to be fetched by `viewer` query. But in this case I would not receive data from `Child.getFragment('child')`.



But as you mentioned, I can receive exactly what I want if I would not use `Child.getFragment('child')`. 



So, when should I use it `Child.getFragment('child')`? How to compose relay containers? Thank you.
",mikhail-riabokon,josephsavona
593,2015-11-13 20:16:22,"@josephsavona Thank you for the article. I already read it. But I still have problems. If I changed `Parent` render method and will render  `Child` Relay Container instead of `Child.jsx` I got a warning



So If I want to fetch data for children, and did not declare that children should have in `Parent` relay container, I should pass `Child` in `RootContainer` and render that in `Parent`?

Could you share an example of Relay and GraphQL, without `graphql-relay``  usage? Thank you in advanced. 
",mikhail-riabokon,josephsavona
593,2015-11-14 07:33:10,"@josephsavona Thank you a lot.
",mikhail-riabokon,josephsavona
589,2015-11-22 15:23:55,"Here is my work on isomorphic `RelayRenderer`: https://github.com/denvned/relay/commits/isomorphic-renderer

It uses #625 as a base.

@josephsavona as you suggested I added to `RelayRenderer` a property that triggers synchronous render, and I didn't touch `GraphQLQueryRunner`. The property is a boolean named `prepared`. If the property is set, `RelayRenderer` initializes its state by checking the store cache. If all the data is already in the store and the force fetch mode is not used, then it doesn't send any queries. If only deferred data is missing, then it renders with available required data, and sends queries to fetch the remaining deferred data.

So, it is enough to set the `prepared` property to switch on the isomorphic mode in `RelayRenderer`:



But you should examine the source to see the details. It looks pretty solid for me.

Is that good for a PR?

TODO: tests for the new mode.
",denvned,josephsavona
589,2015-12-03 03:23:12,"Hi @josephsavona, I am currently working on a project that will need this feature; and wondering if the above mentioned PR is a feasible solution?  or what needs to be done to make progress on this feature? and thanks @denvned for your work :+1: 
",willopez,denvned
589,2015-12-03 03:23:12,"Hi @josephsavona, I am currently working on a project that will need this feature; and wondering if the above mentioned PR is a feasible solution?  or what needs to be done to make progress on this feature? and thanks @denvned for your work :+1: 
",willopez,josephsavona
589,2015-12-30 04:03:20,"> Yeah it seems that way, but it actually isn't necessary. RelayQueryRoot objects can be serialized to plain objects/arrays via the toGraphQL.Query(relayQuery) function. 

@josephsavona , @yungsters Looks like it is not possible anymore because of https://github.com/facebook/relay/commit/a26c8b4703adb3ae1b28421fdd06a9b7e8140f85. Is it possible to revert that commit back? It will be hard to implement `Relay.prepare`, as discussed above, without `toGraphQL`. Also [isomorphic-relay](https://github.com/denvned/isomorphic-relay), which many people use, already actively [uses](https://github.com/denvned/isomorphic-relay/blob/v0.4.0/src/prepareData.js#L20) `toGraphQL`.
",denvned,josephsavona
589,2015-12-30 05:58:51,"@denvned Sorry about that. I have a revision awaiting internal review that will bring this back.
",yungsters,denvned
589,2015-12-30 08:28:35,"@yungsters please add a note about `toGraphQL` method, that it used for isomorphic apps, for debugging and logging. Its removing should be prevented in future.
",nodkz,yungsters
589,2015-12-31 05:17:50,"@yungsters Thanks for bringing `toGraphQL` back!
",denvned,yungsters
589,2016-05-10 15:59:41,"This has been implemented as `Relay.ReadyStateRenderer`. @denvned can you confirm that there's nothing left to do here?
",josephsavona,denvned
589,2016-05-13 16:36:28,"@josephsavona In _isomorphic-relay_ I have managed to implement [`IsomorphicRelayRenderer`](https://github.com/denvned/isomorphic-relay/blob/v0.7.0-beta.0/src/IsomorphicRenderer.js) that does not use Relay private API anymore, thanks to `Relay.ReadyStateRenderer`. So, yeah, this specific issue is probably solved.

But some other parts of _isomorphic-relay_ still have to use few Relay internals, namely `toGraphQL.Query`, `fromGraphQL.Query` and `RelayStoreData#handleQueryPayload`. Any ideas how we would replace these with public API? Would [GraphMode](https://github.com/facebook/relay/issues/967) help with this?
",denvned,josephsavona
589,2016-05-13 16:46:59,"> But some other parts of isomorphic-relay still have to use few Relay internals, namely `toGraphQL.Query`, `fromGraphQL.Query` and `RelayStoreData#handleQueryPayload`

@denvned thanks for confirming. We should add public methods for serializing/deserializing queries (the to/fromGraph stuff). `handlQueryPayload` is now accessible via `RelayEnvironment#getStoreData()#handleQueryPayload`.
",josephsavona,denvned
588,2015-11-12 18:11:29,"@dminkovsky
To make debugging easier, can you copy paste the config for your mutation and the optimistic payload?
",yuzhi,dminkovsky
588,2015-11-12 18:16:40,"Thanks @yuzhi.

I could do that, but I am guessing to really make it worth your while to spend time on this, I should 
provide a little working project that shows a complete round trip. 

I am working toward a deadline now; but this is important for me. I'm sure you wouldn't mind if I get back to you in a few days?
",dminkovsky,yuzhi
585,2015-11-11 23:20:33,"@josephsavona latest Chrome. Attached is a (crappy) screenshot with values from the debugger.

<img width=""1787"" alt=""screen shot 2015-11-11 at 3 19 42 pm"" src=""https://cloud.githubusercontent.com/assets/368904/11106016/ac547fba-8887-11e5-88cf-98eaa4c45814.png"">
",LegNeato,josephsavona
585,2015-11-12 00:41:29,"@taion We previously allowed argument-less query builders to have fragments, but this doesn't make sense. The stricter check is here: https://github.com/facebook/relay/commit/c9baf7f19a05b20bed6474d14fdbc8e3111e913e#commitcomment-14343423
",josephsavona,taion
579,2015-11-17 18:35:09,"@josephsavona as I stated also in the issue #533 this code is mostly for guidance.
I just focused on how to make it work for the projects I am working on which depend on this plugin.
For simplicity I just modified the output of the generated files. However, from that it should be quite straightforward to modify the source files.

I will check later today if you got this to work, if not I will work on the source files.
Let's get it done :)
",amenuor,josephsavona
579,2015-11-18 00:21:08,"@josephsavona I have checked-in the major changes to have this plugin working on babel6.

I have had some issues with es6 Spread operator. Somehow it doesn't work on babel6 (it gives Syntax errors) or I couldn't make it work. Based on http://babeljs.io/repl/ (which still run babel 5.x) I have defined an _extends function and use that instead. Not elegant but it seems to work.

I receive several errors when trying to run the tests and check that everything is actually fine.
Flow doesn't like several hundreds statements in /node_modules/*
Jest complains about some syntax errors related to destructuring assignments as far as I can see...

However, the plugin builds fine... we just need to verify that it actually works :)
I do not have so much experience with Flow and Jest, so if you have maybe you can figure this out faster than I can?
",amenuor,josephsavona
579,2015-11-18 18:53:00,"@leebenson well spotted! :) Now it works correctly.
@josephsavona I have checked in the changes, and all tests pass on the plugin side. The build is still failing because of two main issues:

1) the main relay package is not supporting babel6 yet. I only worked on the babel-relay-plugin. I could help also on the main package if needed.
2) Flow gives 7000+ errors. I haven't looked much into it yet, but it seems to be related to the new packages in node_modules (as for instance babel-core). 
",amenuor,josephsavona
579,2015-11-21 02:08:50,"@josephsavona glad I could help :)
",amenuor,josephsavona
577,2015-11-11 04:15:04,"@zpao do you mind importing this? lgtm
",josephsavona,zpao
574,2015-11-18 18:18:12,"@josephsavona @kassens any comments on this ? Would be helpful to add that in :dancers: 
",xuorig,josephsavona
574,2015-12-17 05:10:02,"@steveluscher sorry for the wait, (finals week 😪) I have updated the PR with what you have recommended. I make the check in `buildFragmentForEdgeInsertion`. If the newEdge is not present in `mutatedFields` after it's been populated, we can assume `rangeBehaviors` was not matching the trackedConnection and we can warn.

Should this be an invariant or keep it as a warn ? Let me know if this is what you had in mind!
",xuorig,steveluscher
574,2016-01-06 00:20:26,"Thanks for your patience, @xuorig. We just went over this internally, and I'd like to share a summary of our discussion. I wrote:

> Let me try to work through this to make sure I understand it.
> 
> Client devs have the option of configuring a RANGE_ADD config or not. If they do configure one, it's likely because they expect it to be of use.
> 
> Now, if you've specified a RANGE_ADD config, there are tracked connections that match, but none of them match your rangeBehaviors, it's because you have a connection in your app with arguments that you haven't accounted for in your RANGE_ADD config. This is the aim of the warning, to say “hey… we found at least one tracked connection for that parentID/connectionName combination, but we couldn't find an associated rangeBehavior – did you forget to configure one?”
> 
> > @yungsters: …this warning … can be triggered [if] the key does not have a range behavior defined.
> 
> Interesting. To fallback by refetching the whole connection is good (and what the code does now if you don't have a matching range behavior) but one of the nice things about RANGE_ADD configs is to prevent refetching and to enable optimistic mutations. When you miss a rangeBehavior, you lose all of that without warning.

What if we changed the warning to indicate that the entire connection has been refetched and that the developer can't expect optimistic mutations to work, with a little bit about how to write a more efficient and optimism-compatible mutation. Something like:

> “Relay.Mutation: Since the connection `ships(orderby:""latest"")` of the field `faction` with id `123` matched none of the rangeBehaviors specified in your `RANGE_ADD` config, the entire connection has been refetched. Configure a range behavior for this connection to fetch only the new edge and to enable optimistic mutations. See http://… for more information.”

The only problem here is that there's no way for the developer to squelch this warning if their desired behavior _was_ to refetch the connection. Thoughts, @yuzhi @xuorig @yungsters?
",steveluscher,xuorig
574,2016-01-10 23:02:34,"@steveluscher @yungsters I propose that we change the warning message to something like @steveluscher proposed, where we clearly state which connection wasn't found in the rangeBehaviors. 

In another PR we can address the `REFETCH` / `ALL`  and `IGNORE` behaviors ? I would gladly work on a solution for this too.
",xuorig,yungsters
574,2016-01-10 23:02:34,"@steveluscher @yungsters I propose that we change the warning message to something like @steveluscher proposed, where we clearly state which connection wasn't found in the rangeBehaviors. 

In another PR we can address the `REFETCH` / `ALL`  and `IGNORE` behaviors ? I would gladly work on a solution for this too.
",xuorig,steveluscher
574,2016-01-11 03:12:50,"I have modified the PR with the message @steveluscher proposed. I think this might be a good first step to clear up the small confusion people have with `RANGE_ADD` mutations.
",xuorig,steveluscher
572,2015-11-12 20:38:59,"@devknoll no worries!
",josephsavona,devknoll
572,2015-11-13 03:14:55,"@josephsavona let me know if this works
",devknoll,josephsavona
572,2015-11-13 19:15:06,"@devknoll nice job on this!
",josephsavona,devknoll
570,2015-11-09 19:36:16,"@josephsavona What about the `injectBatchingStrategy` in `RelayContainer`? Should this just move to the `RelayContainer` constructor?
",devknoll,josephsavona
570,2015-11-13 01:38:53,"@devknoll I would recommend rebasing this after #572 closes. The best bet to avoid conflicting changes from earlier commits might be to just pull over all the changes starting with ""Move the garbage collector API into RelayStore"" onto a new branch off master. Obviously no rush :-)
",josephsavona,devknoll
569,2015-11-09 08:52:18,"Incredible work, how many peoples under @devknoll user? )))
",nodkz,devknoll
568,2015-11-09 17:31:27,"@devknoll I'll be importing these internally and recreating your stack of commits to isolate each change, bear with me.
",josephsavona,devknoll
565,2015-11-12 07:45:55,"@josephsavona Looks like all of those changes were made, just in a later commit (99ead02) and PR

_edit_: This is suuuuper confusing, haha. Let me rebase and see if 99ead02 can be moved to this PR.
",devknoll,josephsavona
565,2015-11-12 08:29:28,"@josephsavona Done. Rebased on master and rearranged the commits for the `GraphQLStoreQueryResolver` changes to come first.

I'll go back and get the rest of the PRs updated now.
",devknoll,josephsavona
564,2015-11-09 16:32:30,"@dminkovsky This is a great idea. We'd like to support the option to skip pending mutations with the same collision key instead of enqueueing them. There's an open issue at #550 discussing this, let's continue discussion there.
",josephsavona,dminkovsky
564,2015-11-10 04:39:36,"Thank you @josephsavona. Sorry I didn't find that issue. 
",dminkovsky,josephsavona
562,2015-11-12 02:35:39,"@devknoll I have a follow-up that should land soon to address the remaining module-scope state.
",josephsavona,devknoll
560,2015-11-07 22:25:50,"@devknoll this is definitely on the right track in terms of splitting up the changes incrementally. I'll review in more detail when I'm at a computer. 
",josephsavona,devknoll
559,2016-01-05 04:20:55,"I created a PR recently (https://github.com/facebook/relay/pull/721) which is more or less a Implementation of @josephsavona `DataContainer`.

That PR is based on the current version of Relay, which means there is no clear notion of ""Relay Core"".  In that sense it doesn't resolve this issue here.
",andimarek,josephsavona
559,2016-01-06 07:36:20,"@josephsavona Thanks for this quick response. I understand your position and that you want to make sure that those fundamental changes are going into the right decision.

Because my PR #721 will not be merged soon I might end up maintaining a temporary fork of relay to be able to use it without React. Of course I'm happy to contribute back the lessons learned. 
",andimarek,josephsavona
559,2016-01-06 12:05:54,"@josephsavona Thanks for these hints... I will check it out.
",andimarek,josephsavona
559,2016-03-11 07:57:37,"@josephsavona sure ... I will give feedback soon.
",andimarek,josephsavona
559,2016-03-12 13:28:26,"@josephsavona Overall it looks very good.
As a general goal I would also hope that relay-core will be a new npm module, with no dependency on react. 

About the proposed API: I think it covers already a lot.

I am not so sure about the cache specific methods: It could be more a implementation detail of the core and only visible through some flag (e.g.`useCacheOnly`) instead of specific methods like `fetchQueryFromCache`.
Based on my `generic-relay` experiment and the integration in Angular the  API seems a bit more low-level than needed. (Not saying this is wrong: Better this way than a too high level API, imho).

The server-less rendering is great, because it will help to have a central Relay-Store even when some data is fetched over the network outside of Relay.

What about methods for all running queries/tasks? This could also be useful. 
",andimarek,josephsavona
559,2016-07-06 02:30:00,"Thanks for the quick reply @wincent!
",syrusakbary,wincent
558,2015-11-08 21:23:21,"@josephsavona Do we want `RelayStore` to own the `RelayStoreData` instances? Seems like yes, but wanted to confirm.
",devknoll,josephsavona
558,2015-11-08 21:32:17,"@josephsavona Also `GraphQLStoreRangeUtils` seems a little tough. Not sure who should own the instance in this case. Going to try keeping it in `RelayStoreData` and passing it down.
",devknoll,josephsavona
558,2016-01-10 10:23:13,"@josephsavona you can use this syntax to track subtasks:



Result:
- [ ] In progress
- [x] Done
",vslinko,josephsavona
558,2016-03-09 13:45:15,"As of 8e53183bd4f323196a71f471d6275fe024706a66, all of Relay's internal state tracking has been contextualized. Each instance of `RelayEnvironment` is an isolated environment with its own cache of data, network layer, task scheduler, etc. This is an important prerequisite for server rendering in open source as well as allowing some new use cases. The next step is #559 - splitting Relay Core and the React/Relay integration layer - follow along there for more details.

Thanks especially to @denvned and @devknoll for their impressive contributions!
",josephsavona,devknoll
558,2016-03-09 14:59:26,"Amazing work! Thanks @denvned, @devknoll, @josephsavona . :tada:
",rodrigopr,josephsavona
558,2016-03-09 14:59:26,"Amazing work! Thanks @denvned, @devknoll, @josephsavona . :tada:
",rodrigopr,devknoll
558,2016-03-09 17:02:39,"Yeah!

On Wed, Mar 9, 2016 at 6:59 AM Rodrigo Ribeiro notifications@github.com
wrote:

> Amazing work! Thanks @denvned https://github.com/denvned, @devknoll
> https://github.com/devknoll, @josephsavona
> https://github.com/josephsavona . [image: :tada:]
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/558#issuecomment-194333793.
",KyleAMathews,josephsavona
558,2016-03-09 17:02:39,"Yeah!

On Wed, Mar 9, 2016 at 6:59 AM Rodrigo Ribeiro notifications@github.com
wrote:

> Amazing work! Thanks @denvned https://github.com/denvned, @devknoll
> https://github.com/devknoll, @josephsavona
> https://github.com/josephsavona . [image: :tada:]
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/558#issuecomment-194333793.
",KyleAMathews,devknoll
557,2015-11-07 09:04:48,"@devknoll - great to see you're thinking about this! Moving away from singletons will have to be done incrementally to keep everything working in the interim, but we're happy to provide support and help guide you through these PRs.

I can share an internal doc that I wrote detailing the high-level steps for removing singletons and global state, will follow-up tomorrow. 
",josephsavona,devknoll
557,2015-11-07 20:34:42,"@devknoll In addition to the previous issue to go with this PR, also take a look at #559 which describes our thoughts on drawing a clear boundary between Relay Core and the Relay/React integration. The proposed `RelayContext` there is a merge of the operations supported by the current `Relay.Store` and `RelayStoreData`.
",josephsavona,devknoll
556,2016-10-29 13:16:17,"I will not rubber stamp and land your change for you @josephsavona!  I can import it for you and you can get your change reviewed by someone though :)
",facebook-github-bot,josephsavona
553,2015-11-07 16:24:40,"@kassens Thanks. I will just mention some observations. You said that fields with the same name should merge, which I agree with.   But thats not happening for any fields right now (including simple ones not having any argument) as far as I can see. 

So for something like this



Relay sends



If its fragment



Relay sends



I don't see any merging going on. My understanding is that it somehow got merged on the server...

And that merging goes wrong on server for fields with enum argument. Thats reason why I blamed graph-ql for it.

In your example it makes sense to me that nameRed and nameRed2 resulted in the same name fields (_namevidys9) - because they will get same value..  and should be merged, no need to hash them differently in my opinion.
",jardakotesovec,kassens
553,2015-11-30 07:19:35,"@josephsavona Nope, wokrs fine now (on graphql 4.13). Thanks!
",vladar,josephsavona
550,2015-11-09 11:06:03,"@josephsavona Yes.. that should not be that difficult as my first time Relay contribution.

But not sure if make more sense to just silently remove pending transactions from the queue or make them fail so the transaction callback gets always called. It would be necessary indicate that the failing reason (probably via status) is that it is skipped.

I am inclining to the first option - just remove pending transactions (and all relevant clean up) as its easier and I don't see much benefit of calling the failure callbacks. But would like your opinion.

Also we need good api name for it, here are some ideas: `shouldClearCollisionQueue`/`shouldSkipCollisionQueue` or shorter options: `shouldClearQueue`/`shouldSkipQueue`
",jardakotesovec,josephsavona
550,2015-11-10 14:44:06,"I like @devknoll 's idea as it helps cover reasonable use case when user want to control (postpone) when update is sent to server. 

To keep discussion moving forward, here are some api ideas based on that idea:
Relay.Store.queue(mutation).commit(callbacks) could be equivalent to Relay.Store.Update(mutation, callbacks).

Both methods `queue` and `update` would return reference to transaction, which would have method `dequeue()`. This method would return `true` if dequeue was done (has not been sent to server yet).

So for use case when you just want to skip pending mutations, I would just keep reference to one transaction and call `dequeue()` before passing new mutation to `update`.

And for situation I want to postpone (wait for some saving event) updating server I would use `queue(mutation)` method and once I want to save it I would call `commit(callbacks)` on that transaction.

Also it can be easily combination of these two use cases. Thoughts?
",jardakotesovec,devknoll
550,2015-11-10 16:04:09,"Hmm. How about:



This covers all of the above use cases, and also allows Relay to track the sequence in which the updates were originally created. This means Relay can revert/apply them in the correct order in cases where the user did create two overlapping mutations and want to commit both.

EDIT: modified per @devknoll's suggestion below.
",josephsavona,devknoll
550,2015-11-10 18:51:33,"I like the way this is headed. I want to add is that we should make a basic API that auto-""commits"". The manual control seems like it should be the advanced use case. We could rename the `update` method from @josephsavona's comment to `updateLocal` which makes it clear that it's uncommitted. This would free up `update` to be defined as `updateLocal().commit()`.
",kassens,josephsavona
550,2015-11-13 04:14:58,"@josephsavona @devknoll I'd like to come up with a PR for this unless someone has started. From what I understand this is basically just coming up with a new function on the store, `updateLocal`, that will create a transaction without commiting it ? 

It seems like thats all we need to allow debounce since we have `commit` and `rollback` on the `Transaction` already. Let me know if I underestimate the issue :dancer: 
",xuorig,josephsavona
550,2015-11-13 04:14:58,"@josephsavona @devknoll I'd like to come up with a PR for this unless someone has started. From what I understand this is basically just coming up with a new function on the store, `updateLocal`, that will create a transaction without commiting it ? 

It seems like thats all we need to allow debounce since we have `commit` and `rollback` on the `Transaction` already. Let me know if I underestimate the issue :dancer: 
",xuorig,devknoll
550,2015-11-13 04:54:12,"@xuorig - all yours! :-)
",josephsavona,xuorig
550,2016-02-09 07:11:26,"@wincent Its possible to delay committing mutation to server, but its not possible to skip mutation that is already in queue yet.

This use case make sense for situations when there is no save button and user is changing input or some slider that could potentially generate many mutation requests and its necessary to skip queued mutations to do that efficiently - basically skip intermediate values.

Most convenient for developer would be to have api directly in mutation `shouldSkipQueue` that I suggested at the beginning, that would just say if mutation should remove mutations in the queue.

Agreement here was to handle this out of relay, so I attempted to add possibility to rollback queued mutation in #646 .

But I am generally opened to any other solution for such use case that will play nicely with new mutation api. Using optimistic updates became very convenient..  as its not necessary to keep some additional state.
",jardakotesovec,wincent
550,2016-11-16 09:43:10,"thanks for the blogpost @xuorig! It looks really useful but Im not sure how it ties into my problems with `skipping queries` that is qued up. Lets say I make during 2 seconds about 10 queries via user interaction. Im currently seeing that only 6 of the queries are sent and the other 4 is qued up. What I actually want to do is to somehow have control on when to skip these 4 queries :)
",proProbe,xuorig
549,2015-12-24 10:06:16,"@josephsavona can you reopen this ?
",filod,josephsavona
549,2016-02-04 02:58:39,"@josephsavona any news on this ? or can i take any temporary solution to avoid this bug ?
",filod,josephsavona
549,2016-08-05 05:14:47,"+1 Here, We've been having the same issue, without changing anything most of the time works fine, but at some point we got the spread error, @josephsavona any new about this?
",CoericK,josephsavona
545,2015-11-03 20:50:05,"@xuorig This is awesome!!! I have some minor feedback but overall looks good.
",josephsavona,xuorig
545,2015-11-03 22:35:37,"@josephsavona I've addressed your comments. Let me know what you think about my solution for iterating only once over directives. Not the most pretty but it's hard to make it with that Skip > Include priority.
",xuorig,josephsavona
543,2016-03-03 17:11:58,"@wincent we didn't end up changing the store format (yet) - should we just close this and continue with it later if necessary? (feel free to reopen)
",josephsavona,wincent
543,2016-03-03 17:52:11,"@josephsavona: @yungsters was asking me about this yesterday. I was going to reroll it, but it didn't seem like the highest impact thing I could to so I just let it sit. Closing is the right call for now!
",wincent,josephsavona
542,2016-01-06 21:42:32,"Re:

> Users expect the new edge to be fetched, but Relay doesn't have sufficient information to do so. This is because Relay doesn't know what fields should be fetched. —@josephsavona 

In troubleshooting this issue, I considered this may be the case, but then thought: ""but then why `RANGE_ADD` configuration have the `edgeName` field? Isn't that how Relay determines what to query for?"" I guess just knowing the `edgeName` field isn't enough because it doesn't know the structure of the node? Might this structure come from the fat query?
",dminkovsky,josephsavona
541,2015-11-02 20:37:49,"@skevy I'm not sure why, but I can't assign this to your directly - but thanks for the heads up, looking forward to this!
",josephsavona,skevy
541,2015-11-02 20:39:21,"@josephsavona it's cuz I'm not a collaborator. Silly Github.

Is anyone at FB working on this for OSS release? Or only for internal use
",skevy,josephsavona
541,2015-11-02 22:52:43,"@josephsavona Agreed, I would definitely need the subscribe/unsubscribe methods in some cases.

Although now I wonder if the RelayContainer is the right place for this... you'd still have to add this _particular_ subscription to any component that requests `story { likeCount }`. And it kind of runs the risk of coincidence-driven-development where every component that uses `likeCount` will benefit from _just one_ RelayContainer in the tree that defines a subscription - but remove that component, and suddenly your real time updates stop working!

I wonder if it would be possible to implement ""live queries"" _on the client_, so that whenever the current route contains `likeCount`, it automatically subscribes to every (opt-in) Subscription that could update `likeCount`... kind of like a fat query in reverse? This feels like one of those models which would reveal a lot of intractable edge cases as soon as you got in too deep to get back out :stuck_out_tongue: . It certainly works for the given example of `StoryLikeSubscription, but the whole point of the Subscription thing seems to be to provide more flexibility than live queries allow. What sort of use cases would break this model?
",dallonf,josephsavona
541,2015-11-03 07:16:43,"@dallonf great idea. But I recommend use Hash for `subscriptions` like in `fragments`. In order to be able to have several subscriptions, and be able to get access to their state:



@josephsavona It would be great if we can get subscriptions status and ability to manipulate them in Component:


",nodkz,josephsavona
541,2015-11-10 00:33:05,"@pasviegas Good idea! Unfortunately it isn't quite so simple. Subscription queries may execute on the server at _any_ time after the subscription is opened, which means that the ""tracked"" (active) queries on the client can be different between executions. While we _could_ allow users to define a fat query for subscriptions, it would mean that the data fetched by the subscription would depend on what had been queried when the subscription was first created. In other words, it would create a non-deterministic query that would be difficult to reason about.

Requiring a static subscription query makes it clear exactly what data will be refreshed when a subscription event occurs.
",josephsavona,pasviegas
541,2016-01-12 06:25:13,"I'm going to try and take a stab at this.  I checked with @skevy and he might start next week so I'll try and communicate anything I do in case it is useful.

I spent this afternoon looking at Relay mutation code.  I have a few questions:

1) Is it desirable to keep a central reference to all subscriptions?  There is the `RelayMutationQueue` which holds all mutations, but from what I can tell this is required for:
- queueing collisions
- optimistic updates get re-run multiple times (if I understand the code) so a reference is required to all mutations
- `RelayContainer` can check if there are pending mutations on a record

There might be other reasons I'm missing / not understanding.

I'm not sure if subscriptions would require something similar.  It could be useful for visibility and maybe some kind of mass dispose.  Either way it would be easy to add them to a central map someplace if desired.

2) For `writeRelayUpdatePayload`, again, just a quick glance, it looks like it can be re-used for subscriptions.  This sounds reasonable / expected?  The only issue I saw was `handleRangeAdd` has an invariant on `clientMutationID`.  Could that invariant be removed and the code with `RelayMutationTracker` only be run when `clientMutationID` is in the payload?

I haven't looked at the functionality of `RelayMutationTracker` yet -- todo list for tomorrow -- so this might answer itself.

3) Finally, I looked at RxJS to try and familiarize myself with the lingo.  Here is rough pseudo-code for `Relay#subscribe`:



code for `RelayNetworkLayer#sendSubscription` would return a function that performs unsubscribe / dispose:



Seem reasonable?

Thanks!
",eyston,skevy
541,2016-04-21 20:22:44,"@josephsavona so @leeb's tweet in March wasn't quite accurate?  https://twitter.com/leeb/status/710362545282875392
",timhaines,josephsavona
541,2016-04-21 21:15:52,"@josephsavona kindof thinking out loud, but is there a way today for me to give a query and query vars, relay force fetches the data based on that query and merges it with the local cache.

above would let me just send ids in the websocket payload and then relay can just fetch the required data using the query config. wondering if this approach is an anti pattern.
",chirag04,josephsavona
541,2016-05-21 19:22:27,"@josephsavona in which format payload should be specified for `RelayStore.getStoreData().handleQueryPayload(query, payload)`. Can you please provide an example as there is no reference for above in docs. Even if I try to provide same query that my component has and this.props.rootQ in payload, in next render cycle it nullifies all data.

Example:


",shahankit,josephsavona
541,2016-05-27 20:12:07,"> I amended my comment - we are experimenting with subscriptions and real-time updates internally (more info), but the core team is not currently working on providing a public API for subscriptions in open-source. This is in large part because it's possible to use pieces of Relay API to implement this in userspace as I outlined.

@josephsavona out of curiosity, why are subscriptions not on the agenda to support as part of Relay's core api? Or is just a matter of priorities?

One of the main reasons why I would adopt REST instead of GraphQL at the moment is since there doesn't seem to be a solution out there that's dealt with consuming GraphQL in a reactive web app (in a consistent way). Maybe it's not that big a deal since it _can_ be done, but it would be great to keep under the umbrella of Relay for consistency and simplicity. It also seems like a very common use case so would add a lot of value. 
",sampeka,josephsavona
541,2016-05-29 18:00:30,"good point @NevilleS! Node Interface to the rescue!
",xuorig,NevilleS
541,2016-06-06 03:56:57,"@xuorig 
To confirm the `dataId` of my connection would be found at `this.props.location.orders.__dataID__` correct?  Or am I looking in the wrong place?


",alexanderlamb,xuorig
541,2016-06-17 15:41:21,"@taion Nope, I'm just playing in the wild :smile: 

**Edit**
I'm not an FB employee
",edvinerikson,taion
541,2016-06-17 17:13:49,"@edvinerikson incredible thing! 

I planned to implement it after finishing [graphql-compose](https://github.com/nodkz/graphql-compose) as middleware on the server side for schema. And on the client side via [react-relay-network-layer](https://github.com/nodkz/react-relay-network-layer) as middleware for websockets for next major release.

So I am looking forward to your code release. You'll save me a lot of time by your working solution. You are my idol on this week!
",nodkz,edvinerikson
541,2016-06-17 17:27:02,"@edvinerikson , I'd love to see how you've implemented what you have, even before a release. I'm relatively new to relay, and I am not familiar with the source yet. I am about to attempt to implement subscriptions in relay myself. Seeing your modifications would help me see the effected parts of relay, and allow me to make the same or similar changes to get a temporary solution into my project much much faster.

Thanks and let me know!
",tjmehta,edvinerikson
541,2016-08-17 16:56:14,"@taion We get a fair number of questions about this, so I think leaving this open for now makes sense. I've updated the description though, to make it clear that we are not actively pursuing a full subscriptions API within the core.
",josephsavona,taion
541,2016-08-17 19:26:59,"@josephsavona if not subscriptions, then I think you are almost ready to release 1.0.0 with new features, better performance and new mutation api.

Most of all I am waiting new mutation api, cause all other things are quite comfortable. For me Relay is the best store keeper, than ReduxAppolo things.
",nodkz,josephsavona
541,2016-08-19 17:55:51,"@josephsavona 

Looking through #1298 and discussing with @edvinerikson – would you be okay with merging the scaffolding for subscription support in #1298?

I mean specifically https://github.com/facebook/relay/pull/1298/files#diff-320b6df8cf530a681d201c75772401eaR163, https://github.com/facebook/relay/pull/1298/files#diff-3a2c3b1ea174f413b5118b1aac4ecc2eR115, and an skeletal implementation of `RelayEnvironment#subscribe` that just throws.

This would allow actually implementing subscriptions in user-space, but still maintaining first-class API support.

Right now, with relay-subscriptions, an additional HoC is required to inject subscription support into components, which feels unnecessary given that there already is a Relay environment and a Relay container.
",taion,edvinerikson
541,2016-08-19 17:55:51,"@josephsavona 

Looking through #1298 and discussing with @edvinerikson – would you be okay with merging the scaffolding for subscription support in #1298?

I mean specifically https://github.com/facebook/relay/pull/1298/files#diff-320b6df8cf530a681d201c75772401eaR163, https://github.com/facebook/relay/pull/1298/files#diff-3a2c3b1ea174f413b5118b1aac4ecc2eR115, and an skeletal implementation of `RelayEnvironment#subscribe` that just throws.

This would allow actually implementing subscriptions in user-space, but still maintaining first-class API support.

Right now, with relay-subscriptions, an additional HoC is required to inject subscription support into components, which feels unnecessary given that there already is a Relay environment and a Relay container.
",taion,josephsavona
541,2016-08-19 21:15:03,"@taion Is the main reason for adding those to avoid an extra HOC for those components that have subscriptions? If that's the case, this can probably be handled purely in user space. You could, for example, create a `RelaySubscriptionContainer.create(Component, subscriptions, spec)` function that delegates to `Relay.createContainer` (so that users only have to write one wrapper function instead of two). The extra HOC should be trivial in practice, given that relatively few containers would have subscriptions.

Please let me know if I'm overlooking something though!
",josephsavona,taion
541,2016-11-19 00:34:07,"Thanks @edvinerikson. Maybe a mutation doesn't translate to a subscription. The fat query intersection is dynamic based on previous data retrieved and doesn't make sense in the context of a more static subscription payload.
",jg123,edvinerikson
540,2015-11-10 05:29:32,"Thank you for your summary @josephsavona. 

Having read #466, the connection specs and docs, what I wonder most is how it might be possible to reconcile these two paging methods while keeping cursors opaque. If cursors are opaque, jumping to arbitrary pages seems impossible. 

The thing about the opaque cursor-based approach as I understand it is not just that it reflects the infinite scrolling use-case. Given that Relay came from Facebook—a massive distributed system—I assumed its cursor-based paging is more significantly related to the peculiarities of paging in distributed systems: specifically that skip/limit paging is non-performant in distributed applications. The issues are described in this blog post about [MongoDB paging](http://blog.mongodirector.com/fast-paging-with-mongodb/), but basically any distributed DB that I've played with has warned about skip/limit paging for this reason[1]. It might make sense to think about this issue from this angle.

[1] c.f. [Elasticsearch paging](https://www.elastic.co/guide/en/elasticsearch/guide/current/pagination.html)
",dminkovsky,josephsavona
540,2015-11-10 15:49:45,"@dminkovsky Yup, we use cursor-based pagination precisely because skip/limit isn't performant in large data sets. Also, skip/limit can return overlapping results if items are added between fetching pages.

One option might be to make connection handling injectable. Something like `Relay.injectConnectionHandler(handler)` where the handler had methods to read the list of edge IDs given the GraphQL arguments, as as well as methods to add/remove sets of edge IDs along with the arguments used to fetch them. This could be based off the existing GraphQLRange API.

@yuzhi - thoughts?
",josephsavona,dminkovsky
540,2015-11-10 18:44:52,"@taion Agreed, these are distinct use cases and ultimately Relay should support all of them. Allowing connection handling to be injectable would make it easier for products to choose between approaches, without having to build both models (page number & limit/offset are isomorphic) into the core and test them separately. Note that connections account for much of the complexity in Relay internals, so testing against one well-defined injection API is preferable to `n` arbitrary connection models.
",josephsavona,taion
540,2015-12-16 13:06:13,"I also would like to be able to jump to a specific page. @taion - you write above ""I feel like the current pagination API offers enough to (with at most minor tweaks) satisfactorily implement page-based pagination"". Can you please explain how to achieve this? Many thanks...
",shaimo,taion
540,2015-12-17 08:07:00,"@taion - that's indeed easy - my concern was that using some arbitrary page parameter rather than the cursor I would be losing the benefits of the connection type. If there are no such benefits, then not even sure why bother with connection in the first place rather than just some standard field...?
",shaimo,taion
540,2015-12-17 16:50:57,"@taion Thanks for your help. I'll check if I can relax my requirements and maybe just use what Connection provides. Maybe indeed in large datasets it doesn't make much sense to allow the viewer to ""jump"" to a particular page anyway (especially if the dataset is not fixed, in which case next time you will get different results anyway)...
",shaimo,taion
540,2016-01-14 18:49:39,"@taion Can you please clarify what the nice stuff is exactly?
Even for windowed pagination I would like new edges to be inserted/removed ""magically"" after insert/delete mutations.
Is there other ""nice stuff"" that has to be considered?
",BerndWessels,taion
540,2016-01-14 19:25:21,"@taion Thats true, even though in some of my previous apps the visible window would be updated to reflect inserts and updated correctly. But that might be actually a bit out of scope here since it usually also requires a ""real-time"" connection or notifications from the back-end.

So what you are saying is: forget about connections and implement a simple windowed pagination as a simple query for a list - because connections do not provide any benefit in this case?
",BerndWessels,taion
540,2016-01-14 20:29:45,"Thanks @taion. There is only one last thing I am concerned about - memory. What if a user pages through huge amounts of rows - maybe even in different connections - will the store get bigger and bigger - or is there some kind of garbage collection in the Relay Store as well?
",BerndWessels,taion
540,2016-01-14 21:03:22,"@taion I thought that Relay Connections might be able to remove unused edges from the Store. But maybe memory concerns is a totally different discussion.
",BerndWessels,taion
538,2016-02-10 04:44:50,"Hey @wincent, if I wanted to run some more mutation-related ideas/questions past you, how would you prefer to see it? Just comment here? For example, I'm curious to hear what the Relay team's thoughts are about scenarios where the client _can't_ know in advance which nodes might be affected by a mutation...
",NevilleS,wincent
538,2016-02-10 06:18:40,"@NevilleS: I'm fine with you creating separate issues, as they provide us with a space to explore each topic. But just bear in mind that they might ultimately get closed and folded into the checklist above if it they end up being something that we can tackle as part of the mutations overhaul.
",wincent,NevilleS
538,2016-06-14 22:02:58,"Hi @wincent 
Do you have any ETA about multiple file uploads?
",eugenehp,wincent
538,2016-10-26 18:21:17,"Hi @NevilleS. Long time! I've been out of the Relay loop a bit lately: Relay 2 presentations? Are you talking about talks (like https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable) or a feature called ""presentations""?
",dminkovsky,NevilleS
538,2016-12-20 17:40:58,Done thanks to @wincent - check out [`Relay.GraphQLMutation`](https://facebook.github.io/relay/docs/api-reference-relay-graphql-mutation.html#content).,josephsavona,wincent
537,2015-12-16 22:26:48,"@josephsavona Is there any undocumented way to do this currently (before this is done)? Primarily to throw away the entire store and all cached data?
",grydstedt,josephsavona
537,2015-12-16 23:53:17,"I experimented with this in #485 and spun off some ideas into separate commits, but this ultimately didn't pan out. We'll continue exploring ideas around cache eviction. As @kassens noted, `forceFetch` can be used to forcibly refetch information when necessary.
",josephsavona,kassens
532,2015-11-07 19:02:20,"@kassens, When I open this issue I had node v0.12 installed.
Now after upgrade to last stable node: v5.0.0, npm: 3.3.6.
But error the same. Should I have node v4.1.1 and npm 2.14.4 exactly?
",designeng,kassens
526,2015-10-30 10:49:36,"@joshblack Thanks for filing this, but due to the restrictions that @zpao mentioned we can't support npm3 yet. I'll close this for now.
",josephsavona,zpao
525,2015-10-30 11:00:07,"Thanks for this @joshthecoder!

Since we can't be guaranteed a ref, we should get rid of this `this` binding too: https://github.com/facebook/relay/blob/master/src/container/RelayContainer.js#L302-L304

Can you send an update?
",steveluscher,joshthecoder
525,2015-10-30 18:11:24,"@steveluscher Wouldn't this break the current behavior of onReadyStateChange callback you provide when calling setVariables() or forceUpdate()? I'm not sure what use case there is for having access to your component instance in that callback. Maybe for invoking setState()?
",joshthecoder,steveluscher
525,2015-10-30 19:15:29,"@joshthecoder We should only pass `null` as the instance _if_ it's a stateless functional component, otherwise RelayContainer should continue to pass the instance.
",josephsavona,joshthecoder
525,2015-10-30 20:22:20,"@josephsavona These changes should maintain the current behavior for non-stateless functional components. `this` should still be the component instance.

Also I'm not sure if there's a better way to detect that besides looking for `isReactComponent` on the prototype. Seen the React code use it in a few spots for similar use cases.
",joshthecoder,josephsavona
523,2015-10-30 11:10:44,"Can I ask you to take a look at this solution, @josephsavona?
",steveluscher,josephsavona
523,2015-10-30 14:06:45,"@HurricaneJames Thanks for working on this. Introducing a custom map implementation could affect performance and before we go down this path we'll need to understand by how much. I'll import this internally and try benchmarking.
",josephsavona,HurricaneJames
523,2015-10-30 14:17:37,"@HurricaneJames After double-checking the spec we realized that ES2015 `Map`s preserve insertion order, so it should be sufficient to use those. Can you update to just use `Map`?
",josephsavona,HurricaneJames
523,2015-11-04 22:29:07,"@HurricaneJames yup, it's provided by `fbjs`. I believe the OSS version uses the same polyfill as babel.
",josephsavona,HurricaneJames
522,2015-10-30 14:01:49,"What @josephsavona means is that, somewhere in your app, there's a query for `onboarding_data` that's not represented in your fat query. The fat query is a query that represents all the possible things that could change in your application as a result of this mutation. Whatever way you're fetching `onboarding_data` in the first place, replicate it in the fat query, and support it in your mutation's backend implementation. Relay will notice that the running app has a query for this data, and will include it in the mutation query.

If you need more information, or you want to go through an example, reopen this question on Stack Overflow and paste a URL to it here!

https://stackoverflow.com/questions/ask?tags=relayjs
",steveluscher,josephsavona
521,2015-10-29 17:36:15,"@josephsavona, I have  StoriesPage which is a root container. Along with StoriesPage I have AddStoryPage which is also a rootContainer so when I go from StoriesPage to AddStoryPage there I do AddStoryMutation (RangeAdd on StoryConnection) which succeeds (new edge's fields match the stories connection node fields which is queried in StoriesPage) and on success I go back to StoriesPage but there the new edge has not been added unless I do full reload, shouldn't it be updating as it is the only page requesting stories connection? for rangeBehaviors I have {'' : ''}
",IlyasM,josephsavona
521,2016-02-07 10:32:01,"@steveluscher Hi, I run into the same problem out of nowhere, can you tell me the answer to jwaldrip's problem? 
Thanks
",bfwg,steveluscher
520,2015-11-02 06:03:20,"Thanks for you response @steveluscher 
Currently, I'm going with a solution similar to the first option you pointed out. I feel better for now, since I'm not the only one doing this way, but yes, would be awesome to see this in the core.
",schweller,steveluscher
520,2016-04-21 12:20:05,"@josephsavona thanks for clarification.

If somebody needs example of `BatchNetworkLayer`, and wrapping `express-graphql` you can found it here https://gist.github.com/nodkz/d9a6380d55067192295382e8e490f39f
",nodkz,josephsavona
520,2016-04-21 17:15:42,"@nodkz would be cool to publish that as an npm module :-)
",josephsavona,nodkz
520,2016-04-21 17:17:27,"+1 to that. I was going to ask the same :-) I'd help maintain it!

On Thu, Apr 21, 2016 at 12:15 PM Joseph Savona notifications@github.com
wrote:

> @nodkz https://github.com/nodkz would be cool to publish that as an npm
> module :-)
> 
> —
> You are receiving this because you are subscribed to this thread.
> 
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/520#issuecomment-213023236
",KyleAMathews,nodkz
520,2016-04-22 21:01:16,"@josephsavona @KyleAMathews 
I can not publish my gist as npm module. It is too dumb.

So, I spent all current day and made this great thing: https://github.com/nodkz/react-relay-network-layer
With some simple middlewares. Open for review and PRs.
",nodkz,KyleAMathews
520,2016-04-22 21:01:16,"@josephsavona @KyleAMathews 
I can not publish my gist as npm module. It is too dumb.

So, I spent all current day and made this great thing: https://github.com/nodkz/react-relay-network-layer
With some simple middlewares. Open for review and PRs.
",nodkz,josephsavona
520,2016-04-22 21:21:19,"@nodkz awesome! Thanks for publishing this! I'm going to go ahead and close this issue :-)
",josephsavona,nodkz
505,2015-10-23 22:31:21,"I think that would be acceptable, @michaelchum.

The main intention of this check is to make sure that people developing in the Relay repo are using a known-to-be-supported tool-set, so that they can do things like run the tests without spurious failures. So in this case, `prepublish`, which will run when you do a top-level `npm install`, is probably good enough.

If you run `npm install` from the `examples/` directories, then this parent `prepublish` may not run, like you say (although it would be good to confirm that for sure), although that may be ok.
",wincent,michaelchum
505,2015-10-23 23:56:05,"@wincent Thanks for the clarification! It says in the [npm docs](https://docs.npmjs.com/misc/scripts) that `prepublish` only runs before a package is published or in a ""local"" `npm install`. There's no mention of dependency install.

As you mentioned, since this script helps people developing Relay and not people using Relay as a dependency, I think it makes sense to move it to `prepublish`.

I'm issuing a PR so that people who try out Relay will have working examples :)
",michaelchum,wincent
503,2015-10-25 01:18:57,"@steveluscher The [Relay public API](https://github.com/facebook/relay/blob/master/src/RelayPublic.js) currently does not expose `RelayQueryConfig`. Are you planning on exposing it to subclass `Relay.RelayQueryConfig` as a standard instead of `Relay.Route`? 

I think `Relay.RelayQueryConfig` should be exposed and released (perhaps 0.4.1?) before showing its usage on the homepage.
",michaelchum,steveluscher
502,2015-10-23 23:19:51,"@wincent Why is the correct behavior in that check not to only strip off the `generated` fields rather than all the `requisite` ones? It seems like in practice you'd get all the relevant benefits if you considered only the `generated` ones, while offering a nicer and less unintuitive escape hatch in the case that someone actually wants to query for e.g. `widgets { id }` per the above example (where we have `widgets: [Widget]`, so the query is not actually completely pointless - gives a generic, if potentially expensive, way to get the length of the list).
",taion,wincent
500,2015-10-23 22:08:30,"As @yuzhi mentioned, it's possible that the `edges` field is in a different file from the connection field such that the plugin can't catch all cases. That said, we could definitely detect missing connection arguments when an `edges` subfield _is_ present.

The change would need to happen in [`RelayQLPrinter#printField`](https://github.com/facebook/relay/blob/master/scripts/babel-relay-plugin/src/RelayQLPrinter.js#L316-L320) - if the field is a connection and has an `edges` field, then validate the presence of the necessary arguments.
",josephsavona,yuzhi
500,2015-11-13 04:57:01,"@xuorig thanks!
",josephsavona,xuorig
498,2015-11-11 16:14:40,"@josephsavona Sorry to just get back so late, just taking relay-implementation up again. It would be nice if babel-relay-plugin could detect a 'statically' declared variable in the same file but I suppose that would be a lot of effort to gain just a little bit of DRYness.

Thanks for getting back so quickly though, loving relay and graphql so far!
",Globegitter,josephsavona
496,2015-10-28 13:22:58,"@taion Yeah, this seems like the most robust option. Feel free to cc us on pull requests/branches (even on `react-router-relay`) if you'd like feedback on an implementation.
",josephsavona,taion
494,2015-10-20 16:19:51,"@josephsavona Thanks, thats awesome!
",jardakotesovec,josephsavona
490,2015-10-19 18:27:22,"Thanks for the PR, @HurricaneJames.

We originally added the type-first sorting — somewhat reluctantly — to satisfy an internal requirement (integration with another cache that relied on type-first behavior; D2022689 for any FBers that might be reading along). I'm going to check around and see whether this is still a requirement (I expect it is) and if we can fork this particular detail so that the open source world doesn't have to deal with this.
",wincent,HurricaneJames
490,2015-10-27 17:23:12,"@wincent did we ever find out if this could be merged or if we needed to use the alternate sort algorithm?
",HurricaneJames,wincent
488,2015-10-20 16:59:59,"Thanks for the report @enaqx! I suspect @clentfort is right about this being a dupe, so I'm going to close this one.

Please feel free to comment again if this isn't the case and we can look into this further.
",wincent,enaqx
487,2015-10-21 00:45:36,"@dschafer Thanks for confirming. 

In this case, `RelayDefaultNetworkLayer` should be changed to resolve the request when `data` is non-null or there are no `errors` (if non-null but there errors just log them to console), and only `reject` the request when data is null and there are errors.

@vladar any interest in submitting a PR? ;-)
",josephsavona,dschafer
487,2016-07-12 13:57:56,"@josephsavona any hint on how would you model a request where error condition not block rendering the component? I hit a roadblock and just a one liner would help me to proceed. thanks in advance
",bsr203,josephsavona
487,2016-07-12 16:40:42,"@josephsavona  Thanks a lot for the response. I already have a custom network layer to format the error and would be easy to adapt.

One thing to confirm. Does this ok to do in case of null response as well (if the response can be completely optional - and client can identify this from server error code). would it cause any issue with the internal cache.
",bsr203,josephsavona
482,2016-06-28 16:58:55,"@josephsavona tks helps a lot! 
However after reading this post [graphql-and-authentication](https://medium.com/the-graphqlhub/graphql-and-authentication-b73aed34bbeb#.hsoqxwdhz) I'm considering passing the token in the Viewer and not in the Header.
",rturk,josephsavona
479,2015-10-19 15:57:12,"@HurricaneJames Currently there is no way to avoid the buildup of multiple distinct tracked queries for connections. Note that `forceFetch` refetches the given queries but does not cause other data to be purged. Note that we're actively working on changing tracked queries in #485.

Re mutations that affect connections, we typically recommend specifying the result of connection changes via configs such as `RANGE_ADD`, which tell Relay how a connection will change as the result of a modification. This can help to avoid refetching the entire range - have you tried that? 

@saikat `untrackNodesForID` is private API and may (read: almost certainly will) change at any time. Also, using it in this case on the connection would cause Relay not to fetch the connection nodes at all, which doesn't seem to be the desired behavior.
",josephsavona,HurricaneJames
478,2015-10-19 16:00:38,"@HurricaneJames this appears to be basically the same issue as #479 as both ultimately are caused by the building of tracked queries for a connection. I'm going to close this - let's move discussion to that issue. 
",josephsavona,HurricaneJames
478,2015-10-19 18:28:20,"> Is there a reason the keys were sorted?

@HurricaneJames: I replied on your PR.
",wincent,HurricaneJames
475,2016-03-31 23:20:59,"The mutation `onFailure` callback **should** be called if the mutation fails. I'm going to close this, feel free to comment with additional steps to repro.

@edvinerikson note that the OP is referring to `onFailure` (callback on `RelayStore.{apply,commit}Update`).
",josephsavona,edvinerikson
474,2015-10-28 01:20:45,"@josephsavona  `babel-relay-plugin` `0.3.0`

That is the latest version I guess.

Any ideas what else could be wrong?

Before I used



but that wasn't really what I wanted - or maybe I just don't understand what that `id` is supposed to be. My assumption is that I can stick the ""real"" id in there that comes back from my database?
",BerndWessels,josephsavona
474,2015-10-28 13:25:19,"@josephsavona Yes, I'm using the lastest version of them, v0.4.0 and v0.3.0 ([my package.json](https://github.com/brenoc/relay-starter-kit/blob/relay/typenameIssue/package.json))

@BerndWessels Unfortunately no, I couldn't :(
",brenoc,josephsavona
474,2015-10-28 18:43:44,"@josephsavona 



As @brenoc pointed out, if I add `__typename` to the requested properties the error goes away - but I expected the system to take care of that?
",BerndWessels,josephsavona
474,2015-10-29 16:10:12,"@josephsavona I have a repo that you can run and see the issue:
https://github.com/brenoc/relay-starter-kit/tree/relay/typenameIssue

It's just a fork of relay-starter-kit with some minor changes in the code. Is that helpful?

Sorry for not providing a case in Relay Playground as you asked. I think it will take some time for me to port that code into Relay Playground.
",brenoc,josephsavona
474,2015-12-06 22:01:27,"@josephsavona the unabbreviated error looks like:

> Warning: RelayQueryWriter: Could not find a type name for record `client:client:6810115162:UmVzb3VyY2U6NA==`.

The app works without issue when I don't bump to `0.6.0`. But when I do bump, a specific mutation is triggering the error. The mutation pattern is to create a new item, `Group`, add the new `groupEdge` to my `User`'s `groups` connection, and to add the `userEdge` to the new `Group`'s `users` connection.

I am using a central [registry](https://github.com/rblakeley/pluck-yourself/blob/master/data/types/registry.js) for my object types which [wraps](https://github.com/rblakeley/pluck-yourself/blob/master/data/types/node.js) `nodeDefinitions`, if that's relevant.

I'm not sure how to answer:

> How did you query for that record (i.e. what field did you query that returned it), and what is the schema definition for that field?

...but the relevant files are:
[js/components/NewGroupPanel.js](https://github.com/rblakeley/pluck-yourself/blob/master/js/components/NewGroupPanel.js)
[js/mutations/NewGroupMutation.js](https://github.com/rblakeley/pluck-yourself/blob/master/js/mutations/NewResourceMutation.js)
[data/mutations/NewGroupMutations.js](https://github.com/rblakeley/pluck-yourself/blob/master/data/mutations/NewGroupMutation.js)
[data/types/GroupType](https://github.com/rblakeley/pluck-yourself/blob/master/data/types/GroupType.js)
[data/types/UserType](https://github.com/rblakeley/pluck-yourself/blob/master/data/types/UserType.js)

Edit: looks like #653 may get at the same problem
",rojobuffalo,josephsavona
474,2015-12-07 00:54:07,"@josephsavona :ok_hand:
",rojobuffalo,josephsavona
474,2016-02-20 20:29:33,"@josephsavona For some reason, this doesn't throw the warning on Heroku, but only on local development: [https://relay-rails-blog.herokuapp.com/](https://relay-rails-blog.herokuapp.com)
",gauravtiwari,josephsavona
466,2015-10-15 18:50:31,"@josephsavona Although not entirely connected with initial question above i jumped in because i see this going in the direction i need. So im adding my question.

What you asked:
`would you have links to non-adjacent pages such as ""...[2] [3] [4] ... [10]`

is exactly what i need. 
Our current graphql server is extended so that it can send back total count along with native `pageInfo` information. So i have `pageInfo.total` but Relay does not know it and completely ignores.

How can i pass it nicely to the component (i need total count to be able to render page numbers)?
",GrzegorzKaczan,josephsavona
465,2015-10-15 05:54:56,"@josephsavona Ok, thanks a lot for answer. Should I open issue with feature request for dirtying unused connections? I would like to track it somehow as its very important feature for our use case.
",jardakotesovec,josephsavona
457,2015-10-13 14:52:26,"What @wincent said - for now, use `node` to get efficient refetches. 

@steveluscher is working on supporting a wider variety of root calls (fields) including connections and I believe non-`node` ""identifying"" fields such as fields of the pattern `foo(id: $id)`.
",josephsavona,wincent
456,2015-11-10 23:29:45,"@dminkovsky I'm sorry to hear that this was frustrating. You raise good points about the tradeoff of nesting fields in the query vs container.

Rather than allow more nesting within route queries, we'd like to go in the opposite direction: eliminating the need for routes & their queries, and instead allow express data dependencies solely via containers. @steveluscher is building the prerequisite to this in #112, which adds support for arbitrary root fields. 
",josephsavona,dminkovsky
456,2015-11-10 23:36:32,"@josephsavona Oh no, please—thank you for Relay in general and your work here on GitHub. Really appreciate both! Was less expressing frustration and more providing feedback regarding confusion caused by the docs.

If you are planning to eliminate routes and their queries, then all compositing will be done via containers? Got to read #112... :)

Thanks again
",dminkovsky,josephsavona
455,2015-10-13 07:13:45,"@wincent Thank you!
",tothandras,wincent
453,2015-10-13 01:43:15,"> though in some cases React will be a global so you wouldn't want to warn.

But in that case, we should use the existing ESLint mechanisms for declaring `React` as a global, right?

---

Regardless, @kassens :+1: 
",yungsters,kassens
453,2015-10-13 01:46:56,"Ahh, nice.

@kassens Can you incorporate @zpao's suggestion so that this pull request does not re-introduce the lint errors?
",yungsters,kassens
453,2015-10-13 01:46:56,"Ahh, nice.

@kassens Can you incorporate @zpao's suggestion so that this pull request does not re-introduce the lint errors?
",yungsters,zpao
451,2015-10-12 16:13:54,"Thanks, @yihangho.

@facebook-github-bot import
",wincent,yihangho
450,2015-10-14 01:35:23,"@chandu0101 @jardakotesovec Just published react-relay@0.4.0 and babel-relay-plugin@0.3.0.
",yungsters,jardakotesovec
450,2015-10-14 01:35:23,"@chandu0101 @jardakotesovec Just published react-relay@0.4.0 and babel-relay-plugin@0.3.0.
",yungsters,chandu0101
447,2015-10-12 12:15:09,"@josephsavona any chance on elaborating on SO? I've been working on this for a day now, and don't feel any closer to getting it working.
",AndrewIngram,josephsavona
445,2015-10-09 21:20:27,"@josephsavona is the code you referring to the one from the `getMutation` method like in this example? 



if yes, then this does not solve the problem. 
@chandu0101 is talking about the mutation name that is actually used in the query that is send to the graphql server. 

As an example from scala.js relay version we developed, the query looks like this, even after applying the change you suggested:



as you can see in scala.js it still has a weird name, that indicates me that the name that is used in the query is generated of the name from the actual mutation instance in the global namespace (just a guess). In scala.js this must be unique over the whole javascript libraries that are used, thats why the package name is used. If your suggestion would affect the name used in the query i guess it should be reflected somewhere in this path even in scala.js. but i'm not 100% certain.
",xsistens,josephsavona
445,2015-10-09 21:20:27,"@josephsavona is the code you referring to the one from the `getMutation` method like in this example? 



if yes, then this does not solve the problem. 
@chandu0101 is talking about the mutation name that is actually used in the query that is send to the graphql server. 

As an example from scala.js relay version we developed, the query looks like this, even after applying the change you suggested:



as you can see in scala.js it still has a weird name, that indicates me that the name that is used in the query is generated of the name from the actual mutation instance in the global namespace (just a guess). In scala.js this must be unique over the whole javascript libraries that are used, thats why the package name is used. If your suggestion would affect the name used in the query i guess it should be reflected somewhere in this path even in scala.js. but i'm not 100% certain.
",xsistens,chandu0101
445,2015-10-09 22:43:15,"@josephsavona  thanks alot for pointer , i just opened a PR https://github.com/facebook/relay/pull/448 please review it , i can confirm that scalajs mutations working fine now :+1: 
",chandu0101,josephsavona
444,2015-10-09 15:46:56,"@jardakotesovec Currently append/prepend/remove operations are only supported on connections and not for plain lists. In general connections are more powerful and we recommend using when designing schemas. I'll mark this as an enhancement - we'll accept contributions for similar operators for lists (e.g. append/prepend/remove).
",josephsavona,jardakotesovec
444,2016-03-01 12:01:33,"@wincent Maybe this issue also could be part of the #538? Just in case you have missed that.
",jardakotesovec,wincent
444,2016-03-04 00:23:54,"Yeah, it's definitely related, @jardakotesovec, but I don't think we'll get to any list changes as part of that work, except indirectly (ie. we won't change lists to have connection-like features, but we might be able to make connections as easy as working with lists). Let's this keep this open until the dust settles from that work; we can close it if necessary once we know how things end up.
",wincent,jardakotesovec
441,2015-10-08 21:47:48,"@kassens 
There is a merge conflict because of https://github.com/facebook/relay/commit/89d62360d5133e43ec16500f1407d48792c6704b
",octref,kassens
441,2015-10-08 23:32:46,"@octref: Yes, saw that, but was easy to resolve.
",kassens,octref
439,2015-10-08 17:18:13,"@octref These are dependencies of `react-router`, not Relay. I'd recommend filing an issue with `react-router`. Feel free to comment again here though if that doesn't solve the problem!
",josephsavona,octref
439,2015-10-08 18:21:25,"@octref that would be great, thanks!
",josephsavona,octref
439,2015-10-08 18:29:27,"@octref: rc3 is released now. Want to send the PR for the fix?
",kassens,octref
439,2015-10-08 18:36:35,"@kassens 
Done and signed CLA.
",octref,kassens
433,2015-10-07 17:08:59,"@josephsavona Is it ok?
",akashnimare,josephsavona
433,2015-10-07 22:49:49,"@akashnimare: This got held up because our internal linter blocked it. I've now fixed that, so we can proceed to land this.
",wincent,akashnimare
430,2015-10-06 18:26:42,"@akashnimare The headers need to be changed for _all_ the .js files in `examples/`. Can you confirm that lint passes after the change?
",josephsavona,akashnimare
430,2015-10-06 19:51:43,"@josephsavona  Please See #433 
",akashnimare,josephsavona
429,2016-10-29 13:11:19,"I will not rubber stamp and land your change for you @yungsters!  I can import it for you and you can get your change reviewed by someone though :)
",facebook-github-bot,yungsters
426,2016-06-07 12:55:34,"@nodkz thanks ! this looks definitly cleaner ;)
",IcanDivideBy0,nodkz
426,2016-06-27 17:38:28,"@miracle2k I finally used the authMiddleware which handle a refresh token function as well. You should try the @nodkz solution too, the getter/setter is definitly some kind of a hack

PS: we still write `var self = this;` in 2016 ? xD
",IcanDivideBy0,nodkz
425,2015-10-05 16:07:00,"Thanks for answering @wincent. I'll keep this issue open as a reminder to update the headers.
",fson,wincent
420,2015-10-03 16:52:41,"@fson & @kassens Tnx! 
",cmodijk,fson
420,2015-10-03 16:52:41,"@fson & @kassens Tnx! 
",cmodijk,kassens
416,2016-09-03 00:24:01,"We're planning on totally replacing the Relay website for the release of [Relay 2](https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable), including rethinking how the Playground works, so I am going to close this for now.

Thanks for bringing this issue up, @taion. This had bugged me as well. We'll do our best to make things a bit smoother on the new documentation site.
",wincent,taion
415,2015-10-08 16:23:00,"@josephsavona sorry about the delay.

I ended up resolving the issue by making `Link` be the dynamic type, instead of a container for another dynamic type (`LinkDestination` above).   It seems that the `refragmentRelayQuery` only checks to see if the child fields of a node are of a dynamic type, but it doesn't check if the ""grandchildren"" are dynamic.

Here's the fatQuery and configs for one of the mutations that was failing (several were affected):



The problem isn't really apparent looking at the mutation; the `Link` is a child of `Post`, which is the `node` for `newPostEdge`.  When relay was generating the query on `AddSourceAnnotationToImagePayload`, it was constructing something like



and not including the `... on ExternalLink`  around the `url` field.
",yusefnapora,josephsavona
415,2015-10-22 16:35:16,"I'm having this problem too. @yusefnapora what do you mean by ""Making a type dynamic""?

Any other workarounds? /cc  @josephsavona 

Thank you!
",luisobo,josephsavona
415,2015-10-22 21:03:34,"@josephsavona nope, 0.2.5. It seems the latest is 0.3.0. Updating now. Should this fix the issue tho?
",luisobo,josephsavona
413,2015-10-02 04:24:07,"Thanks, @enaqx!

@facebook-github-bot shipit
",wincent,enaqx
413,2016-10-29 13:10:54,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4101176).
",facebook-github-bot,wincent
412,2015-10-02 01:26:41,"@zpao Thanks for detailed instructions

> move eslint rules from dependency to relay own .eslintrc
> 
> > No, the point of the shared config is that we can share that across our projects and enforce the same rules :)

Ok. Then vice versa. graphql-js should depend on general rules rather than implementing its own, but it seems have quite different codestyle. :)
",enaqx,zpao
412,2015-10-12 19:36:21,"@enaqx I'm going to make the following changes as I merge this upstream:
1. Change `diffRelayQuery.js` to return `null` to have a consistent return.
2. Remove disabling `no-unused-vars` from `RelayQueryTransform`. (This warning is a bug with ESLint and Flow, and not with the code itself.)

Let me know if either of these will be a problem!
",yungsters,enaqx
412,2015-10-12 19:43:26,"@yungsters No problem, thanks!

Although if you remove `no-unused-vars` from `RelayQueryTransform` it will impact tests with warning if lint step will be included.
",enaqx,yungsters
411,2015-10-01 21:08:50,"@josephsavona 

I think that makes a good low-level API. My concern is that this doesn't necessarily match how I might want to think about subscriptions from the front end.

Echoing @KyleAMathews's comment, I feel like I really think more about wanting live updates for a particular query, rather than wanting to subscribe to a specific named subscription. Moreover, I think having specific subscriptions requires closer coupling between the front end and the back end - unlike with mutations and few fields, if the server starts defining a new subscription type that I'm not handling from my front end, I'll lose some set of updates, some of which I might care about.

Do you think it might be possible to define some higher-level subscription API that works on the level of nodes rather than on the level of ""subscriptions""? I definitely want to define mutation-style `getConfigs` for connections, but I feel like there should be some concept of ""here is a generic update to this node that you don't know how to handle, just re-fetch everything in the Relay store for this node from the GraphQL server"".
",taion,KyleAMathews
411,2015-10-01 21:08:50,"@josephsavona 

I think that makes a good low-level API. My concern is that this doesn't necessarily match how I might want to think about subscriptions from the front end.

Echoing @KyleAMathews's comment, I feel like I really think more about wanting live updates for a particular query, rather than wanting to subscribe to a specific named subscription. Moreover, I think having specific subscriptions requires closer coupling between the front end and the back end - unlike with mutations and few fields, if the server starts defining a new subscription type that I'm not handling from my front end, I'll lose some set of updates, some of which I might care about.

Do you think it might be possible to define some higher-level subscription API that works on the level of nodes rather than on the level of ""subscriptions""? I definitely want to define mutation-style `getConfigs` for connections, but I feel like there should be some concept of ""here is a generic update to this node that you don't know how to handle, just re-fetch everything in the Relay store for this node from the GraphQL server"".
",taion,josephsavona
411,2015-10-03 22:27:58,"@josephsavona what are the steps to add support for a `@live` directive? 
",KyleAMathews,josephsavona
411,2015-10-20 13:14:25,"Just FYI to all those on this issue...I'm actively working on implementing the general concepts @josephsavona outlined above. Nothing in PR state yet...but hopefully it won't take me toooo much longer to get it there.
",skevy,josephsavona
411,2015-11-02 19:52:55,"@KyleAMathews thanks for starting this discussion! I've created a new task with the API described above to help guide contributions. Let's continue discussion at #541
",josephsavona,KyleAMathews
411,2015-11-02 19:53:05,"also cc @skevy 
",josephsavona,skevy
411,2016-03-26 00:47:10,"@taion 's idea is feasible if each node type is subscribable to.  I did something like this with Entity Framework and signalR where each change to the database was published.  

So any tree of graphQL nodes on the client would result in a tree of subscriptions to the server.  I then did additional filtering on the client so the server didn't do 'live queries' it just published events when a node's related nodes changed.
",gilesbradshaw,taion
408,2015-10-01 20:43:04,"@wincent I have same problem. I'm running 1844dc940b46021befd7703b574ddbbcee8656f8 atm. 
Running `npm run update-schema` will fill few `description` fields inside `schema.json`.
",zigomir,wincent
407,2016-05-10 23:29:09,"It appears to me that this is a fine workaround and doesn't add much boilerplate to your app and if common in your case could be moved into a higher order component or some other abstraction.

I'm with @josephsavona on this one that we should try to keep the API small.
",kassens,josephsavona
403,2015-09-29 16:54:02,"Gotcha, thanks @yuzhi 
",grydstedt,yuzhi
396,2015-10-12 22:16:48,"@zpao I guess that would be a good solution for the moment.
@wincent Arch Linux already uses to npm3 by default, that's how I encountered this problem.
",clentfort,wincent
396,2015-10-12 22:16:48,"@zpao I guess that would be a good solution for the moment.
@wincent Arch Linux already uses to npm3 by default, that's how I encountered this problem.
",clentfort,zpao
396,2015-10-20 17:46:24,"Spring cleaning, so I threw up https://github.com/facebook/relay/pull/495 for this.

@zpao: I see that you relaxed the requirement in React a few days ago, but I don't think we're ready to go there yet.
",wincent,zpao
395,2015-09-30 19:32:50,"@michaelchum Thanks! @yungsters rebased this diff internally already and he'll land it shortly, so don't worry about the merge conflict.
",kassens,yungsters
395,2015-09-30 19:32:50,"@michaelchum Thanks! @yungsters rebased this diff internally already and he'll land it shortly, so don't worry about the merge conflict.
",kassens,michaelchum
394,2015-09-29 22:12:59,"Thanks for he heads up, @chandu0101. @voideanvalue might have thoughts on this, as he did most of the implementation for the current version of the `RelayMutation` API.
",wincent,chandu0101
390,2015-10-06 12:55:22,"@kassens Hi,

How did you do that? If it's not a secret ) 

I have created [repo](https://github.com/mikhail-riabokon/relay-server-rendering) where I am trying to run Relay + GraphQL on server, but I still have error, which have not resolved yet. In case if you have time and interest, could you have a look on it and write that I did wrong?

Thank you in advance.
",mikhail-riabokon,kassens
389,2015-09-25 17:02:09,"@AnSavvides This is great! Thank you!!
",josephsavona,AnSavvides
385,2015-09-24 22:28:58,"@taion thanks for working on this!
",josephsavona,taion
383,2015-09-24 18:17:11,"An architecture where the complete schema is only known at runtime is quite common in software in my experience. Take a CMS where users can create new types of content using a UI during runtime. Or take any random enterprise software system where types and their fields are defined in a database, again by users with an UI. 

Not everybody is building single-deployment web applications. A lot of software has a multiple independent deployments, each with a different configuration and extensions. Some core types and fields will be in common between all of them, but there are also fields and entire types unique to a deployment. Each schema effectively has its own schema.

Whether this is the best way to architect a system is another debate: can we discuss this accepting that such systems already exist and that it may be interesting to use Relay with them? In some ways a database-generated schema makes software like this a great fit for GraphQL, as this kind of software typically _already_ has sufficient information in its database to generate a schema.

There are multiple ways you can write UIs for software where you don't know the complete schema:
- the schema can be introspected during runtime, and a UI can in part be auto-generated. This may of course need supplementary information beyond what's in a GraphQL schema.
- a subset of the schema may be completely known during development time, even though the software makes you store its definition in the database due to legacy reasons -- that's how all schema information is stored.
- you may not know everything about concrete types in complete deployments, but you may know quite a lot about their interface, and thus you can write a generic UI that can handle these.

graphql-js seems, as far as I can see, to be explicitly engineered to allow the generation of schema information at runtime where needed. But babel-relay-plugin, whatever it does exactly (I don't quite understand yet), is a problem.

Can babel-relay-plugin be avoided entirely? What are the consequences of doing so?

@cesarandreu points at a possible approach: it may be possible to know a subset of the complete schema at compile time. But how would this work for new fields or complete types that only known during runtime?

@josephsavona  I chatted with you briefly at React Conf Europe I believe, just before your Relay talk. So, are you asking me how people can write code in a dynamically typed language? I can try to explain... :)
",faassen,josephsavona
382,2015-09-26 00:09:33,"@michaelchum According to the summary, wouldn't it be enough if we just removed the preinstall line (since install already installs parent directories?)
",kassens,michaelchum
382,2015-09-26 01:10:41,"@kassens I've done a bit of research before the commit :) Because the automatic install on parent directory `relay/` is  `npm install --production` which only installs `dependencies` and ignores `devDependencies`, it will therefore not build since `gulp` (and some other tools required for build) are only in `devDependencies`. 

We need to manually go to `relay/` and run `npm install` at least once in order have `gulp` installed so that any subsequent `npm install` or `npm run build` commands would build Relay.

If the `preinstall` script is removed, we'd have to tell the user to `npm install` in `relay/` first before installing projects in `examples/`.
",michaelchum,kassens
382,2015-09-26 03:27:32,"Thanks for doing the research, I don't have much experience with npm.

@wincent ship it
",kassens,wincent
381,2015-09-24 16:52:18,"We're adding the `pageInfo` during the static transform of the code [here in GraphQLPrinter](https://github.com/facebook/relay/blob/58e45dbb9fd08215884597171ce072551f344c06/scripts/babel-relay-plugin/src/GraphQLPrinter.js#L502-L504). During the transform, we can only look at the current file / GraphQL fragment we're transforming. This means we can't inspect what's inside fragments.

When you want to work on the transform, it will be helpful to create a new test by adding a fixture to [this directory](https://github.com/facebook/relay/tree/58e45dbb9fd08215884597171ce072551f344c06/scripts/babel-relay-plugin/src/__fixtures__).

We could potentially look at this metadata when we generate the query during runtime, but I'm not sure what the implications are of that. I think the heuristic that @josephsavona suggested is pretty good. (How likely is it that you have a fragment just to display the count?)
",kassens,josephsavona
381,2015-09-24 17:27:55,"@kassens Probably easier just to demonstrate with code what I mean - see https://github.com/facebook/relay/pull/385
",taion,kassens
379,2015-09-24 14:42:25,"Sorry about that @josephsavona, still wrapping my head around the Relay source. I added the checks to `writeRelayUpdatePayload` and `writeRelayQueryPayload`. Let me know if anything else looks off!
",aweary,josephsavona
379,2015-09-24 19:56:04,"@josephsavona I really appreciate it, this is helping me get a better handle on things. I added some additional `invariant` checks for the ID in `writeRelayUpdatePayload` and reformatted per your recommendations.
",aweary,josephsavona
379,2015-09-28 14:29:58,"@josephsavona no problem, thanks for bearing with me on it!
",aweary,josephsavona
379,2015-10-08 18:25:39,"@josephsavona sounds great, thanks for the update!
",aweary,josephsavona
375,2015-09-23 21:03:44,"@fson beat me to it - Relay sends JSON, hence `application/json`.
",josephsavona,fson
374,2015-09-23 23:17:47,"Thanks @michaelchum!

@facebook-github-bot import
",kassens,michaelchum
372,2015-09-26 07:10:43,"Sorry for the slow response! I haven't had much internet access in the last couple of days. Just caught up on this and saw that I got mentioned in slack about the same issue.

##### Context on why Relay gets cursors for each edge

When we were building Relay, we tried to gets data so that it can be cached and support as many views as possible with minimal round trips. As @josephsavona mentioned above, different component can paginate with different page sizes. We only ever need the very last and first cursor to paginate correctly, as @taion mentioned. However, getting cursor on every edge means Relay can always generate the correct `pageInfo`, more specifically `startCursor`, `endCursor` fields, without having to do another round trips to get the proper `pageInfo` for a different page size from the server for a different page size.  It didn't make sense to wait for a server round trip for something that's fetching `first:3` when we already have `first:5`. Having cursor on every edge is also handy when mutations can add and remove edges and might make the very last cursor out of date. In those cases, Relay just have to look at the cursor for the last or first not deleted edge.

##### Work around for existing REST endpoints

Provided that you only ever paginate in one direction with this particular connection (Always use `first:<count>` or always use `last:<count>`), you can just generate cursors for edges with something like `<endCursor> + 'i'` where `i` is the number/distance of edges to the last edge. You can optionally hash it, encode it, and etc. to make it seem more opaque. Just make sure your GraphQL wrapper around your REST endpoint knows how to parse it and strip out the `i` portion before sending the request to your REST endpoint.

Things to avoid:
-  `null` cursors
  - if the last edge gets deleted, Relay won't have any cursors to paginate with, and will have to try to refetch the whole connection.
- repeating the same cursor
  - If multiple edges have the same cursor, when a server response for `(first:5, after: <repeatedCursor>)` comes back, Relay won't know which of all the edges with that cursor to insert the newly fetched edges after.

Let me know if this helps.
",yuzhi,taion
372,2015-09-26 07:10:43,"Sorry for the slow response! I haven't had much internet access in the last couple of days. Just caught up on this and saw that I got mentioned in slack about the same issue.

##### Context on why Relay gets cursors for each edge

When we were building Relay, we tried to gets data so that it can be cached and support as many views as possible with minimal round trips. As @josephsavona mentioned above, different component can paginate with different page sizes. We only ever need the very last and first cursor to paginate correctly, as @taion mentioned. However, getting cursor on every edge means Relay can always generate the correct `pageInfo`, more specifically `startCursor`, `endCursor` fields, without having to do another round trips to get the proper `pageInfo` for a different page size from the server for a different page size.  It didn't make sense to wait for a server round trip for something that's fetching `first:3` when we already have `first:5`. Having cursor on every edge is also handy when mutations can add and remove edges and might make the very last cursor out of date. In those cases, Relay just have to look at the cursor for the last or first not deleted edge.

##### Work around for existing REST endpoints

Provided that you only ever paginate in one direction with this particular connection (Always use `first:<count>` or always use `last:<count>`), you can just generate cursors for edges with something like `<endCursor> + 'i'` where `i` is the number/distance of edges to the last edge. You can optionally hash it, encode it, and etc. to make it seem more opaque. Just make sure your GraphQL wrapper around your REST endpoint knows how to parse it and strip out the `i` portion before sending the request to your REST endpoint.

Things to avoid:
-  `null` cursors
  - if the last edge gets deleted, Relay won't have any cursors to paginate with, and will have to try to refetch the whole connection.
- repeating the same cursor
  - If multiple edges have the same cursor, when a server response for `(first:5, after: <repeatedCursor>)` comes back, Relay won't know which of all the edges with that cursor to insert the newly fetched edges after.

Let me know if this helps.
",yuzhi,josephsavona
368,2015-09-23 03:45:20,"@josephsavona 



Here is also my custom scalar for reference: (I'm using Joi for validation)


",juhaelee,josephsavona
365,2015-09-23 00:57:00,"@josephsavona This field would be undefined when the query's missing. This is the only place productCategories is used in a fragment. 
",u9520107,josephsavona
362,2015-09-24 19:25:48,"Made the changes in #374 exactly as @steveluscher stated but not quite like the React Native website. I think this can be closed!
",michaelchum,steveluscher
362,2015-09-25 05:18:04,"Thanks for your help @michaelchum!
",kassens,michaelchum
360,2015-09-28 17:13:33,"@jardakotesovec  Is Dan's response what you were looking for?
",yuzhi,jardakotesovec
360,2015-10-04 10:55:40,"@yuzhi Yes, thanks. I did not realize that this convention is described directly in graphQL [spec](https://facebook.github.io/graphql/#sec-Errors), so I guess no need to have it explicitly in [graphQL - Relay spec](https://facebook.github.io/relay/graphql/mutations.htm). 

So closing, thanks!
",jardakotesovec,yuzhi
358,2015-09-22 16:29:33,"@kassens Are you sure you updated? I've confirmed the fix on latest.
",josephsavona,kassens
358,2015-09-22 21:08:28,"Perfect, thanks @josephsavona!
",shanecav,josephsavona
348,2016-10-29 13:08:43,"I will not rubber stamp and land your change for you @yungsters!  I can import it for you and you can get your change reviewed by someone though :)
",facebook-github-bot,yungsters
340,2015-09-19 05:05:59,"Super excited to get this landed. Thanks @taion!
",steveluscher,taion
340,2015-09-23 22:53:27,"Thanks @taion.

Now let's see if this machine wants to obey me:

@facebook-github-bot import
",wincent,taion
325,2015-09-17 01:06:31,"@josephsavona 
Ok. I'll try that out today and submit a PR later.
",u9520107,josephsavona
319,2015-09-16 00:00:12,"@zpao Thanks!
",RichardForrester,zpao
318,2015-09-16 11:13:19,"We have noticed the same thing about the edge for `RANGE_ADD`.

We used to encode information about the connection field arguments in our cursors, so we could raise an error if a cursor was incorrectly used with changed arguments. This was discussed in https://github.com/facebook/relay/issues/32 (see @dschafer's [answer](https://github.com/facebook/relay/issues/32#issuecomment-130410202)).

However, when adding a support for Relay mutations we noticed that we would need to return the edge from the mutations, so for example a `createStory` mutation payload would have



But the server doesn't know which connections (and connection field args) the client uses the edge for, so we had to remove the extra information from our cursors. They are now basically just object IDs and can be used for any connection / set of arguments. As @devknoll said, it seems like this stability is required for `RANGE_ADD`.

If cursors being compatible across different connection fields / arguments is a requirement for `RANGE_ADD` mutations, maybe it the connection spec needs to be clarified to suggest this behavior?
",fson,devknoll
318,2015-09-16 16:22:19,"I posted the question [here](https://stackoverflow.com/questions/32613879/should-the-opaque-cursors-in-connections-be-stable-across-different-field-args), but agree with @fson: if they should be stable, it should definitely be in the spec.
",devknoll,fson
311,2015-09-14 20:46:24,"Thanks, @zpao. Want to go ahead and import this on the FB side so we can get this in?
",wincent,zpao
309,2015-09-15 18:32:15,"@josephsavona Why not use the [GraphQL syntax for aliases](http://facebook.github.io/graphql/#sec-Field-Alias) instead of the special `@relay` directive in this case?


",fson,josephsavona
309,2015-09-15 18:34:15,"@fson That would be awesome - but that syntax is not supported for fragments. The above is equivalent to the following:


",josephsavona,fson
309,2015-09-15 18:47:10,"@josephsavona Oh, I see.

In the `@relay(alias: 'bigPic')` example, I assume Relay would convert it to something like this:



Where is the name of the field (`profilePic` in this case) defined?
",fson,josephsavona
309,2015-09-18 22:50:26,"@fson Relay can't convert to `lilPic: profilePic ...` because that assumes the fragment has one root field, which is rarely the case. 

Per offline discussion with @leebyron and @dschafer we'll probably have to add support for fragment aliases in the language to make this seamless. This would use your earlier proposal, @fson:


",josephsavona,fson
309,2015-09-18 23:04:15,"Thanks for the clarification @josephsavona.

This seems like the most obvious syntax. However, wouldn't it also assume a fragment with just one field that it can alias? What would happen if you try to apply it to fragment with many fields?
",fson,josephsavona
309,2015-09-18 23:12:10,"@fson the response for aliased fragments would be an object:



Then use it:


",josephsavona,fson
309,2015-09-18 23:37:26,"@fson the new syntax would create a new object, into which the results of the fragment are spread. The current syntax spreads the result into the _outer_ object.

Old result:



New result:


",josephsavona,fson
309,2015-11-21 13:55:09,"@josephsavona Looks like we have to pass both - variable mapping **and** prop with same name to make this work as @taion mentions above.

My example:
I need to display different number of items in connection for different scenarios. Child fragment has variable `commentsShown`.

But if I only pass variable mapping (without props) - Relay fetches all items as expected, but truncates them to initial variable value on render.

If I only pass `prop` with same name - Relay won't fetch all items (subject of this issue).

If I pass both - `commentsShown` variable and `commentsShown` prop everything works as expected. But that seems odd for me. 

Am I missing something?
",vladar,taion
309,2015-11-21 13:55:09,"@josephsavona Looks like we have to pass both - variable mapping **and** prop with same name to make this work as @taion mentions above.

My example:
I need to display different number of items in connection for different scenarios. Child fragment has variable `commentsShown`.

But if I only pass variable mapping (without props) - Relay fetches all items as expected, but truncates them to initial variable value on render.

If I only pass `prop` with same name - Relay won't fetch all items (subject of this issue).

If I pass both - `commentsShown` variable and `commentsShown` prop everything works as expected. But that seems odd for me. 

Am I missing something?
",vladar,josephsavona
309,2015-12-17 08:18:46,"@taion but these prop'd variables are known only in the component context, and not statically in the `fragments` section of the relay container (for instance, a piece of state handled by a component).

Is there something I'm missing ? I mean, fragment variables live in a static context, and I can't see how I would be able to access component runtime data within that static context. Could you explain me, please ?
",netgusto,taion
309,2015-12-21 17:05:13,"@quazzie Thanks for asking. I'm writing an answer to your question on Stack Overflow.
",josephsavona,quazzie
309,2015-12-22 09:40:04,"@taion @vladar Thanks for you answers.

**(react-relay v 0.6.0)**

Still, the relay variables set in the parent (`Freelance`) are set in the nested component (`FreelanceList`; when `console.log`ing this.props.relay.variables I can see them), but not used by relay in the query fragment defined by `FreelanceList`.

I'm puzzled, to say the least.


",netgusto,taion
309,2016-02-11 15:46:26,"I'm pretty well on track with how to do this via @josephsavona's example. But while working with similar code, I am getting the following error:



This is the fragment I am working with:


",jeromecovington,josephsavona
309,2016-02-11 18:19:44,"@josephsavona  - But here I am trying to set the values of `termSlug` and `taxSlug` to those passed in via the route. Ex.


",jeromecovington,josephsavona
309,2016-02-18 04:21:51,"@josephsavona Is there a place to track if the fragment alias will be added to the language? Thank you.


",guzart,josephsavona
308,2015-09-14 17:20:02,"I've imported this into our internal Phabricator instance so we can get some other eyes on it. Thanks for the PR, @freiksenet.
",wincent,freiksenet
307,2015-09-14 14:44:29,"This is a bug, and I missed this when adding support for extracting enums & input objects from `query` types to the printer. For context, enums and input objects are new in GraphQL RFC so our support for them isn't as fully tested. @jardakotesovec we apologize that you've run into some bugs when using them and we'll get this fixed for the next release.
",josephsavona,jardakotesovec
307,2015-09-14 14:48:53,"@josephsavona ok, thanks a lot for quick response. I will look forward to new version and meanwhile stick with 0.1.1
",jardakotesovec,josephsavona
307,2015-09-18 23:21:13,"@jardakotesovec this is now addressed on master and will be out in the next release. thanks for filing the issue!
",josephsavona,jardakotesovec
307,2015-09-20 11:13:56,"@josephsavona Great, thanks..  Noticed that it just missed 0.3.2 release. Hope another minor version bump will be soon :-).
",jardakotesovec,josephsavona
305,2015-09-15 21:26:36,"@KyleAMathews thanks again for reporting this - the issue is now fixed on master, i'm going to close.
",josephsavona,KyleAMathews
303,2015-09-15 17:20:56,"I think ab2afb30b7c53bca75638758acc4a3a4f0542309 is mitigation enough for now. Thanks, @zpao.
",wincent,zpao
295,2015-09-18 17:44:25,"@quazzie did 18964ef fix it for you? That code is for connections. Basic lists are considered as scalars and should have been updated here: https://github.com/facebook/relay/blob/18964ef05d753ef991d5f621367d7b1849352fc6/src/store/RelayQueryWriter.js#L259 
",yuzhi,quazzie
294,2015-11-07 02:47:11,"I second @dminkovsky, a sample code for handling access control with Relay will be much appreciated.
",mugli,dminkovsky
293,2015-09-16 15:45:51,"@taion The default is to refetch from the server, otherwise `append` or `prepend` behavior is used if specified. 

cc @yuzhi @steveluscher 
",josephsavona,taion
293,2015-09-16 15:55:17,":+1: to that, then.

I feel like the cases where I care the most about not refetching the entire connection are usually the ones where operations look like simple appends or prepends.

I think @devknoll's server-side proposal is the most generic and broadly applicable solution, assuming the difficulties with identifying the edge for insert are manageable. I feel like putting even more of this sort of logic in the client is a messier direction API-wise, since I really want my server to own these aspects of the data.

I don't think it's very important that this makes optimistic updates more difficult - rather, I think optimistic updates in these cases in general look more like nice-to-haves, and specifically figuring out where the edge goes optimistically on the client side may not be necessary in many cases, or could be special-cased for important cases.
",taion,devknoll
293,2015-09-16 18:17:52,"> Another option is to provide a way for the schema to define how field arguments correlate to sorting logic. For example, in the query friends(first: 10, orderBy: ""name"") the schema might indicate that edges should be sorted by the name field.

I think this is really interesting. Semantic knowledge of sort/filters could allow cache stores like Relay's to fulfill more cases. However I don't have much knowledge on what would actually need to be encoded in type definitions and schema introspection to provide Relay with relevant data. As you point out, it can only do so much though, it can't tackle anything where information isn't provided in a field like an ""edge rank"" mechanism or where the sort order is a derivation of multiple fields. I'm happy to entertain more specific proposals on this front. 

> I think @devknoll's server-side proposal is the most generic and broadly applicable solution

I concur! It seems to me that there are two problems to solve here:

**1) Send a mutation to a server that results in a modified list then query a minimal set of information to update the list on the client. (The OP's question)**

This problem is broader than Relay and is about best practices when designing GraphQL mutations. 90% of cases can be solved by making an assumption that append/prepend will be the right behavior. Otherwise, I really like the idea of a server responding with a sort of ""placement context"". Just spitballing ideas here, for example:



If `previousEdge` is null, then this is a ""prepend"", otherwise this is an ""insert after"". This example could be extended to include `nextEdge` as well to quickly determine ""append"". Caveat this approach with the mutation would need to know things like sort/filters to determine these prev/next edges, and it may not be possible for the server to do this efficiently at all.

**2) Optimistic mutations by Relay**

Here, in order to support more variable behaviors like this one discussed in this issue, I think @devknoll's ""client side"" approach is in directionally correct. In my eyes an ideal ""gloves off"" approach would be to allow optimistic mutations to be specified by the app developer as ""this is what I think the GraphQL response will be"" - effectively mocking the server. That's a heavy API, but would allow for support of broader behavior.
",leebyron,devknoll
293,2015-09-18 07:41:45,"@josephsavona Can you clarify what you mean by

> The default is to refetch from the server

Per my comment on #340, I can't seem to trigger this behavior at all.
",taion,josephsavona
288,2015-09-13 20:28:17,"@wincent Any info you can provide for how this will work & what it'll entail to set up on an existing GraphQL server? :+1: 
",devknoll,wincent
288,2015-09-14 18:20:20,"@devknoll: Internally, the way `defer` works is that you can denote certain fragments as ""deferred"", distinguishing them from the ""required"" part of the data. Canonical use-case example: the data for showing a post is ""required"" and rendering should be blocked until it arrives, but the data for the comments on the post can be ""deferred"" and get shown later, on arrival.

You can see code in `splitDeferredRelayQueries` that traverses the query splitting off these deferred fragments and producing a tree of new queries: the required part, and any deferred parts; note that the deferred parts are themselves recursively broken down into ""required"" and deferred parts. Note that you can't necessarily fetch all these parts in parallel, because there may be a data dependency here where you won't know for which object to fetch some deferred data until you get the ID of the object in the response to the required part of the query.

Internally, we have a ""batch"" endpoint for the incumbent version of GraphQL that knows how to understand this kind of graph of queries with possible interdependencies. It also understands that one of these dependent queries may need to reference the result of the query that is its dependency, and it knows how to orchestrate all this and flush it all back to the client in chunks.

When we open-sourced GraphQL, we did not include an equivalent notion to this batch endpoint because we wanted to keep the spec minimal and we view the batch endpoint as a separate layer above and not part of GraphQL itself. Additionally, we wanted to take the opportunity to reset and revisit the assumptions that we'd accumulated over years of internal GraphQL use. We didn't want to bake too much in, in a way that would limit our options for implementing batch-like semantics, or others like streaming, prioritization and subscriptions and so on. Many of these ideas are being discussed on the GraphQL Slack channel and on GitHub if you want to learn more.

Anyway, in terms of what all this means for `defer`, there is a short-term plan and a longer-term one.

The short-term plan is to enable use of `defer` by doing query splitting and managing the orchestration of the split queries entirely on the client side. In other words, we can send batches of queries and do dependency management to hold back dependent queries until they have the data they need in order to be fetchable. This approach will incur some overhead, because it may require multiple round trips to the server, but it at least enables `defer` to be used.

The longer-term plan is to continue to work with GraphQL to flesh out the semantics and directives that would need to be in place to get a more integrated approach to deferring data, one which wouldn't depend on client-side management of multiple round trips. We're being deliberately non-committal about this because we want to involve the community and don't want to commit prematurely to a course of action that could limit our options later on.

In the meantime, there is a mid-term possibility, which is that it's all just JavaScript: if you want to take the client side batching logic and put a server-side layer in front of your GraphQL endpoint that gets rid of the roundtrips and does all the management server-side, then that should be totally possible. But for now, the immediate step is to get the purely client-side prototype out the door, which is what I am working on.
",wincent,devknoll
288,2016-03-22 08:09:55,"@wincent you're right - I'm deferring independent queries and I don't care about the order they're coming back, but I'm happy to comply to these restrictions to have `defer()` working.
",anytimecoder,wincent
288,2016-05-17 14:32:16,"Just released new version of [react-relay-network-layer@1.1.0](https://github.com/nodkz/react-relay-network-layer/blob/master/CHANGELOG.md):
- add `gqErrorsMiddleware` to display graphql errors from server
- add experimental `deferMiddleware`. 

Right now `deferMiddleware` just set `defer` as supported option for Relay. So @anytimecoder may use this middleware to avoid hacking `GraphQLQueryRunner`. Also this middleware allow to community use defer in cases, which was described [above](https://github.com/facebook/relay/issues/288#issuecomment-199510058) by @wincent.

So I'll try to play deeper with defer fragments in near future.
",nodkz,wincent
288,2016-07-27 15:11:09,"I have started to work on this for a pure client side solution as @wincent suggested in one of the posts above. For some use-cases simply activating `defer` does indeed work. For other use cases we quickly ran into: `Uncaught Invariant Violation: printRelayOSSQuery(): Deferred queries are not supported.`. 

I managed to hack together a NetworkLayer that gets around this invariant, by accessing `request._query` and other bits I probably shouldn't touch. But I could not find another way to just in the NetworkLayer. Does that mean to support all use-cases code also needs to change in Relay and not just in the NetworkLayer?

The other thing I don't entirely understand is the `splitDeferredRelayQueries` function. Why does it split certain queries into ref queries?
E.g. we have



As long as I just have `${Component.getFragment('customer').defer()}` it all works fine and the split queries look as I would have expected. But as soon as I add the `holding` fragment it splits the deffered fragment off into a nodes query as seen in this test: https://github.com/facebook/relay/blob/master/src/traversal/__tests__/splitDeferredRelayQueries-test.js#L290

What I would have expected is simply these 3 queries:
1: 



2:



3:



Then at least conceptually all queries should work independently. Relay only needs to know that 2 and 3 are deferred, so it can render as soon as 1 has arrived. How come there is this distinction of ref queries? Is this normally handled by the server? How exactly can one use this batchCall information that is stored on the query?

Would my suggested approach make sense for handling everything on the client side? Or given some other directions I would be happy to take a stab at this.

@nodkz have you had any chance to look into this more?
",Globegitter,wincent
288,2016-07-27 15:11:09,"I have started to work on this for a pure client side solution as @wincent suggested in one of the posts above. For some use-cases simply activating `defer` does indeed work. For other use cases we quickly ran into: `Uncaught Invariant Violation: printRelayOSSQuery(): Deferred queries are not supported.`. 

I managed to hack together a NetworkLayer that gets around this invariant, by accessing `request._query` and other bits I probably shouldn't touch. But I could not find another way to just in the NetworkLayer. Does that mean to support all use-cases code also needs to change in Relay and not just in the NetworkLayer?

The other thing I don't entirely understand is the `splitDeferredRelayQueries` function. Why does it split certain queries into ref queries?
E.g. we have



As long as I just have `${Component.getFragment('customer').defer()}` it all works fine and the split queries look as I would have expected. But as soon as I add the `holding` fragment it splits the deffered fragment off into a nodes query as seen in this test: https://github.com/facebook/relay/blob/master/src/traversal/__tests__/splitDeferredRelayQueries-test.js#L290

What I would have expected is simply these 3 queries:
1: 



2:



3:



Then at least conceptually all queries should work independently. Relay only needs to know that 2 and 3 are deferred, so it can render as soon as 1 has arrived. How come there is this distinction of ref queries? Is this normally handled by the server? How exactly can one use this batchCall information that is stored on the query?

Would my suggested approach make sense for handling everything on the client side? Or given some other directions I would be happy to take a stab at this.

@nodkz have you had any chance to look into this more?
",Globegitter,nodkz
288,2016-07-28 09:26:36,"@josephsavona Yes, at the very least for understanding's sake it would be great if you could comment on my little hack: https://gist.github.com/Globegitter/553f7dffd1f7ceaead1aba0dd56c5554

Even though we are not using js on the backend this is great news! Either if we can use it on the client-side or just port it ourselves to python. And this batch API would just as-is take care of deferred queries?
",Globegitter,josephsavona
288,2016-09-03 00:50:14,"I'm going through and cleaning out old issues that were filed against Relay 1, so I'll close this one. As @josephsavona mentioned, we have the primitives in place to straightforwardly implement a `@defer`-like directive in [Relay 2](https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable). Thanks to everybody who commented on this issue!
",wincent,josephsavona
288,2017-02-10 03:15:58,"@wincent  @josephsavona @devknoll    does Relay 2 officially support 'short term' `deferred queries`?

I have a similar user case as your ""post and comments"" example. 
let's say I came to the post page via ""search by keyword"", and I have a section that will display either 'loading comments' or actual comments depending on whether comments data is ready.

At the moment we are using relay 1 and I'm handling the 2 queries manually. Like you said, the comments query depends on post query because we don't know the post id until the post query is resolved by server (we only know keywords initially). This is my demo code



as you can see, the `componentWillMount` and `isCommentsReady` are boilerplate code and should be handled somewhere else.  I would assume I  could 
* remove boilerplate code. remove `should_fetch_comments`
* wrap my `comnets_by_post_id` in a component
* call `${comments_by_postid.getFrament('comments',variables}.defer()`?

My questions are:
(*---try to anwser my own question*)
* how do I pass additional parameters to my deferred query?
*----no you can't. dependent node 's id is the only parameter that Relay passes to your deferred query. Not more other parameters can be passed*
* in my `MyPost` component, how do I know when`comments` fragment gets resolved?
*---you can only check whether the field in `props` is null. There is no `pendingDeferredQueries` available in relay as this feature is not supported yet*
I hope it all makes sense. thanks for reading my long post
(also can you also point out whether I'm following the right relay pattern?
*--yes it is as conformed by Greg int the follow ups*)


 ",bochen2014,wincent
288,2017-02-10 03:15:58,"@wincent  @josephsavona @devknoll    does Relay 2 officially support 'short term' `deferred queries`?

I have a similar user case as your ""post and comments"" example. 
let's say I came to the post page via ""search by keyword"", and I have a section that will display either 'loading comments' or actual comments depending on whether comments data is ready.

At the moment we are using relay 1 and I'm handling the 2 queries manually. Like you said, the comments query depends on post query because we don't know the post id until the post query is resolved by server (we only know keywords initially). This is my demo code



as you can see, the `componentWillMount` and `isCommentsReady` are boilerplate code and should be handled somewhere else.  I would assume I  could 
* remove boilerplate code. remove `should_fetch_comments`
* wrap my `comnets_by_post_id` in a component
* call `${comments_by_postid.getFrament('comments',variables}.defer()`?

My questions are:
(*---try to anwser my own question*)
* how do I pass additional parameters to my deferred query?
*----no you can't. dependent node 's id is the only parameter that Relay passes to your deferred query. Not more other parameters can be passed*
* in my `MyPost` component, how do I know when`comments` fragment gets resolved?
*---you can only check whether the field in `props` is null. There is no `pendingDeferredQueries` available in relay as this feature is not supported yet*
I hope it all makes sense. thanks for reading my long post
(also can you also point out whether I'm following the right relay pattern?
*--yes it is as conformed by Greg int the follow ups*)


 ",bochen2014,josephsavona
288,2017-02-10 03:15:58,"@wincent  @josephsavona @devknoll    does Relay 2 officially support 'short term' `deferred queries`?

I have a similar user case as your ""post and comments"" example. 
let's say I came to the post page via ""search by keyword"", and I have a section that will display either 'loading comments' or actual comments depending on whether comments data is ready.

At the moment we are using relay 1 and I'm handling the 2 queries manually. Like you said, the comments query depends on post query because we don't know the post id until the post query is resolved by server (we only know keywords initially). This is my demo code



as you can see, the `componentWillMount` and `isCommentsReady` are boilerplate code and should be handled somewhere else.  I would assume I  could 
* remove boilerplate code. remove `should_fetch_comments`
* wrap my `comnets_by_post_id` in a component
* call `${comments_by_postid.getFrament('comments',variables}.defer()`?

My questions are:
(*---try to anwser my own question*)
* how do I pass additional parameters to my deferred query?
*----no you can't. dependent node 's id is the only parameter that Relay passes to your deferred query. Not more other parameters can be passed*
* in my `MyPost` component, how do I know when`comments` fragment gets resolved?
*---you can only check whether the field in `props` is null. There is no `pendingDeferredQueries` available in relay as this feature is not supported yet*
I hope it all makes sense. thanks for reading my long post
(also can you also point out whether I'm following the right relay pattern?
*--yes it is as conformed by Greg int the follow ups*)


 ",bochen2014,devknoll
288,2017-02-12 23:58:55,"thanks @wincent . is it a way for client to know when deferred queries are resolved (like `pendingDeferredQueries`, just like `pendingVariables`)? or do I have to check the deferred fields are `null` in code. 
@josephsavona. I'm not quite familiar with `nodes` query. How is it different from `node` query and `connections` query? is the query type created only for deferred query?


https://github.com/facebook/relay/blob/master/src/traversal/__tests__/splitDeferredRelayQueries-test.js#L323",bochen2014,wincent
288,2017-02-12 23:58:55,"thanks @wincent . is it a way for client to know when deferred queries are resolved (like `pendingDeferredQueries`, just like `pendingVariables`)? or do I have to check the deferred fields are `null` in code. 
@josephsavona. I'm not quite familiar with `nodes` query. How is it different from `node` query and `connections` query? is the query type created only for deferred query?


https://github.com/facebook/relay/blob/master/src/traversal/__tests__/splitDeferredRelayQueries-test.js#L323",bochen2014,josephsavona
288,2017-02-14 11:21:25,"thanks @wincent  that helps me a lot!
""to either render a new root container after the initial fetch and render (triggered by calling setState in your componentDidMount callback) or .."" ((I'm familar with the latter one and use it a lot in my work)
 can you please elaborate on the former pattern? e.g. what is the user case for it. thanks",bochen2014,wincent
284,2015-09-10 21:19:22,"Thanks @wincent :+1: 

Concrete ideas for the short term:
1. An inverse of the ""help wanted"" label. This is mostly covered by the issue assignments that are already happening, but I'm not sure if this is codified yet. Then ""help wanted"" just becomes the set of everything that isn't already assigned to FB :wink: 
2. Add/assign GH issues for current internal tasks -- I don't see any GH tasks for the deferred query work that you're currently doing :wink:
3. I like facebook/react's ""good first bug"" label. It helped encourage me to try and contribute!

Given the current age of the project and that most development is happening internally, I think 1+2 would provide a sufficient roadmap in the short term.
",devknoll,wincent
282,2015-09-10 21:50:53,"We discussed this offline and agreed that for now, it's best for product developers to manually add `__typename` when necessary. Relay doesn't need this field to operate correctly, and applications won't need the field for every instance of an interface or union. Not including the field reduces network/cpu/memory overhead by default, and leaves open the option of adding it later.

A `matchFragmentType` function is easy enough to implement outside of Relay core.

@devknoll Thanks for bringing up this idea! I'm going to close but feel free to comment to continue the discussion
",josephsavona,devknoll
280,2015-09-10 20:07:46,"@devknoll interesting. can you file an issue to discuss the idea? 
",josephsavona,devknoll
278,2015-09-11 06:24:11,"@wincent  Thanks for the detailed response.
I respect your reasons, and most of them do sound valid. 
I believe you'll find that while some developers like ""playing with shiny things"", myself included, most are not comfortable with doing that on production, and companies/managers certainly don't want or allow that.

I do agree that you should push for evolving the language, but all I said is, give at least some option for the rest of the audience.
Like in React, there was a notion that ""JSX is optional"" and ""here's how you do it with ES5 or without JSX"". Although most devs used JSX. 
But, there was a choice.

Relay feels it went all in. ES6 and Babel or forget it.

In any case, thanks for sharing all of those libraries with everyone.
",AntouanK,wincent
269,2015-09-09 17:30:21,"@yungsters 

The React Router based implementation is here - https://github.com/taion/relay-todomvc. I'd be happy to PR it if you think it fits.

Aside from the caveat above with how the schema is set up, it has a few other external dependencies and uses webpack a bit differently from the existing examples, though.
",taion,yungsters
268,2015-09-10 01:20:20,"Shall I move this to facebook/graphql-js then, @josephsavona?
",devknoll,josephsavona
262,2015-09-09 05:35:00,"@zpao Thanks. Then I will fix this after the RC release.
",l-urence,zpao
260,2015-09-08 16:47:50,"Looks reasonable to me. Thanks, @devknoll.
",wincent,devknoll
259,2015-09-08 19:58:59,"Thanks a lot @mhart. I'll start again using your starter kit.
",mfirry,mhart
257,2015-09-09 03:08:46,"@wincent 
sorry, what do you mean by beat you to a PR?
",spyalert01,wincent
256,2015-09-08 17:05:58,"@devknoll thanks!
",josephsavona,devknoll
256,2015-09-16 17:59:15,"@josephsavona this happening? :wink: 
",devknoll,josephsavona
256,2015-09-16 18:17:55,"@devknoll Yeah, we should eventually move to the recommended naming scheme. This might take a few rounds of PRs:
- change the package name in the code (and then publish it)
- update everything to depend on it
- also update the docs

Community help appreciated! ;-)
",josephsavona,devknoll
256,2016-01-10 19:50:50,"@devknoll steveluscher @josephsavona Will this replace the `babel-relay-plugin` on NPM ?
If so it should still be in sync with the version number of `react-relay` to avoid confusion ?!
But it looks like there is a `1.0.0` published to NPM - but `react-relay` is only `0.6.1`.
Can you please fix this or am I mistaken here?
",BerndWessels,josephsavona
256,2016-01-10 19:50:50,"@devknoll steveluscher @josephsavona Will this replace the `babel-relay-plugin` on NPM ?
If so it should still be in sync with the version number of `react-relay` to avoid confusion ?!
But it looks like there is a `1.0.0` published to NPM - but `react-relay` is only `0.6.1`.
Can you please fix this or am I mistaken here?
",BerndWessels,devknoll
255,2015-09-08 16:52:02,"Thanks, @adriantoine. This looks reasonable to me. I also see #260, which fixes this this in a different way. Let me check out both of these.
",wincent,adriantoine
255,2015-09-08 16:55:14,"@wincent Not sure, but I think we might need both? #260 was intended to fix a slightly different problem. This one seems to be closer to #201
",devknoll,wincent
250,2015-09-08 14:25:12,"Thanks for the report, @sgwilym, and glad that you where able to get to the bottom of things.
",wincent,sgwilym
247,2015-09-07 15:11:19,"Thanks for reporting and providing such complete information.
TLDR: You can probably ignore the warning.

Looking at the query it is trying to send to the server, it has both a before and after call. That can only happen when we have a gap of unknown edges between two segment of known edges. 



My best guess is you have some components fetching the `first:n` of this photos connection and some components fetching the `last:m` of this same photos connection, which generates the gap and that query. That totally within what Relay's connection manager should support.

The warning is mainly to prevent people from directly doing `before/first` and `after/last` inside components. Those two combinations are used for polling additional things off of a connection and should not be part of any component's queries. The warning is showing up because we recently updated the write path to also read out some edges for some additional logic.

@josephsavona  do you think we can move that warning about doing `before/first` and `after/last` to the transform step so we don't get a lot of false positive warnings?
",yuzhi,josephsavona
247,2015-09-07 18:23:54,"> do you think we can move that warning about doing before/first and after/last to the transform step so we don't get a lot of false positive warnings?

@yuzhi Awesome idea, I'm on it.
",josephsavona,yuzhi
247,2015-09-07 22:02:07,"@josephsavona I can remove the warning from GraphQLRange once you update the transform.
",yuzhi,josephsavona
247,2015-09-08 03:02:39,"@yuzhi sounds perfect
",josephsavona,yuzhi
246,2015-10-01 04:54:24,"Hi @Gregoor @josephsavona ...,
I'm a little bit confused. React, Relay and GraphQL are quite new for me.
Is it possible for example to render recursively a directory structure with n descendants in a single http request?
If not, what's the source of the ""problem""?
- GraphQL doesn't provide a syntax to query recursively data
- or Relay doesn't know how to use this GraphQL syntax.

Relay batch the queries so in the worst case scenario, if I understand, I'll have a single GraphQL Query per level and by using a condition like ${BabushkaList.getFragment('babushka') we can tweak the thing to get n levels at the same time.

Thanks for clarifications.
",grifx,josephsavona
246,2016-01-05 01:30:20,"@dminkovsky `RelayFragmentReference` and the `if/unless` functions on it aren't documented. The plan is to replace these with standard GraphQL `@include`/`@skip` directives so that you could write something like:


",josephsavona,dminkovsky
246,2016-01-05 01:33:40,"@joesavona I was wondering just that—the relationship between if/unless and
directives. Thanks for clarifying!

понедельник, 4 января 2016 г. пользователь Joseph Savona написал:

> @dminkovsky https://github.com/dminkovsky RelayFragmentReference and
> the if/unless functions on it aren't documented. The plan is to replace
> these with standard GraphQL @include/@skip directives.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/246#issuecomment-168863730.
",dminkovsky,dminkovsky
245,2015-09-29 16:08:45,"cc @josephsavona 
",kassens,josephsavona
245,2015-10-05 14:20:09,"Any word on this? @josephsavona doesn't seem to be working for me either.
",aweary,josephsavona
245,2015-10-09 23:06:10,"@josephsavona I can confirm it: the `@include` directive is apparently ignored
",guigrpa,josephsavona
245,2015-10-10 16:39:40,"@josephsavona I should note that the error I was getting was due to using the `@include` directive in an inline fragment which I already noted here: https://github.com/facebook/relay/issues/443

If I use it on each field it seems to be working just fine :+1: 
",aweary,josephsavona
244,2015-09-07 19:33:24,"@KyleAMathews Really happy to heard that! Thanks for filing issues and helping to make Relay better :-)
",josephsavona,KyleAMathews
243,2015-09-08 18:09:14,"@wincent yes the `__DEV__` build makes sense. I noticed a second deprecated warning with `React.render(/*....*/)` in the example. It seems that `React.render(/*...*/)` should be replaced with `ReactDOM.render(/*....*/)` in React v0.14.0.
",l-urence,wincent
236,2015-09-04 21:04:32,"> Separately, I noticed you have widget and widgetId. Why not just fetch widget { id }?

@yungsters my guess is because global IDs are supposed to be opaque :smile_cat: Is there a current recommended method to retrieve the non-global ID of an entity/node other than adding an extra field?
",mhart,yungsters
236,2015-09-04 21:49:57,"@mhart No, but `widget { id }` should be the opaque global ID. If for whatever reason, you actually need the non-global ID, I would actually recommend making _that_ available via an extra field. Does that make sense?
",yungsters,mhart
236,2015-09-09 15:31:54,"@yungsters Yes, we can consider this resolved.  The reason I was retrieving widgetId to begin with was to debug the behavior of REQUIRED_CHILDREN vs. FIELDS_CHANGE.
",ashinohara,yungsters
234,2015-09-03 19:52:12,"@yungsters This could be caused by tracked queries being flattened. These should be unflattened when the mutation is constructed (via `refragmentRelayQuery`) - not sure why that isn't taking effect here.
",josephsavona,yungsters
234,2015-09-11 05:06:18,"Did b16c384 take care of this, @josephsavona, or is there more to do here?
",steveluscher,josephsavona
234,2015-09-12 00:07:22,"@steveluscher yes, this has been resolved.
",josephsavona,steveluscher
233,2015-09-10 16:13:32,"@josephsavona: If we change some stuff we could use the infrastructure that is available for the garbage collector and simply error-out if any data is still subscribed to.
We could change the `RelayStoreQueryResolver` to emit events when new subscriptions are created/disposed, this would enable us to count the number of active subscriptions and not allow `reset` if there are any.
This would even allow us to decouple some things (i.e. we could make `RelayStoreQueryResolver` unaware of the garbage collector)!
",clentfort,josephsavona
233,2015-09-26 18:42:12,"@skevy The workaround for now in React Native is the brute-force equivalent of a page refresh - tear down the current JS context and start a new one. 
",josephsavona,skevy
233,2015-09-26 18:50:21,"cc @skevy @devknoll @taion @fson anybody interested? ;-)
",josephsavona,skevy
233,2015-09-27 18:34:36,"@fson 

I like the idea of not having that global singleton Relay store.

Ignoring implementation difficulties for now, there are a couple of practical API considerations.
- For things like modals and overlays and other dynamic content with data dependencies, when not associating a route to them, it's probably easiest to just set up a new `RootContainer` - this `RootContainer` ideally should share the same store as the top-level `RootContainer`; perhaps `RootContainer`s can export the store as context and children `RootContainer`s can try to use those first
  - The context approach requires things that use portals to use `unstable_renderSubtreeIntoContainer`, though... ideally anybody doing this is using something like `react-overlays` that deals with this for them
- Same as above, but taking the naive routing approach @cpojer covers at https://medium.com/@cpojer/relay-and-routing-36b5439bad9, instead of using `react-router-relay` or something equivalent
- Same as above, but for mocking `.defer` support with extra `RootContainer`s
- @skevy can comment on this, but I believe naive approaches with navigator on RN lead to multiple sibling `RootContainer`s that would not be able to share state with this approach, and that actually keeping everything under a single top-level `RootContainer` requires quite a lot of work
",taion,fson
233,2015-09-27 18:34:36,"@fson 

I like the idea of not having that global singleton Relay store.

Ignoring implementation difficulties for now, there are a couple of practical API considerations.
- For things like modals and overlays and other dynamic content with data dependencies, when not associating a route to them, it's probably easiest to just set up a new `RootContainer` - this `RootContainer` ideally should share the same store as the top-level `RootContainer`; perhaps `RootContainer`s can export the store as context and children `RootContainer`s can try to use those first
  - The context approach requires things that use portals to use `unstable_renderSubtreeIntoContainer`, though... ideally anybody doing this is using something like `react-overlays` that deals with this for them
- Same as above, but taking the naive routing approach @cpojer covers at https://medium.com/@cpojer/relay-and-routing-36b5439bad9, instead of using `react-router-relay` or something equivalent
- Same as above, but for mocking `.defer` support with extra `RootContainer`s
- @skevy can comment on this, but I believe naive approaches with navigator on RN lead to multiple sibling `RootContainer`s that would not be able to share state with this approach, and that actually keeping everything under a single top-level `RootContainer` requires quite a lot of work
",taion,skevy
233,2015-09-27 18:39:18,"@fson Interesting idea. For background, we've found lots of use cases for having multiple `<RelayRootContainer>` instances that share data within a single application. For example, on React Native each screen within a navigation stack typically has its own root container, and if you're integrating Relay into an existing app you might have root containers for each small UI component that you convert to use Relay. 

That said, you're absolutely right that a more complete solution is to integrate RelayRootContainer into the `reset()` lifecycle. Perhaps:
- Allow `reset()` to be called while queries are pending and simply abort them. 
- If a reset occurs, `RelayRootContainer` immediately resets itself as it if was just rendered: it reissues queries for the route and shows the `renderLoading` indicator.
- What to do about pending mutations is less clear.
",josephsavona,fson
233,2015-09-27 18:43:22,"> I like the idea of not having that global singleton Relay store.

@taion We agree. Earlier versions of Relay had _way_ more global state, and we've been steadily refactoring to move this state into instance objects. The eventual goal is that you could configure a `RelayContext`-style object and pass it into the root container, and all query fetching, mutations, etc would then go through that context. This would obviously also help for server rendering.
",josephsavona,taion
233,2015-09-27 18:48:59,"@josephsavona 

What about (optionally) separating that out from `Relay.RootContainer` entirely? The idea would be something like having a `RelayContext` component that exports the context via `getChildContext`.

Then each `Relay.RootContainer` could just try to get its relay context via its `getContext` (and optionally create a new one if there isn't one available already, to simplify normal use cases where you just have a single `RootContainer` up top).

This would work well for the standard RN use case, because you could just wrap the navigator in a `RelayContext` component and have the `RootContainer`s share data. You'd still have to deal with `unstable_renderSubtreeIntoContainer` with dynamic modals rendered into portals for the web, but that's a much more minor issue.

The benefit of doing this would be that it might be possible to avoid an explicit imperative `reset` method, and just re-mount the `RelayContext` component, as @fson said.
",taion,fson
233,2015-09-27 18:48:59,"@josephsavona 

What about (optionally) separating that out from `Relay.RootContainer` entirely? The idea would be something like having a `RelayContext` component that exports the context via `getChildContext`.

Then each `Relay.RootContainer` could just try to get its relay context via its `getContext` (and optionally create a new one if there isn't one available already, to simplify normal use cases where you just have a single `RootContainer` up top).

This would work well for the standard RN use case, because you could just wrap the navigator in a `RelayContext` component and have the `RootContainer`s share data. You'd still have to deal with `unstable_renderSubtreeIntoContainer` with dynamic modals rendered into portals for the web, but that's a much more minor issue.

The benefit of doing this would be that it might be possible to avoid an explicit imperative `reset` method, and just re-mount the `RelayContext` component, as @fson said.
",taion,josephsavona
233,2015-09-27 20:55:46,"@taion Yes! That's basically the long-term vision. However, there's still a bunch of work needed to get there. The approach I outlined for `Relay.Store.reset()` is more meant as a useful stopgap until we have true `RelayContext`s.
",josephsavona,taion
233,2015-11-13 18:51:41,"This issue will largely be addressed by #558, which makes all Relay state contextual (implements the `RelayContext` idea discussed above).

@Globegitter - Yeah, that would be cool. The API could be `Relay.Store.invalidate(query)`, and the implementation would move any records or fields referenced by the query from the ""fresh"" data (`RelayStoreData#_records`) to ""stale"" data (`RelayStoreData#_cachedRecords`). This would cause Relay to refetch the information, without disrupting existing components that may be displaying the data.
",josephsavona,Globegitter
233,2015-11-13 19:38:11,"Instead of (or perhaps in addition to) invalidating it'd be nice to be able
to set expiration times. If relay is a cache it'd be nice to have normal
cache APIs available :-)
On Fri, Nov 13, 2015 at 10:51 AM Joseph Savona notifications@github.com
wrote:

> This issue will largely be addressed by #558
> https://github.com/facebook/relay/issues/558, which makes all Relay
> state contextual (implements the RelayContext idea discussed above).
> 
> @Globegitter https://github.com/Globegitter - Yeah, that would be cool.
> The API could be Relay.Store.invalidate(query), and the implementation
> would move any records or fields referenced by the query from the ""fresh""
> data (RelayStoreData#_records) to ""stale"" data (
> RelayStoreData#_cachedRecords). This would cause Relay to refetch the
> information, without disrupting existing components that may be displaying
> the data.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/233#issuecomment-156521834.
",KyleAMathews,Globegitter
233,2015-11-13 20:00:14,"@KyleAMathews Yup, we're looking into this. However, in early experiments storing the metadata required to record expiration times had a non-trivial impact on product performance.
",josephsavona,KyleAMathews
233,2015-11-13 22:29:28,"@KyleAMathews @josephsavona yep being able to set expiration times would be great as well. But yeah getting performance right is of course important as well ;)
",Globegitter,KyleAMathews
233,2015-11-13 22:29:28,"@KyleAMathews @josephsavona yep being able to set expiration times would be great as well. But yeah getting performance right is of course important as well ;)
",Globegitter,josephsavona
233,2015-11-13 23:28:01,"> A related question, could you invalidate on a timer while the view is active and have the data refreshed underneath it?

@KyleAMathews This is trivial to do today: use `forceFetch`. For example, to poll for updates on a query, use:


",josephsavona,KyleAMathews
233,2015-11-13 23:31:33,"> Could expiration exist outside of core?

@devknoll Good question. It isn't possible today without hijacking some internal methods. It could be an interesting experiment to try building it and see what hooks you need. Again though, the main consideration is perf.
",josephsavona,devknoll
233,2015-12-02 21:41:29,"@josephsavona I know that you guys have been working hard on making Relay state contextual, and it seems like you've made a lot of progress.

Is it in a place yet that would make implementing this easier? 

I still want to log out of my app :)
",skevy,josephsavona
233,2015-12-04 05:58:33,"But what about all of those PRs from @devknoll? :stuck_out_tongue_winking_eye: 
",taion,devknoll
233,2015-12-04 07:28:12,"@taion that contributed to the ""made a lot of progress"" part ;-)
",josephsavona,taion
233,2015-12-04 16:12:12,"@taion to clarify, the recent work around contextualizing state was focused on moving the remaining pieces of state into `RelayStoreData`. This was relatively straightforward in terms of outward API impact and performance. The remaining changes have a much more nuanced impact on both of these aspects - we'll try to do the work in the open as much as possible to get community feedback.
",josephsavona,taion
233,2015-12-07 15:03:43,"@josephsavona , you've written earlier:

> @skevy The workaround for now in React Native is the brute-force equivalent of a page refresh - tear down the current JS context and start a new one.

Do you have any examples or directions on how to do this?
",macrostart,josephsavona
233,2015-12-07 15:03:43,"@josephsavona , you've written earlier:

> @skevy The workaround for now in React Native is the brute-force equivalent of a page refresh - tear down the current JS context and start a new one.

Do you have any examples or directions on how to do this?
",macrostart,skevy
233,2016-01-04 23:41:10,"@josephsavona hello

You mention a ""forceFetch"" method but I don't see it documented here is it normal? https://facebook.github.io/relay/docs/api-reference-relay-store.html
",slorber,josephsavona
233,2016-01-20 14:03:18,"> @KyleAMathews This is trivial to do today: use forceFetch. For example, to poll for updates on a query, >use:
> 
> `const query = Relay.createQuery(Relay.QL`query { ... }`, {var: 'foo'});
>   Relay.Store.forceFetch({query}, readyState => { ... });`

Is there way to make it work as `fatQuery`, so I can refetch everything that is being tracked on some particular connection?

Reason why I just don't call forceFetch inside component that has full query is simply because I need to do it somewhere else.
Something like this:


",jardakotesovec,KyleAMathews
233,2016-03-31 00:59:11,"@edvinerikson The question of how to reset the Relay store still comes up occasionally, so having this issue is a useful way for users to find the current status. I'll update the description to make the plan more clear.
",josephsavona,edvinerikson
232,2015-09-03 15:58:40,"Thanks for the report, @sgwilym. I think we could probably add some (`__DEV__`-only) runtime config shape validation, likely in `RelayMutationQuery.buildQuery` it we had to. But we do have Flow types for those shapes there already though. When your code has an error in it, does it pass Flow typecheck?
",wincent,sgwilym
232,2016-04-15 14:48:55,"@jkettmann I'm glad that Relay playground helped here. Note that the latest version of Relay validates mutation configs - @wincent even added hints that suggest the correct keyword if its misspelled ;-)
",josephsavona,wincent
232,2016-04-15 14:52:37,"@josephsavona Thanks, great news. Good reason to update my dependencies ;-)
",jkettmann,josephsavona
232,2016-09-03 00:10:05,"Closing this thread as it is pretty stale. We added a bunch of validation for mutation configs in [v0.8.0](https://github.com/facebook/relay/releases/tag/v0.8.0), and mutation configs as such are going away entirely in [Relay 2](https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable), being replaced by a new API.

Thanks to @sgwilym and @jkettmann for chiming in.
",wincent,sgwilym
231,2015-09-03 16:45:49,"@sgwilym Good point - the error could be more informative and check whether the field was in the query (which means its a server error to not include in the response) or if it isn't in the query (which means it was subtracted and the message could tell you the field isn't being queried anywhere).
",josephsavona,sgwilym
231,2015-09-08 00:36:56,"I spent quite a while debugging the same thing, too. It was the same issue that @sgwilym was having; i.e., the app wasn't querying the relevant fields.  A more helpful warning message might be useful here.
",bmcmahen,sgwilym
231,2015-09-17 02:22:11,"@steveluscher Awesome! Looks like #237 also addresses the fact that `REQUIRED_CHILDREN` is undocumented so far. :+1: 
",xymostech,steveluscher
226,2015-09-02 21:25:12,"Thanks again, @devknoll. Will merge.
",wincent,devknoll
225,2015-09-02 19:03:10,"Thanks @devknoll! I'll get this merged.
",wincent,devknoll
223,2015-09-02 16:51:04,"We want to eventually turn this into an invariant, but there are currently callers that do something along the following lines:



The route is used by multiple components and some declare the `accountA` fragment while others declare the `accountB` fragment. @josephsavona and I have came up with a way to refactor the products to use two routes, but we need to unbreak them before landing the invariant.
",yungsters,josephsavona
222,2015-09-02 16:16:02,"Thanks @devknoll! I'll get this merged.
",wincent,devknoll
220,2015-09-02 16:55:55,"Doh, thanks for the clarification @yungsters 

Two random, most likely bad ideas:
1. We could automatically issue `node` queries on any known parents after the mutation (possibly just a single plural selection?) Bad because there's an async gap between the mutation finishing and the result coming in.
2. Relay mutation spec could be updated to include an opt-in `parent(parentIDs: [ID!])` field on mutation payloads. This could be added automatically by Relay and would include a list of all local nodes with a connection containing an edge to the node in question. Bad because... not entirely sure what fields we would select while preventing overfetching?
",devknoll,yungsters
219,2015-09-02 16:36:03,"Great! Thanks for this, @sgwilym. I'll get this merged in.
",wincent,sgwilym
218,2015-09-03 03:12:01,"@josephsavona I'm not actually sure about the `clientMutationId`. The idea is to have the next view query the store for the optimistic response (and eventually real response) by that client id.
",amccloud,josephsavona
206,2015-09-02 04:05:19,"@devknoll The goal is to be able to create a plugin from a `schema.js` file directly, instead of having to convert from schema -> introspection JSON. The blocker for this is that the schema file ends up `require()`-ing a different instance of `graphql` than the plugin does, and `instanceof` checks fail in `GraphQLPrinter.js`. 
",josephsavona,devknoll
206,2015-09-02 06:24:42,"@josephsavona However that doesn't help people who have their GraphQL server in another repository, running on a different server or using one of the growing number of other server implementations than graphql-js.

I'm more interested in fetching the schema using the introspection query, since it can work in these scenarios as well. Generalizing it might have some difficulties, because of varying authentication methods people might use etc. But maybe we can still provide a script that, like DefaultNetworkLayer in Relay, works for simpler cases out of the box so people don't need to worry about this when they are just getting started?
",fson,josephsavona
206,2015-09-03 19:55:33,"@devknoll I was just commenting about making integration with JS schemas easier, but I agree that we should also simplify things for products using alternate GraphQL implementations.
",josephsavona,devknoll
206,2015-09-07 04:56:59,"@fson i'm currently doing that.


",amccloud,fson
206,2015-09-07 20:06:02,"Yeah, this is basically the idea I was shooting for. A JSON-based `.graphqlrc` file that allowed you to specify a `schema`, that could either be a local path or a remote GraphQL endpoint.

It seems like it would also be very simple to make it handle a JS file exporting a graphql-js schema, and just have it run the same introspection query for that use case, right @josephsavona?

I'm still not entirely sure that it belongs in the main repo though... It would be nice for other tools if the `.graphqlrc` handling code was extracted into another module (but I suppose something like `require('babel-relay-plugin/graphqlrc')` wouldn't be terrible).
",devknoll,josephsavona
205,2017-01-21 07:39:01,"@wincent `setViewer` will take a token as an input and save the viewer in the context(request). this is my first try tho with graphql and relay so I'm not sure what's the best approach to handle authentication but I have been working for the last 5 days only on the graphql side and I decided to wrap all my queries with a root type that will take the token as an argument and all other queries are nested. for mutations I had in mind that they execute sequentially so I created a setViewer mutation with a token input that a user must run before any other mutation. it was quite sad after I started working on relay that it doesnt support something like that.

Now I have moved to Authorization header and removed the root query and things actually becoming much easier to manage but it just doesnt feel like a graphql way of authentication I think...",kareem3d,wincent
203,2015-09-01 16:06:08,"@jardakotesovec are you using the default network layer? Can you paste the full query that is sent to the server, along with the full set of variables? The snippet you included starts at an `ImageStore` fragment.
",josephsavona,jardakotesovec
203,2015-09-01 20:08:57,"@josephsavona Looks like the printed query is missing the type declaration for `$tagIds_0`.
",yungsters,josephsavona
203,2015-09-01 23:37:38,"@jardakotesovec @grydstedt this is now fixed on master.
",josephsavona,jardakotesovec
203,2015-09-10 10:40:12,"@josephsavona ping :-)
",jardakotesovec,josephsavona
203,2015-09-10 15:46:34,"@jardakotesovec My bad, I didn't realize you couldn't reopen. Do you get this issue if you're running on master (for both `react-relay` and `babel-relay-plugin`)?
",josephsavona,jardakotesovec
203,2015-09-10 17:21:29,"Thanks @josephsavona . You were right - `babel-relay-plugin` was behind, now the type is almost correct :-).  At the moment I am using relay 0.2.1 and babel-relay-plugin 0.2.2.

It still does not handle correctly the non null type situation, my definitions is:



Therefore in request should be `relationType!`, which is not. Is that something that might be fixed already in master(s)?

Error I get: 



Here is the request example:


",jardakotesovec,josephsavona
203,2015-09-10 22:34:41,"@jardakotesovec this is fixed in the PR - the printed type now accounts for arbitrarily nested lists/non-null annotations so that Relay will print `$relationType_1:relationType!` in your example. Working on getting this landed.
",josephsavona,jardakotesovec
203,2015-09-11 00:06:51,"@jardakotesovec should be fixed on master now - let me know if this is still a problem!
",josephsavona,jardakotesovec
202,2015-09-01 23:23:35,"@zpao should be good
",knowbody,zpao
202,2015-09-04 00:02:37,"@yungsters done, the tests are failing but not sure why, haven't done any changes to `src/`
",knowbody,yungsters
201,2015-09-01 16:57:44,"@yungsters Let me know if this is the approach we want to take here. I could also see value in having the examples pointing to a released package.
",devknoll,yungsters
195,2015-09-02 07:20:18,"@yungsters I'm talking about their every two weeks stable release. It seems like with this in mind they are able to move forward faster than other FB projects. Another good example is iojs.
",gyzerok,yungsters
191,2015-08-30 09:30:37,"@fson anyway to name relay's globally unique id `gid` and leave id as is?
",amccloud,fson
191,2015-08-30 17:32:33,"@fson you're correct that `__dataID__` is for the internal ID of the record and should not be accessed by application code (following the usual convention that anything prefixed with an underscore is ""private"").

@boosh this issue was brought up and discussed in #75 - see there for why we haven't added support _yet_. For now, the solution of adding an extra field seems best.

Longer term, we would like to support type-specific IDs (that could then be transparent values), but this is not high priority for the core team. We'll file a public issue to document the changes required to make this work - it would be a great area to have some input from the community!
",josephsavona,fson
191,2015-08-30 17:33:05,"also, @fson, thanks for answering this!
",josephsavona,fson
190,2015-09-01 06:16:38,"Went a slightly different direction with this. I noticed that the anchor links break down at H4, everything above that appears to be unique per page. So this will start generating nested anchors at H4. The benefit of this is that all of the existing anchors (except those that were duplicated) will continue to work.

WTB tests or anchor testing software :wink: 

cc @steveluscher
",devknoll,steveluscher
184,2015-08-27 22:12:00,"This is great. I agree with @steveluscher that this is ultimately best placed in a separate repo.

A few suggestions though:
- By not using `graphql-relay-js`, there's less guarantee that the root fields and mutation will work with Relay. For example, Relay requires that all mutations accept a single argument `input` - [see the spec](http://facebook.github.io/relay/docs/graphql-mutations.html#content) - but the mutations here don't follow this pattern and won't work with `Relay.Mutation`. Also it would probably be best to include an example for each root field (Note that `users` and `hobbies` return lists of items, which is currently unsupported. see #112 )
- file naming is inconsistent (`.js` but some `.es6`)
",josephsavona,steveluscher
184,2015-09-20 16:59:27,"Hi @josephsavona @steveluscher 

I've been abroad and I couldn't fix this properly. I have the example working with mutations already as @josephsavona point me. I have also added some easy navigation using url parameters.

I have to say that mutations lacks a bit more documentation to understand well how it works. It has been more a trial an error process until I managed to make it work.

For example, it confused me for one entire day that `clientMutationId` was always 0 when capturing the request of the mutation until I realized that performing a second mutation gives it an `clientMutationId` of 1, etc. I was thinking that `clientMutationId` must be the id of the object to be mutated.

I have also in the To-do the pull-request to relay-starter-kit. Anyways, I think it is ready if you want to reference it in the React Community Roundup yet.
",sayden,josephsavona
184,2015-09-20 16:59:27,"Hi @josephsavona @steveluscher 

I've been abroad and I couldn't fix this properly. I have the example working with mutations already as @josephsavona point me. I have also added some easy navigation using url parameters.

I have to say that mutations lacks a bit more documentation to understand well how it works. It has been more a trial an error process until I managed to make it work.

For example, it confused me for one entire day that `clientMutationId` was always 0 when capturing the request of the mutation until I realized that performing a second mutation gives it an `clientMutationId` of 1, etc. I was thinking that `clientMutationId` must be the id of the object to be mutated.

I have also in the To-do the pull-request to relay-starter-kit. Anyways, I think it is ready if you want to reference it in the React Community Roundup yet.
",sayden,steveluscher
181,2015-08-27 17:39:20,"@devknoll looks like you made updates before i finished adding all my comments. Can you double-check all of the feedback?

> do you have any thoughts about `hasFragment`?

Adding `hasFragment()` seems reasonable.
",josephsavona,devknoll
181,2015-08-27 17:51:24,":white_check_mark: Updated missing fragment invariant
:white_check_mark: Updated invalid query invariant
:white_check_mark: Changed to 'does not'
:white_check_mark: Nixed fragmentName
:white_check_mark: Fixed test name

Everything should be there now @josephsavona, thanks for your time & effort!
",devknoll,josephsavona
181,2015-08-29 01:39:52,"@devknoll we're basically all set to merge this once the merge conflicts are resolved (sorry about that, but the fix should be minor)
",josephsavona,devknoll
181,2015-08-29 02:19:59,"Whoops, thanks for the heads up @josephsavona 
",devknoll,josephsavona
181,2015-08-29 17:44:12,"@devknoll awesome job on this. thank you!
",josephsavona,devknoll
174,2015-08-27 03:24:58,"@josephsavona - good call - changed it to use the `git@` version.
",philcockfield,josephsavona
170,2015-08-29 07:17:55,"Ok @josephsavona, thx!
I have not try it yet, do you think that something like this could work?


",davide-ganito,josephsavona
168,2015-08-28 03:40:08,"@KyleAMathews We're always interested in feedback and if this plan addresses any use-cases you might have been thinking of. Also, I should clarify that while our goal isn't to ""replace Flux"", implementing this feature could allow us to replace generic variations of Flux in a lot of places.
",josephsavona,KyleAMathews
168,2015-08-28 15:56:16,"@KyleAMathews you can use GraphQL client-side today.
",gyzerok,KyleAMathews
168,2015-08-28 17:22:46,":+1: Thanks @josephsavona! I'll close this issue in lieu of #114 
",KyleAMathews,josephsavona
167,2015-08-26 21:56:45,"@pasviegas thanks for fixing!
",josephsavona,pasviegas
166,2015-08-25 21:57:07,"@yuzhi Thank you! It works! But why `REQUIRED_CHILDREN` isn't documented?
",vslinko,yuzhi
166,2016-01-22 01:42:32,"@josephsavona Thanks :smile: 

Yes, no parts doesn't working. But my concerns is:
- `REQUIRED_CHILDREN` is not pointed in the formal document -  [Mutator configuration](https://facebook.github.io/relay/docs/guides-mutations.html#mutator-configuration) and anywhere else.
  
  Does this config is not suggested? #236 
- Is there any method to fetch `addons` field from mutation except `REQUIRED_CHILDREN` ?
  
  the query string is always like `mutation Signin($input_0:SignInMutationInput!){signin(input:$input_0){clientMutationId}}` by default, only `clientMutationId` field.
  
  can we define getMutation like this in the future ?
  
  

thanks again
",gwind,josephsavona
161,2015-08-24 19:50:52,"@devknoll: That's a pretty solid solution to get tests working now. Relay will pass through any props whose name matches a `fragments` key as-is. You'll get a warning about fake data but this is safe to ignore in tests. 

Most of `RelayTestUtils` is intended for internal tests (and we wouldn't want people depending on these APIs) but we would definitely accept PRs to build a public `TestUtils`-esque API for Relay. `RelayTestUtils.createRenderer()` is a good place to start ;-)
",josephsavona,devknoll
161,2016-05-17 18:18:38,"@devknoll Does **mocks** live within Jest's **tests** directory. 

Is there anywhere I can read about this or see a example in a little more detail?
",rterysen-openroad,devknoll
160,2015-08-24 20:02:05,"@albertstill thanks!
",josephsavona,albertstill
152,2015-08-22 23:54:49,"lg2m. Thanks, @lencioni!
",wincent,lencioni
141,2016-06-29 12:05:32,"@josephsavona, the answer is very helpful. Is there any documentation about those arguments? If not, I could write it.
",lvarayut,josephsavona
140,2015-08-24 16:46:30,"@devknoll do you have a good repro case that you could share? 
",josephsavona,devknoll
140,2015-08-24 16:58:52,"@josephsavona Dead simple repro case here: https://github.com/devknoll/relay-starter-kit/tree/duplicate-queries

You can imagine a more sophisticated scenario where e.g. a Header queries for a Viewer's user for name, profile picture, and then some other component (e.g. a Newsfeed comment box) also needs the viewer profile picture. In such a case, the data would be requested twice.
",devknoll,josephsavona
136,2015-09-23 17:38:00,"@taion is right, when I try to use server rendering, I get this error:



which is what you get when you use `whatwg-fetch` instead of `isomorphic-fetch`: https://github.com/github/fetch/issues/125

Is there any workaround?
",adriantoine,taion
136,2015-09-30 16:51:59,"@zpao https://facebook.github.io/react-native/docs/network.html#fetch
",devknoll,zpao
136,2015-10-06 13:00:34,"@adriantoine Yes. I know it, but fetch is not only one problem with Relay on server.
",mikhail-riabokon,adriantoine
136,2015-10-22 21:14:56,"@wincent I'm more than willing to give a hand.. can you or @voideanvalue give me a starting point or two where I could start spelunking into the problem?
",RavenHursT,wincent
136,2015-10-29 19:09:43,"I definitely am.  My team really does need to get server-side rendering with Relay/React by the end of Q12016.  @voideanvalue I'll definitely ping you with any questions I come across.  Thanks!
",RavenHursT,voideanvalue
136,2015-11-10 18:59:54,"Glad to report that I have just managed to implement server side rendering for Relay: https://github.com/denvned/isomorphic-relay

Here is an example: https://github.com/denvned/isomorphic-relay/tree/master/examples/star-wars

@voideanvalue, can you please have a look? And thank you for the great [info](https://github.com/facebook/relay/issues/36#issuecomment-130402024). It helped me very much!
",denvned,voideanvalue
136,2016-01-11 16:21:13,"Thanks @josephsavona, exciting to see so much progress on this. I'll keep an eye on #558 :+1: 
",aweary,josephsavona
136,2016-05-27 15:59:50,"@josephsavona do you guys think that `isomorphic-relay` is ready for production as far as you know?
",aweary,josephsavona
135,2015-08-25 05:03:17,"Thanks @steveluscher 
But in my opinion, I'm sure this is ""good enough"" for an ideal API
In Relay doc, it's encouraged to put all relevant and influenced field in `Mutation getConfig` 
And in this case, it's the `AddMessageMutation` cause the field the variable change,
but the handler in on upper component, which I think it's a little bit suboptimal
Why not let `variables` in `Mutation` being a instance method and let `Mutation input` named something else like `getInputs`
If you think this is worth discussion, I will close this one and open another issue.
If not, you can close this issue since my original question is solved
",transedward,steveluscher
134,2015-08-22 01:25:20,"@josephsavona  thanks
",spyalert01,josephsavona
131,2015-08-20 16:28:40,"@steveluscher Yeah, I was worried that it would be a little too strict -- https://github.com/facebook/relay/pull/49#discussion_r37269845. Shall I open a PR that just requires that the route provides everything the container wants instead?

cc @josephsavona
",devknoll,steveluscher
129,2015-08-21 09:03:26,"HI @steveluscher 
Thanks for your answer. 
The part that you show, I understand, and I know how to deal with it. But how about the part that I show. How can I move that part out from server.js to webpack.config.js?
",spyalert01,steveluscher
129,2015-08-21 14:07:56,"@spyalert01 

The part that you show in your original example is creating a development http server. The settings you are passing to `WebpackDevServer` are not relevant to a production server deployment.

As @steveluscher said, you can use `webpack -p` to have Webpack bundle all of your assets (in the exmaple `webpack.config.js` this would output `app.js`). Then, you would have your production web server, `express` for example, serve the bundle generated by Webpack, `app.js`, alongside your index.html page (and other static non-bundled assets).

Webpack does not provide a production web server, it just bundles your assets together. You must then serve those bundled assets yourself. See [this blog post](http://christianalfoni.com/articles/2015_04_19_The-ultimate-webpack-setup) for examples on how to set this up.
",fortruce,steveluscher
128,2015-08-25 15:30:22,"thanks, @yuzhi nice to hear. I had one already. and below is how I do pagination on messages
https://github.com/transedward/relay-chat/blob/add-pagination/js/components/MessageComposer.js#L53-L60 how I add on `onFailure`

https://github.com/transedward/relay-chat/blob/add-pagination/js/components/MessageSection.js#L66-L74 `the handle callback passed from upper component`

I would keep developing this example for future feature like server-side rendering...
and any one interested can follow [here](https://github.com/transedward/relay-chat).

I am also looking forward for future development of Relay, hoping it will be more mature and bringing benefit for everyone using it.
",transedward,yuzhi
127,2015-08-20 23:13:52,"@zpao Gotcha. Explains why I had to alias react to react-native to use relay.
",amccloud,zpao
127,2015-09-11 16:28:15,"@spicyj Very few. This was one of the main issues. I am successfully using relay with react-native. I use webpack so I aliased react to react-native. I also had to include https://github.com/johanneslumpe/react-native-browser-polyfill
",amccloud,spicyj
126,2016-06-28 00:12:15,"@steveluscher that repo doesn't seem to exist (or is private?)
",mhart,steveluscher
126,2016-06-28 02:38:03,"It's private, for a few moments longer. Stay tuned!

> On Jun 27, 2016, at 5:12 PM, Michael Hart notifications@github.com wrote:
> 
> @steveluscher that repo doesn't seem to exist (or is private?)
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
",steveluscher,steveluscher
125,2015-08-20 22:56:21,"@taion They may look similar in that example because the optimistic payload is very thorough, but keep in mind that optimistic responses are completely optional. Mutations can have simpler optimistic response or no optimistic updates at all. The optimistic response also doesn't tell Relay store where to add edges or what to do with fields that are just a list of ids that are meant to be deleted. One potential thing we might not need from the optimistic payload is the `story.id` since that can be inferred from the `getConfigs`, but I'm not sure how the rest are being overlapped.

@mhart Fragments in mutations are mainly a way to declare what the mutation might need to generate the optimistic payload, which might also include fields that don't need to be in the `fatQuery` or be part of the `getConfigs`. It's similar to how components has fragments to declare what it needs to generate the view. What do you think it is duplicating or does it just look similar to the other ones in the examples?
",yuzhi,taion
125,2015-08-20 22:56:21,"@taion They may look similar in that example because the optimistic payload is very thorough, but keep in mind that optimistic responses are completely optional. Mutations can have simpler optimistic response or no optimistic updates at all. The optimistic response also doesn't tell Relay store where to add edges or what to do with fields that are just a list of ids that are meant to be deleted. One potential thing we might not need from the optimistic payload is the `story.id` since that can be inferred from the `getConfigs`, but I'm not sure how the rest are being overlapped.

@mhart Fragments in mutations are mainly a way to declare what the mutation might need to generate the optimistic payload, which might also include fields that don't need to be in the `fatQuery` or be part of the `getConfigs`. It's similar to how components has fragments to declare what it needs to generate the view. What do you think it is duplicating or does it just look similar to the other ones in the examples?
",yuzhi,mhart
124,2015-08-20 03:45:19,"@josephsavona I'm very glad my plea for empathy was heard. I wasn't sure which way it would go. I'd like to take a whack at proposing ways the api can be simplified after I read the docs more and have some time to play with Relay.

However, in my experience, when I have written some code, especially documentation, I find that following the documentation, pretending I am completely unfamiliar with the library helps me identify how the documentation and especially the code can be polished and refined further. I also wouldn't expect someone else to know how code I've written could be improved better than myself.

That said, I'd still be happy to point out things I struggle to understand, or things that feel awkward, and provide ""dream code"" as long as it is understood that my feedback may be incomplete and feeble at this point.
",jehoshua02,josephsavona
124,2015-08-20 06:08:43,"I'm fully agreed with @jehoshua02 about hes thoughts about Relay API. My were definitely the same. I think that Routes and Mutations are redundant. More than that currently Relay is tightly coupled with server schema implementation. I do not like all those wrappers for creating GraphQL schema. So it looks like now Relay is tightly coupled to the facebook. On the other hand React API is really awesome and simple. But its only IMO.

@josephsavona 
Please check [my repo](https://github.com/gyzerok/redux-graphql) where I started to create custom implementation of Relay in July before official release.
The motivation was: 
1) bored to wait official release 
2) In Relay you need to provide custom implementation for only-client stores, so you need to use one other framework for it which is bad in my opinion
3) Redux is really awesome and I like to use its devTools even in Relay context
So I've ended up with some Redux-tools implementation which current provides data fetching mechanism. 
I've found [react-redux](https://github.com/rackt/react-redux) idea about Smart and Dumb components quite cool. Generally you create Smart components for your root view tree nodes (which correspondes to routes) and dumb component for other views. You can read more about it in the react-redux docs. So my implementation is kind of react-redux fork.
Readme is currently out of date. Please check `examples` directory to see my ideal api for this.

@jehoshua02 If you interested in more simple API, I would be happy if you can help me in my project. Together we may challenge better API which later on we can provide to Relay team.
",gyzerok,josephsavona
121,2015-08-19 17:56:07,"@yuzhi if I remove the photos field from the query it works just fine at returning my UserType. 
",amccloud,yuzhi
121,2015-08-19 19:30:31,"@yuzhi That fixed it for me!
",amccloud,yuzhi
119,2015-08-19 19:05:25,"@yuzhi Do you think it would be useful for the connection config types too? I haven't used them much yet, but they refer to a `parentID` which could theoretically also be missing from an optimistic mutation.
",devknoll,yuzhi
115,2015-08-19 17:49:04,"Thanks @josephsavona -- actually, I'm pleased that none of my changes are done in a _total_ vacuum :wink: they all at least get tested on my production app too, since that's where I usually run into an issue first :smile: So I would have caught that! 

Any thoughts with regards to the now two old deprecated formats? Does it still make sense for the signature here to be `() => Relay.QL` (maybe variables require it?) rather than the regular return like mutations? 
",devknoll,josephsavona
115,2015-08-24 21:33:25,"Whoops, thanks @josephsavona. #58 can't come soon enough ;-) Let me know if this is likely to be accepted and I'll add doc updates to the PR
",devknoll,josephsavona
115,2015-08-27 04:49:34,"> Let's be more explicit about when the new logic will take effect in order to avoid surprising behavior 

Ahhh, had something like that originally. Fixed.

> `field.isScalar()`

`GraphQLFieldNode`s don't have an `isScalar`, so I'm checking for # of child fields directly instead.

> RelayQL: Expected query

I changed this to `buildRQL` since it seems to follow the conventions more as far as I can tell.

> `query.name`

Wasn't sure if you wanted the name from the route/fragment or the root call. Went with the latter, let me know.

> We should also add a test case in getRelayQueries-test that ensures route params are passed through properly.

Let me know if the new test addresses your concerns!

@josephsavona Thanks, and sorry for the delay! I'll get the doc changes in soon too.
",devknoll,josephsavona
115,2015-08-27 19:28:48,":white_check_mark: `getQuery` -> `getFragment`
:white_check_mark: `fragment` -> `fragmentReference`
:white_check_mark: `GraphQL.QueryFragment` -> `RelayFragmentReference`

I also went ahead and cleaned up the rest of the calls to `getQuery` in buildRQL-test.js, and added a line to the changelog.

cc @josephsavona Thanks!
",devknoll,josephsavona
115,2015-08-28 01:41:10,"@devknoll awesome! thanks again for working on this. i'm working on syncing this and your other change.
",josephsavona,devknoll
115,2015-08-29 19:47:08,"Should be good to go now @josephsavona, thanks!
",devknoll,josephsavona
115,2015-09-01 01:32:54,"@devknoll this is awesome. thanks!
",josephsavona,devknoll
115,2015-09-02 15:25:40,"I don't think so. Passing different params to `getFragment` seems like a valid thing to want to do in some cases, but @josephsavona could comment on longer term plans.

I see it as mostly just a way to cut down on some of the initial boilerplate necessary, since most often queries are going to be of the same format:



That being said, I do wonder if perhaps this would have been better solved at the babel plugin layer instead, so that the actual queries getting to Relay don't change...
",devknoll,josephsavona
114,2015-08-24 12:22:06,"@josephsavona My current case (real world example): 

Consider thread of comments. Single comment can be ""focused"" or not. Focused comment will be highlighted + there is separate non-child component in the sidebar that displays full details about comment author.

So what I need effectively is:
1. Know if currently rendered comment is ""focused"" to show some outline.
2. Find out currently active thread (there may be many different threads)
3. Receive details about author of focused comment for currently active thread

So this is pretty much transient local state. It must be shared because required by different hierarchies or React components (thread and authorInfo).

Ideally, with Relay-only solution I would write query like this:



I guess, I would also want to add some `directive` to query to mark field as local state.

But even if you can implement something like this for querying - there is another question about handing local state transitions. They may require some state transition engine behind them (like Flux store / state reducer).

Also they may be ""mixed"" - say local state changed when some mutation is executed that also mutates data on the server.

There are indeed many edge cases here.
",vladar,josephsavona
114,2015-09-18 14:46:16,"@taion 
Well yeah, but I could be using graphql and resolving to localStorage or indexDB completed on the device. Setting up the cache service like a backend on a webworker maybe, and let all the components fetch data via Relay regardless of fetching from backend or fetching from local cache.

But I guess that's added work to write the cache service with graphql if we can use localStorage from the beginning. Not to mention more overhead for simply storing some data on client-side.

Just a thought anyway...
",u9520107,taion
114,2016-02-03 02:09:09,"> being able to query public GraphQL servers from within your app

@KyleAMathews Do you mean query multiple public GraphQL servers? You could query a public server today by configuring a network layer.
",josephsavona,KyleAMathews
114,2016-02-03 06:28:14,"Wait how would that work?
On Tue, Feb 2, 2016 at 6:09 PM Joseph Savona notifications@github.com
wrote:

> being able to query public GraphQL servers from within your app
> 
> @KyleAMathews https://github.com/KyleAMathews Do you mean query
> multiple public GraphQL servers? You could query a public server today by
> configuring a network layer.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/114#issuecomment-178957965.
",KyleAMathews,KyleAMathews
114,2016-02-03 17:50:26,"@KyleAMathews configure a network layer and request data? what am i missing?
",josephsavona,KyleAMathews
114,2016-03-15 17:32:08,"First off, thanks for open sourcing Relay. There's some really clever ideas in this project, and we really appreciate all the work the team has done.

We're currently evaluating Relay, and how to elegantly combine client state and events with Relay server data is the biggest unanswered question (we've looked at Stackoverflow and the issues here).

@josephsavona What's the recommended way of doing this in production today? We think that nailing this will be one of the best indicators of how well Relay fits our needs. It appears to be the biggest weakness (and potential risk) with using Relay before this issue is resolved.

I'm assuming Facebook tackled this problem in some way for the complex UI state in AdsManager? 

**Side note**: We'd love to see a blog post on best practices regarding Schema design :)
",jimkyndemeyer,josephsavona
114,2016-03-16 00:40:26,"IMO, if you mix in too much of the imperative approach to state management you go back to square one. When you need to change your UI you'll have a lot of rework. 

@josephsavona I had captured the following after talking to you a while back. Is this still in the roadmap?

> Any app state that is not sync'd to the db is not something that Relay encompasses right now, but there is an ongoing discussion for handling scenarios like client-side form validation and state updates from sources other than the db (e.g. websocket)
> 
> These important scenarios will be addressed according to the Relay Roadmap (https://github.com/facebook/relay/wiki/Roadmap):
> 
> API for resolving fields locally: #431.
> 
> Support querying & compiling client-only fields by extending the server schema, and a means for writing data for these fields into the cache: #114. 
",idibidiart,josephsavona
114,2016-03-16 13:35:53,"@josephsavona Thanks for the info. I looked it over, and we'll definitely use the imperative API for ad-hoc searches etc.

We're looking for an elegant way of synchronizing local shared state with the Relay variables that are kept inside Relay containers. The use case is similar to what @vladar and @staugaard posted.

Let me give you an example based on the TodoMVC app by adding a new feature:

Imagine the user can click on a todo to select it. On the right hand side, there should be a Relay container that displays additional details about the selected todo.

To make sure this happens we need shared state, e.g. a `selectedTodoId` property in a store. The `Todo` component can dispatch a `SELECT_TODO` action, and our `Relay(TodoDetails)` container needs to use the `selectedTodoId` value as a variable to query the details of the todo.

From what I can find in the Relay Container API, the way to do this is to use `this.props.relay.setVariables`.

The trick is to call `setVariables` each time any relevant local state changes. I found an example of calling setVariables to keep them in sync at [fdecampredon/f337605e393a5b032b85#file-redux-relay-js-L73-L80](https://gist.github.com/fdecampredon/f337605e393a5b032b85#file-redux-relay-js-L73-L80)

We've arrived at something similar in our prototyping: An additional HoC that is placed in-between a Relay container and the component that needs the Relay data as props. So something like:



`ClientStateRelayVariablesListener` does the following:
- It renders `ComponentThatNeedsData` by forwarding all props
- It subscribes to the store and each time a property changes it checks for a matching Relay variable name on `this.props.relay.variables`. If there is a match it calls `this.props.relay.setVariables`on behalf of `ComponentThatNeedsData`

That's the basic gist of what we're doing. The actual implementation is a bit more complicated since `setVariables`is async, so we queue up the local state changes and only signal them once the Relay data comes back

While the query is running we set a ""(variableName)IsLoading"" boolean on the store, e.g. `selectedTodoIdIsLoading`. This allows the details component to render a spinner. As a side note we use mobx to signal the names and values of properties that change on the store.

I guess I'm looking for some kind of feedback as to whether this approach is the way to go?

We don't want to overlook something in the current Relay API, or over-engineer this. Our goal is to provide a great DX where our team doesn't have to also write setVariables boilerplate code each time they mutate shared local state.
",jimkyndemeyer,josephsavona
114,2016-03-16 15:15:42,"I agree with @talon here

@josephsavona :  those were capturing what the Relay Roadmap stated, not my gist. Sorry for the confusion. Your Relay roadmap had stated at some point these ideas/features were being pursued:

> API for resolving fields locally: #431.
> 
> Support querying & compiling client-only fields by extending the server schema, and a means for writing data for these fields into the cache: #114.

Are these still on the Roadmap? 

When it comes to the subject of client-only state and Relay, I think the two features listed in the Roadmap (see Update #1 below) are must-have eventually. But I see a risk at a conceptual level in what many people take for granted: that client's job is to specify to the server how to satisfy user intent -- This leads to all sorts of complications. App state that sync'd via Relay between the UI component tree and our graph model on the server should be all that is needed in most cases (other than client-only state say animation state and other client state that we don't care to sync to server, e.g having 5 windows open in Gmail) Client should relay mutations to that state that are due to user interaction and the server should figure out user intent and how to satisfy it. Having the client figure out user intent and how to satisfy it (and, specifically, having to keep stateful client-side logic to do that) means that you're isolating that part of the application's behavior in the client, which leads to a much heavier and more complicated client codebase.
",idibidiart,josephsavona
114,2016-03-16 15:23:15,"@taion I don't really understand your answer. Can you outline how you would solve the scenario I outlined. I'd be more than happy to learn that we are in fact over-engineering this :)
",jimkyndemeyer,taion
114,2016-03-16 15:40:01,"@taion Isn't that just an implementation detail? Whether we're using setVariables or updating a route,  the challenge is to ensure that the store and the relevant Relay (root)containers alway stay in sync.

What we've done with the additional HoC is let developers say abstractly, ""My Relay variable ""foo"" should always stay in sync with property ""foo"" on store ""Bar"". The HoC then takes care of the subscription logic, e..g remembering to unsubscribe in unmount. Without the HoC that code is scattered throughout the component tree.
",jimkyndemeyer,taion
114,2016-08-12 23:47:26,"@josephsavona do you have any updates? Getting proper support for local state in Relay is huge (no pun intended)!

There is no branch to track how things progress, which I assume is because of Facebooks from Internal use to OSS release workflow.
",hkjorgensen,josephsavona
113,2015-08-18 23:06:57,"@dschafer this requires no client changes, correct?
",josephsavona,dschafer
113,2015-08-19 17:34:22,"> @dschafer this requires no client changes, correct?

Correct.
",dschafer,dschafer
112,2015-08-25 15:58:25,"@yungsters @josephsavona is it possible that this change would also allow us to remove the Relay-specific Input Objects on mutations? It seems super strange that GraphQL supports multiple arguments but then Relay forces them to all be wrapped up ;-)

Edit: would lose the ability to have a single variable in the document and stuff all the values into a variable as an input object though.
",devknoll,yungsters
112,2015-12-23 20:29:48,"@steveluscher has there been any progress on this? Is there anyway I can help? Right now, we're basically using `JSON.stringify()` to send in multiple arguments via Relay to a root query.  It's a very hacky solution, but seems to be working.  Would love to be able to remove this cruft from our project sooner rather than later ;-)
",RavenHursT,steveluscher
112,2015-12-31 06:23:43,"@yungsters If I were to embrace the origins of Relay, and build a system of my own that has a similar ""root call"" named `viewer`, is it fair to say that `viewer` is sort of like the current active user's window into the nested data fields?



If I were currently signed in as a some user, the `accounts` field would take my session and authorization into account, on the back-end, and only provide me with the items I should be able to access, or any other properties that may change based on who I am?

How would this system work without the requirement of a user being signed in, but having the ability to create an account and sign in? With the `accounts` connection being under the `viewer`, it's not possible to mutate `accounts` and so there's a chicken/egg problem there.

I'm trying to figure out how to embrace this design, and also build a user auth system entirely on top of GraphQL / Relay.
",ryancole,yungsters
112,2015-12-31 06:40:59,"@ryancole You have the description of `viewer` correct. For example, at Facebook, `viewer` contains a `news_feed` connection field that is always the current viewer's news feed. Another notable field that `viewer` has is the `actor` field which allows querying the current user's information.

As far as I know, our internal GraphQL endpoint was not originally designed for usage without authentication. However, the data model backing `viewer` _does_ support the notion of an ""unauthenticated user"". More recently, we've augmented the GraphQL endpoint to support fetching fields for unauthenticated users, but off the top of my head, I do not know what is and is not accessible.

What I imagine to be common with most applications that deal with authentication (and which is certainly true for Facebook) is for the entire client store to be reset when authenticating as a user. This is useful for a variety of reasons including isolation of concerns (e.g. modules that can assume there is a logged in user vs. those that do not make this assumption) as well as privacy and security (i.e. the simplest way to ensure that there is no cross-contamination or leaking of a user's private information is to start with a clean slate).

For example, most of the Facebook mobile apps built using React Native and Relay implement authentication without Relay, but — upon obtaining an access token — switch to relying on Relay for all user client data management.

This would certainly complicate things in a system where a user can authenticate using multiple accounts (e.g. something like an operating system such as Windows or OS X where a user can be logged in as multiple user simultaneously). But if you do not need this degree of control, I would try to keep things simple. Hope this makes sense / helps!
",yungsters,ryancole
112,2016-01-11 20:38:36,"@dschafer thanks for sharing! :+1: 
",emmenko,dschafer
112,2016-02-05 16:28:13,"The ability to have nesting in root queries per @ForbesLindesay's [comment](https://github.com/facebook/relay/issues/112#issuecomment-166937271) would be great. Would make composition and refactoring easier. 

>  There's no technical reason we couldn't allow nesting in the root query. — @josephsavona 

Really? Doesn't there have to be at most one leaf in a root query? Otherwise, how would Relay know at which leaf to anchor fragments?
",dminkovsky,josephsavona
112,2016-04-11 12:53:22,"@steveluscher do you know when this will ship? 
",mattecapu,steveluscher
112,2016-04-11 14:14:54,"@mattecapu We aren't actively working on this. I'd recommend checking out @dschafer's [comment](https://github.com/facebook/relay/issues/112#issuecomment-170648934) for a good workaround. 
",josephsavona,dschafer
112,2016-04-11 14:34:52,"@josephsavona thank you, can I know why this isn't a priority? I was pretty baffled to discover Relay isn't capable yet to do this kind of things as they seem very natural.
As of @dschafer's comment, it looks like a workaround for the multiple-parameters issue, while I need to fetch an array



But I get

> RelayOSSNodeInterface: Expected payload for root field `comp1s` to be a single non-array result, instead received an array with 1 results.

And I'm not really grasping the `viewer` workaround.
",mattecapu,josephsavona
112,2016-04-11 14:34:52,"@josephsavona thank you, can I know why this isn't a priority? I was pretty baffled to discover Relay isn't capable yet to do this kind of things as they seem very natural.
As of @dschafer's comment, it looks like a workaround for the multiple-parameters issue, while I need to fetch an array



But I get

> RelayOSSNodeInterface: Expected payload for root field `comp1s` to be a single non-array result, instead received an array with 1 results.

And I'm not really grasping the `viewer` workaround.
",mattecapu,dschafer
112,2016-04-11 16:30:15,"FWIW, since the workaround is so simple (add a ""viewer""-esque field on your
root query), I'm pretty OK that the Relay team is focusing on other stuff 😁

On Mon, Apr 11, 2016, 10:35 AM Matteo Capucci notifications@github.com
wrote:

> @josephsavona https://github.com/josephsavona thank you, can I know why
> this isn't a priority? I was pretty baffled to discover Relay isn't capable
> yet to do this kind of things as they seem very natural.
> 
> —
> You are receiving this because you commented.
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/112#issuecomment-208376966
",NevilleS,josephsavona
112,2016-04-11 17:02:30,"@NevilleS the issue is that this thread is perhaps the only documentation of this ""feature"", so it's a bit disappointing to dive into Relay and then stumble upon this obstacle. Moreover the `viewer` design pattern is not explained anywhere (at least I can't find an explanation, I'll be happy to be wrong on this!) and as a beginner I scratched my head looking at the example and thinking ""Why this?"".
In fact I'd be happy to understand how to work around this for now.

@wincent I may sound pedant/unrespectful but actually I'm a great fan of the whole React/Relay/GraphQL thing and I understand the last two are still a pretty novel technology so it's fair to have some issues! I want you (and the rest of the team) to know I really appreciate your work and effort in doing this! OSS is hard and you're doing fine anyway :smile: 
The question was more a matter of understanding, because the queries I wrote seemed straightforward to me and clashing with this issue made me wonder if I really understood how Relay is supposed to work or I'm missing something.
",mattecapu,wincent
112,2016-04-11 17:02:30,"@NevilleS the issue is that this thread is perhaps the only documentation of this ""feature"", so it's a bit disappointing to dive into Relay and then stumble upon this obstacle. Moreover the `viewer` design pattern is not explained anywhere (at least I can't find an explanation, I'll be happy to be wrong on this!) and as a beginner I scratched my head looking at the example and thinking ""Why this?"".
In fact I'd be happy to understand how to work around this for now.

@wincent I may sound pedant/unrespectful but actually I'm a great fan of the whole React/Relay/GraphQL thing and I understand the last two are still a pretty novel technology so it's fair to have some issues! I want you (and the rest of the team) to know I really appreciate your work and effort in doing this! OSS is hard and you're doing fine anyway :smile: 
The question was more a matter of understanding, because the queries I wrote seemed straightforward to me and clashing with this issue made me wonder if I really understood how Relay is supposed to work or I'm missing something.
",mattecapu,NevilleS
112,2016-04-12 07:07:16,"Okay building on @dschafer's solution I managed to work around this. For now is just an ad-hock hack but I hope to encapsulate this logic in a general-purpose wrapper.

I edited the code above in the following way:





My `react-router` routes



Hope to help someone with this
",mattecapu,dschafer
112,2016-05-05 07:32:18,"@josephsavona I apologize for vague description what I had in mind. Example should clear it up.



This is the on demand scenario when I want to get metadata for formats using `setVariables`. My use case is that I have some general informations for all formats (from initial 'static' query) but need to get some extra informations on demand on different places in the app and wanted to reduce over-fetching. So I know the ids for formats and want to get extra fields on-demand for few of them.

But afaik it is not possible to tell Relay that I am gonna use list of actual graphQL ids. Therefore it re-fetches format for any new combination of ids.

So lets say at first I would do:
1) `setVariables({formatIds: [id1, id2]})`, relay fetches formats id1 and id2 with all required fields in this fragment instead of just missing fields.
2) `setVariables({formatIds: [id3, id2]})`, relay fetches formats with id3 and id2 instead of just missing fields for id3

`node` field is the closest thing, but I can't use it for list of ids and use it in component fragment to get data from container.  
",jardakotesovec,josephsavona
112,2016-05-05 17:54:10,"aahh @jardakotesovec have you seen the `@relay(plural: true)` option yet? That would allow you to ask for multiple ids and return you all these elements.
",Globegitter,jardakotesovec
112,2016-05-07 14:49:24,"@josephsavona

> Note that this method will write the results of the query into the cache, and all affected components will re-render if necessary (i.e. you don't need to call setState or anything in the callback above).

I actually tried that, I built a query to fetch some additional fields on a node and sent it to the node interface.
The query built by Relay looks correct (only the missing fields are asked), but the result is never merged into the cache.
The only way I found to get the updated data is `Relay.Store.readQuery(query)[0];`
Any idea what I'm doing wrong ?
",kamek-pf,josephsavona
112,2016-05-09 06:40:57,"@josephsavona I am aware of the _plural identifying root field_, but I have two issues there
- I need this field `formats` it on different places in the app inside components and I don't see how I could use them inside fragment, since its root field
- And yes it allows to link keys with objects, but it does not know that its actual graphQL id, therefore if I get all formats (with some basic fields) at the beginning and want to get extra fields using root identyfing fields, it fetches all fields and creates additional mapping between id and object. This issue was mentioned [here](https://github.com/facebook/relay/issues/457).
",jardakotesovec,josephsavona
110,2015-08-19 07:45:07,"Great, thanks @josephsavona!
",fson,josephsavona
108,2015-08-18 16:09:51,"As @devknoll explained, the easiest thing would be to have a ""viewer""-like object for now. For context, root fields are expected to conform to the Object Identification spec which allows Relay to create a mapping from `root field name + argument => node ID`. For example:
- `node(id: 123)`
  - Response: `{id: 123, ...}`
  - We know that `node` with `id` of `123` maps to the node with ID of 123.
- `user(usernames: [yungsters, en_js])`
  - Response: `[{id: 456, ...}, {id: 789, ...}]`
  - We know that `user` with `username` of `yungsters` maps to the node with ID of 456.
  - We know that `user` with `username` of `en_js` maps to the node with ID of 789.

We want to change some assumptions made to be able to enable querying arbitrary fields from the root (e.g. a connection), but for now it isn't super smooth.
",yungsters,devknoll
107,2015-08-18 17:35:08,"The problem you're running into is the same one that several others have been filing issues about. Basically, fields on the root are treated specially and assumed to either:
- Map to a single node (e.g. `node(id: 123)`, `me`), or...
- Map to an array of nodes (e.g. `nodes(ids: [123, 456])`).

Your `users` field does not have any arguments, so it is assumed to respond with a single record. For now, if you create a root object (e.g. `viewer`) and add a `users` field on it, this should work. However, @yuzhi also brought up the point that you might actually want `users` to be a connection instead of a plural field. (If you ever have hundreds of users, you might want to paginate instead of getting them all back.)

I'll write up a more comprehensive issue to explain what the problem is, why it exists, current workarounds, and future plans.
",yungsters,yuzhi
106,2015-08-19 01:15:15,"@josephsavona speaking of routing, is there more detailed example on how relay works with multiple routings and view-switching? As far as I can see currently all examples are single-routed, thanks.
",coodoo,josephsavona
106,2015-08-24 16:53:25,"@josephsavona No, as I  reported #135, I would post a more explained-through there
You can close this issue if you guys think the issue about client side data managing is well under tracked.
I have gotten the route working. So I get the answer with my original question
",transedward,josephsavona
104,2015-08-18 17:29:35,"@devknoll Nope, `getRelayQueries` is the only caller of `buildRQL.Query`.
",yungsters,devknoll
103,2015-08-18 06:55:15,"Community: 1
@cpojer: 0
",yungsters,cpojer
100,2015-08-18 17:12:39,"Thanks for the explanation @josephsavona!

A quick follow up question: I changed this to a variable like this:



Now I'm getting an error on the server: `Argument ""orderBy"" expected type ""ReindexOrderBy"" but got: {field: ""name"", order: ""ASC""}`. (That is, the schema expects an enum `ASC` but Relay printed it as a string.)
Is `printRelayQuery` not printing enums inside input objects a known bug or should I open a separate issue about that?
",fson,josephsavona
100,2015-08-18 18:11:34,"@josephsavona I noticed the enum values sent separately in the request body using the `variables` property would already work. When does Relay send variables separately and when does it bake them in the query string?

I wonder if I could somehow force them to be sent separately and use this to work around the fact that enums can't be printed. If not, I'll just try to avoid enums in input objects for now.
",fson,josephsavona
100,2015-08-19 16:40:38,"Thanks for the explanation @josephsavona. That makes sense.

Just making sure I understood the proposed solution for supporting enums within object values, if we were to implement that the fragments and variables sent to the server would be something like this?



variables (with generated unique names):


",fson,josephsavona
100,2015-08-21 17:05:34,"@josephsavona Looks good so far!

Noticed `printRelayQuery` is in `__forks__`. What is the ""canonical"" repo for it?
",fson,josephsavona
99,2015-08-18 22:39:11,"@taion Found this too: https://facebook.github.io/relay/docs/api-reference-relay-mutation.html#getfragment-static-method so I guess that makes it official? :wink: 
",devknoll,taion
98,2015-08-19 16:36:50,"@liesislukas thanks for the contribution! please see our feedback so we can merge.
",josephsavona,liesislukas
98,2015-08-28 16:39:42,"Ping @liesislukas; we'd love to get this in. Do you have time to update the PR with @josephsavona's comments?
",steveluscher,josephsavona
98,2015-08-28 16:39:42,"Ping @liesislukas; we'd love to get this in. Do you have time to update the PR with @josephsavona's comments?
",steveluscher,liesislukas
98,2015-09-01 19:50:47,"@liesislukas, I've added another commit on top of this one [here](https://github.com/facebook/relay/pull/209) to address the issues raised, so I am going to close out this pull request.

Thanks for your contribution!

[Edit: actually added the link.]
",wincent,liesislukas
97,2015-08-21 18:05:43,"@jardakotesovec Sorry for missing this: yes, `${Child.getFragment(..).if(variables.foo)}` is supported. Be sure to check the value of `variables.showPopup` in your render code and skip rendering `<SongList>` when it's false, otherwise you'll get errors about missing data.
",josephsavona,jardakotesovec
97,2015-08-27 17:48:38,"@jardakotesovec did that solution work for you? I'm going to close this issue since the question is answered, but feel free to reopen if you have any additional questions!
",josephsavona,jardakotesovec
95,2015-08-27 17:47:37,"I'm closing this due to the synchronous limitation and because @steveluscher is tracking `babel-relay-plugin` updates at relayjs/relay-starter-kit#13.
",josephsavona,steveluscher
94,2015-08-18 14:58:57,"@devknoll this might be a bit hacky, but have you tried getting that root query to take in a string and JSON.stringify the two variables? 

@jardakotesovec  Correct, connections can not be root fields at the moment. As @josephsavona  mentioned, we might be able to remove these limitations
",yuzhi,jardakotesovec
94,2015-08-18 14:58:57,"@devknoll this might be a bit hacky, but have you tried getting that root query to take in a string and JSON.stringify the two variables? 

@jardakotesovec  Correct, connections can not be root fields at the moment. As @josephsavona  mentioned, we might be able to remove these limitations
",yuzhi,josephsavona
94,2015-08-18 14:58:57,"@devknoll this might be a bit hacky, but have you tried getting that root query to take in a string and JSON.stringify the two variables? 

@jardakotesovec  Correct, connections can not be root fields at the moment. As @josephsavona  mentioned, we might be able to remove these limitations
",yuzhi,devknoll
94,2015-08-18 15:03:04,"@yuzhi So, I think in my own case, I might just change my urls to be less hierarchical (they are getting ridiculous as is...). 

But lots of folks do use hierarchical urls, so it seems like a restriction worth removing, if possible.
",devknoll,yuzhi
92,2015-08-18 17:17:20,"@yungsters no it doesn't, give me a minute :smile: 
",devknoll,yungsters
92,2015-08-18 17:19:13,"Sorry, noticed a typo. Should be good now @yungsters :smile: 
",devknoll,yungsters
91,2016-09-03 00:47:51,"Going to close this as [Relay 2](https://speakerdeck.com/wincent/relay-2-simpler-faster-more-predictable) will have support for arbitrary ""handle"" fields, for which you can register a handler in a way similar to what @steveluscher has suggested. As we're unlikely to undertake the work required to implement something like that on Relay 1, I'm going to mark this one as closed for now.

Thanks to everybody for their input!
",wincent,steveluscher
90,2015-08-17 18:12:11,"@josephsavona We can just deal with the new syntax internally. The eventual plan is to move to the new syntax anyway, so we might as well get everyone used to it. :)
",yungsters,josephsavona
89,2015-08-18 06:23:33,"@dschafer: Good idea! Just naming a scalar type Cursor and having it to work similar to ID (so implementation details up to server, serializes as string) would be enough for us.
",freiksenet,dschafer
89,2015-08-18 16:08:56,"@yungsters Currently the spec says you must return either a String or a Non‐Null wrapper around a String, so a scalar `Cursor` type is not allowed. I think changing the type from `String` to `Cursor` as @dschafer hinted would also make sense from the user point of view, as it would make it clear that a valid cursor is expected and not just any string.
",fson,yungsters
89,2015-08-18 16:08:56,"@yungsters Currently the spec says you must return either a String or a Non‐Null wrapper around a String, so a scalar `Cursor` type is not allowed. I think changing the type from `String` to `Cursor` as @dschafer hinted would also make sense from the user point of view, as it would make it clear that a valid cursor is expected and not just any string.
",fson,dschafer
78,2015-08-15 06:48:47,"Thanks, @bbirand!
",wincent,bbirand
77,2015-08-15 22:52:25,"@fson You're right, I haven't played with GraphQL before so I wasn't sure what to expect from that. Saying so, that sounds like a weird error to throw back when an empty query is passed to it, don't you think?
",OmgImAlexis,fson
75,2015-08-15 01:00:33,"Building on @yungsters's comment - supporting type-specific IDs is less trivial than it might seem at first glance and introduces complexity and maintenance cost to the framework. It's more than a matter of adding a `type` field to the `node` call. Relay would have to fetch and track the type of _every_ record in the system and use this information everywhere it constructs queries (which is obviously often). 

Given that it is trivial for the server to encode/decode a global ID to/from type + ID, it is not clear that the cost of implementation and maintenance is justified. We'd be curious to hear feedback from you and the community about this.
",josephsavona,yungsters
71,2016-12-15 07:43:27,@fson what if we're trying to use Relay with an external source? For instance I want to work with the Github GraphQL API but `updateSchema.js` keeps overriding my attempts to fetch remote data.,trentontri,fson
67,2015-08-14 15:04:04,"@steveluscher Just curious -- how did you test the IntroduceShip mutation? I feel like the UI for that is missing...
",cletusw,steveluscher
63,2015-08-14 00:56:02,"Wait... @josephsavona 



Wouldn't this only let the composed fragments compose on `Node`? If `ContainerB` wanted a `User` instead, he wouldn't be able to fragment on that, right?
",devknoll,josephsavona
63,2015-08-14 01:01:21,"@devknoll With the Relay GraphQL spec most types will implement the `Node` interface, so this would be okay. In your example if `RouteA` matched, you'd end up with the following (valid) GraphQL:


",josephsavona,devknoll
63,2015-09-09 07:19:30,"@josephsavona unfortunately it doesn't help in following situations:
1. Trully dynamic components when parent is not aware of all possible children (like Relay.RootContainer)
2. Code splitting - when actual child component is loaded on demand and you don't have reference to it's container at static time

Would be great if Relay could provide some solution for these cases as well as they are fairly common.
",vladar,josephsavona
60,2015-08-13 17:03:30,"@jaredly awesome - can you add a link to the code for that screenshot? Those are internal modules and the API is likely to change.
",josephsavona,jaredly
59,2015-08-13 19:46:17,"good question, @danielgriese, and great answer @fson!

I'm closing this out because the answer is quite thorough, but I've added a link to it here: https://github.com/facebook/relay/wiki/Frequently-Asked-Questions

Feel free to reopen if you have follow-up questions.
",josephsavona,fson
59,2015-08-14 06:58:00,"Thanks for your reply @fson!
We should note that the babel-node call in the updateSchema script needs to be extended to allow for spread operators. Took me a while to get it to run, I'm just using ""--stage 1"" now.

The proposed solution works fine, if I set the widgetName with a value in the initialVariables of my Container. 
But when I hook it up to an input field, dynamically setting the variable value via this.props.relay.setVariables I get 400 - Bad Request errors from the server.

Query being sent by Relay:



Return the following error:
""Cannot query field ""widgets"" on ""Node"".""

I guess the problem lies in the details of the starter-kit-example. Probably it is resolving the ID to a Node instead to a User. I'll try to investigate it a bit further.

Thanks and kind regards,
Daniel
",danielgriese,fson
58,2015-08-13 19:22:58,"@wincent Agreed about disabling `shadow` warnings.
",josephsavona,wincent
58,2015-08-13 20:02:44,"@wincent @josephsavona cool I'll disable it and fix the issues. I copied react's one just to start this off, thought that you might have some kind of guidelines at Facebook. Any other suggestions?

what do you think about `no-unused-expressions`?
at the moment there is a lot of places where we do something if the expression is `true`, e.g.:
in src/container/RelayContainer.js (256):



with `no-unused-expressions` it would need to look like:



not sure which one do you prefer?

---

also not sure why the tests are failing on travis, seems like some issue while installing from npm
",knowbody,wincent
58,2015-08-13 20:02:44,"@wincent @josephsavona cool I'll disable it and fix the issues. I copied react's one just to start this off, thought that you might have some kind of guidelines at Facebook. Any other suggestions?

what do you think about `no-unused-expressions`?
at the moment there is a lot of places where we do something if the expression is `true`, e.g.:
in src/container/RelayContainer.js (256):



with `no-unused-expressions` it would need to look like:



not sure which one do you prefer?

---

also not sure why the tests are failing on travis, seems like some issue while installing from npm
",knowbody,josephsavona
58,2015-08-14 07:49:48,"@josephsavona ok, I'll do that and update the PR. @zpao I think for now let's just add the basic ESlint rules and make sure they pass, and then we can add the ones which we see there is a need for?
",knowbody,josephsavona
58,2015-08-14 07:49:48,"@josephsavona ok, I'll do that and update the PR. @zpao I think for now let's just add the basic ESlint rules and make sure they pass, and then we can add the ones which we see there is a need for?
",knowbody,zpao
58,2015-08-14 11:41:11,"@josephsavona updated the code, let me know what you think.  

travis is still failing while trying to run `npm install`

**Edit:**
was just looking at [your style guide](https://github.com/facebook/relay/blob/master/CONTRIBUTING.md#style-guide) and you have included trailing commas, so in that case the [style guide](https://github.com/facebook/relay/blob/master/CONTRIBUTING.md#style-guide) should be updated or leave the `comma-dangle` in ESlint rules
",knowbody,josephsavona
58,2015-08-15 00:38:36,"@knowbody I'm sorry if my previous comment wasn't clear. The addition of ESLint here should require no changes whatsoever to the `src/` directory. This will ensure that future syncs between OSS and our internal repository can proceed smoothly. Let's disable the `comma-dangle` rule (also it appears some variables were renamed - leftover fixes from `no-shadow`, maybe?

Regarding style: we do prefer trailing commas, but this is the one preference for which we don't also have an internal lint rule (and so there are some inconsistencies in the existing code).
",josephsavona,knowbody
58,2015-08-16 18:50:39,"@zpao thanks for the hints :+1: 

@josephsavona check it now please. I think I fixed all you asked for
",knowbody,josephsavona
58,2015-08-16 18:50:39,"@zpao thanks for the hints :+1: 

@josephsavona check it now please. I think I fixed all you asked for
",knowbody,zpao
58,2015-08-21 11:56:58,"@josephsavona @wincent is anything blocking this to be merged?
",knowbody,wincent
58,2015-08-21 11:56:58,"@josephsavona @wincent is anything blocking this to be merged?
",knowbody,josephsavona
58,2015-08-24 21:08:18,"@knowbody See comments above. Again, we _sincerely_ appreciate all the effort you've put into this, but to simplify syncing code for now the configuration should consider the code valid as-is, and there should be no changes to the `src/` directory.
",josephsavona,knowbody
58,2015-08-24 22:51:25,"@josephsavona sure, sorry fixing all that now
",knowbody,josephsavona
58,2015-08-24 23:22:09,"@josephsavona should be good to go now
",knowbody,josephsavona
58,2015-09-01 07:51:14,"@zpao just seen the merge you've done with react. agree, let's close and I start the new PR with the rules from fbjs repo. How does it sound? @josephsavona 
",knowbody,josephsavona
58,2015-09-01 07:51:14,"@zpao just seen the merge you've done with react. agree, let's close and I start the new PR with the rules from fbjs repo. How does it sound? @josephsavona 
",knowbody,zpao
55,2015-08-13 15:37:29,"@knowbody Jest not working on node 0.12.x is a known issue (see https://github.com/facebook/jest/issues/243). For me the tests started working after installing node 0.10 and running `npm rebuild`.

From #10 it seems that as soon as Jest 0.5.0 stable version gets released, this project can move to iojs and the old version of node is no longer needed.
",fson,knowbody
55,2015-08-13 15:49:04,"oh, make sense now, thanks @fson!
",knowbody,fson
55,2015-08-13 15:57:50,"@knowbody I think that's a good idea. There's a warning from `npm install` if you're running an unsupported version, but it's pretty easy to miss.
",fson,knowbody
55,2015-08-13 16:07:33,"@knowbody I installed v0.10.40, which is the latest 0.10.x release and it worked with that.
",fson,knowbody
55,2015-08-14 07:01:27,"@knowbody Try double checking your `npm --version`. I know whenever I re-install 0.10.x, the `npm` I get is archaic (v1.x.x).
",yungsters,knowbody
55,2015-08-14 15:11:26,"@yungsters I don't know actually what happened but tried to `npm install` yesterday again and it worked with node 0.10.40 and npm 1.4.28.

I just think we should add clear instructions as it's important to run those tests locally and I'm guessing most of ppl use 0.12.7.

any ETA on when Jest 0.5.0 stable will be released?
",knowbody,yungsters
54,2015-08-14 04:53:07,"@wincent I think we still have this in React but we should probably remove it there too. Unfortunately that field is checked on end users. Ideally we could just check it on developers machines (actually, we probably could write a simple prepublish hook…).

It's not an enforced dependency and with iojs shuffling along it might be time to give it up.
",zpao,wincent
51,2015-08-13 17:52:09,"> Or is it as simple as Relay is not made with this kind of data flow in mind?

It's definitely within scope. As @devknoll mentioned, we are actively discussing what subscriptions should look like in open source GraphQL. Internally, we already have prototypes that work with Relay, but they depend on bits of internal infra. We need to figure out how best to tackle this in open source, and websockets may be part of the solution.
",wincent,devknoll
50,2015-08-13 17:05:13,"@sairion thanks!
",josephsavona,sairion
40,2015-08-13 23:35:32,"Great! Thanks @josephsavona @steveluscher 
",syrusakbary,josephsavona
40,2015-08-13 23:35:32,"Great! Thanks @josephsavona @steveluscher 
",syrusakbary,steveluscher
36,2015-08-13 06:38:40,"@voideanvalue But how do you set proper HTTP response code in the ""preload"" case? For example, user asked for missing resource and you should send 404, but you've sent 200 in the initial response because you haven't fetched your data yet. 
",th0r,voideanvalue
36,2015-08-13 11:41:08,"@voideanvalue Thanks for the thorough response, really appreciated!

> I'll try to write an example when I find some free time.

That would be fantastic!
",stevoland,voideanvalue
36,2015-08-17 16:41:06,"@davide-ganito as @voideanvalue mentioned, Relay supports server rendering but:

>  the hooks aren't exposed currently and it is undocumented at this point. We do plan to expose and document [them] in the near future. 
",josephsavona,voideanvalue
32,2015-08-13 09:15:33,"@freiksenet Right, In that case I apparently don't understand correctly what is the actual issue you reported. 

> mentioned that using cursors when, eg, ordering changes is not guaranteed to be correct. 

I thought that you are referring of changing connection argument (orderby) is causing the problem with cursors. Maybe if you could give me example with bit more context.

Thanks!
",jardakotesovec,freiksenet
32,2015-08-13 12:59:06,"Quoting @yuzhi from slack

> You can have something like `connectionName(orderby: 'foo', first: 10)`, Relay will keep it > separate from `connectionName(first:10)`, and do it's best to keep the ordering we got from the server.

@freiksenet So as you also mentioned - Relay use new cursors with new arguments for connection.

I understand @dschafer example - when cursors on server changes for some reason (cache expires, data changes by different client, ...) it makes sense to inform client that existing cursors are invalid. 

But still don't understand why changing connection arguments on client would cause the problem as Relay should keep separate cursors automatically.

Hope I am not causing more confusion.. but its important for me to understand what limitations are potentially there. Thanks!
",jardakotesovec,freiksenet
32,2015-08-13 12:59:06,"Quoting @yuzhi from slack

> You can have something like `connectionName(orderby: 'foo', first: 10)`, Relay will keep it > separate from `connectionName(first:10)`, and do it's best to keep the ordering we got from the server.

@freiksenet So as you also mentioned - Relay use new cursors with new arguments for connection.

I understand @dschafer example - when cursors on server changes for some reason (cache expires, data changes by different client, ...) it makes sense to inform client that existing cursors are invalid. 

But still don't understand why changing connection arguments on client would cause the problem as Relay should keep separate cursors automatically.

Hope I am not causing more confusion.. but its important for me to understand what limitations are potentially there. Thanks!
",jardakotesovec,dschafer
26,2015-08-17 07:30:38,"@josephsavona even if relay components aren't inheriting react-native's Component?

https://github.com/facebook/relay/blob/master/src/container/RelayContainer.js#L23

I'm getting `Can't find variable: document` in getActiveElement
",amccloud,josephsavona
26,2015-08-25 21:54:39,"@josephsavona Relay cannot work as-is with React Native because Relay includes React web as a hard dependency, and including React web into React Native is not functional.

Here's a commit that shows the minimal changes to build relay against react-native:
https://github.com/facebook/relay/commit/e0037c78931edc3286e5217894348ca8ece1225b

The 'dist' step of building relay still fails with that commit, with the error:
![image](https://cloud.githubusercontent.com/assets/699550/9480445/21f4eb66-4b51-11e5-8ceb-e89682a80416.png)

I'm not sure exactly why that's failing.

The last two things we had to do to get relay working with react native was:
- Commit relay's `/lib` directory since building `dist` failed (above)
- stub `process.env` before including Relay in the react-native application, since `process` doesn't exist in react-native's JS environment.  This is only necessary until the `dist` step of compilation works, since dist will remove all `process.env` references. I made a pseudo-module called 'relay',, which is a bit silly but functional:


",boourns,josephsavona
26,2015-08-29 22:16:15,"@josephsavona can we re-open this?
",amccloud,josephsavona
26,2015-09-27 18:45:45,"> why is Relay pulling in Promise from fbjs?

@taion We're using some not-sure-why-they-aren't-standard Promise methods like `done`
",josephsavona,taion
26,2015-10-07 14:11:01,"@chandu0101 maybe the version of react-native in your app is 0.12?
",almascript,chandu0101
26,2015-10-07 14:49:41,"> @chandu0101 maybe the version of react-native in your app is 0.12? 

hmm no , btw why my version matters here i am using u r node_modules lib folder ..(btw  i am new to this js build tools/systems) 
",chandu0101,chandu0101
26,2015-10-07 15:03:19,"@chandu0101 In you app you require 'react-native' and 'relay'. I suppose the version of react-native, that you require and the version of react-native in relay should be the same. Not sure about your error, maybe try adding polyfill as suggested by @boourns 
",almascript,chandu0101
26,2015-10-07 15:07:32,"@chandu0101 Well done!
",almascript,chandu0101
26,2015-10-26 09:52:48,"@skevy do you have a ready-to-use fork somewhere?
",gre,skevy
26,2015-11-18 15:56:14,"@skevy - understood, and thanks for the clarification.
",jeromecovington,skevy
26,2015-11-20 11:55:54,"For me the workaround provided by @skevy works well with RN 0.13.0 and Relay 0.4.0.
",l-urence,skevy
26,2015-11-20 14:25:10,"I opened a repo with `react-native init` equivalent project, with relay support, based on @skevy work. https://github.com/lenaten/react-native-relay.
",lenaten,skevy
26,2015-11-20 15:08:55,"Thanks @skevy , @lenaten and @l-urence !
",shishircc,skevy
26,2015-12-15 17:13:28,":+1: 

@skevy Great job! can we use your packages directly ? (maybe in npmjs.org)
",filod,skevy
26,2015-12-15 20:02:35,"I've set up a private npm and I've published three packages based on @skevy's branches, but since the packages are scoped to my organization (`@org/fbjs`, `@org/react-relay`, `@org/react-native`) I'm having a hard time with `require` as I have to do `require(""@org/fbjs"")` instead of `require(""fbjs"")`.

I'm new to the whole private npm world, so I'm probably doing something wrong.

Any hints to how I can avoid this?
",theodorton,skevy
26,2015-12-16 07:41:11,"@skevy 

~~hi, as you suggest, i setup my own sinopia, and publish the package.~~

~~but now, i can not even start **an empty app**, i got this error:~~



~~any hint on this ?~~

---

sorry ， seems forgot to `AppRegistry.registerComponent` will cause this. now i can use relay, thanks again !
",filod,skevy
26,2015-12-16 23:08:09,"@skevy Thank you so much, I managed to get your fork's working using Sinopia and the list @lenaten mentions here https://github.com/facebook/relay/issues/26#issuecomment-159192009
",mpretty-cyro,skevy
26,2016-01-04 19:05:16,"@skevy Thank you so much. Would be great if you could post here once it all has been merged and released.
",BerndWessels,skevy
26,2016-01-31 12:05:37,"@lenaten @skevy Have you tried using decorators with patched react-native, relay. I couldn't use it even after whitelisting es7.decorators in .babel.json.
",shahankit,skevy
26,2016-02-11 19:08:51,"either way this issue should be reopened as the bot closed it prematurely /cc @josephsavona 
",boourns,josephsavona
26,2016-02-12 16:19:31,"thanks @josephsavona!
",boourns,josephsavona
26,2016-02-12 18:42:18,"@BerndWessels Quite the contrary. There's a lot of momentum from the ""official"" side. As @josephsavona has just said, there's only one issue left. There were a lot of PRs and a lot of back and forth that went into this. It was a substantial effort with lots of work put in both officially, and unofficially.
",pthrasher,josephsavona
26,2016-02-14 19:24:41,"@pthrasher @steveluscher @josephsavona thanks for all your effort.
Sometimes it is hard to see what is going on behind the scenes just from following the Git Issues.
I believe Relay is the way to go and being able to use it in web and mobile will clean up my code base a lot.
Looking forward to it.
",BerndWessels,steveluscher
26,2016-02-14 19:24:41,"@pthrasher @steveluscher @josephsavona thanks for all your effort.
Sometimes it is hard to see what is going on behind the scenes just from following the Git Issues.
I believe Relay is the way to go and being able to use it in web and mobile will clean up my code base a lot.
Looking forward to it.
",BerndWessels,josephsavona
26,2016-02-19 15:37:32,"@skevy are we just waiting on these two PRs ?

https://github.com/facebook/react-native/pull/5084
https://github.com/facebook/relay/pull/714

Looks like the others are closed or merged.
",geekgonecrazy,skevy
26,2016-03-01 15:22:38,"a zoo of fbjs versions for current `npm` releases. @josephsavona 
<img width=""177"" alt=""screen shot 2016-03-01 at 16 20 54"" src=""https://cloud.githubusercontent.com/assets/1857263/13431443/b6193600-dfc9-11e5-9aa2-2f8d572e913e.png"">
",eugenehp,josephsavona
26,2016-03-05 08:35:24,"@skevy awesome job getting everything up and running.

I've just tried pulling the latest code from RN master, installed react-relay 0.7.3 and setup the .babelrc as per https://github.com/facebook/relay/pull/714 but I still seem to be running in to issues (see screenshot), not sure if I'm missing a step that I couldn't see in the thread. Any thoughts? (was hoping to be able to try converting from redux to relay this weekend).

![untitled](https://cloud.githubusercontent.com/assets/15862619/13546669/4066bf7a-e309-11e5-88ee-02af17394fed.png)
",mpretty-cyro,skevy
26,2016-03-06 00:40:15,"@steveluscher I actually managed to get it running and yea that's pretty much what I had to do (I re-applied the blacklist changes from here https://github.com/facebook/react-native/commit/ad8a33586410c6f9048983f64f8f86e0715e73b8 also removing the fbjs/Map one which seems to be what that commit does). I also had to remove the 'Libraries/vendor/core/isEmpty.js' and 'Libraries/vendor/core/Map.js' files then it started working (though not sure if this is needed).

Must have pulled the latest changes to master just before that commit came through.

cc @l-urence
",mpretty-cyro,steveluscher
26,2016-03-06 18:10:08,"@steveluscher have you tried running RN + Relay with  chrome debugging enabled? I get ""Unexpected end of input"". With debugging disabled or the Relay specific code commented out all works fine. Are you running Relay form npm or latest from github?
",l-urence,steveluscher
26,2016-03-06 23:40:32,"@steveluscher Thx! It works with a custom network layer using XMLHttpRequest. 
",l-urence,steveluscher
26,2016-03-07 11:33:04,"@steveluscher Just wanted to let you know I pulled the latest from master and re-installed the modules and it now works without any changes.

Also, for anyone who is interested, https://github.com/relay-tools/relay-local-schema will work if you make a few minor changes to graphql-relay to support react-native (give me a yell if anyone wants the changes required).
",mpretty-cyro,steveluscher
26,2016-03-08 23:28:55,"@taion, I was merely trying to properly document the above steps more clearly, since there were some discrepancies as to how the .babelrc file should be written. With that said, my comments above due constitute as issue-related. ;)
",jefferyvincent,taion
26,2016-03-09 23:44:30,"I just checked out a fresh copy of Relay from master, and did the following:



A wild React Native and Relay app appeared.

Countless thanks to @skevy, @boourns, @gre, @davidaurelio, @martinbigio, @zpao, @spicyj, and everyone on this thread who helped us tear down the barriers to using Relay with React Native in the open source community. I can't wait to field all of your React Native specific GitHub issues.

We're done here. Open new issues at https://github.com/facebook/relay/issues or https://github.com/facebook/react-native/issues as you discover them!
",steveluscher,skevy
26,2016-03-09 23:44:30,"I just checked out a fresh copy of Relay from master, and did the following:



A wild React Native and Relay app appeared.

Countless thanks to @skevy, @boourns, @gre, @davidaurelio, @martinbigio, @zpao, @spicyj, and everyone on this thread who helped us tear down the barriers to using Relay with React Native in the open source community. I can't wait to field all of your React Native specific GitHub issues.

We're done here. Open new issues at https://github.com/facebook/relay/issues or https://github.com/facebook/react-native/issues as you discover them!
",steveluscher,zpao
26,2016-03-10 02:00:02,"Awesome work @steveluscher!
",martinbigio,steveluscher
26,2016-03-10 11:17:20,"@steveluscher awesome work!
",davidaurelio,steveluscher
26,2016-03-10 12:13:35,"@steveluscher :+1: 
",eugenehp,steveluscher
26,2016-03-11 05:04:46,"@steveluscher Great ![](https://assets-cdn.github.com/images/icons/emoji/unicode/1f389.png)
",gmochid,steveluscher
20,2015-08-13 03:26:07,"@yungsters What's the ideal behavior? Would it be sufficient to just find the `route.queries` that includes a particular fragment and keep everything else the same?
",devknoll,yungsters
20,2015-08-13 03:31:23,"@devknoll Yes, I think that is the ideal behavior. Unfortunately, there is no good way of figuring out which queries in `route.queries` includes `X` when all we have to work with is `${Component.getFragment(X)}`.
",yungsters,devknoll
20,2015-08-13 17:26:06,"> What if we got rid of ${Component.getFragment(X)} all together and made it clearer that the query name must match your component's fragment name?

Yes. We should do that, and also implement @devknoll's idea - root component fragments are automatically added whenever the route key matches the component key, and it's a warning/error if either one has a key that the other is missing.
",josephsavona,devknoll
15,2015-08-12 01:49:31,"Thanks @yungsters - does index.js need to be added to `files` in package.json too? Not sure if `main` will include it automatically...
",devknoll,yungsters
15,2015-08-12 01:50:01,"@devknoll Good catch. :)
",yungsters,devknoll
15,2015-08-12 01:54:46,"@devknoll Actually, it looks like npm automatically includes `index.js` (maybe because it's set to `main`). But being explicit never hurts.
",yungsters,devknoll
15,2015-08-12 05:05:53,"@yungsters Looks like index.js needs to be included in the gulp file too! :smile: 
",devknoll,yungsters
14,2015-08-12 23:56:21,"As @yungsters mentioned, we're using ES2015 quite heavily. I know now why `babel-runtime` isn't polyfilling `String::repeat()`. @sebmck explains:

> It doesn't alias prototype methods. You can never be sure that something is always the right type. So in `foo.repeat()` you can't tell that `foo` is always going to be a string (you could with flow types but that's not implemented), so it's an unsafe transformation. Although in that case you can easily tell since it's just a string literal, but it'd be weird to support one and not the other.

This has helped to open up a wider discussion: should Relay attempt to bring its own polyfills, or should we empower (and require) you to bring the polyfills appropriate for your project. [React does this](https://facebook.github.io/react/docs/working-with-the-browser.html#polyfills-needed-to-support-older-browsers), to a certain extent. cc/ @zpao
",steveluscher,yungsters
14,2015-08-13 06:43:13,"@yungsters  OK, then I'm going to close this and will send separate PR. Thanks!
",sairion,yungsters
8,2015-08-13 01:31:52,"I could probably get this in.

@yungsters do you have a good idea of what would make a good `routeName`? I assume `baseName` isn't enough if it's being relied on for cache keys. Maybe `baseName + hash(uri)`?

That only works if you only have one route per file though... ;-)
",devknoll,yungsters
8,2015-08-13 03:36:20,"@devknoll Ahh, makes sense.
",yungsters,devknoll
7,2015-08-12 05:22:22,"@yungsters thanks for explanation! Maybe note somewhere in docs will be useful, I believe many people will have similar confusion. 
",genbit,yungsters
7,2015-08-12 14:52:16,"> In the future, I think we will strip out any routing-specific properties (and maybe even rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig).

@yungsters This would be great, also for (spoken) conversation: I can imagine some confusion could pop up with the phonetically incestuous names of  `Relay.Route`, `Relay.Container`, and `Relay.RootContainer`.
",sgwilym,yungsters
6,2015-10-01 09:33:27,"I came in here to communicate that I think the tutorial needs serious work, and I found this issue. I got overwhelmed myself, and I had someone else communicate to me they got lost quickly themselves. Glad people are working on this. The guides themselves are much better, but if I'd just had to deal with the tutorial I'd have given up. The tutorial is unfortunately currently bad advertising for Relay. I'm going to give more constructive feedback next.

Splitting this into ""intro to GraphQL"", ""intro to Relay client"" and ""how to build a Relay-compliant GraphQL schema"" would be good. Some people who are looking to learn Relay are going to work with existing
GraphQL schemas and won't even need the latter tutorial. They are interested in the client-side only. And if I use some other implementation technology for the GraphQL server, such as Python, I'm not interested
in the JS details of that either.

I think the ""Hello Relay"" tutorial should focus on building a client-side app only against some existing GraphQL endpoint. It's fine if I get some kind of demo server installed or can point my code to an existing one on the web. It shouldn't go into how to construct the endpoint at all. I'm fine if this is done on the filesystem without in-browser magic. Benefits of just going for the filesystem:
- closer to the layout of real world projects that use Relay.
- it's also simpler to implement such a tutorial than something that's more fancy and uses in-browser editing facilities, etc. I think a better tutorial should be done quickly to limit further damage the current one does.

I also don't like the current tutorial approach where you take an existing project, ignore almost entirely what it is in it, and replace it with vast amounts of tutorial-specific code. I'm happy to explore the layout of an existing project, but I'd rather do it just checking that project out and reading source code comments that explain what it all does and points to further details elsewhere.

I like how @steveluscher separates multiple steps of the Relay tutorial:
- A UI that shows a list of stories.
- Pagination of stories. This shows off a core Relay feature quickly.
- Compose components and GraphQL fragments by adding comments below each story.
- Mutations. Creating new comments.

Each step should end in a fully working Relay project that doesn't require you to know about the next steps yet. There's nothing about the server implementation in any of this.
",faassen,steveluscher
6,2015-10-01 14:26:26,"@taion I think there are many cases where UI developers are using Relay _without_ having to worry about the GraphQL server implementation, and more cases where developers may want to use another GraphQL server implementation altogether. For that reason, I much prefer a structure by @steveluscher, where schema building is deferred to the end. This way you serve both audiences: people who just want to use Relay on the client side, and people who are interested in building Relay-compliant server implementations. 

If you have a big discussion about graphql-js with Relay extensions from the start, you risk losing part of the audience. You bury the lead on Relay too: Relay is about making it easier to develop UIs, and instead you distract people with a lot of stuff about server implementation requirements that may or may not be relevant to them, but what is in any case not the main selling point of Relay.

So @taion, since you're happy with the tutorial as is, do you think it would get worse if it followed a structure as suggested by @steveluscher? 
",faassen,taion
6,2015-10-01 14:26:26,"@taion I think there are many cases where UI developers are using Relay _without_ having to worry about the GraphQL server implementation, and more cases where developers may want to use another GraphQL server implementation altogether. For that reason, I much prefer a structure by @steveluscher, where schema building is deferred to the end. This way you serve both audiences: people who just want to use Relay on the client side, and people who are interested in building Relay-compliant server implementations. 

If you have a big discussion about graphql-js with Relay extensions from the start, you risk losing part of the audience. You bury the lead on Relay too: Relay is about making it easier to develop UIs, and instead you distract people with a lot of stuff about server implementation requirements that may or may not be relevant to them, but what is in any case not the main selling point of Relay.

So @taion, since you're happy with the tutorial as is, do you think it would get worse if it followed a structure as suggested by @steveluscher? 
",faassen,steveluscher
6,2015-10-01 15:07:33,"@taion Obviously a Relay tutorial needs to talk a bit about GraphQL, first, which is exactly what @steveluscher proposed. What it doesn't need to do first is talk about how to implement a server like that. You can show how to build a UI with an existing demo server. Your concern for those who want to work in a different order are easily taken care of by use of a paragraph somewhere on top of the Relay tutorial: ""We are going to use a demo GraphQL server for the UI tutorial, but see <link> if you want to skip ahead and see how you can build your own."" That way what Relay is all about is focused on first. The ""how to build your own"" can then start saying ""We're going to use this specific set of JS technologies, but see <link> for alternatives.""

The Relay project should not be in the business of explaining how to implement a full GraphQL server anyway: that's the job of the GraphQL project. It should only explain how you can make a GraphQL server Relay compliant, and it can use the JS reference implementations as examples.
",faassen,taion
6,2015-10-01 15:07:33,"@taion Obviously a Relay tutorial needs to talk a bit about GraphQL, first, which is exactly what @steveluscher proposed. What it doesn't need to do first is talk about how to implement a server like that. You can show how to build a UI with an existing demo server. Your concern for those who want to work in a different order are easily taken care of by use of a paragraph somewhere on top of the Relay tutorial: ""We are going to use a demo GraphQL server for the UI tutorial, but see <link> if you want to skip ahead and see how you can build your own."" That way what Relay is all about is focused on first. The ""how to build your own"" can then start saying ""We're going to use this specific set of JS technologies, but see <link> for alternatives.""

The Relay project should not be in the business of explaining how to implement a full GraphQL server anyway: that's the job of the GraphQL project. It should only explain how you can make a GraphQL server Relay compliant, and it can use the JS reference implementations as examples.
",faassen,steveluscher
1,2015-08-11 20:05:22,"great :smile: thanks @vjeux 
",brentvatne,vjeux
1546,2017-02-15 21:03:38,"@josephsavona Requested this issue be created to discuss.

Having to override the network layer:


Using these configs:



Using this query:



The store updates fine, but doing a `this.forceUpdate()` on a parent component didn't re-render the changes to the `records`. I had to use `forceFetch`, but the `Relay.Store` after doing a `forceFetch` looks identical to me.

`Relay.Store` upon initial render:

`Relay.Store` in Relay.GraphQLMutation onSuccess callback after commit:

Relay.Store `readyState` after forceFetch:

`Relay.Store` after forceFetch:
",mattferrin,josephsavona
1504,2017-01-18 05:40:26,"So I did a bit of digging, but not sure where to go from here.
I understand that code like [this](http://stackoverflow.com/q/11616630/4776002) can trigger the 'Converting circular structure to JSON' error.
So the contents of `node` that is being passed to `printRelayOSSQuery.js:33`.

I reverted back to `v0.9.3` of the forked one, and now it's back to normal.
I'm starting to think this might be an issue with the fork, closing now.
Will probably consult @alloy on this. The fork doesn't have an issues tab, so hopefully I can bring the conversation here.
",Naoto-Ida,alloy
1502,2017-01-14 05:14:56,"@alloy so good, thank you for taking the time to figure this out! 

Cc @kassens",josephsavona,kassens
1502,2017-01-17 18:20:05,"@kassens has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4423631).",facebook-github-bot,kassens
1501,2017-01-13 19:33:23,hmm interesting. cc @yuzhi ,josephsavona,yuzhi
1497,2017-01-15 00:23:22,"> If we can subscribe to different types of updates and update store from a single place and be assured that the containers will automatically update, it will a big thing!

Yup, that's how Relay works. Queries, mutations, and subscriptions all publish new data into the store. Whenever a publish happens, all observers of the store are notified. Containers conceptually observe the results of their fragments, so they are re-rendered whenever data changes in the store that affects their result (regardless of the source of that data). 

> The current recommended library for subscriptions removes subscriptions on component unmount and therefore, requires forceFetch to be true, which is very inefficient.

This seems tangential to the above question. How to combine diffing, force-fetching, and subscriptions is application specific. Ideally any subscriptions API would allow a product to choose between several options. An initial forceFetch followed by holding a subscription until unmount seems like a reasonable approach, since it keeps the number of subscriptions proportional to the data being actively viewed. On the other hand, if the maximum number of subscriptions is known to not grow too large, it maybe be desirable to just subscribe to all updates you may ever care about, and then not use forceFetch. @edvinerikson, @taion - does `relay-subscriptions` support both approaches?",josephsavona,taion
1497,2017-01-15 00:23:22,"> If we can subscribe to different types of updates and update store from a single place and be assured that the containers will automatically update, it will a big thing!

Yup, that's how Relay works. Queries, mutations, and subscriptions all publish new data into the store. Whenever a publish happens, all observers of the store are notified. Containers conceptually observe the results of their fragments, so they are re-rendered whenever data changes in the store that affects their result (regardless of the source of that data). 

> The current recommended library for subscriptions removes subscriptions on component unmount and therefore, requires forceFetch to be true, which is very inefficient.

This seems tangential to the above question. How to combine diffing, force-fetching, and subscriptions is application specific. Ideally any subscriptions API would allow a product to choose between several options. An initial forceFetch followed by holding a subscription until unmount seems like a reasonable approach, since it keeps the number of subscriptions proportional to the data being actively viewed. On the other hand, if the maximum number of subscriptions is known to not grow too large, it maybe be desirable to just subscribe to all updates you may ever care about, and then not use forceFetch. @edvinerikson, @taion - does `relay-subscriptions` support both approaches?",josephsavona,edvinerikson
1476,2016-12-09 14:31:07,"@josephsavona  I have a case where I want to search data and load more afterwards (when user scrolls)
My first thought was to call a query `search(query:""something"", first:10)`, before component renders. But since I want to  be able to load more data, I'll need to use `setVariables()`. This would cause relay to create a `node(id:...)` query. Since I don't have `id` in my case, here are some ideas: 

1. Use a mutation, but how would you load more data using a mutation? 
2. Implement custom logic, and modify relay store 
3. Use `viewer` field, so graphql understands `node` queries by using user's id. 

How should I solve this? ",shakaIsReal,josephsavona
1472,2017-01-26 05:46:10,"@josephsavona I can confirm this. On the latest version 0.10.0 of react-relay I got the same problem.

Babel-relay-plugin converts correctly fragment fields with alias option, but query sended without alias.",nodkz,josephsavona
1460,2016-12-05 21:22:11,"Good questions. A lot of the complexity in Relay is not obvious if you haven't tried to build something like it. For example, it's easy to forget that props *are the results of queries*, so you can't have a `query()` function that depends on props/state (as in your example) or rely on React lifecycle methods for updating/constructing them.

If you're interested in how Relay 0.9 works, i'd highly recommend watching @wincent's talk: https://facebook.github.io/relay/docs/videos.html#relay-deep-dive-slides-https-speakerdeck-com-wincent-relay-deep-dive (there's a video or annotated slides)",josephsavona,wincent
1457,2016-11-27 22:19:06,"I think it'd be cool to only get the minimum data to resolve a global id to an object. Use case: getting new `ships` using cursor. 


`getFaction()` could return many object (id, name, ships).. But we don't need all of them when we're interested in `obj.ships` and `obj.id`. There's no need to load the data we already have on the client or don't need. 

Therefore relay could send a partial argument. `partial: true` 



 
And in `idFetcher` we could do this, 



Sure people can encode this inside `globalIdField`. But adding this change and documenting it to people can prevent data over fetching



 What do you think, is this change worth it? Or it just adds complexity? 

@leebyron  @wincent  ",shakaIsReal,wincent
1442,2016-12-14 02:06:33,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4324991).",facebook-github-bot,wincent
1441,2016-12-14 06:33:15,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4325907).",facebook-github-bot,wincent
1440,2016-12-14 06:34:23,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4325909).",facebook-github-bot,wincent
1436,2016-11-04 05:07:09,"@steveluscher please review this, and if it's ok bump new version. Thanks.
",nodkz,steveluscher
1436,2016-11-07 03:48:49,"@josephsavona can you review it and publish?
",nodkz,josephsavona
1434,2016-11-02 13:15:49,"Hi. I'm working on GraphQL support for Flow. It should make Flow validate queries/fragments against schema and convert them to js types.

This tool must be framework agnostic, but should support all major libraries like Relay and Apollo. I saw Greg's and Joe's talks on how the new Relay is going to be different, but there are not many details. I understand that API is not stable yet, but I'd design the tool according to current ideas about Relay.

For example, it's not clear how fragment spreads will resolve fragment by it's name. Or how can custom directives alter the query result.

Can you give any info about the new Relay API?

cc @wincent ",pvolok,wincent
1433,2016-12-14 02:07:45,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4325005).",facebook-github-bot,wincent
1427,2017-01-12 00:37:01,"Maybe Johannes can update my PR? I don't have time right now unfortunately.
Thank you.

On Wed, Jan 11, 2017 at 4:17 PM, Joseph Savona <notifications@github.com>
wrote:

> *@josephsavona* commented on this pull request.
> ------------------------------
>
> In README.md <https://github.com/facebook/relay/pull/1427>:
>
> > @@ -6,7 +6,7 @@ Relay is a JavaScript framework for building data-driven React applications.
>  * **Colocation:** Queries live next to the views that rely on them, so you can easily reason about your app. Relay aggregates queries into efficient network requests to fetch only what you need.
>  * **Mutations:** Relay lets you mutate data on the client and server using GraphQL mutations, and offers automatic data consistency, optimistic updates, and error handling.
>
> -[Learn how to use Relay in your own project.](https://facebook.github.io/relay/docs/getting-started.html)
> +[Learn how to use Relay in your own project](https://facebook.github.io/relay/docs/getting-started.html) or read a [comprehensive introduction](https://learnrelay.org).
>
> Would be easiest if @dminkovsky <https://github.com/dminkovsky> can
> update the PR directly.
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/facebook/relay/pull/1427>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AANWZdnxZ6f4mn6t9scQnF0TZMDl2zggks5rRUbwgaJpZM4KfN1S>
> .
>
",dminkovsky,josephsavona
1425,2016-12-14 06:44:42,"@wincent has imported this pull request.  If you are a Facebook employee, you can view this diff [on Phabricator](https://phabricator.intern.facebook.com/D4325930).",facebook-github-bot,wincent
1411,2016-10-07 06:19:42,"投稿してくれてありがとうございます！

This is a great question. I believe that the way we handle this is implicitly. As in, both the authenticated user and their language preference are part of the GraphQL executor context, as opposed to being passed explicitly as arguments to any field. 

Cc @dschafer - any suggestions here?
",josephsavona,dschafer
1401,2016-11-03 18:02:21,"@josephsavona any feedback on this?
",tomconroy,josephsavona
1369,2016-09-03 21:27:19,"# New Relay APIs

The core team is currently focused on developing the next major version of Relay, which we have been referring to as ""Relay 2"" as a working title, but which will ultimately be just a new set of APIs within the existing Relay. The new APIs are the best parts of Relay today - co-located GraphQL and React components and a declarative API - but is simpler, faster, and more predictable. This issue is to track our overall progress and give us a place to point people toward information.
## More Information
- Check out our recent [blog post](https://facebook.github.io/react/blog/2016/08/05/relay-state-of-the-state.html) on the state of the project and our goals/plan going forward.
- @wincent's [deep dive](https://facebook.github.io/relay/docs/videos.html#relay-2-simpler-faster-more-predictable-slides-https-speakerdeck-com-wincent-relay-2-simpler-faster-more-predictable) explains how Relay 2 works from a technical perspective; check this out if you're curious about the implementation and how it differs from current Relay.
- @josephsavona's [React Rally talk](https://speakerdeck.com/josephsavona/reintroducing-relay) provides an overview of the new APIs from a product developer's perspective, including the types of performance enhancements and API simplifications it unlocks.

## FAQs
### Do I have to relearn everything?

The core concepts of Relay continue to apply: co-located GraphQL and render logic, a declarative API that lets you specify what data you need, not how to fetch it. If you're familiar with Relay today, the updated Relay should feel familiar, with some rough edges removed (no more Routes, for example, just queries and variables). If you're _new_ to Relay, there will less concepts to learn and, we hope, it should be easier to get started.

There are definite API differences, but the core concepts are the same and the API changes serve to make Relay simpler and more predictable.

### What is the upgrade path?

Note that _we will continue to support the current API for the foreseeable future_ - we're using it too! Where possible, we will provide tools to help the community upgrade their own apps. We're currently exploring a limited interoperability API as well as codemods and other tools.

### How can I prepare for the new API? 

In general, the main theme is to reduce dynamic APIs that can prevent Relay from understanding the structure of a query statically (i.e. at build time). Examples of such dynamic APIs in current Relay are:

- `RelayMutation` and fat/tracked queries. Future releases will deprecate this API in favor of a static mutation API. We recommend using [`RelayGraphQLMutation`](https://facebook.github.io/relay/docs/api-reference-relay-graphql-mutation.html) to ease the transition to new mutations.
- `RelayContainer#prepareVariables()`. Future releases will deprecate support for this function; the workaround is to use (global) query variables and prepare dynamic values at the Renderer.
- `RelayContainer#initialVariables()` with *runtime function calls* specifically (inline constants/literals such as `initialVariables: {count: 10}` are static, runtime function calls such as `initialVariables: {count: getRuntimeValue()}` are not). Future releases will deprecate support for dynamically assigned initial variables. Similar to `prepareVariables`, a workaround will be to use (global) query variables.

### When will the updates to Relay be released?

We open source tools that we have proven in production. We're working to refine the product developer experience, finish/polish some features, and ship the first apps using it. 

### Where can I learn more / follow progress?

**The best way to follow our progress is to [read our meeting notes](https://github.com/facebook/relay/tree/master/meta/meeting-notes)**. We publish these semi-weekly, and are exploring a new format with more detailed status updates about sub-projects. We cannot guarantee that we can always keep this issue up to date, so always see the meeting notes for updates.

## High-Level Tasks

Below is a high-level overview of the work remaining to release the new APIs and core:

- [x] Introduce a static mutation API: [`Relay.GraphQLMutation`](https://facebook.github.io/relay/docs/api-reference-relay-graphql-mutation.html#content)
- [x] Poly-fill the new core's public API via the legacy core.
- [ ] Introduce static query APIs (new Renderer and Container variants)
- [ ] Deprecate old query APIs (`Relay.RootContainer`, `Relay.Renderer`, `Relay.Container`)
- [ ] Introduce the new core.",josephsavona,wincent
1369,2016-09-03 21:27:19,"# New Relay APIs

The core team is currently focused on developing the next major version of Relay, which we have been referring to as ""Relay 2"" as a working title, but which will ultimately be just a new set of APIs within the existing Relay. The new APIs are the best parts of Relay today - co-located GraphQL and React components and a declarative API - but is simpler, faster, and more predictable. This issue is to track our overall progress and give us a place to point people toward information.
## More Information
- Check out our recent [blog post](https://facebook.github.io/react/blog/2016/08/05/relay-state-of-the-state.html) on the state of the project and our goals/plan going forward.
- @wincent's [deep dive](https://facebook.github.io/relay/docs/videos.html#relay-2-simpler-faster-more-predictable-slides-https-speakerdeck-com-wincent-relay-2-simpler-faster-more-predictable) explains how Relay 2 works from a technical perspective; check this out if you're curious about the implementation and how it differs from current Relay.
- @josephsavona's [React Rally talk](https://speakerdeck.com/josephsavona/reintroducing-relay) provides an overview of the new APIs from a product developer's perspective, including the types of performance enhancements and API simplifications it unlocks.

## FAQs
### Do I have to relearn everything?

The core concepts of Relay continue to apply: co-located GraphQL and render logic, a declarative API that lets you specify what data you need, not how to fetch it. If you're familiar with Relay today, the updated Relay should feel familiar, with some rough edges removed (no more Routes, for example, just queries and variables). If you're _new_ to Relay, there will less concepts to learn and, we hope, it should be easier to get started.

There are definite API differences, but the core concepts are the same and the API changes serve to make Relay simpler and more predictable.

### What is the upgrade path?

Note that _we will continue to support the current API for the foreseeable future_ - we're using it too! Where possible, we will provide tools to help the community upgrade their own apps. We're currently exploring a limited interoperability API as well as codemods and other tools.

### How can I prepare for the new API? 

In general, the main theme is to reduce dynamic APIs that can prevent Relay from understanding the structure of a query statically (i.e. at build time). Examples of such dynamic APIs in current Relay are:

- `RelayMutation` and fat/tracked queries. Future releases will deprecate this API in favor of a static mutation API. We recommend using [`RelayGraphQLMutation`](https://facebook.github.io/relay/docs/api-reference-relay-graphql-mutation.html) to ease the transition to new mutations.
- `RelayContainer#prepareVariables()`. Future releases will deprecate support for this function; the workaround is to use (global) query variables and prepare dynamic values at the Renderer.
- `RelayContainer#initialVariables()` with *runtime function calls* specifically (inline constants/literals such as `initialVariables: {count: 10}` are static, runtime function calls such as `initialVariables: {count: getRuntimeValue()}` are not). Future releases will deprecate support for dynamically assigned initial variables. Similar to `prepareVariables`, a workaround will be to use (global) query variables.

### When will the updates to Relay be released?

We open source tools that we have proven in production. We're working to refine the product developer experience, finish/polish some features, and ship the first apps using it. 

### Where can I learn more / follow progress?

**The best way to follow our progress is to [read our meeting notes](https://github.com/facebook/relay/tree/master/meta/meeting-notes)**. We publish these semi-weekly, and are exploring a new format with more detailed status updates about sub-projects. We cannot guarantee that we can always keep this issue up to date, so always see the meeting notes for updates.

## High-Level Tasks

Below is a high-level overview of the work remaining to release the new APIs and core:

- [x] Introduce a static mutation API: [`Relay.GraphQLMutation`](https://facebook.github.io/relay/docs/api-reference-relay-graphql-mutation.html#content)
- [x] Poly-fill the new core's public API via the legacy core.
- [ ] Introduce static query APIs (new Renderer and Container variants)
- [ ] Deprecate old query APIs (`Relay.RootContainer`, `Relay.Renderer`, `Relay.Container`)
- [ ] Introduce the new core.",josephsavona,josephsavona
1364,2016-08-31 07:07:03,"for issue #1361 @wincent 
",vangavroche,wincent
1362,2016-08-30 17:41:59,"I was going to fix the nits that @josephsavona mentioned, but you already did that. Linter just exploded for me. What lints are you seeing?
",wincent,josephsavona
1345,2016-08-20 05:25:15,"Right now I'm watching @wincent [talk about Relay 2](https://www.youtube.com/watch?v=OEfUBN9dAI8&feature=youtu.be) and think that `making all static` should have DEV flag. Wants developer make all static, or computable at runtime according to Hot Reload when modules updated. 

Maybe I'm something missing. But I'm worried about losing HMR, cause it's the best feature, that developers have now.
",nodkz,wincent
1327,2016-08-08 16:07:39,"Hello, @josephsavona I replied to this issue too late .I am still having this issue and posted alot more information about it on the closed issue number below. 
#1291

https://github.com/facebook/relay/issues/1291

Thanks again for all of your help. 
",rterysen-openroad,josephsavona
1326,2016-08-08 15:27:14,"I just want to note a constant struggle I have with the way Relay masks/scopes data. It is very very frustrating to construct forms from smaller relay container input components. consider this example:



 and **UserDropdown** 



The crux of the example being that the parent `UserForm` requests a different field then it's child, hover the selected user being passed back up is scoped to `UserDropdown` for obvious reasons. This makes constructing a new object to be saved later _really_ frustrating. The above is only a simple case it gets much hairier as you add complexity or need/want to isolate form sections into their own components. I could manually ""rescope"" the user to the correct one by finding it in the `users` array in UserForm, but that can be costly and adds a ton of silly complexity. 

In these cases we've taken to awkwardly avoiding `createContainer` entirely and exporting fragments only, but that makes it hard to interop with actual relay containers, who constantly complain about the record they are given. The only other option is to jsut give up co-locating the queries with these components, which sounds ok in the above case but not in actual situations where the form is large, multi-stage, and made up of many layers of components.

cc @taion
",jquense,taion
1325,2016-08-08 10:14:49,"@yangit Relay caching is based on IDs of each fragment, it's generated by Relay based on the data that you have inside the fragment. The best way to avoid this would be to:
- set internal ID for each entity whenever you can. 
- Avoud using `null` and use empty string instead `""""`
- Switch to Relay Connection instead of Relay Array where possible because it provides you with better flexibility. 

@steveluscher can you please advise us on this?

Best,
Eugene
",eugenehp,steveluscher
1321,2016-08-04 17:17:48,"Thanks for letting us know about this. For some context, we measure every substantive change internally on real devices, so we know that the core logic of e.g. `writeRelayQueryPayload` hasn't regressed. However, we don't have an equivalent set up to make sure performance doesn't regress as a result of OSS build config - this is definitely something we should address as we want to ensure OSS users get the same performance we see internally. @rodrigopr, thank you again for your bringing this to our attention!

The `inlineRequires` settings causes `require` calls to be moved to the point where a module is referenced, instead of at the top of the file. You've probably noticed this while debugging, for others looking at this issue, the effect is as follows:



On mobile devices we have found that this can improve performance by delaying the work of requiring modules until they are needed (at the cost of some overhead on future invocations). On the server, the inverse (not doing inline requires) is clearly better, as indicated by your findings.

This might be a good argument for having two different builds: the default one optimized for clients, the other for use on the server (we could also disable the query/fragment cache on this one). Thoughts?

Also ccing @zpao about the OSS inline requires perf.
",josephsavona,zpao
1313,2016-08-02 18:27:27,"@spicyj Ben could you please take a look?
",JenniferWang,spicyj
1298,2016-07-25 22:58:15,"@josephsavona, I have manually tested simple end-to-end use-cases, and Subscriptions are working. But this is very much a WIP, and I have lots of cleanup and tests to write.

I submitted this PR to open up a channel of communication with you, as I have lots of questions. I will post my questions in comments below.
",tjmehta,josephsavona
1297,2016-07-25 15:13:05,"I had a brief discussion with @jeffmo about making flow understand graphql. He suggested to ask Relay team about how you solve the problem of typing relay apps. In the meeting notes it says that @sampepose is working on flow types generation script, but nothing I could find about what that is.

Can you provide any details about your approach for typing relay apps? Would it bring any value if flow supported graphql?

What I mean by graphql-support is parsing queries/fragments like `Relay.QL`fragment on User {...}``, validating them, generating prop types for relay-components, etc.
",pvolok,jeffmo
1297,2016-07-25 15:13:05,"I had a brief discussion with @jeffmo about making flow understand graphql. He suggested to ask Relay team about how you solve the problem of typing relay apps. In the meeting notes it says that @sampepose is working on flow types generation script, but nothing I could find about what that is.

Can you provide any details about your approach for typing relay apps? Would it bring any value if flow supported graphql?

What I mean by graphql-support is parsing queries/fragments like `Relay.QL`fragment on User {...}``, validating them, generating prop types for relay-components, etc.
",pvolok,sampepose
1296,2016-08-02 16:11:49,"Hey there - thanks for all the details. ccing @yuzhi who has worked a lot on cache, one of us will try to take a look.
",josephsavona,yuzhi
1285,2016-07-15 18:36:37,"Most fixes using `eslint --fix` and one manual line break.

Inspired by the upgrade on the root directory by @zpao:
https://github.com/facebook/relay/commit/cc04adef211017656e77ed765744f0b7b647b70d
",kassens,zpao
1282,2016-07-16 18:55:35,"Thanks for your question. We're trying to keep GitHub issues focused on bugs and enhancements to keep signal high for contributors. I'd recommend asking your question on [Stack Overflow](http://stackoverflow.com/questions/tagged/relayjs) and tagging it with '#relayjs'. 

As others have mentioned, there are lots of great resources online that answer your question. A few suggestions:
- @steveluscher's [Zero to GraphQL in 30 minutes talk](https://www.youtube.com/watch?v=UBGzsb2UkeY) is a must-watch.
- There's also an accompanying [zero-to-graph repo](https://github.com/steveluscher/zero-to-graphql).
- And there's an overview of lots of tools at [awesome-graphql](https://github.com/chentsulin/awesome-graphql).
",josephsavona,steveluscher
1281,2016-07-20 01:16:07,"Hmm. `printRelayQuery` is a module that is shimmed to use either `printRelayOSSQuery` (in open source) or an internal version at Facebook. I suspect that the require is failing because Jest doesn't think that `printRelayQuery` is a module and so it is getting transformed differently.

@cpojer any ideas?
",josephsavona,cpojer
1281,2016-11-07 12:51:05,"@sibelius @lucasbento sorry for keeping silence. My macbook was in the service. I'm glad I'm not alone in this question.. I guess you've already guessed that I have a working solution for Jest 14 but not for Jest >= 15. Here's the issue with the repro and the example for Jest 14 https://github.com/facebook/jest/issues/1898. Guys from the Jest team do not answer it unfortunately. 
",GrigoryPtashko,lucasbento
1279,2016-07-12 13:34:11,"@steveluscher should we go ahead and depreciate `RelayRoute` here too? 
",washt,steveluscher
1270,2016-07-10 23:18:48,"The problem was that `mutateAndGetPayload` was receiving `args`, besides the arguments that you specifies in inputFields, it add one more field`clientMutationId`, i was passing args to my custom function and it was cleaning up the fields that doesnt match with my model, in this case `clientMutationId`, so  the solution was to make a copy from args like this, `let _args = Object.assign({}, args)`, it was passing the args argument by reference and then when `outputFields` was called the field `clientMutationId` didnt exists

@josephsavona maybe u want to consider this for the future.
",CoericK,josephsavona
1262,2016-07-06 16:07:16,"I'm going to go ahead and cc @wincent here because in his commit message for 71e2350 it looked like he was a little unsure about whether everything should be `REQUIRED` 👍 
",NevilleS,wincent
1246,2016-06-28 15:10:20,"As discussed in https://github.com/facebook/relay/pull/1232, this should make it easier to maintain a forked version of Relay and change the name of the field to use as Node ID.

@josephsavona Did I understand everything correct?
",alloy,josephsavona
1241,2016-06-25 14:38:58,"List of desirable features:
- [x] 1. Pass several variables on the top level (not only input). It needed for getting fine grained payload which required some additional variables. [Implementation founded here](https://github.com/facebook/relay/blob/829450ab74aa5c6b0cdb453cb76b1fbc45f16687/src/mutation/RelayGraphQLMutation.js#L374)
- [ ] 2. Move on top level clientMutationId. It is to annoying extract it from inputs and passes to output. Downside we get visibility of this fieldname for every mutation in graphiql doc.
- [ ] 3. Nested mutations in graphql. For example, I have seven methods for mutating user model. It will be nice if I hide them all under `user: UserMutations` field/type.
- [ ] 4. Allowing `path`s in `getConfigs()` for `parentName`, `fieldIDs[key]`, `deletedIDFieldName` in deeply nested GraphQL elements would be nice. So I could have something like `pathToConnection` rather than `connectionName`, as in some environments it can be quite unnatural to enforce the immediate parent of a list to be a relay node. (@Globegitter [last paragraph in comment](https://github.com/facebook/relay/issues/1241#issuecomment-235308799)) 

Fill free to leave your desirable features in comments. I'll add them to this list with a serial number for referencing in the further discussions.

Will be cool if @wincent write about newly implemented features, what planned and of course what think about our desirable features. 
",nodkz,wincent
1241,2016-06-25 14:38:58,"List of desirable features:
- [x] 1. Pass several variables on the top level (not only input). It needed for getting fine grained payload which required some additional variables. [Implementation founded here](https://github.com/facebook/relay/blob/829450ab74aa5c6b0cdb453cb76b1fbc45f16687/src/mutation/RelayGraphQLMutation.js#L374)
- [ ] 2. Move on top level clientMutationId. It is to annoying extract it from inputs and passes to output. Downside we get visibility of this fieldname for every mutation in graphiql doc.
- [ ] 3. Nested mutations in graphql. For example, I have seven methods for mutating user model. It will be nice if I hide them all under `user: UserMutations` field/type.
- [ ] 4. Allowing `path`s in `getConfigs()` for `parentName`, `fieldIDs[key]`, `deletedIDFieldName` in deeply nested GraphQL elements would be nice. So I could have something like `pathToConnection` rather than `connectionName`, as in some environments it can be quite unnatural to enforce the immediate parent of a list to be a relay node. (@Globegitter [last paragraph in comment](https://github.com/facebook/relay/issues/1241#issuecomment-235308799)) 

Fill free to leave your desirable features in comments. I'll add them to this list with a serial number for referencing in the further discussions.

Will be cool if @wincent write about newly implemented features, what planned and of course what think about our desirable features. 
",nodkz,Globegitter
1216,2016-06-15 12:17:35,"Fixes #1208

That `invariant` doesn't seem to make sense in that function, removing it will allow us to use `rangeBehavior` functions with other types than string.

@josephsavona
",xuorig,josephsavona
1208,2016-06-15 06:52:34,"@xuorig Since you are the one who proposed this changed and implemented it, could you bring some insight about this issue? Particularly _why is `getObjectFromCalls` denying non-string values?_
",ooflorent,xuorig
1208,2016-06-15 18:09:55,"> This was possibly added on FB side when they imported, so I might be missing some context.

It was added by @josephsavona with the comment ""lint/flow fixes"", so maybe he recalls what the lint/flow errors were that prompted the change.
",wincent,josephsavona
1203,2016-06-08 23:37:03,"cc @josephsavona
",yuzhi,josephsavona
1201,2016-06-08 23:34:28,"Quoting @dschafer 

> Without a limiting filter like `first` or `last`, the behavior of the connection is undefined. The server could return every item in the list (which could mean we're massively overfetching if the list grows in size), it could just return a default value; the client has no idea. Clearly, the client has some idea of the behavior that it wants: it should specify that behavior with a `first:` or `last:` filter. If you want up to N items, do `(first: N)`. If you want all items, ask yourself: if there were 1,000,000 items in the future, would you want to fetch all of them? The answer is clearly no; you would want to cap it at some reasonable limit X. In that case, do `(first: X)`.
",yuzhi,dschafer
1201,2016-06-08 23:53:33,"@wincent @yuzhi Thank you for the comments and yes I think the iPad/Mac Pro/iMac analogy is quite spot on.

I can see the point that @dschafer is making and that clarifies the `ConnectionField` use-case fully and this can be closed. I would agree then that it makes most sense to add more power to lists, which then gives users full flexibility. Will try and finish the work on that soon.
",Globegitter,dschafer
1200,2016-06-07 19:13:24,"np!, Still pretty surprising behaviour though, wonder what you think of this issue @josephsavona
",xuorig,josephsavona
1197,2016-06-02 17:16:39,"Thanks for asking about this. This has [come up before](https://github.com/facebook/relay/issues/724#issuecomment-169669734). From my answer there:

> Relay creates a new node query intentionally - it saves the server the work of fetching the list itself (it would also be more complicated to generate a more optimal query - to a person it's easy to see, but there can be weird edge cases and it's simplest to use node calls).

Internally we use a batching network layer that would send all n queries in a single request. In OSS @nodkz has built something similar that I'd recommend trying: https://github.com/nodkz/react-relay-network-layer
",josephsavona,nodkz
1173,2016-05-27 00:59:36,"/cc @wincent FYI.
",LegNeato,wincent
1162,2016-05-22 17:19:11,"@rarutu `connectionFromPromisedArray` is helper that assumes that whole dataset in is in that array, thats reason why it works only if you fetch everything. 

You need to implement (or find) such helper that will work efficiently with MongoDB.  These helpers always gets backend specific.

I don't use MongoDB with graphql, but @nodkz recently referenced some graphql+mongodb [resources](https://github.com/facebook/relay/issues/1150#issuecomment-220283327) which hopefully help you to get clear picture.
",jardakotesovec,nodkz
1159,2016-05-20 22:43:56,"Now that `react-relay` has passed @davidaurelio's `relay` in version, would it be possible to use the `relay` package name on npm?

It would save me feeling dumb every time I accidentally type


",taion,davidaurelio
1159,2016-05-20 22:54:42,"Funny you should ask. @cpojer brought up the same idea only an hour ago.
",wincent,cpojer
1146,2016-05-17 16:35:59,"Thanks @Yaxian.

I'm totally unqualified to review this. Help, @yuzhi!
",wincent,yuzhi
1141,2016-05-14 17:29:15,"This is a great question. 

@dschafer probably has the best context on error handling in GraphQL. Dan, any resources on this?
",josephsavona,dschafer
1141,2016-05-28 00:48:13,"I was definitely interested in hearing some community thoughts on this one. I got asked about this a bunch at a recent React meetup and felt like I didn't have a great answer... pinging @dschafer again?
",NevilleS,dschafer
1133,2016-05-11 12:05:04,"Due latest meeting notes this issue is more related to @wincent. 
Greg, can you provide such great feature? 

I can wait next vim screencast 😉. But I can not live without promises with committing mutations 😜!   
",nodkz,wincent
1123,2016-05-06 16:43:13,"In general I think we want to keep the default layer pretty simple, and the intention is that if you want to do anything ""special"" you can bring your own.

[Here](https://github.com/facebook/relay/issues/1120) is a similar issue from a day or two ago, which includes an interesting comment from @KyleAMathews to [a user-space network layer project](https://github.com/nodkz/react-relay-network-layer).
",wincent,KyleAMathews
1120,2016-05-06 19:48:01,"Cool! Big props to @nodkz for taking this on. 
",KyleAMathews,nodkz
1109,2016-05-03 05:38:20,"Does removing `babel-runtime` from the build affect your builds at all, @skevy, @taion? I don't know how you build your apps.
",steveluscher,taion
1109,2016-05-03 05:38:20,"Does removing `babel-runtime` from the build affect your builds at all, @skevy, @taion? I don't know how you build your apps.
",steveluscher,skevy
1105,2016-05-01 18:32:28,"Addressed your comments @josephsavona 
",xuorig,josephsavona
1104,2016-05-15 13:55:42,"@josephsavona Have addressed most of your comments. Seeing as you have now more thoroughly documented the variable passing down (https://github.com/facebook/relay/pull/1142) I simplified the example.

I did however think that some of the other sections could do with some further explanation. For me it is often more easy to understand things based on an (explained) example.

Let me know if anything else needs fixing up.
",Globegitter,josephsavona
1104,2016-05-27 11:11:04,"@josephsavona Anything still blocking this PR being merged?
",Globegitter,josephsavona
1103,2016-04-29 20:06:03,"I believe @wincent fixed this in d1abc54d5ab60fc8e0b17353ea3b9b3bf2d4f4a0
",josephsavona,wincent
1091,2016-04-28 13:47:37,"@chentsulin: check out @kassens diff links above. That _might_ fix it, and is _at least_ related.
",wincent,kassens
1087,2016-04-26 05:11:31,"As spotted by the eagle eyes of @taion here:

https://github.com/facebook/relay/commit/94cab57559ff205#commitcomment-17242321
",wincent,taion
1086,2016-05-04 22:09:34,"Just a quick update: @steveluscher has done a fair bit of work over the last few days upgrading dependencies (of particular significance, moving ~~6-to-5~~ Babel from 5 to 6), so we'll probably cut a new release soon with that work, and that would be a good time to revisit this question of having verifying that everything works out of the box.
",wincent,steveluscher
1086,2016-05-11 00:43:22,"@steveluscher  is upgrading a bunch of stuff in #1118 and #1119, which means we'll be able to do a release soon. I don't think there is much point in trying to make things work until (one of?) those have landed. But at that point, I think it would be great to do some of the things I mentioned in my comment above.
",wincent,steveluscher
1086,2016-05-25 21:08:35,"New release is likely to happen this week. We'll check that all the examples work, but there are lots of local-system variables, tooling version issues, and ordering issues that may mean that they don't work in specific circumstances, so _once the release is out_ we'll be grateful for any reports of specific issues (and ideally _fixes_ for those issues, because we may not be able to repro them).

In the meantime, duplicate reports of things not working won't really help resolve things.

@sampepose: do you think we should do the things [I mentioned above](https://github.com/facebook/relay/issues/1086#issuecomment-214752939) (using shrinkwrap and cutting the number of examples down to one) before or after we cut the release?
",wincent,sampepose
1083,2016-04-25 23:50:40,"Thanks for the PR, @dylanahsmith.

The use of client mutation IDs comes from their extraction from Facebook's internal implementation, where they have existed for years (perhaps since the original implementation of mutations, although my memory doesn't extend back that far). Perhaps @dschafer can speak to why/how they arose in the design.

The deal-breaker here, however, is that Relay internals themselves assume a client mutation ID, so this would be a breaking change (as you note), and I am not sure we want to do that. Disclaimer: I haven't fully read #825 yet so I am not sure whether there is a rationale in there strong enough to overturn whatever reasons Dan (or somebody else) can share with us for why things currently are the way they are.

Adding the discussion label for now so we can get some more opinions on this.
",wincent,dschafer
1083,2016-04-26 00:28:28,"> Perhaps @dschafer can speak to why/how they arose in the design.

So that clients could have a unique identifier to associate with mutations, and to link a mutation to its payload. It's also really nice for subscriptions, since you can determine if a given subscription payload is associated with a mutation that you yourself created.

I think I'd be fine with making this nullable, and clientMutationId will be null if you pass up null in the input. I'd still want to enforce that we always set it, but that can be a convention and not part of the spec.
",dschafer,dschafer
1083,2016-06-30 22:30:37,"Thoughts on this, @josephsavona, @kassens, @yuzhi?
",steveluscher,yuzhi
1083,2016-06-30 22:30:37,"Thoughts on this, @josephsavona, @kassens, @yuzhi?
",steveluscher,kassens
1083,2016-06-30 22:30:37,"Thoughts on this, @josephsavona, @kassens, @yuzhi?
",steveluscher,josephsavona
1067,2016-04-25 18:27:44,"Thanks for this, @Globegitter. I'm not actually sure that we do want to document all of these options, as that would mean supporting them going forward. `inputArgumentName` and `snakeCase`, for example, might only exist because we needed to distinguish internally between open source GraphQL conventions and our preexisting internal ones.

@josephsavona, @yuzhi, @steveluscher. Any thoughts on which, if any of these options you'd prefer to remain undocumented?
",wincent,yuzhi
1067,2016-04-25 18:27:44,"Thanks for this, @Globegitter. I'm not actually sure that we do want to document all of these options, as that would mean supporting them going forward. `inputArgumentName` and `snakeCase`, for example, might only exist because we needed to distinguish internally between open source GraphQL conventions and our preexisting internal ones.

@josephsavona, @yuzhi, @steveluscher. Any thoughts on which, if any of these options you'd prefer to remain undocumented?
",wincent,josephsavona
1067,2016-04-25 18:27:44,"Thanks for this, @Globegitter. I'm not actually sure that we do want to document all of these options, as that would mean supporting them going forward. `inputArgumentName` and `snakeCase`, for example, might only exist because we needed to distinguish internally between open source GraphQL conventions and our preexisting internal ones.

@josephsavona, @yuzhi, @steveluscher. Any thoughts on which, if any of these options you'd prefer to remain undocumented?
",wincent,steveluscher
1054,2016-04-16 14:41:26,"addressed your comments @josephsavona 

Not sure about the CI Failure ?
",xuorig,josephsavona
1054,2016-04-21 01:31:10,"Rebased and got 🍏, I know this is a fairly large PR, but any comments ? cc @josephsavona 
",xuorig,josephsavona
1053,2016-04-15 18:18:48,"@Globegitter We agree. One of our ideas here was to have a Relay ""debugger"" - something that optionally prints information about what Relay is doing in order to make it more obvious what's happening (diffing a query, writing data into the store, constructing a mutation query, etc). The aim would be to both help people debug when issues do occur as well as to help people learn about all the things Relay is doing behind the scenes. 

@yuzhi has been focused on this lately, but there's plenty of room for contributions here. I'd encourage you to send a PR with changes that you think would be helpful and we can discuss from there.
",josephsavona,yuzhi
1053,2016-04-16 03:45:25,"Probably quite related to #1045 which @yuzhi was also taking a look at :)
",xuorig,yuzhi
1048,2016-04-14 14:17:23,"Thanks for letting us know about this issue. In general, calling `setVariables` in `componentWillReceiveProps` can lead to an infinite loop. Changing variables fetches more data, which will typically cause the component to re-render, which will cause new props to be received. I'll get to a workaround/follow-up in a moment, but before that - what's the use-case for setting variables in `willReceiveProps`? If a component needs data, that _should_ be expressible in its fragments such that the parent can ensure all data is available.

We encountered some issue with the old behavior of `setVariables` and don't plan on reverting to it. Specifically, it's possible for one component in a to call `forceFetch` such that another component ends up missing some data (forceFetch on a range overwrites the range - if i force fetch for 5 items and you had fetched 20, now you'll suddenly get only 5. we refer to this as the ""missing records/items problem""). The only option before the setVars change was for the affected component to also forceFetch (because setVars would previously see that the affected components vars were the same and avoid refetching), which could cause an infinite loop of refetching. The new behavior allows a component so affected to use `setVars` and avoid the infinite loop (because setVars merges new range items instead of overwriting).

tl;dr Yes, we should make it possible to see what vars are pending, but I'm still curious about the use-case for calling `setVariables` in willReceiveProps (seems like an anti-pattern).

cc @yuzhi 
",josephsavona,yuzhi
1046,2016-04-14 04:29:41,"Right now I almost finished rewrite own module, like `graffiti-mongoose`, which generates GraphQL types and schemas from the existing mongoose models. I didn't found any problems with querying in Relay, but found some lacks in Mutations. I suppose that same problems have clients of reindex.io (@freiksenet can you aprove this?)

1) Passing variables to query in `getFatQuery` method. GraphQL support such behaviour, but in Relay.mutation I didn't find such ability. 

Eg. user add new `note`, and this change some `summary` in the `article` with `$articleId`. 
Of course we can change payload for mutation and add article there. But in my case I want get it via `viewer`. May be tomorrow somebody want add another model for fetching after mutation on the client. So I try obtain some features for auto-generated schemas, and eventually write less code on the backend:



2) Problem with nesting in `getConfigs`. It will be cool if we can write fieldNames via dotNotation for nested nodes (see https://github.com/mariocasciaro/object-path or https://github.com/rhalff/dot-object). So for example above, I would like to write such config:



Also this should work with ADD_RANGE and others. 

**So this two things can not so dusty reduce changing code on the backends, when frontend wants more and more new data after mutations.**
",nodkz,freiksenet
1045,2016-04-13 14:21:37,"Great idea, @yuzhi was just talking about adding something like this.
",josephsavona,yuzhi
1035,2016-04-08 20:10:06,"@zjlovezj: Thanks for asking!

You can expect a release soon. @steveluscher was talking about preparing one as early as today, but as you know, sometimes things come up so it could end up sliding to next week, so we'll see exactly when it falls.

As for the meeting notes, I believe @josephsavona was going to publish them, but he's been busy with other work so I think I'll just go ahead and do it now.
",wincent,steveluscher
1035,2016-04-08 20:10:06,"@zjlovezj: Thanks for asking!

You can expect a release soon. @steveluscher was talking about preparing one as early as today, but as you know, sometimes things come up so it could end up sliding to next week, so we'll see exactly when it falls.

As for the meeting notes, I believe @josephsavona was going to publish them, but he's been busy with other work so I think I'll just go ahead and do it now.
",wincent,josephsavona
1030,2016-06-22 22:15:53,"Well, we _do_ have it, but not _inside_ Relay. The way we're trying to go moving forward is to make a small, modular, well-defined core upon which it is easy to build other abstractions (or compose inside existing abstractions). Offline caching is a good example of the kind of thing that we don't want in the core but we do want to be possible in ""user space"". Your use-case (ha, almost wrote use-cache) is very similar to the ones for which we use the disk cache (not strictly offline mode, but fulfilling queries with (potentially stale) data while we wait for fresh data to come back from the network.

I am not sure what the limitations with respect to caching connections are. At a high level the API just deals with records, fields and root calls. @yuzhi knows the most about this so perhaps she can chime in on how this interoperates (or doesn't) with connections.
",wincent,yuzhi
1025,2016-04-07 03:01:07,"@josephsavona suggested in #558 that this will happen as part of #559 however this meta task seems not so trivial and will likely take some time so why wait when it seems like we can leverage all the hard work people put into making Relay contextual already ?
",tlvenn,josephsavona
1023,2016-04-05 23:55:40,"Thanks for asking about this. 

cc @yungsters - you have the most context on readyState callbacks. I feel like this is intentional but can't immediately remember why.
",josephsavona,yungsters
1022,2016-04-05 22:33:02,"In code review for D3136035 @yungsters suggested hoisting a guard up to the callsites. Turns out the callsites already have guards (either due to prior `invariant` calls or an explicit `if`), so the guard isn't needed at all (in fact, was in there as a remnant of an intermediate state I had while preparing that diff).

So, let's just remove the guard.
",wincent,yungsters
1018,2016-04-05 00:35:15,"Yes, there is still a roadmap, but it's something we'll only update periodically.

More frequently updated are our meeting notes which you can find at: https://github.com/facebook/relay/wiki/Meeting-notes

We're going to move those off the wiki, though, and into the repo itself via PRs, so that people can get notifications when we publish new notes. I believe @josephsavona has a couple of week's worth of meeting notes that he said he was going to publish, but if he doesn't get to it shortly I'll do it.
",wincent,josephsavona
1018,2016-04-05 03:32:01,"Hi @wincent 

Thanks for the update and looking forward to latest meeting notes.

We're making an attempt at a major adoption of GraphQL/Relay across our products, web and mobile, and I'm trying to find out if the ideas listed below regarding support of local/client state are still part of the plan? Are they still justified in your view? @wincent @josephsavona

API for resolving fields locally: #431.
Support querying & compiling client-only fields by extending the server schema, and a means for writing data for these fields into the cache: #114.

?
",idibidiart,josephsavona
1014,2016-04-01 01:32:15,"Fixes https://github.com/facebook/relay/issues/690
I couldn't really find more es6 stuff other than what it checks (except for `Map` which got transpiled to `_Map` for some reason).
Not sure about tests.. Do we need a test for this and where should it go if so?
cc @josephsavona
",edvinerikson,josephsavona
1013,2016-03-31 23:47:26,"Fixes https://github.com/facebook/relay/issues/968 (maybe..)
I couldn't verify that this fixes it. When I tried it locally I could run the plugin in 0.10 without the patch.
#### Edit

I managed to verify that it is working now.
I used the schema/babel config in the todo example and ran `node node_modules/.bin/babel test.js`
**test.js**



cc @kassens @josephsavona
",edvinerikson,kassens
1013,2016-03-31 23:47:26,"Fixes https://github.com/facebook/relay/issues/968 (maybe..)
I couldn't verify that this fixes it. When I tried it locally I could run the plugin in 0.10 without the patch.
#### Edit

I managed to verify that it is working now.
I used the schema/babel config in the todo example and ran `node node_modules/.bin/babel test.js`
**test.js**



cc @kassens @josephsavona
",edvinerikson,josephsavona
1000,2016-04-14 15:58:03,"cc @wincent, @yuzhi re problems with automatic query construction. This is more evidence to suggest for requiring that mutation query construction be more static/manual/explicit.
",josephsavona,yuzhi
1000,2016-04-14 15:58:03,"cc @wincent, @yuzhi re problems with automatic query construction. This is more evidence to suggest for requiring that mutation query construction be more static/manual/explicit.
",josephsavona,wincent
998,2016-03-28 20:26:08,"This blames to a1a4d99cb698e1eed63d28f8291ef114115d515d which adds a reference to the internal only `RelayVariable`. @steveluscher would you mind taking a look? Maybe we need a fork or we can move `RelayVariable` to OSS?
",kassens,steveluscher
993,2016-03-28 18:12:44,"This makes sense and would seem to make nested `<RelayRenderer />`s easier to use (no need to supply the environment prop to every instance). Have there been any downsides to this approach? 

cc @gaearon @yungsters 
",josephsavona,yungsters
993,2016-04-05 15:52:01,"@aihornmac Thanks again for suggesting this idea. A `<Provider>` style component does separate the concerns of setting the context from rendering the data, and could be useful whenever there are nested `RelayRenderer`s. Let's leave this open and see if there's any more input.

@taion Would this be helpful for `react-router-relay`?
",josephsavona,taion
983,2016-03-23 14:57:36,"Thanks for posting and searching for relevant existing issues. As you noted, our existing connection handling is cursor-based; because this is our primary use case the core team is unlikely to work directly on alternate forms of pagination. 

The simplest approach here is to use a plain list field with page/limit arguments as @taion suggested. What do you think about closing this issue and continuing discussion at #540?
",josephsavona,taion
981,2016-03-23 00:01:08,"Picking this up again as it relates to work on mutations by @wincent and diffing by @kassens - the goal is to have a single `RelayFragmentResolver` instance for every combination of runtime fragment & dataID, such that we know what fragments are actively subscribed on what ids. This is just the resolver implementation, a follow-up will replace GraphQLStoreQueryResolver with this.
",josephsavona,wincent
981,2016-03-23 00:01:08,"Picking this up again as it relates to work on mutations by @wincent and diffing by @kassens - the goal is to have a single `RelayFragmentResolver` instance for every combination of runtime fragment & dataID, such that we know what fragments are actively subscribed on what ids. This is just the resolver implementation, a follow-up will replace GraphQLStoreQueryResolver with this.
",josephsavona,kassens
973,2016-03-22 06:18:00,"First off, thanks!  Second off, feel free to ignore any / all of this -- I am just curious :).

I'm not sure I follow why two steps.  If in (1) you are intersecting the fat query I'm not sure what (2) does (I'm assuming query resolvers are components subscribed to the store?).

As for gotcha's with (1) I'm aware of an issue currently handled by Relay where the store has a `null` value but the tracking query might be:



Looking at the store data only you wouldn't know `text` and `completed` were being tracked since `selectedTodo` was currently `null` (or at least that is my understanding).  Any other major gotcha's for intersecting the fat query with the store data itself?

I previously had asked @josephsavona about the tracked queries and he mentioned performance was a big benefit.  I might not be fully understanding this, but are connections the performance driver here?  e.g. I have 100 edges in a connection, in order to intersect I don't want to have to traverse all 100 edges?  Or is that not how to handle the connection case anyways?

Do abstract types pose a problem for intersecting or in all cases does Relay have the type information required stored in the store?
",eyston,josephsavona
973,2016-07-01 22:24:26,"@xuorig pointed me here.

If I'm reading this issue correctly, this seems like it'd be a significant improvement in behavior as well.

If I have queried a connection with a bunch of arguments (say corresponding to querying with different names), and I need to refetch those connections, this would mean that I have an easy way to avoid refetching that connection with arguments corresponding to components that are no longer mounted.

Is that correct? Or e.g. am I misunderstanding something about the current behavior?
",taion,xuorig
966,2016-03-18 15:11:14,"This idea came up in internal discussion too. CC'ing some of the participants in case they want to respond: @devknoll, @yungsters, @cpojer, @joshduck, @sahrens, @josephsavona, @elynde.

(If nobody chimes in, I'll try and summarize the thread later on.)
",wincent,josephsavona
966,2016-03-18 15:11:14,"This idea came up in internal discussion too. CC'ing some of the participants in case they want to respond: @devknoll, @yungsters, @cpojer, @joshduck, @sahrens, @josephsavona, @elynde.

(If nobody chimes in, I'll try and summarize the thread later on.)
",wincent,devknoll
966,2016-03-18 15:11:14,"This idea came up in internal discussion too. CC'ing some of the participants in case they want to respond: @devknoll, @yungsters, @cpojer, @joshduck, @sahrens, @josephsavona, @elynde.

(If nobody chimes in, I'll try and summarize the thread later on.)
",wincent,yungsters
966,2016-03-18 15:11:14,"This idea came up in internal discussion too. CC'ing some of the participants in case they want to respond: @devknoll, @yungsters, @cpojer, @joshduck, @sahrens, @josephsavona, @elynde.

(If nobody chimes in, I'll try and summarize the thread later on.)
",wincent,cpojer
966,2016-03-18 15:11:14,"This idea came up in internal discussion too. CC'ing some of the participants in case they want to respond: @devknoll, @yungsters, @cpojer, @joshduck, @sahrens, @josephsavona, @elynde.

(If nobody chimes in, I'll try and summarize the thread later on.)
",wincent,sahrens
966,2016-03-18 15:48:09,"Yeah, this bubbled up internally too in P56213804. @josephsavona suggested I toss it here.
",dougli,josephsavona
956,2016-03-16 20:02:22,"cc @yungsters 
",cpojer,yungsters
945,2016-03-11 16:33:29," As discussed in #574, #542

Introduce 2 new range behaviors:
- `REFETCH`: Will refetch the entire connection (to squelch the warning when no `rangeBehavior` matches the tracked connection)
- `IGNORE`: Replaces using null, means the range should not be refetched at all.

I've deprecated `null`, maybe we don't need to, what do you think ?

@yungsters @steveluscher 

let me what you think! 🍻
",xuorig,yungsters
945,2016-03-11 16:33:29," As discussed in #574, #542

Introduce 2 new range behaviors:
- `REFETCH`: Will refetch the entire connection (to squelch the warning when no `rangeBehavior` matches the tracked connection)
- `IGNORE`: Replaces using null, means the range should not be refetched at all.

I've deprecated `null`, maybe we don't need to, what do you think ?

@yungsters @steveluscher 

let me what you think! 🍻
",xuorig,steveluscher
944,2016-05-08 19:34:34,"@steveluscher do we need this anymore?
",josephsavona,steveluscher
943,2016-03-10 20:28:28,"Now that we support `@relay(isStaticFragment: true)` to denote static fragments (thanks @yungsters!), we can use the fragment name as the id for static fragments instead of a hash. This means the identifier is stable across changes to the file, making it a bit easier to work with.
",josephsavona,yungsters
942,2016-03-10 19:44:26,"This simplifies state handling in `RelayRenderer`, but does not change external behaviour and API. It follows principles described in section ""[Thinking in React: Identify the minimal (but complete) representation of UI state](https://facebook.github.io/react/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state)"". I identified that only two things actually determine internal state of `RelayRenderer`:
- the most recent ready state (the `readyState` state param),
- and whether we received a ready state at least once (the new `active` state param).

The `active` param means that we made a render while having a ready state at least once, and next time we will rerender only if we also have a ready state (we might have reseted the ready state to `null` after sending new queries).

Previously other state params were either redundant or derivable from `readyState` and `active`.

After this refactoring it will probably be easy for `RelayRenderer` to make use of `RelayRedayStateRenderer` [proposed](https://github.com/facebook/relay/pull/921#issuecomment-194392149) by @yungsters.

But originally it was submitted as a part of #921 to simplify implementation of isomorphic rendering for `RelayRenderer`.
",denvned,yungsters
928,2016-03-08 23:19:48,"Thanks for reporting this. @steveluscher was looking into these just today.
",josephsavona,steveluscher
927,2016-03-08 19:12:35,"As per @steveluscher's [astute diagnosis of a bug](https://github.com/facebook/relay/issues/768#issuecomment-193887941), we probably want to enforce that fields specified as `connectionName` actually correspond to real connections (ie. with `isConnection` metadata set to `true`).
",wincent,steveluscher
898,2016-03-03 15:32:48,"Thanks for working on this. Eventually we won't need a reset method because you will just create a new RelayContext instead. I'm not sure if we want to add an API that we'll delete so soon, but in this case there is enough demand that it might be best to proceed. Let's get some feedback here before proceeding. 

Cc @wincent 
",josephsavona,wincent
895,2016-03-02 23:40:37,"Note: this is inspired by and partially based on @iamchenxin's work in #767 and #844. Thanks for the head start!

Relay currently assumes that identifying argument values are strings (numbers _sort_ of work, but not really). This builds on #894 (which added support to the plugin for parsing/printing literal InputObjects) by allowing identifying arguments to be basically anything - boolean, number, string, or array/object of the the same.

Key changes include:
- Change the `CallValue` type from mixed to an explicit list of the supported types
- Change `forEachRootCallArg` to return both the literal JS value of the argument as well as a serialized key
- Change all callers of `forEachRootCallArg` (and some places that manually inspected the identifying arg) to correctly choose between the identifying argument value (i.e. when constructing a query with it) or the identifying argument key (for use with `RelayRecordStore.{putDataID,getDataID}`).
- Added tests that the writer correctly creates root records for queries with non-string identifying arguments.
",josephsavona,iamchenxin
894,2016-03-02 21:36:20,"cc @iamchenxin 
",josephsavona,iamchenxin
884,2016-02-29 18:07:21,"cc @wincent 
",josephsavona,wincent
881,2016-02-25 17:40:32,"per discussion with @zpao 
",josephsavona,zpao
877,2016-02-24 08:11:08,"0.9.0-fb3 comes with all those sweet npm3 fixes. Also see #840 and #832.

Tests are passing for me on node4 both with npm2 and npm3.

See https://github.com/facebook/jest/commit/7b44ca0ab0270fe453a3c84cb1799fcac20993e9 and https://github.com/facebook/jest/commit/2d10421baf79081ce698791023360144fb595a27

cc @jkassens @raineroviir
",cpojer,raineroviir
870,2016-02-23 18:26:48,"Thanks for reporting this. Technically IDs/strings are equivalent, and a single string literal is valid at a location that accepts an array of strings. This suggests that a `ID!` should flow into `[String]` and Relay is producing not-invalid queries. 

@leebyron @dschafer can you confirm?
",josephsavona,dschafer
868,2016-02-22 22:06:13,"cc @josephsavona what I mentioned IRL at react conf
",clayallsopp,josephsavona
863,2016-02-22 07:13:55,"Thanks for filing this; this is really two issues in one. First is that it's hard to read the machine-generated queries, which we've optimized more for byte-size than we have for debugging. Second, there's the need to debug queries at all - please let us know when you encounter issues so we can also try to address these via documentation, fixes, etc.

As for printing readable queries, we'd like to keep the printed output as consistent and minimal as possible. However, a middle ground could be to offer a way to transform the current printer output into something more readable. If `printRelayOSSQuery` returned a nullable fragment map of printed fragment name -> original fragment name, then it would be possible to rewrite the printed query (swapping `...F0` for the corresponding name). You could use this in DEV, for example, to help debug. In production the map wouldn't be returned (hence making it nullable) to avoid the overhead of allocating this mapping.

@yungsters thoughts?
",josephsavona,yungsters
863,2016-05-10 16:17:25,"@yuzhi recently added an option where queries are printed with newlines/spacing in DEV mode. Might be worth also printing the fragment name in DEV too (plus the hashed value as a prefix/suffix, which is necessary to distinguish multiple copies of the same fragment that may have different variables).
",josephsavona,yuzhi
854,2016-02-21 00:40:09,"what's up with the bot? Is it dead? @yungsters 
",cpojer,yungsters
848,2016-02-18 05:22:47,"In the second gist there are multiple records that have `id: {}` - which means that either invalid data is being returned by the server - IDs should be strings - or prepareData is somehow transforming it incorrectly. I noticed that in the first paste the results do not have these malformed IDs, which also suggests that it is the transform step. Can you confirm that the IDs are correct prior to the transform step? It might be worth digging into isomorphic- relay to see where the ID objects are being generated (or maybe file an issue on that repo and link it here?)

Cc @denvned
",josephsavona,denvned
844,2016-02-17 02:30:38,"@steveluscher Thank you,i will fix them all this evening.
",iamchenxin,steveluscher
844,2016-02-17 16:05:36,"@steveluscher Need one more day to complete this. 
Find that acceptting objects need to modify `babel-relay-plugin`.  
Seems at now Relay makes the argument as an array:  
 `(first:5 )` ->



I think maybe the object-arg would be placed as a value for key 'callValue' ?

From [RelayQLPrinter.js#L466](https://github.com/facebook/relay/blob/master/scripts/babel-relay-plugin/src/RelayQLPrinter.js#L466) and [RelayQLAST.js#L361](https://github.com/facebook/relay/blob/master/scripts/babel-relay-plugin/src/RelayQLAST.js#L361) ,it seems there is no ObjectType support at all level RelayQLArgument.  
Will add them tomorrow, maybe will modify another files which interactive with `RelayQLArgument`.
",iamchenxin,steveluscher
844,2016-02-17 18:40:33,"@steveluscher Need help , When i use [t.valueToNode](https://github.com/facebook/relay/blob/master/scripts/babel-relay-plugin/src/babelAdapter.js#L35) from `babelAdapter` , Pass a number type to it still return something like `{""type"":""Literal"",""value"":` .  
How could i make it return a numberType. What implement  the `valueToNode` use.

Its my first time to look into a babel plugin,so there are so much things i do not known.
I search the modules of `babel-relay-plugin`  find a function `Literal(node)` in babel's `inferers.js`



And i search the [babel-handbook](https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md) ,find some function like `t.numberLiteral`.

Go to sleep,see you tomorrow,thanks.

---

**Seems i have wrong typing .. `t.valueToNode` is okay( return number type) , will recheck this tomorrow.**
",iamchenxin,steveluscher
844,2016-02-18 17:59:37,"@steveluscher Almost done. and need some help. 
Did not find the function to let plugin generate Array `[]` . So i template write `[]` as key-value [RelayQLPrinter.js#L556](https://github.com/iamchenxin/relay/blob/fixGraphQLFragment/scripts/babel-relay-plugin/src/RelayQLPrinter.js#L556). Need to modify it tomorrow evening.
And i also a bit confused where to test the `getDataID` for new types.
",iamchenxin,steveluscher
844,2016-02-20 20:05:18,"@josephsavona @steveluscher 
Maybe i should learn jest first, i do unit test whole night by hand, have no idea why `stableStringifyTmp.js` be mocked by some test files.(but when i touched that file,it suddenly can require the real  `stableStringifyTmp.js`).   (temporary rename my function to `stableStringifyTmp` ,later,i should check if it is work right by using `stableStringify`).

Now the only failed test is this:



CheckinSearchInput! vs CheckinSearchInput ( should check this,tomorrow)

And i have not set the webstorm right for eslint, so i will modify the code style later by hand,when i finish them. (i need to search how to get webstorm load the eslint plugins ?).
",iamchenxin,josephsavona
844,2016-02-20 20:05:18,"@josephsavona @steveluscher 
Maybe i should learn jest first, i do unit test whole night by hand, have no idea why `stableStringifyTmp.js` be mocked by some test files.(but when i touched that file,it suddenly can require the real  `stableStringifyTmp.js`).   (temporary rename my function to `stableStringifyTmp` ,later,i should check if it is work right by using `stableStringify`).

Now the only failed test is this:



CheckinSearchInput! vs CheckinSearchInput ( should check this,tomorrow)

And i have not set the webstorm right for eslint, so i will modify the code style later by hand,when i finish them. (i need to search how to get webstorm load the eslint plugins ?).
",iamchenxin,steveluscher
844,2016-02-21 05:58:15,"@josephsavona Now , i mainly confused by some mechanism of Relay's unit test. I can not get the node-debug or bugger worked for unit test .and also I need to learn lots of things (jest , flow, babel-plugin ~~).
And need some help! the file `stableStringifyTmp` i wrote, cannt be require-actual ,in some unit test file. ( seems in that file `stableStringifyTmp` will be auto mocked, but if i modified  any character in that file,and save the file, suddenly the  real  `stableStringifyTmp` will be used rightly. How could i solve this problem？what things does i miss)
",iamchenxin,josephsavona
844,2016-02-22 15:09:26,"@josephsavona Finished . 
Merge my function to `stableStringify`. and extend original `stableStringify` for possible expansions later.
But stay the returned string from `stableStringify`  to be a none standard JSON. Cause some unit test files assume the returned string has a raw `key` style. See : 
 [stableStringify.js#L107](https://github.com/iamchenxin/relay/blob/fixGraphQLFragment/src/query/stableStringify.js#L107) -> [stableStringify.js#L49](https://github.com/iamchenxin/relay/blob/fixGraphQLFragment/src/query/stableStringify.js#L49)
",iamchenxin,josephsavona
844,2016-02-24 18:46:05,"@josephsavona @steveluscher I test this fix in real relay project. And find something strange,this is the last point do not support object. [forEachRootCallArg](https://github.com/facebook/relay/commit/425f309e82976b974d291e63b4676ff9d45d4390#diff-41479ecf3670e4e60511fb37625a0e1aR54) 
In this function , i modified the code from old `fn('' + identifyingArgValue)` to fn( identifyingArgValue), but when test with an object arg, the `identifyingArgValue` was still automaticly converted to `[object object]` , im not sure why this will happen, its just a callback (an arrow function from [RelayOSSNodeInterface.js#L83](https://github.com/facebook/relay/blob/425f309e82976b974d291e63b4676ff9d45d4390/src/interface/RelayOSSNodeInterface.js#L83) ),when the `identifyingArgValue` passed in its immediately turned to a `[object object]`
",iamchenxin,steveluscher
826,2016-02-10 23:46:51,"Another thing that was confusing was that the configuration for the effects of a mutation are all written and stored on the client, when they are tightly coupled to the what the mutation actually affects when run on the server. For something like:



All of that seems like effect logic that the server is actual the root source of truth for. It seems like the only time that code would change would be when the mutation on the server changed. And with that in mind, it seems weird for every Relay client that is interacting with the server to have to rewrite that logic (or go to the trouble of sharing it in a separate library, in the case of a publicly consumed GraphQL/Relay API…)

Why not let the server opt-in to support Relay by passing back that information with the returned values of the mutation. Something like this inside the mutation resolver:



(Or even something more descriptive than `relay` since that logic seems pretty framework-agnostic, as long as it remains completely declarative.)

If we were able to move that logic to the server, the clients would become a lot simpler, and each new client wouldn’t have to reimplement the same “config” code that is inherent to the actions the server is performing itself, making it even easier to get started once you have a Relay-ready server implementation.

There’s a good chance I’m missing something here :)

I now see that other issues have been created with this thought: https://github.com/facebook/relay/issues/489 https://github.com/facebook/relay/issues/293 https://github.com/facebook/relay/issues/125. And that there's a meta issue summarizing them: https://github.com/facebook/relay/issues/538!

In https://github.com/facebook/relay/issues/125 @yuzhi alluded to `getConfigs` being needed for the optimistic responses to be implemented, and those are always going to be purely client-side I'd imagine, so that's a limitation. In that case, I think it would be great to get the server to contain the logic in the schema definition, and for the client to just use it (like it does with the Schema definition itself). 

If there was a way to augment GraphQL for this to all happen with introspection, that would seem to be the cleanest solution—as long as it doesn't muddy up GraphQL. Seems like a way of attaching metadata to a type or query or mutation isn't crazy. Otherwise, maybe there's a separate Relay schema that a server could implement to keep all of that logic in one place, and not require it to be reimplemented by each client.
",ianstormtaylor,yuzhi
814,2016-02-10 16:27:03,"cc @wincent - who recently changed internal metadata key names in a way that I believe would avoid this.
",josephsavona,wincent
810,2016-02-09 18:14:57,"This PR is another step toward making all Relay state contextual (#558). Originally this was submitted as a part of #683, but @josephsavona [suggested](https://github.com/facebook/relay/pull/683#issuecomment-166386149) to split it to smaller PRs.
",denvned,josephsavona
810,2016-02-19 22:14:53,"Updated with the master.

Tests started failing recently. Looks like Jest can't find `ReactDOMServer`.
Cc @cpojer 
",denvned,cpojer
806,2016-02-08 19:03:31,"This is something we've explored and may implement going forward. The performance benefits - especially in terms of network bytes - are not necessarily what you'd expect, however. @wincent did some analysis here and can probably share more.
",josephsavona,wincent
800,2016-02-07 00:51:45,"@josercruz01 take a look at this :)
",daemonsy,josercruz01
791,2016-02-05 17:28:23,"@cpojer any idea why the previous version was working internally but not in OSS?
",josephsavona,cpojer
784,2016-02-02 03:44:02,"Please see the issue originally filed by @fson at https://github.com/graphql/graphql-js/issues/263 where Relay could generate an invalid query:


",leebyron,fson
784,2016-02-05 22:48:30,"There are two basic approaches here:
- Flatten the query prior to printing it.
- Print duplicated fields, but in a way that passes validation. Based on @leebyron's example this would mean printing:
  query ($orderBy: _GroupOrdering) {
    viewer {
      allGroups_...: allGroups(orderBy: $orderBy) { count }
      allGroups_...: allGroups(orderBy: $orderBy) { count } # same variable name when value is same
    }
  }

Flattening the query requires a full extra traversal (O(n) operation), so this isn't tenable from a performance perspective. The simpler solution would be to avoid creating new variables when the values are actually the same. This could be achieved by keeping a map in `printRelayQuery` of serialized value -> variable name, and only generating new variables if the current value is not already a key in the map. This logic would go in [`createVariable`](https://github.com/facebook/relay/blob/master/src/traversal/printRelayOSSQuery.js#L298-L310)

@ryancole or @fson any interest in submitting a PR for this? ;-)
",josephsavona,fson
782,2016-02-10 03:16:31,"A generalized version of the problem is as follows. Data is loaded via some fragment:



Note that a given attachment record could also be loaded in other places in the app, perhaps in a list of documents:



This means that it's possible to have a tracked `fragment on Other` for some attachment, such that it could generate the following mutation query, where a `FIELDS_CHANGE` config sets the `id` for field `attachment` to be some `Attachment` record:



Relay cannot skip tracking the `... on Other` fragment since it _is_ a valid fragment that should be refetched in some cases, depending on the mutation. Relay also doesn't have enough information to know which tracked fragments can or can't be included in the mutation query (without having access to the full type hierarchy, which is impractical to load in the client).

This suggests a two-part solution:
1. Mutation fields must have generic types, e.g. the `attachment` field on the above mutation would have to be typed as `Node`, rather than `Attachment`. Relay could warn if it finds a mutation field with a specific type, although this requires both the fat query and config, and therefore may not be feasible to test during the build stage.
2. Relay should construct queries by wrapping any tracked fields (as opposed to fragments) within a fragment with the record's type. In this case, it would generate a mutation query such as:



This would impose an extra restriction on GraphQL schema, so I'm still curious if there is an alternative.

cc @wincent @yuzhi 
",josephsavona,yuzhi
782,2016-02-10 03:16:31,"A generalized version of the problem is as follows. Data is loaded via some fragment:



Note that a given attachment record could also be loaded in other places in the app, perhaps in a list of documents:



This means that it's possible to have a tracked `fragment on Other` for some attachment, such that it could generate the following mutation query, where a `FIELDS_CHANGE` config sets the `id` for field `attachment` to be some `Attachment` record:



Relay cannot skip tracking the `... on Other` fragment since it _is_ a valid fragment that should be refetched in some cases, depending on the mutation. Relay also doesn't have enough information to know which tracked fragments can or can't be included in the mutation query (without having access to the full type hierarchy, which is impractical to load in the client).

This suggests a two-part solution:
1. Mutation fields must have generic types, e.g. the `attachment` field on the above mutation would have to be typed as `Node`, rather than `Attachment`. Relay could warn if it finds a mutation field with a specific type, although this requires both the fat query and config, and therefore may not be feasible to test during the build stage.
2. Relay should construct queries by wrapping any tracked fields (as opposed to fragments) within a fragment with the record's type. In this case, it would generate a mutation query such as:



This would impose an extra restriction on GraphQL schema, so I'm still curious if there is an alternative.

cc @wincent @yuzhi 
",josephsavona,wincent
782,2016-02-23 06:34:54,"@NevilleS Yes, the general shape of the solution - wrapping tracked fields in conditioning fragments - is correct. It isn't exactly clear what the most efficient way to determine the fragment type to wrap the field in (perhaps we have to store the parent field type of a fragment when we track it?). 

cc @wincent who is focusing on simplifying mutations - he might have more ideas here.
",josephsavona,wincent
782,2016-02-23 07:03:44,"Actually, I was thinking I'd be able to just use the type of the node in
the mutation payload, unrelated to the tracked fragments. This means the
query tracking is unaffected and only the mutation query building logic
needs to be aware of this.

I haven't tried anything yet though - is it possible to get the type
information of the mutation payload at runtime? Is that stored at all?

On Tue, Feb 23, 2016, 1:35 AM Joseph Savona notifications@github.com
wrote:

> @NevilleS https://github.com/NevilleS Yes, the general shape of the
> solution - wrapping tracked fields in conditioning fragments - is correct.
> It isn't exactly clear what the most efficient way to determine the
> fragment type to wrap the field in (perhaps we have to store the parent
> field type of a fragment when we track it?).
> 
> cc @wincent https://github.com/wincent who is focusing on simplifying
> mutations - he might have more ideas here.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/782#issuecomment-187568438.
",NevilleS,wincent
782,2016-03-28 20:43:29,"> I believe what needs to happen is some way to carry the ""type"" information through from the babelRelayPlugin so that it is available in the Relay AST when constructing the mutation query,

@NevilleS  `babel-relay-plugin` records the type information for every node, along with whether the type is abstract or concrete - these can be accessed with `getType(): string` and `isAbstract(): boolean` on fields/fragments/queries. Can you put up a PR for your commit that you referenced above? That way we can import it easily and experiment.

cc @wincent this was the issue i mentioned the other day
",josephsavona,wincent
775,2016-03-27 03:35:54,"Thanks for your patience on this issue. We've looked into it several times - I tried to repro, @steveluscher tried to repro, we hacked on it together - and it seems like there is a gap between our understanding of the problem and your actual use case (what we tried worked). 

I understand that it's a bit time consuming, but it would help to have a clear repro of the issue.  Either a full Relay playground link, or a failing unit test, would help us clarify exactly what's happening and determine a solution. 
",josephsavona,steveluscher
768,2016-03-08 17:49:23,"So, here's what I think is going on here.

`NODE_DELETE`, `RANGE_DELETE`, and `RANGE_ADD` depend on the thing you're targeting being a connection (having `isConnection` metadata added to it by the Babel Relay plugin). I suspect that your `postsConnection` isn't acquiring this metadata because it's not a real connection (you've rolled your own offset/limit solution that deviates from the spec somewhat). Look at how your printed `comments` field has `isConnection: true` while your 'posts' field does not. This might be because your `pageInfo` type has the type “paginationInfo” rather than “PageInfo”, but I didn't dig much deeper after figuring out that your posts aren't being stored in the Relay store as a bonafide connection.

We should probably do something here to check that `connectionName` actually represents a bonafide connection. I'll talk to @wincent about this.

Because it's not a connection, `NODE_DELETE` kills the node but not the edge. What you end up with, until the server comes back with what appears to be an ‘overfetched’ response (see #769), is a deleted node and an intact edge. That's why your post re-renders, but has no data, causing the exception.

I think what you want in this case is either to:
1. Find a way to make `posts` register as a bonafide connection
2. Use `FIELDS_CHANGE` and actually return a new set of edges in your optimistic response with the deleted edge removed. This is probably unsuitable for other reasons – it might be hard to ‘pull up’ results from the next page before the server returns.

Side note: make sure that when you return `deletedId` you use the global ID:


",steveluscher,wincent
767,2016-01-26 16:16:31,"@steveluscher thoughts on this? The restriction on string arguments is largely arbitrary, how hard would it be to just allow any type?
",josephsavona,steveluscher
766,2016-01-26 00:35:09,"cc @dylanahsmith
",eapache,dylanahsmith
764,2016-01-26 05:45:26,"@josephsavona rebased
",iamchenxin,josephsavona
761,2016-01-22 21:17:35,"This PR is another step toward making all Relay state contextual (#558). Originally this was submitted as a part of #683, but @josephsavona [suggested](https://github.com/facebook/relay/pull/683#issuecomment-166386149) to split it to smaller PRs.
",denvned,josephsavona
760,2016-01-21 16:18:31,"We have a graphql server (not written in javascript) serving a paginated list of objects. We're trying to conform to the relay specification, but we've hit a few interesting cases that need clarification.
1. `startCursor` and `endCursor` show up in a few examples but not in any official docs; based on my reading of #372 those fields are basically deprecated and we don't have to implement them?
2. Are cursors allowed to depend on other inputs to the connection? Similar to https://github.com/graphql/graphql-relay-js/issues/20, our connection takes a `sort_key` argument that determines the sort order of the returned list. Depending on the specified sort order, the edge for an object may return different cursor values (since the server needs different information in each case to determine the next object). However, a careful reading of https://facebook.github.io/relay/docs/guides-mutations.html#range-add suggests this is not permitted; mutations that return a newly created edge must return a single cursor that can be universally applied to all possible lists in which that edge may appear? How does facebook solve this problem?

cc @dylanahsmith
",eapache,dylanahsmith
754,2016-09-03 18:49:44,"@fabiomcosta Thanks for confirming. I'm going to close as the use of this feature completely disables the caching that caused the bug - feel free to file a new issue if there are any remaining problems!
",josephsavona,fabiomcosta
749,2016-01-25 19:20:04,"@pra85 Thanks so much for taking the initiative to do this! @wincent noticed that our other projects are using `-present` to avoid the necessity for yearly updates. What do you think about moving forward with that change (#757) instead?
",josephsavona,wincent
747,2016-01-15 15:05:02,"Currently Flux is only mentioned once in the Relay docs (deep in the API reference for [Relay.Store](https://facebook.github.io/relay/docs/api-reference-relay-store.html#commitupdate-static-method)). I was initially very confused about the relationship between the Relay and Flux, and I don't think I'm alone.

I would be more than happy to help with the documentation here - I'd just like to hear what you'd like the official word on Flux w/r/t Relay to be.

For example, @josephsavona summed this up succinctly in #168 -

> Relay is an implementation of the Flux pattern

There is probably more to say, e.g. on the use of Flux alongside Relay for ephemeral client state (before #114 is closed).
",chrisbolin,josephsavona
743,2016-01-14 04:21:15,"Note that @taion has suggested a very simple way to achieve this type of pagination - see his comments and the discussion at https://github.com/facebook/relay/issues/540#issuecomment-155531357
",josephsavona,taion
741,2016-01-19 17:06:38,"@mattiasewers thanks for reporting this. We're aware of the compatibility issue with Relay in non-web environments - @skevy's pending #713 addresses the issue with `self`. For now, `isomorphic-relay` is a good workaround.
",josephsavona,skevy
740,2016-01-20 17:01:48,"Did we decide to change this to “non-negative integers” to allow for 0 to mean “fetch the first zero” (eg. fetch none)? @josephsavona @kassens 
",steveluscher,kassens
737,2016-03-31 23:27:57,"@josephsavona, any input on this?
",edvinerikson,josephsavona
732,2016-01-10 19:49:58,"@devknoll @steveluscher @josephsavona Will this replace the `babel-relay-plugin` on NPM ?
If so it should still be in sync with the version number of `react-relay` to avoid confusion ?!
But it looks like there is a `1.0.0` published to NPM - but `react-relay` is only `0.6.1`.
Can you please fix this or am I mistaken here?
",BerndWessels,steveluscher
732,2016-01-10 19:49:58,"@devknoll @steveluscher @josephsavona Will this replace the `babel-relay-plugin` on NPM ?
If so it should still be in sync with the version number of `react-relay` to avoid confusion ?!
But it looks like there is a `1.0.0` published to NPM - but `react-relay` is only `0.6.1`.
Can you please fix this or am I mistaken here?
",BerndWessels,josephsavona
725,2016-01-10 04:07:09,"Maybe @taion has some insight. 
",devknoll,taion
722,2016-01-27 20:12:47,"@josephsavona I changed it to make sure, that the item is only accessed after the invariant check. This what you meant, right?
",andimarek,josephsavona
722,2016-02-03 23:15:32,"@wincent @yuzhi Thoughts on this approach? Note that the equivalent function for reading range data returns both a filtered and unfiltered list of edges, but `getLinkedRecordID` returns the id regardless of the linked record's status. I'm torn about whether the filtering really belongs in the store or if it should happen at a higher level (such as the reader). Thoughts?
",josephsavona,yuzhi
722,2016-02-08 21:46:30,"@andimarek thanks for your patience on this PR. Summarizing an offline discussion with @yuzhi: It turns out that this change would have unintended consequences and we can't proceed with it as-is. The cache reader needs to know what IDs are linked, even if they don't exist in the store at the moment (this is why `getRangeMetadata` returns both a filtered and unfiltered list of edges). Filtering the IDs at the store level also changes which IDs are used to set up component subscriptions, and could cause components not to update when they should. 

A more appropriate place to add this logic would be in `readRelayQueryData` when reading the results for plural linked fields.
",josephsavona,yuzhi
720,2016-01-22 11:06:05,"@josephsavona any insights on this plzzz :)
",slorber,josephsavona
714,2016-02-01 23:08:03,"@skevy We resolved the conflict with our internal plugin, so we could proceed with reimporting this. However, @DmitrySoshnikov has recently added [an option to control plugin ordering](https://github.com/babel/babel/pull/3281#issuecomment-173684655) in babel. I haven't dug into the React Native OSS setup in a while, but I'm wondering if that same type of configuration would allow the Relay plugin to run before the default RN transforms?
",josephsavona,DmitrySoshnikov
714,2016-02-02 04:09:57,"This may not necessarily be needed anymore actually, with some changes that we've done on the RN side (we're going to use a preset now, which plays into taking advantage of @DmitrySoshnikov's changes). 

Will test when that gets merged in (should be tomorrow or so) and I'll report back. :-)

Thanks @josephsavona!
",skevy,DmitrySoshnikov
714,2016-02-05 18:53:45,"@josephsavona so as it turns out...presets still run before things defined in plugins...so really, @DmitrySoshnikov's doesn't help if we want to do this in babelrc:



This will still let `babel-plugin-transform-es2015-template-literals` (which is present in the preset) run before the Relay plugin, and thus still cause breakage.

The only way we'd be able to take advantage of `passPerPreset` is to actually create a `./babelRelayPlugin` preset. I guess you'd make it do something like:



And then do this in your .babelrc:



It would work...doesn't seem ideal though and seems kind of confusing. Thoughts?
",skevy,DmitrySoshnikov
714,2016-02-06 01:23:52,"> so really, @DmitrySoshnikov's doesn't help if we want to do this in babelrc

Yeah, if you have presets, and `passPerPreset`, then it should be something like:



These presets should run in order. However plugins within each preset are still merged.
",DmitrySoshnikov,DmitrySoshnikov
710,2015-12-30 03:09:14,"@yungsters could this have to do with the way we previously de-duped fragments when printing?
",josephsavona,yungsters
707,2015-12-30 02:38:22,"Cc @steveluscher as this related to his work on root calls
",josephsavona,steveluscher
706,2015-12-28 01:12:44,"Thanks for filing this. I'm not aware of any reason that we _can't_ support node 5.x, but others will know more.

cc @zpao
",josephsavona,zpao
699,2015-12-22 14:15:10,"This PR is another step toward making all Relay state contextual (#558). Originally this was submitted as a part of #683, but @josephsavona [suggested](https://github.com/facebook/relay/pull/683#issuecomment-166386149) to split it to smaller PRs.

Currently, Relay resolve mutations props using the global `RelayStore`, and store them in the `props` instance field of `RelayMutation`. That makes it impossible to contextualize Relay mutations without changing the public API.

<s>After analyzing different alternatives, I have found that the probably cleanest solution is not to store resolved mutation props in an instance field, but to pass them as an argument to each of the mutation methods. That way mutations can be reused in different `RelayStoreData` contexts, and also they can be reused in the same context but at different times, because props are re-resolved at each mutation execution.</s>
",denvned,josephsavona
699,2015-12-22 17:05:34,"Thanks for splitting this up. It makes it clear, however, that this is a breaking change for all existing mutations. The `RelayMutation` API indicates that mutations can access `this.props` - see the example at http://facebook.github.io/relay/docs/api-reference-relay-mutation.html#fragments-static-property-example - and this PR removes that property. 

We're going to need to think this through and find a way to not change the public API of mutations, or come up with a transition plan. 

cc @yungsters 
",josephsavona,yungsters
698,2015-12-22 04:46:49,"This PR is another step toward making all Relay state contextual (#558). Originally this was submitted as a part of #683, but @josephsavona [suggested](https://github.com/facebook/relay/pull/683#issuecomment-166386149) to split it to smaller PRs.
",denvned,josephsavona
694,2015-12-21 23:15:10,"@BerndWessels Where did you see this warning, and what version of npm and relay are you using?

cc @kassens 
",josephsavona,kassens
693,2015-12-21 19:43:21,"Thanks for reporting this. Relay removes deleted nodes from connections, and we should probably remove them from lists for consistency. In this case that would mean returning an empty list instead of a list of `[null]`. 

@yuzhi can you think of any reason we shouldn't/can't do this? Implementation-wise it's a matter of making `RelayRecordStore.getLinkedRecordIDs` filter out IDs where the record was deleted (we do this in `getRangeMetadata`).
",josephsavona,yuzhi
683,2015-12-15 18:48:35,"This PR is meant to finish the work started by @devknoll on contextualizing the Relay store. The previous his attempt on that was #603, but he didn't have enough time to finish that soon, so he gave me a permission to continue his work.

Escape from the global Relay store is very important for server side rendering (https://github.com/denvned/isomorphic-relay/issues/6). It also solves the problem of resetting Relay store (#233).

I tried to make this PR as simple as possible to make the initial review easier. That's why there are few things not included yet:
- Unit tests for change of `relayContext` property.
- Updated docs.
- Updated examples.
- Fixed references to changed API in the code comments.

I removed the global Relay store singleton altogether to make sure it is not used anywhere. But it might  make sense to add placeholders for replaced API with deprecation messages, for backward compatibility (like [here](https://github.com/devknoll/relay/blob/0d545bb0b833d1631f55e4bc2fb8919ec898c005/src/store/RelayStore.js)).
",denvned,devknoll
679,2015-12-14 20:58:21,"cc. @steveluscher who know the most about the playground
",yuzhi,steveluscher
676,2015-12-11 04:01:36,"The `RelayStore` has the idea of a `CacheManager` which sets as a layer in the store hierarchy:
- queued : place optimistic mutations go
- records : normal cache where query responses go
- cache : `your thingy goes here`

When you issue a query to the store it takes the first result it hits -- so your cache manager layer would sit at the bottom and be able to handle data requests _before_ anything goes to the network layer.

I haven't done anything with this, so could be 100% wrong, but @steveluscher mentioned it in his meetup talk.  I believe it would allow you to save this to local storage or any other place that would be longer lasting than the normal store layer.
",eyston,steveluscher
676,2015-12-22 17:33:11,"good question. cc @sebmck @amasad @DmitrySoshnikov 
",josephsavona,DmitrySoshnikov
676,2015-12-22 17:33:11,"good question. cc @sebmck @amasad @DmitrySoshnikov 
",josephsavona,amasad
656,2015-12-06 19:51:18,"Hi
@josephsavona mentioned [here](https://github.com/facebook/relay/issues/635) that this should have been fixed with version 0.6.0 - but unfortunately is seem not to be fixed.

Can you please have a look again. It prevents us from upgrading beyond `0.3.0` at all.

Here are the details again with how to reproduce.

The problem comes when upgrading from `babel-relay-plugin(-loader)` `0.3.0` to `0.4.0`, `0.4.1` or `0.6.0`.

With `0.3.0` everything works just fine but with `0.6.0` I get this error in Chrome:

`Uncaught TypeError: Cannot read property 'length' of undefined`

relay.0.4.0.js in line 5394

`if (GraphQL.isQuery(node) && node.fragments.length === 0) {`

The problem is that the `node` object does not have a fragments property.

![relay040](https://cloud.githubusercontent.com/assets/1776695/11459451/aa8a02f0-973b-11e5-9a33-a269e50781bd.png)

You can easily reproduce it yourself with my [Git Repo](https://github.com/BerndWessels/react-webpack).

To reproduce just change the dependencies in `package.json` to

`""babel-relay-plugin"": ""^0.6.0""`
`""babel-relay-plugin-loader"": ""^0.6.0""`
`""react-relay"": ""^0.6.0""`

Setup and run:

`npm install`

Change `data/database/db.js` to point to your mysql/postgres database:



Create some sample data:

babel-node ./scripts/databaseCreate.js

Create the schema:
`npm run schema:update`

Then in one console run:
`npm run schema:serve`

and in another console run:
`npm start`

Now you will see the error in the Chrome DevTools.

Thank you
Bernd
",BerndWessels,josephsavona
655,2015-12-22 01:35:15,"I think that the refetch problem was fixed by e2b533b47ffb33d701ac288679fd18c6846fdc5c, but now I'm seeing a different problem on [this playground](http://facebook.github.io/relay/prototyping/playground.html#source=%2F**%0A%20*%20Copyright%202013-2015%2C%20Facebook%2C%20Inc.%0A%20*%20All%20rights%20reserved.%0A%20*%0A%20*%20This%20source%20code%20is%20licensed%20under%20the%20BSD-style%20license%20found%20in%20the%0A%20*%20LICENSE%20file%20in%20the%20root%20directory%20of%20this%20source%20tree.%20An%20additional%20grant%0A%20*%20of%20patent%20rights%20can%20be%20found%20in%20the%20PATENTS%20file%20in%20the%20same%20directory.%0A%20*%2F%0A%0Aclass%20VocabList%20extends%20React.Component%20%7B%0A%20%20componentDidMount%28%29%20%7B%0A%20%20%20%20var%20self%20%3D%20this%3B%0A%20%20%20%20setInterval%28function%28%29%20%7B%0A%20%20%20%20%20%20self.props.relay.forceFetch%28%29%3B%0A%20%20%20%20%7D%2C%201500%29%3B%0A%20%20%7D%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20%7B%20vocabulary%20%7D%20%3D%20this.props%3B%0A%20%20%20%20return%20%28%0A%20%20%20%20%20%20%3Cul%3E%0A%20%20%20%20%20%20%20%20%7Bvocabulary.edges.map%28edge%20%3D%3E%20%28%0A%20%20%20%20%20%20%20%20%20%20%3Cli%3E%7Bedge.node.content%7D%3C%2Fli%3E%0A%20%20%20%20%20%20%20%20%29%29%7D%0A%20%20%20%20%20%20%3C%2Ful%3E%0A%20%20%20%20%29%3B%0A%20%20%7D%0A%7D%0A%0A%0Aclass%20Novel%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20var%20%7B%20novel%20%7D%20%3D%20this.props%3B%0A%20%20%20%20return%20%28%0A%20%20%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%20%20%3Ch2%3EWords%20you%20can%20use%20in%20this%20novel%3A%3C%2Fh2%3E%0A%20%20%20%20%20%20%20%20%3CVocabList%20vocabulary%3D%7Bnovel.vocabulary%7D%20%2F%3E%0A%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%29%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20HelloApp%20extends%20React.Component%20%7B%0A%20%20render%28%29%20%7B%0A%20%20%20%20%2F%2F%20Relay%20will%20materialize%20this%20prop%20based%20on%20the%0A%20%20%20%20%2F%2F%20result%20of%20the%20query%20in%20the%20next%20component.%0A%20%20%20%20return%20%3CNovel%20novel%3D%7Bthis.props.novel%7D%20%2F%3E%3B%0A%20%20%7D%0A%7D%0A%0AVocabList%20%3D%20Relay.createContainer%28VocabList%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20vocabulary%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20VocabTermConnection%20%7B%0A%20%20%20%20%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20content%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%0ANovel%20%3D%20Relay.createContainer%28Novel%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20novel%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Novel%20%7B%0A%20%20%20%20%20%20%20%20vocabulary%28first%3A%2020%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%24%7BVocabList.getFragment%28'vocabulary'%29%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%2C%0A%7D%29%3B%0A%0AHelloApp%20%3D%20Relay.createContainer%28HelloApp%2C%20%7B%0A%20%20fragments%3A%20%7B%0A%20%20%20%20%2F%2F%20This%20GraphQL%20query%20executes%20against%0A%20%20%20%20%2F%2F%20the%20schema%20in%20the%20'schema'%20tab%20above.%0A%20%20%20%20%2F%2F%0A%20%20%20%20%2F%2F%20To%20learn%20more%20about%20Relay.QL%2C%20visit%3A%0A%20%20%20%20%2F%2F%20%20%20https%3A%2F%2Ffacebook.github.io%2Frelay%2Fdocs%2Fapi-reference-relay-ql.html%0A%20%20%20%20novel%3A%20%28%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20fragment%20on%20Novel%20%7B%0A%20%20%20%20%20%20%20%20%24%7BNovel.getFragment%28'novel'%29%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%0A%7D%29%3B%0A%0Aclass%20HelloRoute%20extends%20Relay.Route%20%7B%0A%20%20static%20routeName%20%3D%20'Hello'%3B%20%20%2F%2F%20A%20unique%20name%0A%20%20static%20queries%20%3D%20%7B%0A%20%20%20%20%2F%2F%20Here%2C%20we%20compose%20your%20Relay%20container's%0A%20%20%20%20%2F%2F%20'greetings'%20fragment%20into%20the%20'greetings'%0A%20%20%20%20%2F%2F%20field%20at%20the%20root%20of%20the%20GraphQL%20schema.%0A%20%20%20%20novel%3A%20%28Component%29%20%3D%3E%20Relay.QL%60%0A%20%20%20%20%20%20query%20NovelQuery%20%7B%0A%20%20%20%20%20%20%20%20novel%28novelId%3A%20%221%22%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%24%7BComponent.getFragment%28'novel'%29%7D%2C%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%60%2C%0A%20%20%7D%3B%0A%7D%0A%0AReactDOM.render%28%0A%20%20%3CRelay.RootContainer%0A%20%20%20%20Component%3D%7BHelloApp%7D%0A%20%20%20%20route%3D%7Bnew%20HelloRoute%28%29%7D%0A%20%20%2F%3E%2C%0A%20%20mountNode%0A%29%3B%0A&schema=%2F**%0A%20*%20Copyright%202013-2015%2C%20Facebook%2C%20Inc.%0A%20*%20All%20rights%20reserved.%0A%20*%0A%20*%20This%20source%20code%20is%20licensed%20under%20the%20BSD-style%20license%20found%20in%20the%0A%20*%20LICENSE%20file%20in%20the%20root%20directory%20of%20this%20source%20tree.%20An%20additional%20grant%0A%20*%20of%20patent%20rights%20can%20be%20found%20in%20the%20PATENTS%20file%20in%20the%20same%20directory.%0A%20*%2F%0A%0Aimport%20%7B%0A%20%20GraphQLObjectType%2C%0A%20%20GraphQLSchema%2C%0A%20%20GraphQLString%2C%0A%20%20GraphQLNonNull%0A%7D%20from%20'graphql'%3B%0A%0Aimport%20%7B%0A%20%20connectionArgs%2C%0A%20%20connectionDefinitions%2C%0A%20%20connectionFromArray%2C%0A%20%20fromGlobalId%2C%0A%20%20globalIdField%2C%0A%20%20nodeDefinitions%2C%0A%7D%20from%20'graphql-relay'%3B%0A%0Aclass%20Novel%20extends%20Object%20%7B%7D%0Aclass%20VocabTerm%20extends%20Object%20%7B%7D%0Avar%20novel%20%3D%20new%20Novel%28%29%3B%0Anovel.id%20%3D%20'1'%3B%0A%0Avar%20vocabulary%20%3D%20%5B%5D%3B%0A%0A%28function%28%29%20%7B%0A%20%20var%20vocabTerm1%20%3D%20new%20VocabTerm%28%29%3B%0A%20%20vocabTerm1.id%20%3D%20'1'%3B%0A%20%20vocabTerm1.content%20%3D%20%22hello%22%3B%0A%20%20vocabulary.push%28vocabTerm1%29%3B%0A%20%20var%20vocabTerm2%20%3D%20new%20VocabTerm%28%29%3B%0A%20%20vocabTerm2.id%20%3D%20'2'%3B%0A%20%20vocabTerm2.content%20%3D%20%22world%22%3B%0A%20%20vocabulary.push%28vocabTerm2%29%3B%0A%7D%29%28%29%3B%0A%0Afunction%20getNovel%28id%29%20%7B%0A%20%20return%20novel%3B%0A%7D%0A%0Afunction%20getVocabTerm%28id%29%20%7B%0A%20%20return%20vocabulary%5Bid-1%5D%3B%0A%7D%0A%0Afunction%20getVocabulary%28%29%20%7B%0A%20%20return%20vocabulary%3B%0A%7D%0A%0Avar%20%7BnodeInterface%2C%20nodeField%7D%20%3D%20nodeDefinitions%28%0A%20%20%28globalId%29%20%3D%3E%20%7B%0A%20%20%20%20var%20%7Btype%2C%20id%7D%20%3D%20fromGlobalId%28globalId%29%3B%0A%20%20%20%20if%20%28type%20%3D%3D%3D%20'Novel'%29%20%7B%0A%20%20%20%20%20%20return%20getNovel%28id%29%3B%0A%20%20%20%20%7D%20else%20if%20%28type%20%3D%3D%3D%20'VocabTerm'%29%20%7B%0A%20%20%20%20%20%20return%20getVocabTerm%28id%29%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20return%20null%3B%0A%20%20%20%20%7D%0A%20%20%7D%2C%0A%20%20%28obj%29%20%3D%3E%20%7B%0A%20%20%20%20if%20%28obj%20instanceof%20Novel%29%20%7B%0A%20%20%20%20%20%20return%20NovelType%3B%0A%20%20%20%20%7D%20else%20if%20%28obj%20instanceof%20VocabTerm%29%20%7B%0A%20%20%20%20%20%20return%20VocabTermType%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20return%20null%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%29%3B%0A%0Avar%20VocabTermType%20%3D%20new%20GraphQLObjectType%28%7B%0A%20%20name%3A%20'VocabTerm'%2C%0A%20%20fields%3A%20%28%29%20%3D%3E%20%28%7B%0A%20%20%20%20id%3A%20globalIdField%28'VocabTerm'%29%2C%0A%20%20%20%20content%3A%20%7Btype%3A%20GraphQLString%7D%2C%0A%20%20%7D%29%2C%0A%20%20interfaces%3A%20%5BnodeInterface%5D%2C%0A%7D%29%3B%0A%0Avar%20NovelType%20%3D%20new%20GraphQLObjectType%28%7B%0A%20%20name%3A%20'Novel'%2C%0A%20%20fields%3A%20%28%29%20%3D%3E%20%28%7B%0A%20%20%20%20id%3A%20globalIdField%28'Novel'%29%2C%0A%20%20%20%20vocabulary%3A%20%7B%0A%20%20%20%20%20%20type%3A%20vocabTermConnection%2C%0A%20%20%20%20%20%20args%3A%20connectionArgs%2C%0A%20%20%20%20%20%20resolve%3A%20%28novel%2C%20args%29%20%3D%3E%20connectionFromArray%28getVocabulary%28%29%2C%20args%29%2C%0A%20%20%20%20%7D%2C%0A%20%20%7D%29%2C%0A%20%20interfaces%3A%20%5BnodeInterface%5D%2C%0A%7D%29%3B%0A%0Avar%20%7BconnectionType%3A%20vocabTermConnection%7D%20%3D%0A%20%20connectionDefinitions%28%7Bname%3A%20'VocabTerm'%2C%20nodeType%3A%20VocabTermType%7D%29%3B%0A%0Aexport%20default%20new%20GraphQLSchema%28%7B%0A%20%20query%3A%20new%20GraphQLObjectType%28%7B%0A%20%20%20%20name%3A%20'Query'%2C%0A%20%20%20%20fields%3A%20%28%29%20%3D%3E%20%28%7B%0A%20%20%20%20%20%20node%3A%20nodeField%2C%0A%20%20%20%20%20%20novel%3A%20%7B%0A%20%20%20%20%20%20%20%20type%3A%20NovelType%2C%0A%20%20%20%20%20%20%20%20args%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20novelId%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20type%3A%20new%20GraphQLNonNull%28GraphQLString%29%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20Here%20we%20define%20a%20resolver%20that%20returns%0A%20%20%20%20%20%20%20%20%2F%2F%20the%20data%20defined%20above.%20Were%20this%20schema%0A%20%20%20%20%20%20%20%20%2F%2F%20executing%20on%20the%20server%20side%2C%20you%20could%0A%20%20%20%20%20%20%20%20%2F%2F%20write%20a%20resolve%20method%20that%20fetches%0A%20%20%20%20%20%20%20%20%2F%2F%20live%20data%20from%20a%20database.%0A%20%20%20%20%20%20%20%20resolve%3A%20%28root%2C%20%7BnovelId%7D%29%20%3D%3E%20getNovel%28novelId%29%2C%0A%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%7D%29%2C%0A%20%20%7D%29%2C%0A%7D%29%3B%0A).



Any idea why the `vocabulary` field isn't wrapped in a `fragment on Novel { … }` @josephsavona?
",steveluscher,josephsavona
654,2015-12-07 01:28:58,"I was seeing if local data could be implemented via a Network Layer (inspired by the reactjs meetup talk by @steveluscher -- the network layer was a common answer on how to extend Relay).  This will eventually be done as part of #114, so I'll close this with your answer :).

The idea was having a composite network layer where a query is split and routed to different network layers -- one of which could be local (e.g. https://github.com/relay-tools/relay-local-schema).  This is easy for top level fields, but is proving ridiculous if you allow arbitrary mixing ... I'm ending up post-walking the query and building up a queue of queries with each entry of the queue an array of queries capable of being done in parallel.



default network layer:



local network layer:



And then if each draft had `author` it would go back to the default network layer per draft (but could be done in parallel):



So basically -- a terrible idea it is turning out (ps. this doesn't work at all).  Even if this did work an unfortunate thing is that you need the entire local schema on the device at once (vs having the schema downloaded incrementally attached to components).

thanks!
",eyston,steveluscher
646,2016-03-08 00:34:17,"> Do you have some thoughts on getStatus issue I mentioned in my initial comment? Would be handy if getStatus would return something when its processed instead of exception.

Indeed, but the difficultly is in differentiating between completed and invalid IDs. One solution would be to keep around the map of IDs that have been successfully committed, but that will continue to leak memory into the future.

Another solution would be to change `RelayMutationQueue` to expose methods on some instance that callers can obtain a reference for as long as needed.

@josephsavona Do you remember the reason for why we chose to use IDs instead of exposing a public form of the pending transaction (which would have all the methods like `getError`, `getStatus`, `commit`, etc.)?
",yungsters,josephsavona
639,2015-12-01 16:19:02,"Fix for #615, proposed in #538

Makes `rangeBehaviors` a function that receives the connection arguments and returns one of `GraphQLMutatorConstants.RANGE_OPERATIONS`.

Will try and write a codemod for this during the week if I have time.

To check if the tracked connections where included in rangeBehaviors, the old behavior was to check if the connection's `rangeBehaviorKey` was in the `rangeBehaviors` map. Now that we don't have access to the `rangeBehaviors` map I've followed @josephsavona 's advice. I am fetching the connectionIds and calling `getRangeFilterCalls` on each one to get all the `rangeBehaviors` using the parentID.

Since these rangeBehaviors are not in the same format I've wrote a new function for connections called `getRangeBehaviors`. It is almost the same as `getRangeBehaviorKey` except it returns a list of the actual calls instead of a string representation. I can then make the correct check using these values.

Other thing I've added is a function `getObjectFromCalls` in `writeRelayUpdatePayload`. It transforms calls like this  `[{name: 'orderby', value: 'recent'}]` to an object like this `{orderby: 'recent'}` that can be passed to the `rangeBehaviors` function.

Rest is pretty straight forward I think, let me know what you think! 
",xuorig,josephsavona
636,2015-11-29 20:04:02,"Hello

As mentioned [here](https://github.com/facebook/relay/issues/635) by @josephsavona `It's important to upgrade react-relay and babel-relay-plugin together.`

To be able to do that and also to be able to update the [babel-relay-plugin-loader](https://github.com/BerndWessels/babel-relay-plugin-loader) we need the new `0.5.0` version of the `babel-relay-plugin` published to NPM.

Chan you please do that and let me know here? I will update the loader then right away.

Thank you
Bernd
",BerndWessels,josephsavona
617,2015-12-06 09:47:07,"@steveluscher, Applied your suggestion. Thanks!
",denvned,steveluscher
615,2015-11-19 18:28:26,"As mentioned by @johanobergman in #604 and similar to what @AndrewIngram [proposed](https://github.com/facebook/relay/issues/538#issuecomment-156396132) in #538, let's make `rangeBehaviors` a function that receives the connection arguments and returns one of `GraphQLMutatorConstants.RANGE_OPERATIONS`.



Add an appropriate deprecation warning to `RelayDeprecated`.

Bonus: write a [jscodeshift](https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb#.pe5meqdiz) codemod that will mod this:



…to this:


",steveluscher,cpojer
610,2015-11-20 07:46:53,"I'm not an expert on that. @dschafer might have suggestion for best practices for cursors.
",yuzhi,dschafer
607,2015-11-17 21:17:55," @plievone done
",xuorig,plievone
604,2015-11-17 23:13:03,"Thanks! That's really useful.
1. It sounds like there is a bug, since the query shouldn't need to be in alphabetical order. I think @steveluscher will be the best person to look into that.
2. I am not familiar with `react-router-relay` and what side effect it might have. Just to be sure, can you check the query variables inside the container with the query of the connection where it includes dates as the variables? Do you know whats the top-level code Relay it calls with when `back` is clicked? Does it make a new RelayRootContainer? Does it remember the results of all the `setVariables` calls that were used? 
",yuzhi,steveluscher
601,2015-11-15 21:07:01,"Hey, I was pretty confused about about the usage of the term ""GraphQL call"" on the documentation for RANGE_ADD. Fortunately @taion [clarified this for me on SO](http://stackoverflow.com/questions/33631322/what-are-the-graphql-calls-in-the-rangebehaviors-attribute-of-the-range-add). Is it worth updating the docs? Thanks.
",dminkovsky,taion
599,2015-11-15 05:28:59,"This looks good, and thanks for the tests! 

Having two such similar methods is definitely redundant though. @yungsters @wincent - thoughts on making it the default for `update` to not commit the transaction, and require users to call `commit()`? We could keep the old behavior for one release with a warning.
",josephsavona,wincent
599,2015-11-15 05:28:59,"This looks good, and thanks for the tests! 

Having two such similar methods is definitely redundant though. @yungsters @wincent - thoughts on making it the default for `update` to not commit the transaction, and require users to call `commit()`? We could keep the old behavior for one release with a warning.
",josephsavona,yungsters
596,2015-11-13 17:28:38,"Thanks for filing this. This is caused by queries being flattened prior to creating the mutation query. 

Cc @yungsters - we should flatten only the optimistic query. 
",josephsavona,yungsters
594,2015-11-13 19:10:35,"Not totally sure how I feel about this... In my case, we're using errors in e.g. mutations to pass along any application specific user visible errors (as suggested by @dschafer).

At the very least, resolve should probably _also_ include any errors, and since this changes the semantics of mutation callbacks (I think), should be documented as a breaking change.
",devknoll,dschafer
594,2015-11-17 01:20:03,"@devknoll I see what you mean, I guess this solution would make errors inaccessible for anybody wanting to use them when there is data. @josephsavona what do you think ?
",xuorig,josephsavona
594,2015-12-06 04:23:57,"@devknoll or @josephsavona, can you give this one last look, then close if you decide we should leave the current behavior as it is?
",steveluscher,josephsavona
589,2015-11-12 20:37:22,"cc @yungsters 
",josephsavona,yungsters
589,2015-12-30 04:03:20,"> Yeah it seems that way, but it actually isn't necessary. RelayQueryRoot objects can be serialized to plain objects/arrays via the toGraphQL.Query(relayQuery) function. 

@josephsavona , @yungsters Looks like it is not possible anymore because of https://github.com/facebook/relay/commit/a26c8b4703adb3ae1b28421fdd06a9b7e8140f85. Is it possible to revert that commit back? It will be hard to implement `Relay.prepare`, as discussed above, without `toGraphQL`. Also [isomorphic-relay](https://github.com/denvned/isomorphic-relay), which many people use, already actively [uses](https://github.com/denvned/isomorphic-relay/blob/v0.4.0/src/prepareData.js#L20) `toGraphQL`.
",denvned,yungsters
588,2015-11-12 16:47:00,"This sounds like it could be a bug. It's definitely odd since we handling optimistic and server payloads almost identically. 

@yuzhi any chance you can look into this?
",josephsavona,yuzhi
578,2015-11-17 18:05:09,"@yungsters  @josephsavona thoughts?
",yuzhi,yungsters
578,2015-11-17 18:05:09,"@yungsters  @josephsavona thoughts?
",yuzhi,josephsavona
577,2015-11-11 03:59:09,"`fbjs-scripts` 0.5 hasn't been shipped yet but tested locally with `npm link`

cc @DmitrySoshnikov 
",zpao,DmitrySoshnikov
577,2015-12-03 00:44:24,"I got into a state where tests weren't passing but all cleared up now. I split out the changes to the actual `require` statements since @DmitrySoshnikov is doing that separately - this will go in after.

@facebook-github-bot import
",zpao,DmitrySoshnikov
574,2015-11-10 14:40:35,"Possible improvement for #542

Lot's of issues and misunderstanding with that one, range add mutations can be confusing with the current warning messages.

Better solution as @steveluscher said:
- When relay does not query the new edge because it was not included in the intersection of tracked and fat queries, show a different warning saying it's a client-side problem ( Connection was never used in the app )
- If the edge was queried but is not in the payload, explain it's a server side problem.

In `handleRangeAdd`, if the edge is missing from the payload, check if the operation `RelayQueryMutation` contained the newEdge field. If it didn't, it means the new edge was not included because it wasn't in the intersection of the tracked/fat query. If it did, it means the server should've returned that field and didn't.

I've added a function `getNodeByFieldName` to check if the operation contained the field to get the new edge. Not sure if it is the best way to check that, let me know.

The actual warning messages probably need some work, let me know what you think would be the best messages for these cases.
",xuorig,steveluscher
574,2015-11-10 15:56:06,"cc @steveluscher @kassens 
",josephsavona,kassens
574,2015-11-10 15:56:06,"cc @steveluscher @kassens 
",josephsavona,steveluscher
574,2015-11-18 18:18:12,"@josephsavona @kassens any comments on this ? Would be helpful to add that in :dancers: 
",xuorig,kassens
574,2016-01-06 00:20:26,"Thanks for your patience, @xuorig. We just went over this internally, and I'd like to share a summary of our discussion. I wrote:

> Let me try to work through this to make sure I understand it.
> 
> Client devs have the option of configuring a RANGE_ADD config or not. If they do configure one, it's likely because they expect it to be of use.
> 
> Now, if you've specified a RANGE_ADD config, there are tracked connections that match, but none of them match your rangeBehaviors, it's because you have a connection in your app with arguments that you haven't accounted for in your RANGE_ADD config. This is the aim of the warning, to say “hey… we found at least one tracked connection for that parentID/connectionName combination, but we couldn't find an associated rangeBehavior – did you forget to configure one?”
> 
> > @yungsters: …this warning … can be triggered [if] the key does not have a range behavior defined.
> 
> Interesting. To fallback by refetching the whole connection is good (and what the code does now if you don't have a matching range behavior) but one of the nice things about RANGE_ADD configs is to prevent refetching and to enable optimistic mutations. When you miss a rangeBehavior, you lose all of that without warning.

What if we changed the warning to indicate that the entire connection has been refetched and that the developer can't expect optimistic mutations to work, with a little bit about how to write a more efficient and optimism-compatible mutation. Something like:

> “Relay.Mutation: Since the connection `ships(orderby:""latest"")` of the field `faction` with id `123` matched none of the rangeBehaviors specified in your `RANGE_ADD` config, the entire connection has been refetched. Configure a range behavior for this connection to fetch only the new edge and to enable optimistic mutations. See http://… for more information.”

The only problem here is that there's no way for the developer to squelch this warning if their desired behavior _was_ to refetch the connection. Thoughts, @yuzhi @xuorig @yungsters?
",steveluscher,yuzhi
574,2016-01-06 00:20:26,"Thanks for your patience, @xuorig. We just went over this internally, and I'd like to share a summary of our discussion. I wrote:

> Let me try to work through this to make sure I understand it.
> 
> Client devs have the option of configuring a RANGE_ADD config or not. If they do configure one, it's likely because they expect it to be of use.
> 
> Now, if you've specified a RANGE_ADD config, there are tracked connections that match, but none of them match your rangeBehaviors, it's because you have a connection in your app with arguments that you haven't accounted for in your RANGE_ADD config. This is the aim of the warning, to say “hey… we found at least one tracked connection for that parentID/connectionName combination, but we couldn't find an associated rangeBehavior – did you forget to configure one?”
> 
> > @yungsters: …this warning … can be triggered [if] the key does not have a range behavior defined.
> 
> Interesting. To fallback by refetching the whole connection is good (and what the code does now if you don't have a matching range behavior) but one of the nice things about RANGE_ADD configs is to prevent refetching and to enable optimistic mutations. When you miss a rangeBehavior, you lose all of that without warning.

What if we changed the warning to indicate that the entire connection has been refetched and that the developer can't expect optimistic mutations to work, with a little bit about how to write a more efficient and optimism-compatible mutation. Something like:

> “Relay.Mutation: Since the connection `ships(orderby:""latest"")` of the field `faction` with id `123` matched none of the rangeBehaviors specified in your `RANGE_ADD` config, the entire connection has been refetched. Configure a range behavior for this connection to fetch only the new edge and to enable optimistic mutations. See http://… for more information.”

The only problem here is that there's no way for the developer to squelch this warning if their desired behavior _was_ to refetch the connection. Thoughts, @yuzhi @xuorig @yungsters?
",steveluscher,yungsters
574,2016-01-06 01:12:22,"I discussed with @yuzhi a bit. Currently, setting a range behavior configuration to `null` means the range should not be refetched at all. I think we should change this to `IGNORE` instead of `null`.

We can add a `REFETCH` or `ALL` constant to squelch the warning.
",yungsters,yuzhi
573,2015-11-09 20:49:26,"@josephsavona 
Oh I forgot to change it back to ""react-relay"": ""file:../../"",
@jabagawee 
Sorry, my eyes isn't working today :P
",bfwg,josephsavona
573,2015-11-10 03:12:21,"@kassens or @steveluscher can you take a look?
",josephsavona,kassens
573,2015-11-10 03:12:21,"@kassens or @steveluscher can you take a look?
",josephsavona,steveluscher
566,2015-11-09 02:12:40,"Builds on #565. Part of #558

@josephsavona ~~It seemed important that `GraphQLStoreRangeUtils` continue converting IDs -> broadcast IDs, for non-`RelayStoreData` users like `GraphQLStoreQueryResolver`. That said, since `GraphQLStoreQueryResolver` also relies on `RelayStoreData`, maybe that could change.~~ _edit:_ nvm.

I think it might make sense to rename `GraphQLStoreRangeUtils` to `GraphQLStoreRangeData`... let me know what you think.
",devknoll,josephsavona
560,2015-11-07 21:05:58,"@josephsavona Is this more along the lines of what you're looking for?

Part of #558
",devknoll,josephsavona
558,2015-11-07 20:11:38,"cc @devknoll who's started experimenting with this in #557
",josephsavona,devknoll
558,2016-03-09 13:45:15,"As of 8e53183bd4f323196a71f471d6275fe024706a66, all of Relay's internal state tracking has been contextualized. Each instance of `RelayEnvironment` is an isolated environment with its own cache of data, network layer, task scheduler, etc. This is an important prerequisite for server rendering in open source as well as allowing some new use cases. The next step is #559 - splitting Relay Core and the React/Relay integration layer - follow along there for more details.

Thanks especially to @denvned and @devknoll for their impressive contributions!
",josephsavona,denvned
558,2016-03-09 14:59:26,"Amazing work! Thanks @denvned, @devknoll, @josephsavona . :tada:
",rodrigopr,denvned
558,2016-03-09 17:02:39,"Yeah!

On Wed, Mar 9, 2016 at 6:59 AM Rodrigo Ribeiro notifications@github.com
wrote:

> Amazing work! Thanks @denvned https://github.com/denvned, @devknoll
> https://github.com/devknoll, @josephsavona
> https://github.com/josephsavona . [image: :tada:]
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/558#issuecomment-194333793.
",KyleAMathews,denvned
550,2015-11-09 16:39:04,"Two mutations with the same collision key may be initiated from different parts of UI and be unaware of each other. There should be _some_ callback that fires in the case of a mutation to allow for any cleanup, though I agree that `onFailure` isn't appropriate for this case. 

@yungsters @wincent Thoughts on switching to either an `onReadyStateChange`-style callback with props such as `{error, aborted, data}`? Calling `onSuccess` when a mutation isn't intuitive.
",josephsavona,wincent
550,2015-11-09 16:39:04,"Two mutations with the same collision key may be initiated from different parts of UI and be unaware of each other. There should be _some_ callback that fires in the case of a mutation to allow for any cleanup, though I agree that `onFailure` isn't appropriate for this case. 

@yungsters @wincent Thoughts on switching to either an `onReadyStateChange`-style callback with props such as `{error, aborted, data}`? Calling `onSuccess` when a mutation isn't intuitive.
",josephsavona,yungsters
547,2015-11-06 04:31:38,"Making queries easier to debug is a great idea. Having different implementations between DEV and production can lead to subtle bugs, so we probably won't have a DEV printing mode. However, we should look at making the future Relay dev tools pretty-print queries.

cc @kassens 
",josephsavona,kassens
547,2015-11-06 19:04:33,"@yusefnapora awesome! @kassens let's keep this in mind for dev tools (if you didn't implement it already ;-)
",josephsavona,kassens
545,2015-11-03 19:29:34,"Fixes #536 

I've been working with graphql-ruby and relay and been wanting to use directives. I found #536 yesterday night and tried to work on a solution today.

Following what @josephsavona said in the issue, I've modified`RelayQueryNode.getChildren` so it only return children that are not skipped (meaning `skip if: true` and `include if: false`). I've implemented the function `RelayQueryNode.shouldBeIncluded` which
- Checks if a skip directive is present ( It has priority over include)
  - If an if argument is present, return the negated value
- Checks if an include directive is present
  - if an if argument, return the value
- return true in all other cases

I've tried to take into consideration that other directives and arguments other than `if:` might be added, which might make the code a little bit more complicated, let me know if I should just assume that the argument is if right now.

Let me know if the solution makes sense. I've added 2 tests, modified a printing test that included a field that should be skipped and also modified the metric test since the getChildren method now calls getDirectives for every field.

Haven't had much chance to look at Relay in detail so let me know how I can improve this!
",xuorig,josephsavona
543,2016-03-03 17:52:11,"@josephsavona: @yungsters was asking me about this yesterday. I was going to reroll it, but it didn't seem like the highest impact thing I could to so I just let it sit. Closing is the right call for now!
",wincent,yungsters
542,2015-11-02 21:21:01,"per @steveluscher:

> The task. Given a RANGE_ADD mutation config:
> 1) If Relay never queries for the new edge because they were eliminated during the intersection of the tracked and fat queries, explain that there's a client-side problem and how to fix it (namely to make sure the parent/connection is used – ie. tracked – in your app)
> 2) If the server never responds with the newly created edge despite having been queried for it, explain that the problem is on the server side.
",josephsavona,steveluscher
541,2015-11-02 19:51:38,"Realtime data in GraphQL is something that we and the community are actively exploring. There are many ways to achieve ""realtime"" or near-realtime updates: polling, ""live"" queries, or event-based approaches (more on these tradeoffs [on the GraphQL blog](http://graphql.org/blog/subscriptions-in-graphql-and-relay/)). Furthermore, there are a variety of transport mechanisms to choose from depending on the platform: web sockets, MQTT, etc.

Rather than support any one approach directly, we would prefer to allow developers to implement any of these approaches. Therefore, we don't plan to create a `RelayMutation`-style API for subscriptions. Instead we're working create a ""write"" API that will make it easy for developers to tell Relay about new data (along the lines of `store.write(query, data)`). See #559 for more information.

For now, we recommend checking out @edvinerikson's [`relay-subscriptions`](https://github.com/edvinerikson/relay-subscriptions) module.
",josephsavona,edvinerikson
540,2015-11-10 15:49:45,"@dminkovsky Yup, we use cursor-based pagination precisely because skip/limit isn't performant in large data sets. Also, skip/limit can return overlapping results if items are added between fetching pages.

One option might be to make connection handling injectable. Something like `Relay.injectConnectionHandler(handler)` where the handler had methods to read the list of edge IDs given the GraphQL arguments, as as well as methods to add/remove sets of edge IDs along with the arguments used to fetch them. This could be based off the existing GraphQLRange API.

@yuzhi - thoughts?
",josephsavona,yuzhi
540,2015-11-10 18:05:45,"I'm much less cool than @yuzhi, but I've been prodding at this a bit and have some thoughts.

I think there's really 3 kinds of common pagination patterns: page number pagination, limit/offset pagination, and cursor pagination. As a reference point, DRF is fairly comprehensive and [implements all three](http://www.django-rest-framework.org/api-guide/pagination/) (though its cursor-based pagination approach is not directly compatible with Relay's assumptions because it only provides start and end cursors).

Relay already handles cursor pagination just fine, so we don't need to talk too much about it, except mention that most cursor paginated REST APIs actually only provide start and end cursors rather than per-element cursors.

Page number based pagination seems like it'd be really ""easy"" in some sense to handle in Relay - your queries would take the form of `connection(page: $page)`; this essentially works out-of-the-box right now if you write the query as `connection(page: $page, first: $DUMMY)`. This works just fine for window-based pagination based on explicit pages, and the existing `PageInfo` is essentially fine.

Limit/offset pagination in this context actually seems very similar to cursor pagination; it seems like essentially the same as cursor pagination, except that (1) the cursors are non-opaque to the client, and (2) the cursors can change underneath the client as records are inserted and removed.

One complexity in both cases is how to handle new elements getting inserted into the collections, but frankly neither method of pagination really deals well with dynamic lists anyway.

Partially, #466 I think just speaks to the difficulties of trying to do window-based pagination when using cursors. I think that complexity is more at the application layer conceptually though; imagine the following:
1. Page displays first 10 items starting at #1; previous page unavailable, next page available
2. Go to next page
3. See first 10 items starting at #11; previous page available
4. A new element #0 is prepended to the beginning
5. Go to previous page
6. Page displays 10 items starting at #1; previous page available
7. Go to previous page again
8. Page displays only #0 (???)

I think there are meaningful practical difficulties with windowing on cursor-based APIs, which make it a bad enough fit that it might be better to not try to shoehorn it in.
",taion,yuzhi
538,2015-11-02 17:49:56,"This is a meta-task to track progress toward making Relay mutations simpler to both understand and to define in common cases.

In a client/server system there is an unavoidable complexity in handling writes: 
- Making network requests
- Handling error (and possibly retries)
- Sequencing possibly overlapping writes
- Handling optimistic changes and reverting them on error, or clearing them on success
- Handling server response payloads
- (server) Implementing business logic to process incoming writes

Relay handles the vast majority of this complexity on behalf of developers. The tradeoff is that GraphQL mutations are abstracted from the underlying data store, and therefore the system _cannot automatically know what changed_. This requires the developer to tell the system what changed in the form of mutation configs (`getConfigs`). 

There are several avenues for exploration:
1. Simplify the process of defining mutation configs. @steveluscher proposed creating helper functions that would replace the need for the mutation config objects.
2. Require product developers to manually convert the mutation payload into a set of change operations (e.g. `set('record', 'field', 'value')` or `append('connection', 'edgeId')`). If Relay could understand a small set of these change operations, the community could work to define helpers for converting payloads into this form.
3. Create a standard response format for GraphQL mutations to match the change operations from 2, such that mutations would return a description of what changed. This would not reduce the work of defining mutations, but would allow defining the changes once instead of once per client.

It's important to note that the current mutations API is heavily skewed toward practicality: it has allowed us to iterate quickly and produce resilient applications. We're interested in making this API better and welcome contributions from the community. In particular, the best form of contribution is either links to prototypes or pull requests, which will help us and the community understand the practical tradeoffs of any alternative APIs.
",josephsavona,steveluscher
536,2015-11-10 15:43:16,"@xuorig thanks for the PR!
",josephsavona,xuorig
525,2015-11-18 01:03:30,"@kassens Addressed your comment. Good catch! 
",joshthecoder,kassens
520,2015-10-30 16:12:04,"We just had a conversation about what role core can play here. Broadly:
1. You could create a new batching network layer (and an associated server implementation) that batches those queries together into a single fetch, streams back the results as they're available, and calls `request.resolve(…)` on each `RelayQueryRequest`. This is what we do at Facebook.
2. Relay core could combine each query into one so you get batching by default. Would have to auto-alias each root field (eg. `user` to `user as user0`, in case there are multiple `user` root calls in the batch).

We should carefully trade off against:

a. New demands we place on the implementation of GraphQL servers
b. The ability to maintain choice with respect to _how_ queries are parallelized (client-side? server-side?)
c. The ability to stream responses into the system as they become ready

Looping in @josephsavona and @wincent.

Are you interested in helping with this?
",steveluscher,wincent
520,2015-10-30 16:12:04,"We just had a conversation about what role core can play here. Broadly:
1. You could create a new batching network layer (and an associated server implementation) that batches those queries together into a single fetch, streams back the results as they're available, and calls `request.resolve(…)` on each `RelayQueryRequest`. This is what we do at Facebook.
2. Relay core could combine each query into one so you get batching by default. Would have to auto-alias each root field (eg. `user` to `user as user0`, in case there are multiple `user` root calls in the batch).

We should carefully trade off against:

a. New demands we place on the implementation of GraphQL servers
b. The ability to maintain choice with respect to _how_ queries are parallelized (client-side? server-side?)
c. The ability to stream responses into the system as they become ready

Looping in @josephsavona and @wincent.

Are you interested in helping with this?
",steveluscher,josephsavona
509,2015-10-24 15:14:08,"Ah, thanks for pointing this out. We use `require('setImmediate')` because internally at Facebook there is a polyfill that we use for this.

I think that we might actually have to add a forked version of the module for OSS, that just calls the native implementation.

cc @yuzhi 
",wincent,yuzhi
506,2015-10-23 16:20:02,"This simplifies the build process to avoid excessive i/o and process spawning, instead doing the work in a single pass.

cc @wincent 
",zpao,wincent
502,2015-10-23 23:15:33,"Thanks for bringing this up, and in such a well-detailed way!

It's possible that this issue will simply go away in the future because we as almost certainly going to remove query subtraction as a concept from Relay.

> So, TLDR; is this desired and correct behavior? If so, what is the reasoning behind it? What problem is this solving?

In short, yes, and I'll try to explain why.

### Why we subtract queries now

The idea of query subtraction is that if you fire off multiple queries in a batch, later queries in the batch may redundantly request fields that prior in-flight queries from the batch are already in the process of retrieving. So, we subtract any in-flight queries from newly-added queries before sending them (the newly-added queries). Sometimes, these queries can get subtracted away to nothing, in the sense of them being ""empty"", which means there's no point in sending them. Here's an example of an obviously ""empty"" query:



In this query, we already know the `id`, so there is no point in requesting it.

#### An aside on requisite fields

Note that there are a few different field types at play here:
- **requisite:** Without these fields, Relay won't work. They should not be stripped.
- **generated:** These are generated by Relay whenever we notice a place where we'll need them (ie. they are also requisite) but the query author hasn't explicitly provided them.
- **normal:** Fields supplied by the query author (which means non-generated, although they may be requisite).

So, a field can be:
- requisite and generated
- requisite and non-generated
- non-requisite and non-generated

But not non-requisite and generated (we wouldn't have generated it if it weren't requisite).

#### Back to what I was saying about subtraction...

As you saw, we are going to consider a field to be ""empty"" if, after subtraction, it is a scalar (no children), it's requisite, it's _not_ a ""ref query dependency"" (this is related to our support for deferring part of a query, and these fields can never be stripped), and it's not aliased. That aliasing check is the escape hatch, and the nasty hack that you discovered to hint to the subtractor that it shouldn't consider your field to be content-less and unworthy of sending.

We do all of this so that a tree that consists of _only_ requisite fields and their parents may be considered empty, because there is no demonstrated reason why you would want to fulfill such a query in practice. If we were to let these through, we'd end up letting a lot of basically empty/pointless queries slip through to the server for no good reason.

### Why we think it may not be worth subtracting queries in the future

In practice, we suspect that the actual amount of data-over-the-wire that we save by doing this subtraction is minimal. We could probably just delete the whole thing, get a nice reduction in complexity, with little or no impact on performance (any over-the-wire costs could be offset by cheaper processing costs, an easier-to-iterate code base, and scope for doing other clever things to reduce query upload size).

The only reason we need this still, for now, is to support the ""preload"" mode that @voideanvalue  describes [here](https://github.com/facebook/relay/issues/36#issuecomment-130402024). In this mode, we run queries on the server, the client starts downloading static resources, we tell the client about the queries and it registers them as pending. The query results come in and we stream them down. In the meantime, the client can use query subtraction to ensure that it doesn't redundantly request data which is already being fetched by ""in-flight"" queries (even if they are in-flight on another machine, in a data center).

There are other ways to solve this problem without relying on query subtraction, but that is the (temporary) solution that we have for now.

### Recommendation

You should probably run with your alias hack for now, and know that this problem will eventually go away. I don't know if we actually want to document this right now (beyond what I've written here), because I am hoping that this is all just temporary.

As this is not a bug but is working as intended, I'm going to mark this as closed, but feel free to add comments with any more questions or thoughts that you might have.
",wincent,voideanvalue
500,2015-10-23 20:30:38,"On the surface, this looks reasonable to me.

@yuzhi , @josephsavona: Can you think of any reason why we'd want to defer this check until runtime?The other invariants in the writer are all about validating the response shape and internal state, which can only be known at runtime.
",wincent,yuzhi
500,2015-10-23 20:30:38,"On the surface, this looks reasonable to me.

@yuzhi , @josephsavona: Can you think of any reason why we'd want to defer this check until runtime?The other invariants in the writer are all about validating the response shape and internal state, which can only be known at runtime.
",wincent,josephsavona
500,2015-10-23 20:44:54,"@josephsavona  probably has better context on this. My guess is that depending on the fragment structure, we might not be able to detect if all `edges` fields are under connections with those calls if the fragments starts as a fragment at the edge it self. It would be harder to tracked the actual structure since the parent node could be in a different file.
",yuzhi,josephsavona
500,2015-11-13 04:56:44,"Oh, yeah @yungsters fixed this for `5.0`
",josephsavona,yungsters
496,2015-10-20 19:15:41,"`react-router-relay` merges all the queries from `react-router` routes into a top level `relay` route. When `react-router` transitions into a new route, `react-router-relay` merges the new queries into a new top level `relay` route.

This breaks relay's `shouldComponentUpdate`, because of [this](https://github.com/facebook/relay/blob/master/src/container/RelayContainer.js#L769-L771) (returns false when `context.route` has changed). @taion suggested I'd post the issue here since there's no easy way for `react-router-relay` to get around this.
",johanobergman,taion
496,2015-10-27 22:15:11,"@josephsavona Do you have any input on this?
",johanobergman,josephsavona
494,2015-10-20 15:49:50,"This is Feature request, based on #464, to keep track of it.

@yuzhi said:

> We currently fetch based on the fragments that was cached, which means having a lot of ranges can be inefficient. In the future, we might look into dirtying cached data and only fetch data needed for the current view to make this step a but more efficient.

I think its important feature, especially for use cases when many different arguments for one connection are used to filter results. If I need to reload that connection, it currently reloads connections with all argument combinations used since application started, which can get crazy.
",jardakotesovec,yuzhi
490,2015-10-27 19:27:32,"I don't think we want to drop the sorting entirely, as we want printed queries to preserve the ordering of the original underlying query (other than the noted constraint that types have to come first) for consistency, determinism and debuggability.

It seems that once #479 is resolved, your issue hopefully will be too. @josephsavona is actively working on addressing that, although it is a multi-step process with no quick fix.
",wincent,josephsavona
487,2015-10-19 16:38:49,"@leebyron @dschafer Is there any way for a client (Relay) to detect whether an error occurred on a nullable field instead of a non-null field?
",josephsavona,dschafer
487,2015-10-20 23:47:41,"> @leebyron @dschafer Is there any way for a client (Relay) to detect whether an error occurred on a nullable field instead of a non-null field?

Nothing built in; you could check to see if `data` is completely null before erroring; that feels like the right thing to do here. The server can also customize what it returns in the error, so we could add that data there if we wanted.
",dschafer,dschafer
465,2015-10-15 01:23:43,"> If I use extra connection arguments to filter results - it can quickly result in many connections cached with different arguments.

As @yuzhi mentioned in #464, Relay currently caches the results for all combinations of connection arguments that have been fetched, which can sometimes grow quite large depending on the product's access patterns. In the future we will likely change this so that only connections that are actively viewed are refetched, and others are marked as stale.

> is [it] possible to use arrays/objects as these extra connection arguments?

Yup! The arguments defined in the connection spec must be as specified (e.g. `first: Int`), but otherwise custom arguments can be of arbitrary types!
",josephsavona,yuzhi
457,2015-10-13 14:13:51,"> Is there something special about `node`?

The Relay GraphQL spec does declare `node` to be special. As it is currently implemented, all object refetching [happens](http://facebook.github.io/relay/docs/graphql-object-identification.html) through the `node` field, so implementing the [Node Interface](http://facebook.github.io/relay/graphql/objectidentification.htm#sec-Node-Interface) is a necessary but not sufficient condition to avoid re-querying.

We have an internal data structure called the `rootCallMap` which enables us to associate fields like `widget(id: $id)` with an underlying, normalized record, but (disclaimer!) I am not super familiar with it. My understanding is that we update it when writing the results for a query like `widget(id: $id) { something}`, but the _first_ time we see such a query, no mapping has been set up yet and so we can't know that we already have the data, even though we may have fetched it via a different field like `widgets` previously. (If this is egregiously wrong, please correct me @yuzhi, @josephsavona...)

I'd recommend for now sticking with `query { node( id: $id ) }` in your route.
",wincent,yuzhi
457,2015-10-13 14:13:51,"> Is there something special about `node`?

The Relay GraphQL spec does declare `node` to be special. As it is currently implemented, all object refetching [happens](http://facebook.github.io/relay/docs/graphql-object-identification.html) through the `node` field, so implementing the [Node Interface](http://facebook.github.io/relay/graphql/objectidentification.htm#sec-Node-Interface) is a necessary but not sufficient condition to avoid re-querying.

We have an internal data structure called the `rootCallMap` which enables us to associate fields like `widget(id: $id)` with an underlying, normalized record, but (disclaimer!) I am not super familiar with it. My understanding is that we update it when writing the results for a query like `widget(id: $id) { something}`, but the _first_ time we see such a query, no mapping has been set up yet and so we can't know that we already have the data, even though we may have fetched it via a different field like `widgets` previously. (If this is egregiously wrong, please correct me @yuzhi, @josephsavona...)

I'd recommend for now sticking with `query { node( id: $id ) }` in your route.
",wincent,josephsavona
457,2015-10-13 14:52:26,"What @wincent said - for now, use `node` to get efficient refetches. 

@steveluscher is working on supporting a wider variety of root calls (fields) including connections and I believe non-`node` ""identifying"" fields such as fields of the pattern `foo(id: $id)`.
",josephsavona,steveluscher
457,2015-10-13 16:29:43,"I'm going to close this out for now. If you want to follow along with @steveluscher's work you can subscribe to #112.
",wincent,steveluscher
456,2015-10-15 04:53:30,"@nickretallack You are absolutely right, and I think there is a good chance we //will// get rid of `Relay.Route`. Routing will still be important to most applications, but the query configuration portion is kind of unnecessary.

There are a few things currently in progress that are getting us closer to this:
- We're handicapping the current `Relay.Route` (as you can see with the existence of `RelayQueryConfig`). Routing does not need to be strictly tied to Relay in any particular way, as long as you can supply parameters from the router into queries.
- Relay currently special case fields on the root type in order to reduce redundant fetching of nodes. @steveluscher is working on generalizing this special case so that it can _eventually_ be applied to not only root fields, but arbitrary fields. (#112)
- Finally, Relay needs to support fragments on the root type in containers.
",yungsters,steveluscher
456,2015-11-10 23:29:45,"@dminkovsky I'm sorry to hear that this was frustrating. You raise good points about the tradeoff of nesting fields in the query vs container.

Rather than allow more nesting within route queries, we'd like to go in the opposite direction: eliminating the need for routes & their queries, and instead allow express data dependencies solely via containers. @steveluscher is building the prerequisite to this in #112, which adds support for arbitrary root fields. 
",josephsavona,steveluscher
453,2015-10-12 23:05:25,"cc @zpao @spicyj 

I assume this is an implicit dependency due to JSX? Is this something we could fix in `eslint-plugin-react`?
",yungsters,spicyj
453,2015-10-12 23:05:25,"cc @zpao @spicyj 

I assume this is an implicit dependency due to JSX? Is this something we could fix in `eslint-plugin-react`?
",yungsters,zpao
442,2015-10-08 20:58:50,"@steveluscher FYI, this is why I was asking about the plugin w.r.t. Relay Playground.
",yungsters,steveluscher
436,2015-10-07 21:07:55,"Since @josephsavona improved the API for react-router-relay, we can now make the index route be a lot less hacky/weird.
",taion,josephsavona
421,2015-10-05 16:14:11,"cc @yuzhi 
",josephsavona,yuzhi
418,2015-10-03 09:11:16,"> @josephsavona [commented on 22 Aug](https://github.com/facebook/relay/issues/143#issuecomment-133738951)
> GraphQL is agnostic of data storage and programming languages. As for how to integrate with MongoDB, this is a really great question to ask at the graphql repo

Someone contributed an example how to use relay together with mongo as the database for graphql, please have a look at their example. https://github.com/sayden/relay-mongoose-example, this might be a good starting point.
",clentfort,josephsavona
416,2015-10-02 18:46:14,"I've noticed this too. What do you think, @steveluscher?
",wincent,steveluscher
411,2015-10-01 19:37:46,"In the subscriptions channel on Slack, a few of us (@taion, @skevy, and I) were discussing what are the missing pieces needed to implement subscriptions.

One important piece in Relay is the ability for a real-time network layer to apply ""mutations"" to the Relay Store. People will use different technologies to push data to their client. In each there needs to be a way to tell Relay this field changed or this node should be prepended to this connection, etc.
",KyleAMathews,taion
411,2015-10-01 19:37:46,"In the subscriptions channel on Slack, a few of us (@taion, @skevy, and I) were discussing what are the missing pieces needed to implement subscriptions.

One important piece in Relay is the ability for a real-time network layer to apply ""mutations"" to the Relay Store. People will use different technologies to push data to their client. In each there needs to be a way to tell Relay this field changed or this node should be prepended to this connection, etc.
",KyleAMathews,skevy
409,2015-10-01 18:33:09,"CC @yungsters who knows this stuff; I might be unaware of some constraints.
",wincent,yungsters
408,2015-10-02 06:13:31,"Yep! We broke this. @josephsavona is on it!
",steveluscher,josephsavona
405,2015-09-30 18:44:42,"Due to limitations internally (cc @cpojer @amasad), I am going to change this to instead check in the build products — `lib/`.
",yungsters,cpojer
405,2015-09-30 18:44:42,"Due to limitations internally (cc @cpojer @amasad), I am going to change this to instead check in the build products — `lib/`.
",yungsters,amasad
396,2015-10-20 18:00:26,"Yea, Relay will have issues but React escapes because we don't use Flow there. That part kinda sucks but hopefully will get fixed by the work @gabelevi is doing (can't find the issue right now).
",zpao,gabelevi
394,2015-09-29 22:12:59,"Thanks for he heads up, @chandu0101. @voideanvalue might have thoughts on this, as he did most of the implementation for the current version of the `RelayMutation` API.
",wincent,voideanvalue
389,2015-09-25 12:51:00,"I just went through the docs and tutorials as I was introducing GraphQL & Relay to a project and found a few places that the docs could be improved on - let me know what you think, feedback is obviously welcome :)

In summary:
- Linked to Conference pages where videos came through & added dates so that people have a little more context on a video's recency
- Added reference to [Relay and Routing medium post](https://medium.com/@cpojer/relay-and-routing-36b5439bad9)
- Changed a couple of sentences at the end of some guides referencing what's coming up next; for example, at the end of the Tutorial section it says you'll be taken to the Guides, but actually you get to the Videos section first
- Added links to external dependencies / plugins / functions that are mentioned and I had to look for rather than click on and be taken there
",AnSavvides,cpojer
383,2016-09-05 06:55:20,"For future googlers:
@taion released awesome [scalar GraphQLType JSON](https://github.com/taion/graphql-type-json) that supports dynamic values for a field!

I'm using it in [graphql-compose-mongoose](http://graphql-compose.herokuapp.com/), so live demos with dynamic field's type can be found here: 
- [Find User with field of MIXED type](http://graphql-compose.herokuapp.com/user/?query=%0A%7B%0A%20%20userById%28_id%3A%20%2257bb44dd21d2befb7ca3f001%22%29%20%7B%0A%20%20%20%20_id%0A%20%20%20%20name%0A%20%20%20%20someMixed%0A%20%20%7D%0A%7D%0A%20%20%20%20%20%20)
- [Create user mutation (with arg of MIXED type)](http://graphql-compose.herokuapp.com/user/?query=%0Amutation%20%7B%0A%20%20userCreate%28record%3A%20%7B%0A%20%20%20%20name%3A%20%22My%20Name%22%2C%0A%20%20%20%20age%3A%2024%2C%0A%20%20%20%20gender%3A%20ladyboy%2C%0A%20%20%20%20contacts%3A%20%7B%0A%20%20%20%20%20%20email%3A%20%22mail%40example.com%22%2C%0A%20%20%20%20%20%20phones%3A%20%5B%0A%20%20%20%20%20%20%20%20%22111-222-333-444%22%2C%0A%20%20%20%20%20%20%20%20%22444-555-666-777%22%0A%20%20%20%20%20%20%5D%0A%20%20%20%20%7D%2C%0A%20%20%20%20someMixed%3A%20%7B%0A%20%20%20%20%20%20a%3A%201%2C%0A%20%20%20%20%20%20b%3A%202%2C%0A%20%20%20%20%20%20c%3A%20%5B%201%2C%202%2C%203%2C%20true%2C%20false%2C%20%7B%20sub%3A%201%20%7D%5D%0A%20%20%20%20%7D%0A%20%20%7D%29%20%7B%0A%20%20%20%20recordId%0A%20%20%20%20record%20%7B%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20age%0A%20%20%20%20%20%20gender%0A%20%20%20%20%20%20contacts%20%7B%0A%20%20%20%20%20%20%20%20email%0A%20%20%20%20%20%20%20%20phones%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20someMixed%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%20%20%20%20%20%20)
",nodkz,taion
372,2015-09-24 03:55:24,"@yuzhi can you provide additional context here? I know we discussed this a while back.
",josephsavona,yuzhi
368,2015-09-23 22:32:40,"I'm double-checking my assumption with @dschafer - but yeah, I was thinking  in `getOptimisticPayload`
",josephsavona,dschafer
368,2015-09-23 22:53:45,"I looked into this and the problem is in `inferRelayFieldsFromData`, where we attempt to infer the query that would correspond to an optimistic payload: objects are assumed to correspond to records, so in this case Relay traverses `coordinate` as if it were a non-scalar and writes the optimistic values for x/y as if they were subfields.

Using `JSON.stringify` in `getOptimisticResponse` is a temporary workaround, but this means that view code will have to handle both the JSON-stringified value and object value for `coordinate`. Long-term we should evaluate using tracked queries to construct a more correct query to match the optimistic response payload.

cc @yuzhi @yungsters 
",josephsavona,yuzhi
368,2015-09-23 22:53:45,"I looked into this and the problem is in `inferRelayFieldsFromData`, where we attempt to infer the query that would correspond to an optimistic payload: objects are assumed to correspond to records, so in this case Relay traverses `coordinate` as if it were a non-scalar and writes the optimistic values for x/y as if they were subfields.

Using `JSON.stringify` in `getOptimisticResponse` is a temporary workaround, but this means that view code will have to handle both the JSON-stringified value and object value for `coordinate`. Long-term we should evaluate using tracked queries to construct a more correct query to match the optimistic response payload.

cc @yuzhi @yungsters 
",josephsavona,yungsters
366,2015-09-22 04:39:14,"We should probably change this to `console.warn`. What do you think @yungsters?
",kassens,yungsters
365,2015-09-22 07:38:16,"Can you include more information about what your current route looks like and also what's defined on the schema for `categories`? Did you get any babel transform errors?

cc @josephsavona could this be printer related?
",yuzhi,josephsavona
364,2015-09-21 23:30:02,"cc @steveluscher 
",vjeux,steveluscher
360,2015-09-22 06:41:12,"cc @dschafer 
",yuzhi,dschafer
358,2015-09-20 20:00:41,"cc/ @yungsters
",steveluscher,yungsters
341,2015-09-18 16:54:19,"cc @wincent who had talked about doing something like this a while back.
",josephsavona,wincent
340,2015-09-19 04:50:21,"> As mentioned above, if I don't explicitly specify the falsy range behavior for status(completed), Relay re-fetches all the edges when I add a new todo, which seems undesirable

That sounds legit. cc/ @yuzhi
",steveluscher,yuzhi
338,2015-09-18 03:25:03,"cc @vjeux 
",josephsavona,vjeux
330,2015-09-16 20:54:50,"cc/ @josephsavona
",steveluscher,josephsavona
327,2015-09-16 17:17:57,"`graphql@0.4.3` and above have changes to validation rules and parsing that affect Relay query compilation, so let's fix at `0.4.2` until we're ready to upgrade.

cc @dschafer @leebyron 
",josephsavona,dschafer
321,2015-09-16 00:01:39,"I think [this PR](https://github.com/facebook/relay/pull/316/commits) introduced some failures on master ([Travis CI output](https://travis-ci.org/facebook/relay/jobs/80348852)). I can repro locally. Going to look into it presently.

cc @josephsavona
",wincent,josephsavona
319,2015-09-16 05:09:43,"I was talking to @josephsavona about this the other day. One of the reasons that these are file references is so that if there's a breaking change in the framework, and we update the examples, any given clone of master will still work.

The file references are also here for the convenience of people who want to change framework code and see the effect on the examples. I think the canonical approach to this is to use `npm link` to link the example and the local copy of the npm module you're hacking on (we used to recommend this) but it doesn't get us the above-mentioned feature for free.

Programming is hard.
",steveluscher,josephsavona
318,2015-09-15 21:23:40,"cc @yuzhi 
",josephsavona,yuzhi
318,2015-09-15 23:01:24,"This might be a better question for GraphQL peeps @dschafer. My understanding is that cursors needs to be opaque but as long as they can be understood by the server to continue fetching additional items on a connection (with or without set of field args) then it shouldn't really matter.
But with the range add config, we would be storing the same edge.
",yuzhi,dschafer
318,2015-09-16 00:03:02,"While we're reaching out to the GraphQL folks, let's get this question on Stack Overflow. I'll ping @dschafer to answer it there, if you'd like to post the URL here.

https://stackoverflow.com/questions/ask?tags=relayjs
",steveluscher,dschafer
318,2015-09-16 11:13:19,"We have noticed the same thing about the edge for `RANGE_ADD`.

We used to encode information about the connection field arguments in our cursors, so we could raise an error if a cursor was incorrectly used with changed arguments. This was discussed in https://github.com/facebook/relay/issues/32 (see @dschafer's [answer](https://github.com/facebook/relay/issues/32#issuecomment-130410202)).

However, when adding a support for Relay mutations we noticed that we would need to return the edge from the mutations, so for example a `createStory` mutation payload would have



But the server doesn't know which connections (and connection field args) the client uses the edge for, so we had to remove the extra information from our cursors. They are now basically just object IDs and can be used for any connection / set of arguments. As @devknoll said, it seems like this stability is required for `RANGE_ADD`.

If cursors being compatible across different connection fields / arguments is a requirement for `RANGE_ADD` mutations, maybe it the connection spec needs to be clarified to suggest this behavior?
",fson,dschafer
311,2015-09-14 17:48:09,"Instead of just logging, actually treat webpack compilation errors as
a failure so that we don't continue.

Test Plan: `gulp dist && echo 'foo'` (with `fbjs@0.2.0`), don't see `foo` echoed.

cc @steveluscher @wincent 

This is the shortest path to prevent the specific issue in #303. Longer term, we might want to something a bit more versatile that also checks at the npm dependency level (might be some packages that do it already, but also pretty easy to do with some `npm outdated --json` and some semver checking or `npm ls --depth=0 | grep 'ERR!'`)
",zpao,wincent
311,2015-09-14 17:48:09,"Instead of just logging, actually treat webpack compilation errors as
a failure so that we don't continue.

Test Plan: `gulp dist && echo 'foo'` (with `fbjs@0.2.0`), don't see `foo` echoed.

cc @steveluscher @wincent 

This is the shortest path to prevent the specific issue in #303. Longer term, we might want to something a bit more versatile that also checks at the npm dependency level (might be some packages that do it already, but also pretty easy to do with some `npm outdated --json` and some semver checking or `npm ls --depth=0 | grep 'ERR!'`)
",zpao,steveluscher
309,2015-09-18 22:50:26,"@fson Relay can't convert to `lilPic: profilePic ...` because that assumes the fragment has one root field, which is rarely the case. 

Per offline discussion with @leebyron and @dschafer we'll probably have to add support for fragment aliases in the language to make this seamless. This would use your earlier proposal, @fson:


",josephsavona,dschafer
294,2015-11-07 03:33:02,"Does @kassens' answer [here](http://stackoverflow.com/a/33577928/802047) help? There, he demonstrates a pattern for implementing privacy at the data loader level.
",steveluscher,kassens
294,2015-11-07 18:02:29,"@kassens' answer does help. Thank you @kassens.

If I may follow up here, please, because it's difficult to discuss his answer via SO comments. 

@kassen writes:

> An approach that I have seen pretty successful is to bake the privacy/access control into the data model/data loader framework.

Totally makes sense. That's how I load users too and will extend this approach to the loading of all nodes.

But in order to make that happen—for example, to do `User.load(id, viewer)`—you need `viewer` at least in the root resolve methods. If so, given Relay today, the only way to get `viewer` into these resolve methods is through `args`. And to get an argument into server-side `args`, you must pass the parameter from the client. An example of this flow:
- A client authenticates by some mechanism outside of Relay.
- As part of the successful authentication, the server provides the user a token to use via HTTP request header—say a `Cookie` or `Authorization`.
- This authentication token must then be available to `Relay.Route`s on the client to use in queries.
- At the server, the token/user ID combination is validated and resolved into and ""hydrated"" `viewer`.

Such a flow seems to have the following implications:
- The `nodeDefinitions` function that comes with `graphql-relay-js` can no longer be used because the `idFetcher` in that implementation only receives and object ID and not the `viewer`.
- I need to decorate all my root field resolvers with a method that validates and hydrates user information.
- The token must be available to the JS runtime. I cannot use `httpOnly` cookies as I've done in the past to protect the token because it needs to be available to `Relay.Route`.
- The `viewer` as hydrated on the server then needs to be available to resolve methods further down the graph for any data loading that might be necessary deeper than the root field.

I'm only not sure about the last of these consequences. I suppose there is some ""context"" I can use. But I am new to this stack.

Anyway, thank you very much. What a wonderful platform.
",dminkovsky,kassens
293,2015-09-12 00:52:12,"Another option is to provide a way for the schema to define how field arguments correlate to sorting logic. For example, in the query `friends(first: 10, orderBy: ""name"")` the schema might indicate that edges should be sorted by the `name` field. Relay could use this metadata to automatically insert new edges at the correct location (and ensure that the `name` field was always fetched when this sort criteria was applied, so that every edge can be sorted correctly).

There are some cases where this may not be possible - in particular, algorithmically sorted connections such as the Facebook News Feed. In these cases, the schema could simply not define ""order by"" semantics for any arguments, and the client would have to specify append/prepend logic when adding edges.

These type of semantic schema annotations could apply more generally around connections, for example allowing for arbitrary names for `edges` and `node` fields and `first`/`after` arguments.

cc @dschafer @leebyron 
",josephsavona,dschafer
293,2015-09-16 15:45:51,"@taion The default is to refetch from the server, otherwise `append` or `prepend` behavior is used if specified. 

cc @yuzhi @steveluscher 
",josephsavona,yuzhi
293,2015-09-16 15:45:51,"@taion The default is to refetch from the server, otherwise `append` or `prepend` behavior is used if specified. 

cc @yuzhi @steveluscher 
",josephsavona,steveluscher
293,2015-09-16 19:41:15,"@dschafer posted an answer [here](http://stackoverflow.com/questions/32613879/should-the-opaque-cursors-in-connections-be-stable-across-different-field-args/32615799#32615799) that I thought was related, since it recommends embedding field arguments into edge creation on a mutation.

With that in mind, maybe we could write a spec for field types like `newFriendsEdge` that includes some additional data in the input or result to help place it.
",devknoll,dschafer
289,2015-09-10 22:18:32,"This looks like it should get fixed by #287. cc @josephsavona
",zpao,josephsavona
288,2016-05-16 15:55:14,"@a3gis Thanks for asking.

We aren't actively working on this right now and probably won't be able to focus on soon (see the [Roadmap and Meeting Notes](https://github.com/facebook/relay/tree/master/meta) for current priorities of the core team). However, we're happy to support the community in building support for this in an open-source network layer. This could be a good candidate for adding to https://github.com/nodkz/react-relay-network-layer, for example (cc @nodkz).
",josephsavona,nodkz
287,2015-09-10 21:42:38,"This reverts commit 47f2602c30b4e7940e26b15825cea5e4980af503.

@steveluscher pointed out that travis already tests the plugin, and for
local testing developers can run the extra `npm test` manually.
",josephsavona,steveluscher
285,2015-09-10 20:45:29,"We've had feedback that:
- Relay has a large number of new concepts with new terminology attached that can make it hard to apprehend.
- It is hard to get a ""big picture"" sense of _why_ things are designed the way they are. As such, people are reduced to monkey-see-monkey-do copying of examples and may not really understand how things are working, or whether their approach ends up being The Correct Way™.
- Without the ""big picture"", making sense of the API docs and guides can be difficult, and they seem relatively terse or thin.

The idea here, then, is to produce a top-down conceptual doc that complements the existing bottom-up tutorial-based documentation and reference material.

I'm thinking here of something like the wonderful ""Git for computer scientists"", that I read years ago when DVCS was still a new thing, and which laid a foundation for understanding all the new stuff (then-foreign concepts like rebasing and the index) that rest upon some simple under pinnings like the DAG and a content-addressable database.

cc @josephsavona per our offline discussion
",wincent,josephsavona
282,2015-09-10 20:35:28,"@wincent @yuzhi  @yungsters thoughts on automatically adding `__typename` for interface/union types?
",josephsavona,yuzhi
282,2015-09-10 20:35:28,"@wincent @yuzhi  @yungsters thoughts on automatically adding `__typename` for interface/union types?
",josephsavona,wincent
282,2015-09-10 20:35:28,"@wincent @yuzhi  @yungsters thoughts on automatically adding `__typename` for interface/union types?
",josephsavona,yungsters
280,2015-09-10 15:38:53,"cc @devknoll @drabinowitz
",josephsavona,devknoll
268,2015-09-09 07:37:31,"`__typename` is [implicit](https://facebook.github.io/graphql/#sec-Type-Name-Introspection), but babel-relay-plugin doesn't know about it and won't compile fragments containing it (partially related to #162?)

It seems like it might be beneficial to have, otherwise developers will have to manually expose one themselves any time they are composing more than one child fragment:



(p.s. would be a lovely time for @dschafer to jump in and drop some news feed knowledge again, since that has since disappeared from the slack archives :wink:)
",devknoll,dschafer
268,2015-09-09 17:09:42,"Products should _definitely_ be able to ask for `__typename` - @dschafer @leebyron thoughts on whether the JSON -> schema builder should generate these fields, or whether we should just hardcode handling for them in the plugin?
",josephsavona,dschafer
265,2015-09-08 22:44:43,"Currently, here's what the Relay Prototyping tool does to surface errors that originate from the Babel Relay plugin:
1. Collect `console.warn` logs; throw them out after they're 500 ms old.
2. Watch for exceptions thrown that contain the text “GraphQL Validation error”
3. Present the collected warnings

This means that errors that crop up under the following conditions will not be displayed:

a. You performed a mutation with GraphQL errors >500ms after the transform
b. You late-added a RelayContainer with GraphQL errors to the tree >500ms after the transform

To fix this, we could modify the `babel-relay-plugin` to accept a config param that tells it to throw errors right away instead of printing console warnings. Thoughts, @josephsavona?
",steveluscher,josephsavona
263,2015-09-08 19:40:04,"I'd love to be able to contribute more meaningfully (+ encourage others to contribute more) to Relay! Most of the outside contributions so far are have been small; mostly fixing bugs, documentation issues, or build/release issues. 

It would be great if we could set up some milestones (or similar) on GitHub so that we can get an idea of not just what is already being worked on by FB, but also a sense of any bigger or longer term projects that the community can contribute to as well.

The former can partially be gleaned from some existing GitHub issues, like...
- [ ] Server-side rendering hooks #136 (@voideanvalue)
- [ ] Client-side schema #114 (@josephsavona)
- [ ] Better intro tutorials #6 (@steveluscher)
- [ ] Support root fields w/o node mapping #112 (?)
- [ ] Better developer tools (@kassens)
- [ ] Support deferred queries (@wincent)

The latter is harder, but probably looks something like:
- [ ] Improved mutation config/error handling #231 #261
- [ ] Easier to use Babel plugin #206
- [ ] ...more

The _Help Wanted_ tags that @yungsters has been adding seem like a good step in this direction, though.
",devknoll,josephsavona
263,2015-09-08 19:40:04,"I'd love to be able to contribute more meaningfully (+ encourage others to contribute more) to Relay! Most of the outside contributions so far are have been small; mostly fixing bugs, documentation issues, or build/release issues. 

It would be great if we could set up some milestones (or similar) on GitHub so that we can get an idea of not just what is already being worked on by FB, but also a sense of any bigger or longer term projects that the community can contribute to as well.

The former can partially be gleaned from some existing GitHub issues, like...
- [ ] Server-side rendering hooks #136 (@voideanvalue)
- [ ] Client-side schema #114 (@josephsavona)
- [ ] Better intro tutorials #6 (@steveluscher)
- [ ] Support root fields w/o node mapping #112 (?)
- [ ] Better developer tools (@kassens)
- [ ] Support deferred queries (@wincent)

The latter is harder, but probably looks something like:
- [ ] Improved mutation config/error handling #231 #261
- [ ] Easier to use Babel plugin #206
- [ ] ...more

The _Help Wanted_ tags that @yungsters has been adding seem like a good step in this direction, though.
",devknoll,yungsters
263,2015-09-08 19:40:04,"I'd love to be able to contribute more meaningfully (+ encourage others to contribute more) to Relay! Most of the outside contributions so far are have been small; mostly fixing bugs, documentation issues, or build/release issues. 

It would be great if we could set up some milestones (or similar) on GitHub so that we can get an idea of not just what is already being worked on by FB, but also a sense of any bigger or longer term projects that the community can contribute to as well.

The former can partially be gleaned from some existing GitHub issues, like...
- [ ] Server-side rendering hooks #136 (@voideanvalue)
- [ ] Client-side schema #114 (@josephsavona)
- [ ] Better intro tutorials #6 (@steveluscher)
- [ ] Support root fields w/o node mapping #112 (?)
- [ ] Better developer tools (@kassens)
- [ ] Support deferred queries (@wincent)

The latter is harder, but probably looks something like:
- [ ] Improved mutation config/error handling #231 #261
- [ ] Easier to use Babel plugin #206
- [ ] ...more

The _Help Wanted_ tags that @yungsters has been adding seem like a good step in this direction, though.
",devknoll,kassens
263,2015-09-08 19:40:04,"I'd love to be able to contribute more meaningfully (+ encourage others to contribute more) to Relay! Most of the outside contributions so far are have been small; mostly fixing bugs, documentation issues, or build/release issues. 

It would be great if we could set up some milestones (or similar) on GitHub so that we can get an idea of not just what is already being worked on by FB, but also a sense of any bigger or longer term projects that the community can contribute to as well.

The former can partially be gleaned from some existing GitHub issues, like...
- [ ] Server-side rendering hooks #136 (@voideanvalue)
- [ ] Client-side schema #114 (@josephsavona)
- [ ] Better intro tutorials #6 (@steveluscher)
- [ ] Support root fields w/o node mapping #112 (?)
- [ ] Better developer tools (@kassens)
- [ ] Support deferred queries (@wincent)

The latter is harder, but probably looks something like:
- [ ] Improved mutation config/error handling #231 #261
- [ ] Easier to use Babel plugin #206
- [ ] ...more

The _Help Wanted_ tags that @yungsters has been adding seem like a good step in this direction, though.
",devknoll,wincent
263,2015-09-08 19:40:04,"I'd love to be able to contribute more meaningfully (+ encourage others to contribute more) to Relay! Most of the outside contributions so far are have been small; mostly fixing bugs, documentation issues, or build/release issues. 

It would be great if we could set up some milestones (or similar) on GitHub so that we can get an idea of not just what is already being worked on by FB, but also a sense of any bigger or longer term projects that the community can contribute to as well.

The former can partially be gleaned from some existing GitHub issues, like...
- [ ] Server-side rendering hooks #136 (@voideanvalue)
- [ ] Client-side schema #114 (@josephsavona)
- [ ] Better intro tutorials #6 (@steveluscher)
- [ ] Support root fields w/o node mapping #112 (?)
- [ ] Better developer tools (@kassens)
- [ ] Support deferred queries (@wincent)

The latter is harder, but probably looks something like:
- [ ] Improved mutation config/error handling #231 #261
- [ ] Easier to use Babel plugin #206
- [ ] ...more

The _Help Wanted_ tags that @yungsters has been adding seem like a good step in this direction, though.
",devknoll,steveluscher
263,2015-09-08 19:40:04,"I'd love to be able to contribute more meaningfully (+ encourage others to contribute more) to Relay! Most of the outside contributions so far are have been small; mostly fixing bugs, documentation issues, or build/release issues. 

It would be great if we could set up some milestones (or similar) on GitHub so that we can get an idea of not just what is already being worked on by FB, but also a sense of any bigger or longer term projects that the community can contribute to as well.

The former can partially be gleaned from some existing GitHub issues, like...
- [ ] Server-side rendering hooks #136 (@voideanvalue)
- [ ] Client-side schema #114 (@josephsavona)
- [ ] Better intro tutorials #6 (@steveluscher)
- [ ] Support root fields w/o node mapping #112 (?)
- [ ] Better developer tools (@kassens)
- [ ] Support deferred queries (@wincent)

The latter is harder, but probably looks something like:
- [ ] Improved mutation config/error handling #231 #261
- [ ] Easier to use Babel plugin #206
- [ ] ...more

The _Help Wanted_ tags that @yungsters has been adding seem like a good step in this direction, though.
",devknoll,voideanvalue
263,2015-09-09 00:14:53,"> I'd love to be able to contribute more meaningfully (+ encourage others to contribute more) to Relay!

Yes, we'd love that too. Thanks for bringing this up!

You have a pretty good list there of what we're working on internally. The one or two things that seem to be missing is better developer tools (@kassens) and porting our already-existing internal support for deferred queries (@wincent).

I am not sure if we're ready to start planning at the milestone level (the project is still so young, that we expect to be doing regular releases at a cadence of about every two weeks or so, and a lot of this early work is reactive/responsive to emergent needs), but doing a better job with labels is something we should do right now.

I also think a bit more of a (tentative) roadmap document could be useful.
",wincent,wincent
263,2015-09-09 00:14:53,"> I'd love to be able to contribute more meaningfully (+ encourage others to contribute more) to Relay!

Yes, we'd love that too. Thanks for bringing this up!

You have a pretty good list there of what we're working on internally. The one or two things that seem to be missing is better developer tools (@kassens) and porting our already-existing internal support for deferred queries (@wincent).

I am not sure if we're ready to start planning at the milestone level (the project is still so young, that we expect to be doing regular releases at a cadence of about every two weeks or so, and a lot of this early work is reactive/responsive to emergent needs), but doing a better job with labels is something we should do right now.

I also think a bit more of a (tentative) roadmap document could be useful.
",wincent,kassens
261,2016-05-10 15:55:39,"@xuorig and @yuzhi have recently implemented this and improved the messaging.
",josephsavona,yuzhi
261,2016-05-10 15:55:39,"@xuorig and @yuzhi have recently implemented this and improved the messaging.
",josephsavona,xuorig
258,2015-09-08 13:38:11,"Hi!

Currently in the spec the `clientMutationId` in mutations has to be non-null. The requirement seems overly strict - in GraphiQL usage or while using other clients but Relay, one doesn't _have_ to use `clientMutationId` to actually make a mutation.

I propose to remove the requirement on non-nullness from clientMutationId, both in input and in payload. Instead one can say that clientMutationId _must_ be returned if it was provided.

Pinging stakeholders - @dschafer.
",freiksenet,dschafer
252,2015-09-07 19:30:06,"cc @steveluscher re. the more informative error messages
",josephsavona,steveluscher
247,2015-09-06 23:37:37,"cc @yuzhi 
",josephsavona,yuzhi
241,2015-09-08 22:46:26,"cc @steveluscher :)
",yungsters,steveluscher
240,2015-09-05 04:25:53,"cc/ @schrockn @dschafer @leebyron
",steveluscher,dschafer
239,2015-09-05 00:59:39,"#217 fixed this. Doesn't look like @yungsters got around to publishing the updated package with that.
",zpao,yungsters
238,2015-09-04 22:43:34,"This is a Jest-provided extension, so not suitable for use outside the
test suite.

Test plan: Boot up Relay Starter Kit. See it load, and no errors about
inexistent `requireActual`.

CC: @yungsters 
",wincent,yungsters
237,2015-11-10 19:07:54,"@steveluscher 's answer (http://stackoverflow.com/questions/32539189/how-to-get-the-id-of-a-new-object-from-a-mutation/32546415#32546415) explains how to use `REQUIRED_CHILDREN` for adding a new node and getting It's ID to be used in callback. However @wincent (http://stackoverflow.com/a/33367168/96725) states that It could also be used for deleting a node without requiring It's parent (where node doesn't know its parent etc.) Could you please provide an example for this use case too? I'm currently working on a mutation, where deleted node isn't aware of it's parents. 
",oguzbilgic,wincent
237,2015-11-10 19:07:54,"@steveluscher 's answer (http://stackoverflow.com/questions/32539189/how-to-get-the-id-of-a-new-object-from-a-mutation/32546415#32546415) explains how to use `REQUIRED_CHILDREN` for adding a new node and getting It's ID to be used in callback. However @wincent (http://stackoverflow.com/a/33367168/96725) states that It could also be used for deleting a node without requiring It's parent (where node doesn't know its parent etc.) Could you please provide an example for this use case too? I'm currently working on a mutation, where deleted node isn't aware of it's parents. 
",oguzbilgic,steveluscher
236,2015-09-04 20:54:58,"Thanks for bringing this up. Indeed, you do need to use `CHILDREN_REQUIRED` because `widget` does not have a parent field (from my understanding) that the view could possibly have already fetched or rendered.

I spoke with @yuzhi and we came to the conclusion that:
- `CHILDREN_REQUIRED` should be renamed to something like `EXTRA_FRAGMENT`.
- We need to revise the code documentation (and add website documentation) for this and its valid use cases.

I hope this answers your question. I'll open a separate issue to rename and revise documentation.

---

Separately, I noticed you have `widget` and `widgetId`. Why not just fetch `widget { id }`?
",yungsters,yuzhi
233,2015-09-26 18:50:21,"cc @skevy @devknoll @taion @fson anybody interested? ;-)
",josephsavona,fson
233,2015-09-26 18:50:21,"cc @skevy @devknoll @taion @fson anybody interested? ;-)
",josephsavona,taion
233,2015-09-26 18:50:21,"cc @skevy @devknoll @taion @fson anybody interested? ;-)
",josephsavona,devknoll
233,2015-09-27 18:34:36,"@fson 

I like the idea of not having that global singleton Relay store.

Ignoring implementation difficulties for now, there are a couple of practical API considerations.
- For things like modals and overlays and other dynamic content with data dependencies, when not associating a route to them, it's probably easiest to just set up a new `RootContainer` - this `RootContainer` ideally should share the same store as the top-level `RootContainer`; perhaps `RootContainer`s can export the store as context and children `RootContainer`s can try to use those first
  - The context approach requires things that use portals to use `unstable_renderSubtreeIntoContainer`, though... ideally anybody doing this is using something like `react-overlays` that deals with this for them
- Same as above, but taking the naive routing approach @cpojer covers at https://medium.com/@cpojer/relay-and-routing-36b5439bad9, instead of using `react-router-relay` or something equivalent
- Same as above, but for mocking `.defer` support with extra `RootContainer`s
- @skevy can comment on this, but I believe naive approaches with navigator on RN lead to multiple sibling `RootContainer`s that would not be able to share state with this approach, and that actually keeping everything under a single top-level `RootContainer` requires quite a lot of work
",taion,cpojer
231,2015-09-03 16:37:40,"Thanks to the help of @devknoll, I found out this issue is because nowhere else in the app is `user { comics }` being queried, so the query from the mutation is being subtracted. I guess my only remaining confusion then is whether Relay should be throwing errors like the one posted above when it doesn't receive the corresponding fragment for a query that it itself subtracted.
",sgwilym,devknoll
217,2015-09-03 06:36:38,"@josephsavona Looks like this made it into the published 0.2.1. We may want to publish a 0.2.2 with this fix after it's merged.
",yungsters,josephsavona
206,2015-09-02 00:16:13,"Allowing configuration via a `.graphqlrc` seems reasonable tome.

I'm actually not familiar with these ""plans for the plugin going forward"". @josephsavona?
",yungsters,josephsavona
202,2015-09-01 08:23:13,"As @zpao suggested (reference #58) here is the new PR with the rules from [facebook/fbjs#49](https://github.com/facebook/fbjs/pull/49).

I'll still need some guidance on what should be Relay specific.

At the moment with the current fbjs rules there is a lot of errors on [no-undef](http://eslint.org/docs/rules/no-undef.html) (example: $FlowIssue, $FixMe, $Enum and also when defining Flow types, this is related to [babel-eslint/known-issues](https://github.com/babel/babel-eslint#known-issues) - [babel-eslint#130](https://github.com/babel/babel-eslint/issues/130) and [babel-eslint#132](https://github.com/babel/babel-eslint/issues/132))

@josephsavona @zpao what are your thoughts?
",knowbody,josephsavona
202,2015-09-01 08:23:13,"As @zpao suggested (reference #58) here is the new PR with the rules from [facebook/fbjs#49](https://github.com/facebook/fbjs/pull/49).

I'll still need some guidance on what should be Relay specific.

At the moment with the current fbjs rules there is a lot of errors on [no-undef](http://eslint.org/docs/rules/no-undef.html) (example: $FlowIssue, $FixMe, $Enum and also when defining Flow types, this is related to [babel-eslint/known-issues](https://github.com/babel/babel-eslint#known-issues) - [babel-eslint#130](https://github.com/babel/babel-eslint/issues/130) and [babel-eslint#132](https://github.com/babel/babel-eslint/issues/132))

@josephsavona @zpao what are your thoughts?
",knowbody,zpao
190,2015-08-31 16:27:17,"@steveluscher For the separate problem of duplicate/nested anchors, I'm currently thinking of just modifying https://github.com/facebook/relay/blob/master/website/core/Header.js to keep the slug in the context and nesting them on render.

Sound good?
",devknoll,steveluscher
186,2015-08-28 19:17:49,"Uh oh. @yungsters it seems like the NetworkLayer changes from #70 made it in, but the doc changes did not. This brings them back!
",devknoll,yungsters
185,2015-08-28 02:13:37,"GraphQL servers may support various forms of pagination, for example:



Relay currently supports only a) - the `edges{node{...}}` variant, and warns about case b) only if the field is called `nodes`. This PR changes the warning by detecting any use of the b) pattern regardless of the field's name.

cc @dschafer @leebyron @schrockn @yuzhi 
",josephsavona,yuzhi
185,2015-08-28 02:13:37,"GraphQL servers may support various forms of pagination, for example:



Relay currently supports only a) - the `edges{node{...}}` variant, and warns about case b) only if the field is called `nodes`. This PR changes the warning by detecting any use of the b) pattern regardless of the field's name.

cc @dschafer @leebyron @schrockn @yuzhi 
",josephsavona,dschafer
182,2015-09-02 01:55:42,"Thanks @devknoll!
",steveluscher,devknoll
181,2015-08-27 07:47:57,"Another crack at #20 / #131

Rather than building the query set from the set of all fragments that a component has, it builds them from the set **required** by the route, and throws if the component doesn't provide one.

I'm on the fence about keeping `hasFragment`.

This should be compatible with FB code, but let me know if it's not @steveluscher @josephsavona
",devknoll,steveluscher
181,2015-08-27 07:47:57,"Another crack at #20 / #131

Rather than building the query set from the set of all fragments that a component has, it builds them from the set **required** by the route, and throws if the component doesn't provide one.

I'm on the fence about keeping `hasFragment`.

This should be compatible with FB code, but let me know if it's not @steveluscher @josephsavona
",devknoll,josephsavona
181,2015-08-27 17:34:57,"Fixed. @josephsavona do you have any thoughts about `hasFragment`? I don't really like bloating the RelayContainer interface...
",devknoll,josephsavona
180,2015-08-27 04:18:15,"[Per @josephsavona's request](https://twitter.com/en_JS/status/635842439991836673), this is some initial feedback on my experience going through [the tutorial](https://facebook.github.io/relay/docs/tutorial.html). I should mention I had little exposure to and no experience with either GraphQL or Relay before this.

I started getting very lost around [the section on authoring a schema](https://facebook.github.io/relay/docs/tutorial.html#authoring-a-schema). I found myself typing the code listings to follow along, but not really understanding what everything meant or did as I did so (especially at the call to `nodeDefinitions` and when defining types/connections). There's quite a bit of verbose-looking code to it all, and I felt like it might be apparent to me at the end what it did, but that point never really came.

In the end, I got the game to work after some fiddling (I chose a different name for the mutation and thus the fat query's `fragment on CheckHidingSpotForTreasurePayload` didn't work), but I didn't really understand why, and my attempt to add a simple mutation to reset the game state without needing to restart the server took me a surprisingly large amount of time to get right.

In the end, I decided to start over and go as raw and simple as possible. With the help of [this article](https://medium.com/@clayallsopp/your-first-graphql-server-3c766ab4f0a2) I started with a _super minimal_ schema, and once I got it working (and realized how little code was actually required), I managed to come up with this simple schema that fetches data from Reddit:



It was then a relatively simple matter of copying patterns from the tutorial to render the data with React and Relay (after dropping the second `after` parameter from the root field). I was [very happy to see it all work](https://twitter.com/BinaryMuse/status/636737593577598976). Now that I understand the basics and have a somewhat-working knowledge, I feel comfortable with learning what's wrong/could be improved with my little schema, and [diving into graphql-relay](https://github.com/graphql/graphql-relay-js) and learning more advanced techniques.

In hindsight, I think my confusion stemmed from two things:
1. I wasn't very familiar with GraphQL. I understood the ideas, but basically none of the implementation. A skim of the spec helped, but at the time I felt there was very little official documentation to point me in the right direction. This is partially my fault for not being quite prepared, though either a pointer to another document or something to that matter would probably be helpful.
2. `graphql-relay`'s abstractions—while I'm sure they're very useful (I'm still digging in), they seemed to be the cause of what seemed like a lot of noise in the code as I was copying it down. The names didn't resonate any kind of meaning with me, and the documentation for them only makes sense if you're already familiar with the basics.

I hope this issue doesn't come off as too critical; the project is of course young, and docs are hard, and I was hardly the best candidate for them. :) Relay (and GraphQL) seems super cool, and I'm looking forward to learning more!
",BinaryMuse,josephsavona
180,2015-08-27 16:42:30,"cc @steveluscher 
",josephsavona,steveluscher
175,2015-08-26 22:22:51,"I think it's so that `npm test` runs both Flow and Jest (to discourage people from submitting pull requests that break Flow types). @steveluscher would know the original intent.
",yungsters,steveluscher
170,2015-08-26 21:29:51,"This type of polymorphic fragment definition isn't supported. A similar option is to use interfaces - for example, multiple types might have connection fields with the type `UsersConnection` and `node` fields of type `User`. This would allow you to create generic components that could paginate a list of users. 

@dschafer Can you think of any other options?
",josephsavona,dschafer
168,2015-08-25 23:57:35,"In the blog post introducing Relay, @josephsavona said, ""We're working to extend Relay to provide a unified interface for interacting not only with server data, but also in-memory and native device data (and, even better, a mix of all three).""

I was curious to hear more about what that means exactly :)

Does this mean you'd like Relay to replace Flux at Facebook? Will you be able to create client-side only GraphQL types that you can query/mutate client side?

Any plans to do stuff like time-traveling debugging, user state saving/restoring, etc.?
",KyleAMathews,josephsavona
162,2015-08-24 23:03:54,"There's no reason why this couldn't work. 

@dschafer I tried transpiling an instrospection query with `babel-relay-plugin`, but got an error at [this line in GraphQLPrinter](https://github.com/facebook/relay/blob/master/scripts/babel-relay-plugin/src/GraphQLPrinter.js#L105):

`options.schema.getQueryType().getFields()[rootCallName];`

Probably because the `__schema` field doesn't exist in the application's schema. Any ideas?
",josephsavona,dschafer
147,2015-08-22 18:26:25,"It is possible to have nested `<RelayRootContainer>`s, but this would incur multiple round trips. However, the case that you're describing is similar to the problem of nested routes - have you looked at react-router? That in combination with https://github.com/devknoll/relay-nested-routes would allow fetching all the data for the Layout and Conent. 

See also @cpojer's [great blog post about this topic](https://medium.com/@cpojer/relay-and-routing-36b5439bad9).
",josephsavona,cpojer
138,2015-08-21 19:17:19,"On master, I'm seeing field aliases that look like `_0NaN`. Seems to be due to https://github.com/facebook/relay/blob/master/package.json#L31 being used over the one in fbjs.

Not quite sure which one we _want_ to be using, but the crc32 on npm returns a base16 string :smile: 

@yungsters @yuzhi 
",devknoll,yuzhi
138,2015-08-21 19:17:19,"On master, I'm seeing field aliases that look like `_0NaN`. Seems to be due to https://github.com/facebook/relay/blob/master/package.json#L31 being used over the one in fbjs.

Not quite sure which one we _want_ to be using, but the crc32 on npm returns a base16 string :smile: 

@yungsters @yuzhi 
",devknoll,yungsters
136,2015-08-21 18:01:19,"Relay was built to support server-side rendering, and we are doing so internally at Facebook. @voideanvalue gives a great overview of [how that works](https://github.com/facebook/relay/issues/36#issuecomment-130402024). However, the necessary hooks and APIs are not exposed in the OSS release. A future update to Relay will provide support and documentation for this feature.
",josephsavona,voideanvalue
136,2015-09-24 15:26:29,"Yeah, this same issue affects using Relay on React Native

@yungsters @zpao - should we require that users bring their own `fetch` polyfill? Another option would be to split `RelayDefaultNetworkLayer` into its own package.
",josephsavona,yungsters
136,2015-09-24 15:26:29,"Yeah, this same issue affects using Relay on React Native

@yungsters @zpao - should we require that users bring their own `fetch` polyfill? Another option would be to split `RelayDefaultNetworkLayer` into its own package.
",josephsavona,zpao
136,2015-09-24 17:21:57,"I had looked at node fetch modules when @steveluscher did this initially. We sort of brushed off the node case. But it's obviously an issue people are having.

I hadn't seen `isomorphic-fetch` at the time, I sort of like that. The only problem with it is that afaik, it's not going to be awesome for browser packaging when using Webpack (unless that has started reading the `browser` field in `package.json`). Browserify should be fine though. I'd like to hear from Webpack experts about what would need to be done (my concern is not for us consuming it here but for the end user app consuming Relay).

For React Native… I'm not sure. The node one uses node APIs and maybe we bring in some shimming so that packaging works but I also wouldn't be surprised if we don't. Would want to talk to experts. There might already be a `fetch` polyfill implemented in the RN runtime and if it uses the `browser` package there maybe it _just works_.

Seems like we can probably move the fetch discussion elsewhere since it's not really the point of this issue, just a piece of the puzzle.
",zpao,steveluscher
136,2015-10-22 00:33:30,"@RavenHursT 

> Do we have any updates on this?

I don't believe anybody is actively working on this internally right now (although this issue is currently assigned to @voideanvalue he's working on other stuff presently). It's possible that providing support to an external contributor who wants to work on this might get us there faster than doing it ourselves.
",wincent,voideanvalue
136,2015-10-22 21:14:56,"@wincent I'm more than willing to give a hand.. can you or @voideanvalue give me a starting point or two where I could start spelunking into the problem?
",RavenHursT,voideanvalue
135,2015-08-24 15:27:22,"#146 seems related - cc @steveluscher 
",josephsavona,steveluscher
132,2015-08-20 23:14:30,"Currently, if you have pass a route into a `RootContainer` that has n queries, then n fetches are made to the server.

This actually seems like an issue that should be resolvable before the query even hits the network layer, so fixing it should mean good things even for custom network layers!

@yungsters @josephsavona @dschafer Is there any fundamental problem with just generating a union of the queries in `processQueue` before sending them off? Is this compatible with future plans for `@defer`'d queries?
",devknoll,yungsters
132,2015-08-20 23:14:30,"Currently, if you have pass a route into a `RootContainer` that has n queries, then n fetches are made to the server.

This actually seems like an issue that should be resolvable before the query even hits the network layer, so fixing it should mean good things even for custom network layers!

@yungsters @josephsavona @dschafer Is there any fundamental problem with just generating a union of the queries in `processQueue` before sending them off? Is this compatible with future plans for `@defer`'d queries?
",devknoll,josephsavona
132,2015-08-20 23:14:30,"Currently, if you have pass a route into a `RootContainer` that has n queries, then n fetches are made to the server.

This actually seems like an issue that should be resolvable before the query even hits the network layer, so fixing it should mean good things even for custom network layers!

@yungsters @josephsavona @dschafer Is there any fundamental problem with just generating a union of the queries in `processQueue` before sending them off? Is this compatible with future plans for `@defer`'d queries?
",devknoll,dschafer
131,2015-08-20 16:28:40,"@steveluscher Yeah, I was worried that it would be a little too strict -- https://github.com/facebook/relay/pull/49#discussion_r37269845. Shall I open a PR that just requires that the route provides everything the container wants instead?

cc @josephsavona
",devknoll,josephsavona
127,2015-08-20 22:57:40,"@zpao What is the best approach here?
",josephsavona,zpao
127,2015-08-20 23:02:09,"This ties into the work that needs to be done to get react native all on board with react 0.14 and no longer providing their own override. (eg, you would do `require('react')` to create classes, the same way you do on web - that would be the isomorphic react, then `require('react-native')` gives you something else, like the renderer a la `require('react-dom')`).

cc @spicyj @sebmarkbage who have been working on this.

Not sure how far out that is, but perhaps React Native can just add `unstable_batchedUpdates` to their React overrride.
",zpao,sebmarkbage
127,2015-08-20 23:02:09,"This ties into the work that needs to be done to get react native all on board with react 0.14 and no longer providing their own override. (eg, you would do `require('react')` to create classes, the same way you do on web - that would be the isomorphic react, then `require('react-native')` gives you something else, like the renderer a la `require('react-dom')`).

cc @spicyj @sebmarkbage who have been working on this.

Not sure how far out that is, but perhaps React Native can just add `unstable_batchedUpdates` to their React overrride.
",zpao,spicyj
126,2015-08-20 18:20:50,"Thanks for pointing this out! It is unused in the current implementation, but the current implementation also refetches the todos, whether or not their `complete` flag has been flipped. This would also work:



…but having to specify at least one `id` for `changedTodos` in `fieldIDs` is awkward, especially because this mutation is designed to make supplying the actual todos optional.

Maybe there's something else that we could do here, like:



… to signal that we want to intersect the fat query with the union of all the tracked queries for this type, and send the resultant query up with the mutation.

Thoughts, @yuzhi @joesavona, @yungsters?
",steveluscher,yuzhi
126,2015-08-20 18:20:50,"Thanks for pointing this out! It is unused in the current implementation, but the current implementation also refetches the todos, whether or not their `complete` flag has been flipped. This would also work:



…but having to specify at least one `id` for `changedTodos` in `fieldIDs` is awkward, especially because this mutation is designed to make supplying the actual todos optional.

Maybe there's something else that we could do here, like:



… to signal that we want to intersect the fat query with the union of all the tracked queries for this type, and send the resultant query up with the mutation.

Thoughts, @yuzhi @joesavona, @yungsters?
",steveluscher,yungsters
126,2016-06-28 01:16:13,"@zpao is https://github.com/relayjs/relay-examples private?
",mhart,zpao
121,2015-08-19 15:41:50,"Nothing specific jumped out at me. The some of the gibberish characters you see are just auto-generated fragment names and field aliases. One thing I wanted to double check is does your `viewer` root field return a `User` type?

@dschafer does anything look out of place to you?
",yuzhi,dschafer
119,2016-01-06 19:56:58,"Is [this comment from the todos example](https://github.com/facebook/relay/blob/6229170583737b8fb633777b911ba40cbe37c312/examples/todo/js/mutations/AddTodoMutation.js#L60-L61) the result of behavior? @yungsters 
",dminkovsky,yungsters
118,2015-09-11 04:40:43,"@taion did this in https://github.com/taion/relay-todomvc

…putting a PR on my wishlist. :gift: 
",steveluscher,taion
112,2015-08-25 15:58:25,"@yungsters @josephsavona is it possible that this change would also allow us to remove the Relay-specific Input Objects on mutations? It seems super strange that GraphQL supports multiple arguments but then Relay forces them to all be wrapped up ;-)

Edit: would lose the ability to have a single variable in the document and stuff all the values into a variable as an input object though.
",devknoll,josephsavona
110,2015-08-18 17:31:54,"In the meantime, to unblock you, you can adapt [this one](https://github.com/facebook/relay/blob/master/examples/todo/scripts/updateSchema.js) for your purpose!

cc/ @josephsavona
",steveluscher,josephsavona
109,2015-08-18 16:15:42,"cc @cpojer 
",yungsters,cpojer
106,2015-08-19 01:26:57,"cc @steveluscher who was going to work on an example with multiple routes
",josephsavona,steveluscher
105,2015-08-18 17:28:38,"This should be resolved by #96 - thanks @devknoll! (feel free to re-open if it isn't)
",josephsavona,devknoll
104,2015-08-18 17:28:04,"@yungsters Are there any internal users of `buildRQL.Query`? Seems like it's only being used for routes. I'll probably make this change there if not.
",devknoll,yungsters
103,2015-08-18 06:52:04,"@cpojer 
RE: #102 
",knowbody,cpojer
100,2015-08-18 17:19:21,"This is a known limitation - we didn't have time to add support for printing enums inside input objects. Again, this isn't difficult but it requires adding quite a bit more metadata about arguments in order to print them correctly. 

cc @leebyron @dschafer is there anything we can do to make it easier for tools to autogenerate valid inputs?
",josephsavona,dschafer
91,2015-08-18 19:53:54,"The transport layer is probably the wrong place to introduce this as it couples too much of the system together; in particular, the transpiler (to annotate types), the query representation (to expose this metadata), and any network implementation. It also increases the responsibility of a network layer, putting a burden on all implementors.

The best way to approach this is to change `babel-relay-plugin` to annotate the types of leaf fields, and add support in the payload processing phase (`RelayQueryWriter`) for deserializing ""complex"" values. For each leaf field, check if it has a non-scalar (Int, String, Boolean) type and if so, determine if there is an injected handler for that type. Pseudo code:



cc @yungsters 
",josephsavona,yungsters
91,2015-08-18 19:56:36,"Edit: summarizing on offline discussion with @yungsters - given the complexity of the ""ideal"" solution I described above, we're inclined to _not_ add support for deserializing complex values right now. Doing so could conflict with other planned improvements such as querying local/device data and representing the cache as an immutable object.

We'd be curious to see how you approach this in a custom network layer and see about integrating that work down the road.
",josephsavona,yungsters
90,2015-08-17 16:43:30,"@yungsters @yuzhi Perhaps we should add a `RelayGraphQLInterface` with a `formatVariable(name: string): string` method, so that we can format these strings appropriately?
",josephsavona,yuzhi
90,2015-08-17 16:43:30,"@yungsters @yuzhi Perhaps we should add a `RelayGraphQLInterface` with a `formatVariable(name: string): string` method, so that we can format these strings appropriately?
",josephsavona,yungsters
89,2015-08-17 16:28:31,"cc @dschafer 
",josephsavona,dschafer
84,2015-08-17 16:29:10,"cc @dschafer 
",yuzhi,dschafer
80,2015-08-17 16:51:39,"cc @steveluscher 
",josephsavona,steveluscher
76,2015-08-15 05:33:00,"cc @dschafer 
",josephsavona,dschafer
70,2015-08-18 06:58:55,"Note that this PR depends on changes in fbjs. I'll publish a new version of fbjs to go with this PR when this is ready.

@devknoll Per our discussion, I've removed `credentials: 'same-origin'` as a default.
",yungsters,devknoll
67,2015-08-14 05:10:42,"@dschafer @steveluscher 
",cletusw,steveluscher
67,2015-08-14 05:10:42,"@dschafer @steveluscher 
",cletusw,dschafer
67,2015-08-14 06:04:46,"I checked this out, and can confirm that it works! I'll leave it to @dschafer to push the button, since he might be interested in something like this for his [original example](https://github.com/graphql/graphql-relay-js/blob/master/src/__tests__/starWarsData.js).
",steveluscher,dschafer
66,2015-08-14 04:48:46,"Ah gotcha. Sorry to delay anything open source! I bet you won't have to wait long, right @steveluscher nudgenudge ;)
",zpao,steveluscher
66,2015-08-14 06:11:14,"@yungsters wanted to push v0.1.1 tonight, but I whined and said “tomorrow.”

So… tomorrow.
",steveluscher,yungsters
62,2015-08-13 23:48:20,"@wincent I think that was just me being n00b when I initially created the repository. (I was testing with `npm pack` and forgot to remove the file before checking in.)
",yungsters,wincent
53,2015-08-13 17:33:09,"@steveluscher: thoughts?
",wincent,steveluscher
53,2015-08-14 06:59:24,"Also curious to hear if @zpao has any feedback.
",yungsters,zpao
50,2015-08-13 06:44:18,"This is discussd in #14 and reported in #42. /cc @yungsters 
",sairion,yungsters
49,2015-08-13 21:50:57,"This now addresses https://github.com/facebook/relay/issues/20#issuecomment-130770234, raising an error if either a route or the container have any unmatched queries/fragments.

cc @yungsters @josephsavona
",devknoll,yungsters
49,2015-08-13 21:50:57,"This now addresses https://github.com/facebook/relay/issues/20#issuecomment-130770234, raising an error if either a route or the container have any unmatched queries/fragments.

cc @yungsters @josephsavona
",devknoll,josephsavona
42,2015-08-12 21:54:00,"Thanks for reporting! @steveluscher is looking into this in #14.
",voideanvalue,steveluscher
32,2015-08-12 10:15:58,"@dschafer mentioned that using cursors when, eg, ordering changes is not guaranteed to be correct. Should compliant server implementation:

a) signal error 
b) return null
c) proceed as normal, even if result might be pretty random?
",freiksenet,dschafer
32,2015-08-13 12:59:06,"Quoting @yuzhi from slack

> You can have something like `connectionName(orderby: 'foo', first: 10)`, Relay will keep it > separate from `connectionName(first:10)`, and do it's best to keep the ordering we got from the server.

@freiksenet So as you also mentioned - Relay use new cursors with new arguments for connection.

I understand @dschafer example - when cursors on server changes for some reason (cache expires, data changes by different client, ...) it makes sense to inform client that existing cursors are invalid. 

But still don't understand why changing connection arguments on client would cause the problem as Relay should keep separate cursors automatically.

Hope I am not causing more confusion.. but its important for me to understand what limitations are potentially there. Thanks!
",jardakotesovec,yuzhi
26,2015-08-12 05:27:52,"The remaining steps are:
- [x] Relay/React Native/fbjs versioning
- [x] Use the appropriate `unstableBatchedUpdates` depending on React/React Native
- [x] Version of `fetch` polyfill for React Native
- [ ] Document the use of `babel-relay-plugin` with React Native (see discussion at https://github.com/facebook/relay/pull/714#issuecomment-181204627) 
- [x] Create a fresh React Native project, set up Relay, configure the plugin per the documentation added in the previous step, and make sure everything works as expected.

Note: edited by @josephsavona
",qingfeng,josephsavona
26,2015-10-07 10:34:06,"@kusamakura I have Relay working with react-native 0.11.4 (see fork here: https://github.com/ProjectSeptemberInc/relay/commits/react-native ). I've followed @boourns tips tracked in this issue but also skipped all commits since Relay integrated ReactDOM : https://github.com/facebook/relay/commit/2d822400dbcf14f9636ab3149477f4ff0a0ee466 (so I'm based on the commit before it..)

This solution is temporary and is based on one month ago source code.

BTW in this last commit, @spicyj said that

> Internally for RN, we'll shim ReactDOM as just `{unstable_batchedUpdates: ReactUpdates.batchedUpdates}`

I hope react-native compatibility will be addressed soon.
",gre,spicyj
26,2015-12-15 04:17:13,"+1 resolving this will be incredibly beneficial to RN projects @vjeux @mkonicek @nicklockwood any work happening in RN to make Relay integration easier? We're deciding whether to use Relay for a product which is going to be huge in Australia .. This one issue is holding us back!
",zuhair-naqvi,vjeux
26,2015-12-15 05:46:02,"I suggest using this as starting point. It works out of box. It has
modified version of RN and relay which work well together.

https://github.com/lenaten/react-native-relay.

Read the repository readme for more information

On 15 December 2015 at 12:17, zuhair-naqvi notifications@github.com wrote:

> +1 resolving this will be incredibly beneficial to RN projects @vjeux
> https://github.com/vjeux @mkonicek https://github.com/mkonicek
> @nicklockwood https://github.com/nicklockwood any work happening in RN
> to make Relay integration easier? We're deciding whether to use Relay for a
> product which is going to be huge in Australia .. This one issue is holding
> us back!
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/facebook/relay/issues/26#issuecomment-164640639.
",shishircc,vjeux
26,2016-02-12 22:33:50,"Thanks for your patience on this, @BerndWessels. I've been working all week to land a few last PRs across the ecosystem that will let us use Relay in React Native projects. I'll keep chipping away at this iceberg along with @skevvy, @davidaurelio, and many others until it's done!
",steveluscher,davidaurelio
26,2016-03-06 18:17:27,"**EDIT**: Oh… I just read your comment more carefully. I didn't realize that this worked with Chrome debugging disabled. That's an excellent clue as to what's gone wrong. Thanks! cc/ @shayne @davidaurelio 

Yes. That's the next thing we're working on. It looks like `fetch()` (used by Relay's default network layer) is broken in RN. The fetch promise resolves with no content, so the JSON parser chokes (`JSON.parse('')`).

In the meantime, I might have to write a network layer that uses `XMLHttpRequest`.
",steveluscher,davidaurelio
26,2016-03-09 23:44:30,"I just checked out a fresh copy of Relay from master, and did the following:



A wild React Native and Relay app appeared.

Countless thanks to @skevy, @boourns, @gre, @davidaurelio, @martinbigio, @zpao, @spicyj, and everyone on this thread who helped us tear down the barriers to using Relay with React Native in the open source community. I can't wait to field all of your React Native specific GitHub issues.

We're done here. Open new issues at https://github.com/facebook/relay/issues or https://github.com/facebook/react-native/issues as you discover them!
",steveluscher,spicyj
26,2016-03-09 23:44:30,"I just checked out a fresh copy of Relay from master, and did the following:



A wild React Native and Relay app appeared.

Countless thanks to @skevy, @boourns, @gre, @davidaurelio, @martinbigio, @zpao, @spicyj, and everyone on this thread who helped us tear down the barriers to using Relay with React Native in the open source community. I can't wait to field all of your React Native specific GitHub issues.

We're done here. Open new issues at https://github.com/facebook/relay/issues or https://github.com/facebook/react-native/issues as you discover them!
",steveluscher,davidaurelio
25,2015-08-12 05:16:28,"`index.js` needs to be built by gulp because it contains ES6 spreads.

c.c. @yungsters 
",devknoll,yungsters
20,2015-08-13 04:53:37,"Whoah, idea 1 _is_ super hacky, but I like the way you think. ;)

Another more involved possibility is that we do something like what we did with `RelayMutation#getName`:



The more I think about it, there really is no semantic value to the keys in `queries`. What if we got rid of `${Component.getFragment(X)}` all together and made it clearer that the query name must match your component's fragment name?

I'm also curious what @josephsavona thinks about this.
",yungsters,josephsavona
14,2015-08-12 23:56:21,"As @yungsters mentioned, we're using ES2015 quite heavily. I know now why `babel-runtime` isn't polyfilling `String::repeat()`. @sebmck explains:

> It doesn't alias prototype methods. You can never be sure that something is always the right type. So in `foo.repeat()` you can't tell that `foo` is always going to be a string (you could with flow types but that's not implemented), so it's an unsafe transformation. Although in that case you can easily tell since it's just a string literal, but it'd be weird to support one and not the other.

This has helped to open up a wider discussion: should Relay attempt to bring its own polyfills, or should we empower (and require) you to bring the polyfills appropriate for your project. [React does this](https://facebook.github.io/react/docs/working-with-the-browser.html#polyfills-needed-to-support-older-browsers), to a certain extent. cc/ @zpao
",steveluscher,zpao
6,2015-08-27 18:25:32,"Based on some spectacular feedback from @BinaryMuse, @frantic, and others, here's what I'm thinking:

Split the tutorial into three acts: _Hello GraphQL_, _Hello Relay_, and _Schema Building_.

# Hello GraphQL

Now that [GraphiQL](https://github.com/graphql/graphiql) is open source, we should be able to drop it straight into the Relay docs, so that we can query a GraphQL schema interactively, and see the shape and content of the response immediately. Use the same schema that we use for the _Hello Relay_ tutorial. My present thinking for what the schema should describe is a list of stories with comments & likes.

# Hello Relay

Building upon a knowledge of how to write queries against a GraphQL endpoint, start to build a React app using Relay. First write enough code to query for a list of stories and display them. Next learn how to use calls by adding pagination. Next learn how to compose components and queries by adding comments below each story. Next, learn about mutations by adding the ability to create new comments. All of these activities should be possible to execute in-browser, using an interactive code editor and an in-memory schema.

# Schema Building

The last piece is to lead someone through the creation of a custom schema. This will explain how to use the [graphql-relay-js](https://github.com/graphql/graphql-relay-js) helpers, and in doing so should explain some core concepts like connections, cursors, and nodes. We might even consider punting on this section for the Relay website, since there have already been some excellent writeups on this topic from you: @clayallsopp [[1]](https://medium.com/@clayallsopp/your-first-graphql-server-3c766ab4f0a2) @davidchang [[2]](http://davidandsuzi.com/writing-a-basic-api-with-graphql/) Rising Stack [[3]](https://blog.risingstack.com/graphql-overview-getting-started-with-graphql-and-nodejs/). I have yet to see a Relay focussed one, so maybe there's still some work to do here.

I'm going to get started from the top. If you have thoughts or ideas, pen them down here!
",steveluscher,frantic
